{"componentChunkName":"component---src-templates-tag-tsx","path":"/tag/template/","webpackCompilationHash":"3b8c3c3cfcb69a320067","result":{"data":{"allMarkdownRemark":{"totalCount":11,"edges":[{"node":{"excerpt":"하재승님께서 던전 앤 파이터 클라이언트 로딩 속도 최적화에서 언급하신 dumpable 라이브러리에 대한 이야기를 해보자. 이 라이브러리는 serializable memory가 가능한 dynamic container와 operator =를 사용하여 dumpable한 struct를 만들어준다.다만 몇 가지 아쉬운 점이 있었다.dptr::alloc() 함수가 thread safe하지 않다는 점dstring, dvector…","fields":{"date":"June 30, 2014","slug":"/2014/06/30/dumpable-analysis/"},"frontmatter":{"title":"dumpable 고찰","tags":["c++","template"]}}},{"node":{"excerpt":"Modern C++ Design 책에서 소개한 typelist를 c++11 문법인 variadic template으로 구현해보자.typelist는 type들의 list형태로 compile time에 여러 type에 대한 동일한 작업을 할 때 사용된다. 예를 들면,conversion table을 만들어서 부담이 적은 dynamic_cast를 구현한다던가,hierarchical inheritance를 통한 tuple class…","fields":{"date":"June 29, 2014","slug":"/2014/06/29/variadic-template-typelist/"},"frontmatter":{"title":"variadic template을 사용한 typelist 구현","tags":["c++","template"]}}},{"node":{"excerpt":"간단한 message dispatch 코드를 c++로 구현해보자. 일단 std::function을 안 쓰고 구현해보고, 그 다음에 std::function을 써서 구현해보자.지난 번 글에서 functor_ii로 handler_t의 근간을 이미 설명했다.interface인 wrapper_t, 실 구현체인 impl_t, 그리고 그것을 멤버로 갖는 type erasure가 적용된 대표 type인 handler_t이다.…","fields":{"date":"November 16, 2013","slug":"/2013/11/16/cpp-message-dispatcher/"},"frontmatter":{"title":"c++ message dispatcher","tags":["c++","template","study"]}}},{"node":{"excerpt":"과제는 다음의 Adapter를 만들어보자는 것이다.많은 친구들이 이미 문제를 잘 풀었기 때문에 자세한 설명은 생략한다.이름 잘 지어주는 것도 물론 중요하지만 이정도 코드에서는 저정도 글자만 써줘도 이해할 것 같으니 과감히 생략.개인적으로 풀이 중 가장 마음에 드는 것은 Omniavinco가 if1live 글에 댓글로 단 binder1st 상속을 통한 구현. (있는 것 가져다가 쓰는게 제일)type infererence…","fields":{"date":"November 10, 2013","slug":"/2013/11/10/function-adapter/"},"frontmatter":{"title":"function adapter와 type inference","tags":["c++","template","study"]}}},{"node":{"excerpt":"첫 번째 코드(for_each)는 _Iter, _FuncTy에 들어가는 각 type에 맞게 compile time에 모든 code가 생성(template instantiation)되어 어떤 함수가 호출될지 compile time에 결정되는 구조이고,두 번째 코드(ForEach)는 Iterator와 Functor interface를 구현한 객체가 runtime에 ForEach() 함수로 넘어간 다음 virtual function…","fields":{"date":"November 10, 2013","slug":"/2013/11/10/template-programming-and-type-erasure/"},"frontmatter":{"title":"template 프로그래밍과 type erasure","tags":["c++","template","study"]}}},{"node":{"excerpt":"(한 번에 1~2시간 정도로 짧게(?) 하고 있다. 대충 accelerated c++ 책이랑 EC++ 책을 보고 있다.)C++ 언어를 가지고 C++스럽게 프로그래밍을 해보자! 는 어떤 의미일까?다양한 의견이 있겠지만, 프로그래밍 언어는 표현력이 증가하는 쪽으로 발전한다는 관점에서 프로그래머가 C에 비해서 보다 자신의 의도를 C…","fields":{"date":"November 04, 2013","slug":"/2013/11/04/generic-programming-with-template/"},"frontmatter":{"title":"template을 사용한 generic 프로그래밍","tags":["c++","template","study"]}}},{"node":{"excerpt":"상속을 통한 동적 다형성을 이용하려면, 명시적인 interface가 형성되어야 한다.와 같이 interface와 이를 구현(implements)하는 구체 class를 작성하고이처럼 동일한 interface로 취급할 수 있도록 하나의 container에 각 구체 class들의 객체를 담고\niterating하면서 update 함수를 불러준다. 이 때 type은 game_object *이므로 update…","fields":{"date":"January 10, 2012","slug":"/2012/01/10/implicit-interface-by-template/"},"frontmatter":{"title":"template의 암시적 interface 요구","tags":["c++","template"]}}},{"node":{"excerpt":"위와 같은 형태가 어떤 의미를 지니고, 어느 곳에서 사용될 수 있는지 살펴보자일단 자신의 부모 class를 generic하게 취할 수 있다는 것은 부모의 class 와 자식의 class 간의 결합성을 어느 정도 느슨하게 준다는 의미가 있다. (인자로 무엇을 주냐에 따라 상속 구조가 바뀌니까.)또한 부모 class의 종류에 상관없이 동일한 기능을 추가해줄 수 있다거나, 아니면 부모 class들이 동일한 interface…","fields":{"date":"January 09, 2012","slug":"/2012/01/09/inherits-template-argument/"},"frontmatter":{"title":"template 인자를 상속 받기","tags":["c++","template"]}}},{"node":{"excerpt":"어떤 class 2개가 있다.이 class들은 기본 생성자에서 굉장히 복잡한 작업을 하는 객체들 혹은 생성 자체가 복잡한 class들이다. 이러한 class에 대해 어떠한 작업을 수행하는 generic한 함수가 있다.이 함수는 객체의 type을 받아서 내부에서 모종의 작업을 수행하게 된다. 따라서 메인 함수에서는 다음과 같이 각 class에 대해 operation…","fields":{"date":"November 15, 2011","slug":"/2011/11/15/type-dispatching-by-type-trait-class/"},"frontmatter":{"title":"type_t class 도입을 통한 임시 객체 없는 type 분기","tags":["c++","template"]}}},{"node":{"excerpt":"runtime에 typeid를 써서 객체 type의 동등성(Same)을 확인하고,dynamic_cast를 써서 객체간의 대입가능성(Assignable)을 확인할 수 있다.하지만 이런 것을 확인하기 위해 runtime을 소모하는 것은 너무 아까운 일이다. 고로 template을 써보자.아래의 예제는 두 class, C1과 C2를 통해 진행된다.동등성 확인type 간의 동등성을 확인하는 것은 매우 간단하다. template…","fields":{"date":"July 19, 2011","slug":"/2011/07/19/check-type-equality-and-assignablity-by-template/"},"frontmatter":{"title":"template을 사용한 type간 동등성, 대입가능성","tags":["c++","template"]}}},{"node":{"excerpt":"알고리즘 등의 일반화나 의존성 제거를 위해서 class 사이를 interface 로 쪼개는 경우가 있다.\n나는 C++ 보다는 Java가 더 익숙해서 template보다는 interface나 generics를 사용하는게 더 익숙한 편이다.그래서 저번 자료구조 숙제를 할 때도 당황했던 것이, Iterator나 List 에 대해 Vector나 LinkedList를 구현할 때, 먼저 Interface…","fields":{"date":"July 13, 2011","slug":"/2011/07/13/generic-interface-implemented-by-template/"},"frontmatter":{"title":"template에 의한 generic interface 정의","tags":["c++","template"]}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"tag":"template"}}}