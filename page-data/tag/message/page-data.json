{"componentChunkName":"component---src-templates-tag-tsx","path":"/tag/message/","webpackCompilationHash":"9650fe4e762d5ca857ae","result":{"data":{"allMarkdownRemark":{"totalCount":4,"edges":[{"node":{"excerpt":"Cap’n Proto와 같은 무한대(?)로 빠른 메시지를 설계한다고 생각해보자. 그렇다면 우리는 어떤 점을 고민해야 할까? 이를 위해 잠깐 네트워크로 정보를 전달하는 과정을 생각해보자. end-point #1은 정보를 패킷에 담아 네트워크로 전송한다. (serialize) end-point #2는 네트워크에서 바이트를 읽어 메시지를 구성하고, 그 메시지로부터 정보를 읽는다. (deserialize…","fields":{"date":"February 11, 2014","slug":"/2014/02/11/fast-message-serialization/"},"frontmatter":{"title":"빠른 메시지 만들기","tags":["c++","message"]}}},{"node":{"excerpt":"일단 message에 대한 기본 type과 각 message을 구분하기 위한 enum이 있다. message과 enum 값을 쉽게 연결하기 위해 중간 층을 도입한다. 이제 message을 만든다. 기본적인 handler는 다음과 같이 단순하게 정의할 수 있다. dispatch를 위해 handler에 대한 table을 하나 만들어둔다. 일단 등록된 handler가 없어도 서버 동작에 문제가 없도록 하기 위해 빈 handler…","fields":{"date":"November 19, 2013","slug":"/2013/11/19/message-dispatch-code-generation-by-enum-value/"},"frontmatter":{"title":"메시지 enum에 따른 message 콜백 함수 자동생성","tags":["c++","message"]}}},{"node":{"excerpt":"객체(object)는 상태(state)를 갖고 외부의 조작(mutator)에 의해서 변경될 수 있다.\n이러한 객체를 다루는 프로그래밍을 할 때는, 관찰자(observer)가 객체의 상태 변화(property change)를 감지하여 어떠한 동작(action)을 수행하는 경우가 많이 있다. 이러한 코드를 작성할 경우, 관찰 당하는 객체(subject)와 관찰자(observer…","fields":{"date":"December 20, 2011","slug":"/2011/12/20/event-handler-and-message-passing/"},"frontmatter":{"title":"EventHandler와 Message Passing","tags":["java","message"]}}},{"node":{"excerpt":"본 글을 객체 간의 메시지 통신이 아니라 모듈 간의 메시지 통신에 대해 다룬다.\n즉, 특정 대상 객체를 지정하여 메시지를 보내는 내용이 아니라 전역 MessageQueue에 대해 어떤 Message를 수신할지를 등록하는 Handler 객체에 대한 내용이다. MessageQueue는 전역 객체이다. Message를 받아서 이를 수신 Handler 객체에게 전달한다. 여러 Thread에서 접근할 수 있으므로 Concurrent…","fields":{"date":"November 27, 2011","slug":"/2011/11/27/java-message-dispatcher/"},"frontmatter":{"title":"간단한 Message 체계 구현 (Java)","tags":["java","message"]}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"tag":"message"}}}