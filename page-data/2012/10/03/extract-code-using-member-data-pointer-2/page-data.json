{"componentChunkName":"component---src-templates-page-tsx","path":"/2012/10/03/extract-code-using-member-data-pointer-2/","result":{"data":{"site":{"siteMetadata":{"title":"Lacti's Archive","description":"All about I learned","author":{"name":"Jaeyoung, Choi","url":"https://twitter.com/lacti"}}},"markdownRemark":{"html":"<p>이번 글에서는 <code>Stat</code> 자료구조 내에 배열이 있을 때 이를 어떻게 처리할지에 대해서 알아보도록 하자.</p>\n<p><code>Stat</code> 코드를 작성하다보니, 이동 속도에 관해서는 각각의 변수를 따로 두는 것 보다, 배열 하나로 처리하는 것이 더 낫다는 것을 깨닫게 되었다.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"cpp\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">enum</span><span class=\"mtk1\"> </span><span class=\"mtk10\">MovingStatType</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">MST_WALK</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">MST_RUN</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">MST_RIDE</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">MST_MAX</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">};</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">struct</span><span class=\"mtk1\"> </span><span class=\"mtk10\">Stat</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">float</span><span class=\"mtk1\"> hp;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">float</span><span class=\"mtk1\"> </span><span class=\"mtk12\">movingSpeed</span><span class=\"mtk1\">[MST_MAX];</span></span></span></code></pre>\n<p>배열로 묶어서 <code>movingSpeed</code> 관련 코드가 개선된 것까지는 좋았는데 <code>hp</code>와 <code>movingSpeed</code>는 type이 다르기 때문에 이전 글에서의 방법을 더 이상 사용할 수 없게 되었다. 둘의 type을 비교해보면 아래와 같다.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"cpp\" data-index=\"1\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">typedef</span><span class=\"mtk1\"> </span><span class=\"mtk4\">float</span><span class=\"mtk1\"> </span><span class=\"mtk10\">Stat</span><span class=\"mtk1\">::*DataPtr;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">typedef</span><span class=\"mtk1\"> </span><span class=\"mtk4\">float</span><span class=\"mtk1\"> (</span><span class=\"mtk10\">Stat</span><span class=\"mtk1\">::*ArrayPtr)[</span><span class=\"mtk7\">3</span><span class=\"mtk1\">];</span></span></span></code></pre>\n<p>어쨌든 두 타입이 완전히 달라졌기 때문에, 이를 일치시키지 못한다면 또 다시 switch-case의 지옥을 맛보게 될 것이다. 멤버 데이터 포인터 수준에서는 이를 해결할 수 없기 때문에 <strong>멤버 함수 포인터</strong>를 사용하여 문제를 해결 할 것이다.</p>\n<p>목표는 그냥 멤버 변수와 배열 멤버 변수의 <strong>접근 interface를 통일시키는 것</strong>이다. 멤버 함수 포인터를 사용할 것이니 함수의 signature는 같아야 한다는 것이다.</p>\n<p>위 <code>Stat</code> 구조체에서는 다음과 같이 생각해볼 수 있다.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"cpp\" data-index=\"2\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">struct</span><span class=\"mtk1\"> </span><span class=\"mtk10\">Stat</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">float&amp;</span><span class=\"mtk1\"> </span><span class=\"mtk11\">Hp</span><span class=\"mtk1\">() { </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> hp; }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">float&amp;</span><span class=\"mtk1\"> </span><span class=\"mtk11\">WalkSpeed</span><span class=\"mtk1\">() { </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">movingSpeed</span><span class=\"mtk1\">[MST_WALK]; }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">float&amp;</span><span class=\"mtk1\"> </span><span class=\"mtk11\">RunSpeed</span><span class=\"mtk1\">() { </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">movingSpeed</span><span class=\"mtk1\">[MST_RUN]; }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">float&amp;</span><span class=\"mtk1\"> </span><span class=\"mtk11\">RideSpeed</span><span class=\"mtk1\">() { </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">movingSpeed</span><span class=\"mtk1\">[MST_RIDE]; }</span></span></span></code></pre>\n<p>이제 위 함수들은 다음의 멤버 함수 포인터로 지칭이 가능하다.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"cpp\" data-index=\"3\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">typedef</span><span class=\"mtk1\"> </span><span class=\"mtk4\">float</span><span class=\"mtk1\">&amp; (</span><span class=\"mtk10\">Stat</span><span class=\"mtk1\">::*Accessor)();</span></span></span></code></pre>\n<p>하지만 모든 멤버 변수에 대해서 저렇게 함수를 만들어주는 것은 여간 고역이 아니다. 이런 일을 사람이 하는 것은 도의에 어긋나니, 컴파일러가 이 일을 대신하도록 해보자.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"cpp\" data-index=\"4\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">struct</span><span class=\"mtk1\"> </span><span class=\"mtk10\">Stat</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">float&amp;</span><span class=\"mtk1\"> </span><span class=\"mtk11\">Hp</span><span class=\"mtk1\">() { </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> hp; }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">template</span><span class=\"mtk1\"> &lt;</span><span class=\"mtk4\">int</span><span class=\"mtk1\"> </span><span class=\"mtk10\">_Index</span><span class=\"mtk1\">&gt;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">float&amp;</span><span class=\"mtk1\"> </span><span class=\"mtk11\">MovingSpeed</span><span class=\"mtk1\">() { </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">movingSpeed</span><span class=\"mtk1\">[_Index]; }</span></span></span></code></pre>\n<p>template 함수를 사용해서 배열의 인자를 template으로 넘겼다. 저 <code>_Index</code> 값으로 <code>MST_WALK</code> 등의 값을 넘기면 그에 해당하는 <code>MovingSpeed&#x3C;></code> 함수를 컴파일러가 알아서 생성해줄 것이다.</p>\n<p><strong>이렇게 생성된 template 함수들의 interface도 위에서 정의한 Accessor에 부합된다. 이것이 핵심 아이디어이다.</strong></p>\n<pre class=\"grvsc-container default-dark\" data-language=\"cpp\" data-index=\"5\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">Accessor acc1 = &amp;</span><span class=\"mtk10\">Stat</span><span class=\"mtk1\">::MovingSpeed&lt;MST_WALK&gt;;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">Accessor acc2 = &amp;</span><span class=\"mtk10\">Stat</span><span class=\"mtk1\">::MovingSpeed&lt;MST_RUN&gt;;</span></span></span></code></pre>\n<p>Stat의 각 멤버에 대해 노출 함수를 만들어주는 것은 지겨운 일이다. 이 함수들 역시 template으로 묶어보자.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"cpp\" data-index=\"6\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">struct</span><span class=\"mtk1\"> </span><span class=\"mtk10\">Stat</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">template</span><span class=\"mtk1\"> &lt;</span><span class=\"mtk4\">float</span><span class=\"mtk1\"> </span><span class=\"mtk10\">Stat</span><span class=\"mtk1\">::*</span><span class=\"mtk4\">_DataPtr</span><span class=\"mtk1\">&gt;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">float&amp;</span><span class=\"mtk1\"> </span><span class=\"mtk11\">Access</span><span class=\"mtk1\">() { </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk4\">this</span><span class=\"mtk1\">-&gt;*</span><span class=\"mtk12\">_DataPtr</span><span class=\"mtk1\">; }</span></span></span></code></pre>\n<p>Access 함수는 멤버 데이터 포인터를 template 인자로 받는다. 이 역시 위에서 정의한 Accessor 타입에 부합된다.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"cpp\" data-index=\"7\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">Accessor acc3 = </span><span class=\"mtk10\">Stat</span><span class=\"mtk1\">::Access&lt;&amp;</span><span class=\"mtk10\">Stat</span><span class=\"mtk1\">::hp&gt;;</span></span></span></code></pre>\n<p>배열의 멤버 데이터 포인터를 template 인자로 받으려면 약간 까다로운데, 그 이유는 배열의 멤버 데이터 포인터의 타입을 명시할 때에는 그 배열의 크기가 필요하기 때문이다.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"cpp\" data-index=\"8\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">struct</span><span class=\"mtk1\"> </span><span class=\"mtk10\">Stat</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">template</span><span class=\"mtk1\"> &lt;</span><span class=\"mtk4\">size_t</span><span class=\"mtk1\"> </span><span class=\"mtk10\">_Size</span><span class=\"mtk1\">, </span><span class=\"mtk4\">float</span><span class=\"mtk1\"> (</span><span class=\"mtk10\">Stat</span><span class=\"mtk1\">::*_ArrayPtr)[_Size], </span><span class=\"mtk4\">int</span><span class=\"mtk1\"> </span><span class=\"mtk10\">_Index</span><span class=\"mtk1\">&gt;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">float&amp;</span><span class=\"mtk1\"> </span><span class=\"mtk11\">Access</span><span class=\"mtk1\">() { </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> (</span><span class=\"mtk4\">this</span><span class=\"mtk1\">-&gt;*</span><span class=\"mtk12\">_ArrayPtr</span><span class=\"mtk1\">)[_Index]; }</span></span></span></code></pre>\n<p>배열 타입 명시를 위한 배열의 크기, 멤버 데이터 포인터 값, 그리고 배열 내의 index. 이렇게 3개의 template 인자를 받는다. 이 함수를 사용하여 acc1, acc2를 다시 정의해 본다면 다음과 같다.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"cpp\" data-index=\"9\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">Accessor acc1 = &amp;</span><span class=\"mtk10\">Stat</span><span class=\"mtk1\">::Access&lt;MST_MAX, &amp;</span><span class=\"mtk10\">Stat</span><span class=\"mtk1\">::movingSpeed, MST_WALK&gt;;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">Accessor acc2 = &amp;</span><span class=\"mtk10\">Stat</span><span class=\"mtk1\">::Access&lt;MST_MAX, &amp;</span><span class=\"mtk10\">Stat</span><span class=\"mtk1\">::movingSpeed, MST_RUN&gt;;</span></span></span></code></pre>\n<p>이제 일반적인 <strong>Access</strong>라는 멤버 함수를 사용하여 모든 멤버를 접근할 수 있게 되었다. 하지만 이미 선언할 때 명시해준 배열의 크기를 또 적어주어야 하는 것은 마음에 들지 않는다. 이를 고쳐보자.</p>\n<p>배열의 크기를 구하기 위해 간단한 메타 템플릿 함수를 작성해보자. 일단 일반적인 interface를 선언하고,</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"cpp\" data-index=\"10\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">template</span><span class=\"mtk1\"> &lt;</span><span class=\"mtk4\">typename</span><span class=\"mtk1\"> </span><span class=\"mtk10\">T</span><span class=\"mtk1\">&gt;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">struct</span><span class=\"mtk1\"> </span><span class=\"mtk10\">countof</span><span class=\"mtk1\">;</span></span></span></code></pre>\n<p>그리고 배열의 크기를 알아내기 위한 특수화된 <em>specialization</em> 메타 템플릿 함수를 작성한다.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"cpp\" data-index=\"11\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">template</span><span class=\"mtk1\"> &lt;</span><span class=\"mtk4\">typename</span><span class=\"mtk1\"> </span><span class=\"mtk10\">_Ty</span><span class=\"mtk1\">, </span><span class=\"mtk4\">typename</span><span class=\"mtk1\"> </span><span class=\"mtk10\">_Class</span><span class=\"mtk1\">, </span><span class=\"mtk4\">size_t</span><span class=\"mtk1\"> </span><span class=\"mtk10\">_Size</span><span class=\"mtk1\">&gt;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">struct</span><span class=\"mtk1\"> </span><span class=\"mtk10\">countof</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">_Ty</span><span class=\"mtk1\"> (</span><span class=\"mtk10\">_Class</span><span class=\"mtk1\">::*)[</span><span class=\"mtk10\">_Size</span><span class=\"mtk1\">]&gt; {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">enum</span><span class=\"mtk1\"> { </span><span class=\"mtk12\">value</span><span class=\"mtk1\"> = _Size };</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">};</span></span></span></code></pre>\n<p><code>countof</code>의 타입 argument가 <code>_Ty (_Class::*)[_Size]</code> 형태이면 그 <code>_Size</code>를 value로 갖는 메타 템플릿 함수이다. <code>decltype</code> 키워드를 사용하여 멤버 데이터 포인터의 타입을 얻을 수 있으므로, 다음과 같이 멤버 데이터 포인터가 가리키는 배열의 크기를 얻을 수 있다.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"cpp\" data-index=\"12\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk10\">countof</span><span class=\"mtk1\">&lt;</span><span class=\"mtk4\">decltype</span><span class=\"mtk1\">(&amp;</span><span class=\"mtk10\">Stat</span><span class=\"mtk1\">::movingSpeed)&gt;::value</span></span></span></code></pre>\n<p>이제 위 배열 멤버에 대한 접근을 다음과 같이 표현할 수 있게 되었다.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"cpp\" data-index=\"13\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">Accessor acc1 = &amp;</span><span class=\"mtk10\">Stat</span><span class=\"mtk1\">::Access&lt;</span><span class=\"mtk10\">countof</span><span class=\"mtk1\">&lt;</span><span class=\"mtk4\">decltype</span><span class=\"mtk1\">(&amp;</span><span class=\"mtk10\">Stat</span><span class=\"mtk1\">::movingSpeed)&gt;::value,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    &amp;</span><span class=\"mtk10\">Stat</span><span class=\"mtk1\">::movingSpeed, MST_WALK&gt;;</span></span></span></code></pre>\n<p>모든 준비가 갖추어졌다. 멤버의 데이터 타입이 배열이든, 그렇지 않든 <code>float&#x26; (Stat::*)()</code> signature를 사용하여 값을 얻을 수 있게 되었다.</p>\n<p>이제 이전 글에서 했던 방법처럼 코드를 정리하면 된다.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"cpp\" data-index=\"14\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">typedef</span><span class=\"mtk1\"> </span><span class=\"mtk4\">float</span><span class=\"mtk1\">&amp; (</span><span class=\"mtk10\">Stat</span><span class=\"mtk1\">::*StatAccessor)();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">StatAccessor </span><span class=\"mtk12\">statAccessorTable</span><span class=\"mtk1\">[BUFF_MAX];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">statAccessorTable</span><span class=\"mtk1\">[BUFF_HP] = &amp;</span><span class=\"mtk10\">Stat</span><span class=\"mtk1\">::Access&lt;&amp;</span><span class=\"mtk10\">Stat</span><span class=\"mtk1\">::hp&gt;;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">statAccessorTable</span><span class=\"mtk1\">[BUFF_WALK_SPEED] = &amp;</span><span class=\"mtk10\">Stat</span><span class=\"mtk1\">::Access&lt;</span><span class=\"mtk10\">countof</span><span class=\"mtk1\">&lt;</span><span class=\"mtk4\">decltype</span><span class=\"mtk1\">(&amp;</span><span class=\"mtk10\">Stat</span><span class=\"mtk1\">::movingSpeed)&gt;::value,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    &amp;</span><span class=\"mtk10\">Stat</span><span class=\"mtk1\">::movingSpeed, MST_WALK&gt;;</span></span></span></code></pre>\n<p><code>statAccessorTable</code>을 사용하여 switch-case 구문도 깔끔하게 정리할 수 있다.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"cpp\" data-index=\"15\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">StatAccessor accessor = </span><span class=\"mtk12\">statAccessorTable</span><span class=\"mtk1\">[buffType];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">switch</span><span class=\"mtk1\"> (buffMethod) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">case</span><span class=\"mtk1\"> SET: (</span><span class=\"mtk12\">stat</span><span class=\"mtk1\">.*</span><span class=\"mtk12\">accessor</span><span class=\"mtk1\">)() = buffValue; </span><span class=\"mtk15\">break</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">case</span><span class=\"mtk1\"> ADD: (</span><span class=\"mtk12\">stat</span><span class=\"mtk1\">.*</span><span class=\"mtk12\">accessor</span><span class=\"mtk1\">)() += buffValue; </span><span class=\"mtk15\">break</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">case</span><span class=\"mtk1\"> RATE: (</span><span class=\"mtk12\">stat</span><span class=\"mtk1\">.*</span><span class=\"mtk12\">accessor</span><span class=\"mtk1\">)() *= buffValue; </span><span class=\"mtk15\">break</span><span class=\"mtk1\">;</span></span></span></code></pre>\n<p><code>AccessorTable</code>을 등록할 때, 아무래도 배열 타입을 등록하는데 코드가 쓸데없이 길어진다. 이는 매크로를 사용하여 깔끔하게 정리할 수 있겠다.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"cpp\" data-index=\"16\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// buff_type.inl</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">BUFF_ENUM</span><span class=\"mtk1\">(BUFF_HP, &amp;</span><span class=\"mtk10\">Stat</span><span class=\"mtk1\">::hp)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">BUFF_ENUM_A</span><span class=\"mtk1\">(BUFF_WALK_SPEED, &amp;</span><span class=\"mtk10\">Stat</span><span class=\"mtk1\">::movingSpeed, MST_WALK)</span></span></span></code></pre>\n<p>역시 적절한 macro 함수 교체를 통해 적절한 코드가 생성되도록 한다.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"cpp\" data-index=\"17\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// buff_bind.cpp</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">#define</span><span class=\"mtk4\"> </span><span class=\"mtk11\">BUFF_ENUM</span><span class=\"mtk4\">(</span><span class=\"mtk12\">name</span><span class=\"mtk4\">, </span><span class=\"mtk12\">ptr</span><span class=\"mtk4\">) </span><span class=\"mtk12\">statAccessorTable</span><span class=\"mtk4\">[name] </span><span class=\"mtk1\">=</span><span class=\"mtk4\"> </span><span class=\"mtk1\">&amp;</span><span class=\"mtk10\">Stat</span><span class=\"mtk4\">::Access</span><span class=\"mtk1\">&lt;</span><span class=\"mtk4\">ptr</span><span class=\"mtk1\">&gt;</span><span class=\"mtk4\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">#define</span><span class=\"mtk4\"> </span><span class=\"mtk11\">BUFF_ENUM_A</span><span class=\"mtk4\">(</span><span class=\"mtk12\">name</span><span class=\"mtk4\">, </span><span class=\"mtk12\">ptr</span><span class=\"mtk4\">, </span><span class=\"mtk12\">idx</span><span class=\"mtk4\">) </span><span class=\"mtk6\">\\</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">    </span><span class=\"mtk12\">statAccessorTable</span><span class=\"mtk4\">[name] </span><span class=\"mtk1\">=</span><span class=\"mtk4\"> </span><span class=\"mtk1\">&amp;</span><span class=\"mtk10\">Stat</span><span class=\"mtk4\">::Access</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">countof</span><span class=\"mtk4\">&lt;decltype(ptr)&gt;::value, ptr, idx</span><span class=\"mtk1\">&gt;</span><span class=\"mtk4\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">#include</span><span class=\"mtk4\"> </span><span class=\"mtk8\">&quot;buff_type.inl&quot;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">#undef</span><span class=\"mtk4\"> </span><span class=\"mtk11\">BUFF_ENUM_A</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">#undef</span><span class=\"mtk4\"> </span><span class=\"mtk11\">BUFF_ENUM</span></span></span></code></pre>\n<p>본 글에서는 완전히 일치하지는 않지만 어느 정도 타입이 비슷할 때, 멤버 데이터 포인터가 아닌 <strong>template 인자를 활용한 멤버 함수로 signature를 맞추어 반복되는 코드의 양을 줄이는 방법</strong>에 대해 알아보았다.</p>\n<p>지난 번 글에서도 언급했지만, 이것이 가능했던 이유는 각 멤버들이 모두 float이었기 때문이다. 다음 글에서는 type erasure를 사용하여 좀 더 일반적인 (하지만 성능에서는 손해를 보는) 방법에 대해 알아보도록 하겠다.</p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n  .default-dark {\n    background-color: #1E1E1E;\n    color: #D4D4D4;\n  }\n  .default-dark .mtk4 { color: #569CD6; }\n  .default-dark .mtk1 { color: #D4D4D4; }\n  .default-dark .mtk10 { color: #4EC9B0; }\n  .default-dark .mtk12 { color: #9CDCFE; }\n  .default-dark .mtk7 { color: #B5CEA8; }\n  .default-dark .mtk11 { color: #DCDCAA; }\n  .default-dark .mtk15 { color: #C586C0; }\n  .default-dark .mtk3 { color: #6A9955; }\n  .default-dark .mtk6 { color: #D7BA7D; }\n  .default-dark .mtk8 { color: #CE9178; }\n  .default-dark .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(255, 255, 255, 0.1));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(255, 255, 255, 0.5));\n  }\n</style>","excerpt":"이번 글에서는 Stat 자료구조 내에 배열이 있을 때 이를 어떻게 처리할지에 대해서 알아보도록 하자. Stat…","fields":{"date":"October 03, 2012","shortdesc":"","slug":"/2012/10/03/extract-code-using-member-data-pointer-2/"},"frontmatter":{"title":"멤버 데이터 포인터를 사용하여 연산식 묶어내기 2","tags":["c++","refactor"]}}},"pageContext":{"slug":"/2012/10/03/extract-code-using-member-data-pointer-2/","older":{"slug":"/2012/10/01/extract-code-using-member-data-pointer-1/","title":"멤버 데이터 포인터를 사용하여 연산식 묶어내기 1"},"newer":{"slug":"/2012/10/07/extract-code-using-member-data-pointer-3/","title":"멤버 데이터 포인터를 사용하여 연산식 묶어내기 3"}}},"staticQueryHashes":["848695393"]}