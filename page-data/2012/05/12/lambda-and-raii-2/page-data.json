{"componentChunkName":"component---src-templates-page-tsx","path":"/2012/05/12/lambda-and-raii-2/","webpackCompilationHash":"c52cfe8f35b93f400244","result":{"data":{"site":{"siteMetadata":{"title":"Lacti's Archive","description":"All about I learned","author":{"name":"Jaeyoung, Choi","url":"https://twitter.com/lacti"}}},"markdownRemark":{"html":"<p>C++11은 lambda expression을 지원해주니 좀 다르게 생각해볼 수 있다.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">class</span><span class=\"mtk1\"> </span><span class=\"mtk10\">lock_t</span><span class=\"mtk1\"> {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">public:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">template</span><span class=\"mtk1\"> &lt;</span><span class=\"mtk4\">typename </span><span class=\"mtk10\">functor</span><span class=\"mtk1\">&gt;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">void</span><span class=\"mtk1\"> </span><span class=\"mtk11\">scoped</span><span class=\"mtk1\">(functor&amp; </span><span class=\"mtk12\">func</span><span class=\"mtk1\">) {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk11\">lock</span><span class=\"mtk1\">();</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk11\">func</span><span class=\"mtk1\">();</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk11\">unlock</span><span class=\"mtk1\">();</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">};</span></span></code></pre>\n<p><code>lock_t</code> class 자체에 위와 같이 functor를 받아 실행할 수 있는 함수를 만든다. 그리고 그 앞 뒤로 lock-unlock을 불러준다.</p>\n<p>이렇게 하면 lambda를 사용하여 lock 사용 코드를 보다 깔끔하게 정리해볼 수 있다.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk1\">item_ref inventory_t::</span><span class=\"mtk11\">find</span><span class=\"mtk1\">(</span><span class=\"mtk10\">item_id_t</span><span class=\"mtk1\"> </span><span class=\"mtk12\">item_id</span><span class=\"mtk1\">) {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    item_ref </span><span class=\"mtk11\">item</span><span class=\"mtk1\">(</span><span class=\"mtk4\">NULL</span><span class=\"mtk1\">);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk12\">lock</span><span class=\"mtk1\">.</span><span class=\"mtk11\">scoped</span><span class=\"mtk1\">([&amp;item] () {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk4\">auto</span><span class=\"mtk1\"> iter = std::</span><span class=\"mtk11\">find</span><span class=\"mtk1\">(</span><span class=\"mtk12\">items</span><span class=\"mtk1\">.</span><span class=\"mtk11\">begin</span><span class=\"mtk1\">(), </span><span class=\"mtk12\">items</span><span class=\"mtk1\">.</span><span class=\"mtk11\">end</span><span class=\"mtk1\">(), </span><span class=\"mtk11\">find_item_by_id</span><span class=\"mtk1\">(item_id));</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (iter != </span><span class=\"mtk12\">items</span><span class=\"mtk1\">.</span><span class=\"mtk11\">end</span><span class=\"mtk1\">())</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">            item = (*iter);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    });</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> item;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">}</span></span></code></pre>\n<p>lambda를 통해 lock 구문을 수행하는 코드를 보다 깔끔하게 묶어낼 수 있다… 라고 이야기하고 싶지만, item이라는 값을 반환해야할 방법이 딱히 없어서 외부에서 변수를 선언하고 내부로 전달하는 영 좋지 못한 방법을 쓰고 있다.</p>\n<p>약간 이야기가 다른 길로 가지만, 보다 깔끔한 해결책을 위해 아래와 같이 코드를 작성해볼 수 있다는 것을 이야기하고 싶다.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">class</span><span class=\"mtk1\"> </span><span class=\"mtk10\">lock_t</span><span class=\"mtk1\"> {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">public:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">template</span><span class=\"mtk1\"> &lt;</span><span class=\"mtk4\">typename </span><span class=\"mtk10\">R</span><span class=\"mtk4\">,</span><span class=\"mtk1\"> </span><span class=\"mtk4\">typename </span><span class=\"mtk10\">functor</span><span class=\"mtk1\">&gt;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    R&amp;&amp; </span><span class=\"mtk11\">scoped_return</span><span class=\"mtk1\">(functor&amp;&amp; </span><span class=\"mtk12\">func</span><span class=\"mtk1\">) {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk11\">lock</span><span class=\"mtk1\">();</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        R&amp;&amp; r = </span><span class=\"mtk11\">func</span><span class=\"mtk1\">();</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk11\">unlock</span><span class=\"mtk1\">();</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> std::</span><span class=\"mtk11\">move</span><span class=\"mtk1\">(r);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">};</span></span></code></pre>\n<p>lock 범위 내에서 값을 반환할 수 있는 형태의 코드를 작성한 뒤 이를 사용하도록 한다는 것이다.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk1\">item_ref inventory_t::</span><span class=\"mtk11\">find</span><span class=\"mtk1\">(</span><span class=\"mtk10\">item_id_t</span><span class=\"mtk1\"> </span><span class=\"mtk12\">item_id</span><span class=\"mtk1\">) {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">lock.scoped_return</span><span class=\"mtk1\">&lt;item_ref&gt;([=] () {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk4\">auto</span><span class=\"mtk1\"> iter = std::</span><span class=\"mtk11\">find</span><span class=\"mtk1\">(</span><span class=\"mtk12\">items</span><span class=\"mtk1\">.</span><span class=\"mtk11\">begin</span><span class=\"mtk1\">(), </span><span class=\"mtk12\">items</span><span class=\"mtk1\">.</span><span class=\"mtk11\">end</span><span class=\"mtk1\">(), </span><span class=\"mtk11\">find_item_by_id</span><span class=\"mtk1\">(item_id));</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> (iter != </span><span class=\"mtk12\">items</span><span class=\"mtk1\">.</span><span class=\"mtk11\">end</span><span class=\"mtk1\">())? (*iter): </span><span class=\"mtk4\">NULL</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    });</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">}</span></span></code></pre>\n<p>물론 값을 쓸데없이 복사하는 구간이 있는데, 저 부분은 다시 RAII를 사용하여 묶는 등 코드를 좀 더 정리해볼 수 있겠다. (그게 귀찮아서 위처럼 r-value를 썼는데, 어차피 move constructor가 구현되어있지 않다면 저 방법은 효윺이 영 좋지 않을 수 있다.)</p>\n<p>lambda를 이용해 raii 영역을 하나의 scope로 묶어주는 방법에 대해서 정리해봤다. 하지만 이 방법을 써도 결국 최종 지점 (위 예제에서는 scoped 함수)에서는 결국 raii를 사용하여 자원을 관리할 필요가 있게 된다.</p>\n<p>이러한 패턴은 생각보다 자주 등장하게 되므로, 이에 대한 일반적인 패턴을 만들어놓으면 좋을 것이다. 이를 만족시키는 적절한 template class 를 작성해보자.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">template</span><span class=\"mtk1\"> &lt;</span><span class=\"mtk4\">class </span><span class=\"mtk10\">_Ty</span><span class=\"mtk4\">,</span><span class=\"mtk1\"> void (_Ty::*begin)(), void (_Ty::*end)()&gt;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">class</span><span class=\"mtk1\"> </span><span class=\"mtk10\">raii_t</span><span class=\"mtk1\"> {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">public:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk11\">raii_t</span><span class=\"mtk1\">(_Ty* </span><span class=\"mtk12\">_obj</span><span class=\"mtk1\">)</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        : </span><span class=\"mtk11\">obj</span><span class=\"mtk1\">(_obj) {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        (</span><span class=\"mtk12\">obj-&gt;*begin</span><span class=\"mtk1\">)();</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk11\">~raii_t</span><span class=\"mtk1\">() {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        (</span><span class=\"mtk12\">obj-&gt;*end</span><span class=\"mtk1\">)();</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">private:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    _Ty* obj;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">};</span></span></code></pre>\n<p><code>raii_t</code>라는 class는 특정 type과, 그 type에 대해 시작 시 수행할 함수와 끝날 때 수행될 함수를 template 인자로 받는다. 이제 <code>lock_t</code>에 대한 <code>lock_raii_t</code> class는 다음과 같은 typedef로 정의할 수 있다.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">typedef</span><span class=\"mtk1\"> </span><span class=\"mtk10\">raii_t</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">lock_t</span><span class=\"mtk1\">, &amp;lock_t::lock, &amp;lock_t::unlock&gt; </span><span class=\"mtk10\">lock_raii_t</span><span class=\"mtk1\">;</span></span></code></pre>\n<p><code>lock_raii_t</code>는 <code>lock_t</code>에 대해 동작하면서, 해당 변수가 생성 시 <code>lock_t::lock()</code> 함수를 부르고, 소멸될 때 <code>lock_t::unlock()</code> 함수를 부르게 된다.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk10\">lock_t</span><span class=\"mtk1\"> lock;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk10\">lock_raii_t</span><span class=\"mtk1\"> </span><span class=\"mtk11\">raii</span><span class=\"mtk1\">(&amp;</span><span class=\"mtk12\">lock</span><span class=\"mtk1\">);</span></span></code></pre>\n<p>저 <code>raii_t</code>는 꽤 일반적이어서, 생성과 소멸 시 특정 함수를 통해 자원 관리가 되어야 하는 class에 대해 모두 적용될 수 있다. 예를 들면 <code>shared_ptr</code> (add<em>ref/release</em>ref) 등이 될 수 있다.</p>\n<p>[summerlight]님께서 예제로 달았던 finalizer를 raii의 예로 들어보자. 특정 scope가 끝나는 시점에 수행되어야할 작업들을 명시해주는 객체가 된다. 즉, 익명의 객체를 하나 만들고, 그 소멸자에서 수행될 함수를 인자로 받도록 한다.</p>\n<p>먼저 소멸자에서 무언가를 수행해줄 수 있는 class를 만들어보자.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">template</span><span class=\"mtk1\"> &lt;</span><span class=\"mtk4\">typename </span><span class=\"mtk10\">_Func</span><span class=\"mtk1\">&gt;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">struct</span><span class=\"mtk1\"> </span><span class=\"mtk10\">finalizer</span><span class=\"mtk1\"> {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk11\">finalizer</span><span class=\"mtk1\">(_Func&amp;&amp; </span><span class=\"mtk12\">_func</span><span class=\"mtk1\">)</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        : </span><span class=\"mtk11\">func</span><span class=\"mtk1\">(_func) {}</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk11\">~finalizer</span><span class=\"mtk1\">() {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk11\">func</span><span class=\"mtk1\">();</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">private:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    _Func func;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">};</span></span></code></pre>\n<p>보다 일반적인 함수 수행을 원한다면 (일반 함수, 함수자, 멤버 함수 등) <code>std::function</code> 등을 적절히 사용하는 것도 좋겠지만 본 예제에서는 간단히 위처럼 설계했다. 위 <code>finalizer</code> class는 생성자로 받은 함수를 소멸자에서 수행하므로, 해당 객체가 소멸될 때까지 인자로 받은 함수의 수행을 미루게 된다.</p>\n<p>이제 template argument 유추를 컴파일러에게 맡기기 위해 이 객체를 만들어주는 함수를 만들자.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">template</span><span class=\"mtk1\"> &lt;</span><span class=\"mtk4\">typename </span><span class=\"mtk10\">_Func</span><span class=\"mtk1\">&gt;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">finalizer&lt;_Func&gt; </span><span class=\"mtk11\">do_exit_scope</span><span class=\"mtk1\">(_Func&amp;&amp; </span><span class=\"mtk12\">func</span><span class=\"mtk1\">) {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk11\">finalizer</span><span class=\"mtk1\">&lt;</span><span class=\"mtk4\">_Func</span><span class=\"mtk1\">&gt;(std::</span><span class=\"mtk11\">move</span><span class=\"mtk1\">(func));</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">}</span></span></code></pre>\n<p>그러면 다음과 같이 사용이 가능해진다.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">auto</span><span class=\"mtk1\"> f = </span><span class=\"mtk11\">do_exit_scope</span><span class=\"mtk1\">([=] () {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// implements here!</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">});</span></span></code></pre>\n<p>생성된 객체가 소멸될 때 불려야한다는 것은, 불편하게도 <code>auto f</code>와 같이 명시적으로 변수를 코드로 적어줘야 한다는 이야기다. 이왕이면 이런 것 정도는 자동으로 컴파일러가 해줬으면 좋겠다, 싶으니 약간의 장난을 쳐보자.</p>\n<p>g++은 어떻게 해야 좋을지 모르겠고, <code>__COUNTER__</code> macro가 있는 msvc기준으로 설명하겠다. <code>__COUNTER__</code>는 해당 매크로가 해석될 때마다 1씩 증가하는 predefined macro이다. 따라서 임시 변수 명을 지어주기에는 적합한 녀석이다. (대체품으로 <code>__LINE__</code>를 쓰기도 한데, 이러면 한 줄에 여러 코드를 작성할 수 없다.)</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk15\">#define</span><span class=\"mtk4\"> </span><span class=\"mtk11\">__concat</span><span class=\"mtk4\">(</span><span class=\"mtk12\">a, b</span><span class=\"mtk4\">)      a</span><span class=\"mtk12\">##b</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk15\">#define</span><span class=\"mtk4\"> </span><span class=\"mtk11\">__auto_var</span><span class=\"mtk4\">          </span><span class=\"mtk11\">__concat</span><span class=\"mtk4\">(_auto_var, __COUNTER__)</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk15\">#define</span><span class=\"mtk4\"> </span><span class=\"mtk11\">__do_exit_scope</span><span class=\"mtk4\">(</span><span class=\"mtk12\">f</span><span class=\"mtk4\">)  auto __auto_var </span><span class=\"mtk1\">=</span><span class=\"mtk4\"> </span><span class=\"mtk11\">do_exit_scope</span><span class=\"mtk4\">(f)</span></span></code></pre>\n<p><code>__auto_var</code> 매크로는 자동으로 변수의 이름을 대충 지어주는 매크로다. _auto<em>var라는 prefix를 붙이고, 뒤에 <code>__COUNTER__</code>를 붙여서 \\</em>auto<em>var1, \\</em>auto_var2 등으로 해당 매크로를 사용할 때마다 이름이 알아서 지어지도록 한다.</p>\n<p><code>__COUNTER__</code>와 _auto<em>var를 붙이기 위해서 <code>##</code> 연산자를 썼다. 다만 이게 `</em>auto_var##<strong>COUNTER</strong><code>처럼 사용하면</code><strong>COUNTER</strong><code>이 문자열로 해석되므로</code>__concat`와 같은 다른 macro를 만들어서 사용해야 한다.</p>\n<p>마지막으로 <code>__do_exit_scope</code>라는 매크로 함수를 만들어서, 인자로 받은 함수에 대해 자동 변수 이름을 부여하도록 한다. 이러면 <code>auto f</code>와 같이 명시적으로 이름을 지정해주지 않아도 자동으로 변수를 할당하므로 조금이나마 더 나은 코드를 작성할 수 있다 (라는 기분이 든다-_-)</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk11\">__do_exit_scope</span><span class=\"mtk1\">([=] () { </span><span class=\"mtk11\">_tprintf_s</span><span class=\"mtk1\">(</span><span class=\"mtk11\">_T</span><span class=\"mtk1\">(</span><span class=\"mtk8\">&quot;third</span><span class=\"mtk6\">\\n</span><span class=\"mtk8\">&quot;</span><span class=\"mtk1\">)); });</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk11\">__do_exit_scope</span><span class=\"mtk1\">([=] () { </span><span class=\"mtk11\">_tprintf_s</span><span class=\"mtk1\">(</span><span class=\"mtk11\">_T</span><span class=\"mtk1\">(</span><span class=\"mtk8\">&quot;second</span><span class=\"mtk6\">\\n</span><span class=\"mtk8\">&quot;</span><span class=\"mtk1\">)); });</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk11\">__do_exit_scope</span><span class=\"mtk1\">([=] () { </span><span class=\"mtk11\">_tprintf_s</span><span class=\"mtk1\">(</span><span class=\"mtk11\">_T</span><span class=\"mtk1\">(</span><span class=\"mtk8\">&quot;first</span><span class=\"mtk6\">\\n</span><span class=\"mtk8\">&quot;</span><span class=\"mtk1\">)); });</span></span></code></pre>\n<p>(변수의 소멸 순서는 생성 순서의 역순이므로, 출력 순서는 first - second - third 가 된다.)</p>\n<p>raii 기법은 단순히 생성자/소멸자 쌍에서 관리 대상 객체의 특정 함수 호출 쌍을 맞춰줌으로써 자원 관리에 문제가 없도록 해주는 기법이라 정리해볼 수 있겠다.</p>\n<p>이를 위해 자원이 사용되는 구간을 scope로 한정 짓기 위해 lambda를 사용하는 방법, 그리고 generic한 <code>raii_t</code> template class를 구현하여 사용하는 방법에 대해 간단히 알아보았다.</p>\n<p>여기서 그치지 않고 더 나아가본다면 <strong>raii class 를 단위 전략 기법</strong>을 사용하여 설계하는 것이다. 간단히 설명하면,</p>\n<ul>\n<li>raii 객체가 생성자로 관리할 객체의 주소를 인자로 받는데, 그냥 자신의 멤버 변수로 가지고 있으면 안되나?</li>\n<li>raii 객체가 생성자, 소멸자에서 호출될 함수를 모두 template 인자로 받는데, 위의 finalizer 예제 처럼 한 쪽에 대해 아무 동작을 수행하지 않도록 할 수 있는 다른 장치를 구현할 수 없을까?</li>\n<li>raii 객체의 복사/대입 가능성은 전혀 고려하지 않고 있는데, 이것에 대해서는 어떻게 다루는 것이 좋을까?</li>\n<li>raii 객체에 대해 multi-thread에서 접근한다고 할 필요가 있을 수 있는데, 위 raii class는 그런 관점에서는 일반적이라고 하기에는 무리가 있지 않을까?</li>\n</ul>\n<p>등등, storage, default template argument, ownership, thread-safety 등 몇 가지 세부 구현 전략에 대해서 더 raii class를 더 고민해볼 수 있는데, 이러한 것들을 <strong>단위 전략(policy)</strong> 이라고 불렀던 것이다(MC++D)</p>\n<p>이 내용은 굉장히 흥미롭겠지만, 여백이 부족하여 더 이상 적지 않는다.</p>\n<style class=\"vscode-highlight-styles\">:root {\n  --vscode-highlight-padding-v: 1rem;\n  --vscode-highlight-padding-h: 1.5rem;\n  --vscode-highlight-padding-top: var(--vscode-highlight-padding-v);\n  --vscode-highlight-padding-right: var(--vscode-highlight-padding-h);\n  --vscode-highlight-padding-bottom: var(--vscode-highlight-padding-v);\n  --vscode-highlight-padding-left: var(--vscode-highlight-padding-h);\n  --vscode-highlight-border-radius: 8px;\n\n  --vscode-highlight-line-highlighted-background-color: transparent;\n  --vscode-highlight-line-highlighted-border-width: 4px;\n  --vscode-highlight-line-highlighted-border-color: transparent;\n}\n\n.vscode-highlight {\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n  padding-top: 1rem;\n  padding-top: var(--vscode-highlight-padding-top);\n  padding-bottom: 1rem;\n  padding-bottom: var(--vscode-highlight-padding-bottom);\n  border-radius: 8px;\n  border-radius: var(--vscode-highlight-border-radius);\n  font-feature-settings: normal;\n}\n\n.vscode-highlight-code {\n  display: inline-block;\n  min-width: 100%;\n}\n\n.vscode-highlight-line {\n  display: inline-block;\n  box-sizing: border-box;\n  width: 100%;\n  padding-left: 1.5rem;\n  padding-left: var(--vscode-highlight-padding-left);\n  padding-right: 1.5rem;\n  padding-right: var(--vscode-highlight-padding-right);\n}\n\n.vscode-highlight-line-highlighted {\n  background-color: var(--vscode-highlight-line-highlighted-background-color);\n  box-shadow: inset var(--vscode-highlight-line-highlighted-border-width) 0 0 0 var(--vscode-highlight-line-highlighted-border-color);\n}\n.default-dark {\nbackground-color: #1E1E1E;\ncolor: #D4D4D4;\n}\n\n.default-dark .mtk1 { color: #D4D4D4; }\n.default-dark .mtk2 { color: #1E1E1E; }\n.default-dark .mtk3 { color: #6A9955; }\n.default-dark .mtk4 { color: #569CD6; }\n.default-dark .mtk5 { color: #D16969; }\n.default-dark .mtk6 { color: #D7BA7D; }\n.default-dark .mtk7 { color: #B5CEA8; }\n.default-dark .mtk8 { color: #CE9178; }\n.default-dark .mtk9 { color: #646695; }\n.default-dark .mtk10 { color: #4EC9B0; }\n.default-dark .mtk11 { color: #DCDCAA; }\n.default-dark .mtk12 { color: #9CDCFE; }\n.default-dark .mtk13 { color: #000080; }\n.default-dark .mtk14 { color: #F44747; }\n.default-dark .mtk15 { color: #C586C0; }\n.default-dark .mtk16 { color: #6796E6; }\n.default-dark .mtk17 { color: #808080; }\n.default-dark .mtki { font-style: italic; }\n.default-dark .mtkb { font-weight: bold; }\n.default-dark .mtku { text-decoration: underline; text-underline-position: under; }</style>","excerpt":"C++11은 lambda expression을 지원해주니 좀 다르게 생각해볼 수 있다.lock_t class 자체에 위와 같이 functor를 받아 실행할 수 있는 함수를 만든다. 그리고 그 앞 뒤로 lock-unlock…","fields":{"date":"May 12, 2012"},"frontmatter":{"title":"lambda와 RAII 2","tags":["c++"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2012/05/12/lambda-and-raii-2/"}}}