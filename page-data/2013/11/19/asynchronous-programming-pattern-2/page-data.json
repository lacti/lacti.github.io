{"componentChunkName":"component---src-templates-page-tsx","path":"/2013/11/19/asynchronous-programming-pattern-2/","webpackCompilationHash":"cdfa71eb19fc14d91b48","result":{"data":{"site":{"siteMetadata":{"title":"Lacti's Archive","description":"All about I learned","author":{"name":"Jaeyoung, Choi","url":"https://twitter.com/lacti"}}},"markdownRemark":{"html":"<p>위 이야기에 이어, async 작업과 then 작업 간의 상태 공유에 대해서 알아보자.<br>\nasync에서 then으로 상태를 전달하는 가장 기본적인 방법은 반환값을 사용하는 방법이다. 다른 방법으로는 lambda function에 의한 variable capture가 있겠다.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk3\">// method 1: using return value</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">std::</span><span class=\"mtk11\">async</span><span class=\"mtk1\">([] () { </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk7\">1</span><span class=\"mtk1\">; })</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    .</span><span class=\"mtk11\">then</span><span class=\"mtk1\">([] (std::future&lt;</span><span class=\"mtk4\">int</span><span class=\"mtk1\">&gt; f) { </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">f</span><span class=\"mtk1\">.</span><span class=\"mtk11\">get</span><span class=\"mtk1\">() + </span><span class=\"mtk7\">1</span><span class=\"mtk1\">; })</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    .</span><span class=\"mtk11\">then</span><span class=\"mtk1\">([] (std::future&lt;</span><span class=\"mtk4\">int</span><span class=\"mtk1\">&gt; f) { </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">f</span><span class=\"mtk1\">.</span><span class=\"mtk11\">get</span><span class=\"mtk1\">() + </span><span class=\"mtk7\">1</span><span class=\"mtk1\">; });</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk3\">// method 2: using variable capture by lambda function</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">int</span><span class=\"mtk1\"> result = </span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">std::</span><span class=\"mtk11\">async</span><span class=\"mtk1\">([&amp;result] () { result = </span><span class=\"mtk7\">1</span><span class=\"mtk1\">; })</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    .</span><span class=\"mtk11\">then</span><span class=\"mtk1\">([] () { ++result; })</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    .</span><span class=\"mtk11\">then</span><span class=\"mtk1\">([] () { ++result; });</span></span></code></pre>\n<p>반환 값으로 모든 context를 전달하는 것에는 한계가 있기 때문에 capture를 통한 방법이 더 편할 수 있다.</p>\n<p>하지만 capture되는 변수라는 것도 결국 접근 가능한 scope 내에 있을 때 컴파일러가 해줄 수 있는 것이기 때문에 요청해야 할 비동기 작업들이 여러 함수에 걸쳐서 분포할 경우에는 위 방법으로 구현하기도 간단하지는 않다. 따라서 직접 context와 수행할 작업을 묶어 <code>async_worker</code> class를 구현하는 경우도 있다.</p>\n<p>async<em>worker는 대충 context + async</em>work라고 생각하면 된다.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">class</span><span class=\"mtk1\"> </span><span class=\"mtk10\">my_async_worker</span><span class=\"mtk1\"> {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">public:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// async works</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">void</span><span class=\"mtk1\"> </span><span class=\"mtk11\">work1</span><span class=\"mtk1\">();</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">void</span><span class=\"mtk1\"> </span><span class=\"mtk11\">work2</span><span class=\"mtk1\">();</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">void</span><span class=\"mtk1\"> </span><span class=\"mtk11\">work3</span><span class=\"mtk1\">();</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">private:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// contexts</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">int</span><span class=\"mtk1\"> _context1;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    std::string _context2;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">};</span></span></code></pre>\n<p>즉 수행할 작업을 모두 멤버 함수로 넣고, 필요한 정보를 멤버 변수로 넣는다. 그리고 객체를 생성하고, 각 작업들을 비동기로 수행하고, 모두 완료되면 객체를 메모리에서 해제한다.</p>\n<p>async<em>worker 개념은 단순하고 직관적이다. 마치 functor를 만들기 위해 struct를 하나 만들고 <code>operator ()</code>를 구현하는 것과 비슷하다. 그리고 struct functor를 lambda function으로 바꾸듯, 대부분의 경우 async</em>worker는 async/then 패턴으로 코드를 정리할 수 있을 것이다.</p>\n<p>약간의? 차이가 있다면</p>\n<ul>\n<li>async는 그 자체가 오래 걸리는 작업인 경우가 많은데,</li>\n<li>async_worker의 <code>work()</code> 함수들은 다른 비동기 작업의 완료(completion)에 의해 callback으로 불리는 경우도 있고,</li>\n<li>각기 다른 <a href=\"%7B%25%20post_url%202011-08-11-synchronize-function-execution-in-each-object%20%25%7D\">객체의 수행 흐름</a>에서 불리는 경우도 있다.</li>\n</ul>\n<p>async_worker 패턴은 stackless coroutine 구현으로도 사용될 수 있다. stackless coroutine은 stack을 갖지 않는 coroutine으로 c#의 async/await을 생각하면 된다. 즉 instruction pointer와 stack pointer를 치환하는 방식의 coroutine이 아닌 compiler의 code generation을 통해 multiple entry/return을 구현하는 방식이라고 생각하면 되겠다.<br>\n(자세한 이야기는 coroutine 이야기에서 다루도록 하겠다)</p>\n<p>쉬운 접근을 위해 <code>my_async_worker</code> 코드를 다음과 같이 고쳐보도록 하겠다.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">class</span><span class=\"mtk1\"> </span><span class=\"mtk10\">my_async_worker</span><span class=\"mtk1\"> {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">public:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">bool</span><span class=\"mtk1\"> </span><span class=\"mtk11\">execute</span><span class=\"mtk1\">() {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (_state == </span><span class=\"mtk7\">0</span><span class=\"mtk1\">) { </span><span class=\"mtk11\">work1</span><span class=\"mtk1\">(); _state = </span><span class=\"mtk7\">1</span><span class=\"mtk1\">; </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk4\">true</span><span class=\"mtk1\">; }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (_state == </span><span class=\"mtk7\">1</span><span class=\"mtk1\">) { </span><span class=\"mtk11\">work2</span><span class=\"mtk1\">(); _state = </span><span class=\"mtk7\">2</span><span class=\"mtk1\">; </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk4\">true</span><span class=\"mtk1\">; }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (_state == </span><span class=\"mtk7\">2</span><span class=\"mtk1\">) </span><span class=\"mtk11\">work3</span><span class=\"mtk1\">();</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk4\">false</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">private:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">int</span><span class=\"mtk1\"> _state;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// functions</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// contexts</span></span></code></pre>\n<p>비동기 함수의 context와 function을 private으로 갖고, execute() 함수만 노출되어 있다. 그리고 <code>execute()</code> 함수가 불릴 때마다 state가 전이되어 차례로 work1, 2, 3이 호출될 수 있도록 해준다.</p>\n<ul>\n<li>즉 <code>my_async_worker::execute()</code>를 처음 불러서 <code>work1()</code> 작업을 수행한다.</li>\n<li>그리고 <code>work1()</code> 작업에 대한 completion이 도착하면 다시 <code>execute()</code>를 불러서 <code>work2()</code> 작업을 수행한다.</li>\n<li>그리고 <code>work2()</code> 작업에 대한 completion이 도착하면 다시 <code>execute()</code>를 불러서 <code>work3()</code> 작업을 수행한다.</li>\n<li>이 때 <code>execute()</code>는 return을 반환하므로 더 이상 수행할 작업이 없는 것이다. 따라서 <code>my_async_worker</code> 객체를 메모리에서 제거한다.</li>\n</ul>\n<p>위와 같은 state machine은 기계적으로 생성이 가능하기 때문에 compiler에서 위와 같은 방법을 사용하여 구현한 c#의 async/await이 있는가 하면 <a href=\"https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html\">c에서는 macro으로 구현한 것</a>도 있다.</p>\n<p>async를 통해 비동기 작업을 시작한 후 then으로 이어할 작업을 설정하는 async/then 패턴과, 수행할 비동기 작업과 context를 묶어서 하나의 객체로 구성하는 async_worker 패턴을 간단히 알아보았다.</p>\n<p>각자의 기본 개념을 적절히 이해하여 각 상황에 맞게 적절히 사용하면 되겠다.</p>\n<style class=\"vscode-highlight-styles\">:root {\n  --vscode-highlight-padding-v: 1rem;\n  --vscode-highlight-padding-h: 1.5rem;\n  --vscode-highlight-padding-top: var(--vscode-highlight-padding-v);\n  --vscode-highlight-padding-right: var(--vscode-highlight-padding-h);\n  --vscode-highlight-padding-bottom: var(--vscode-highlight-padding-v);\n  --vscode-highlight-padding-left: var(--vscode-highlight-padding-h);\n  --vscode-highlight-border-radius: 8px;\n\n  --vscode-highlight-line-highlighted-background-color: transparent;\n  --vscode-highlight-line-highlighted-border-width: 4px;\n  --vscode-highlight-line-highlighted-border-color: transparent;\n}\n\n.vscode-highlight {\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n  padding-top: 1rem;\n  padding-top: var(--vscode-highlight-padding-top);\n  padding-bottom: 1rem;\n  padding-bottom: var(--vscode-highlight-padding-bottom);\n  border-radius: 8px;\n  border-radius: var(--vscode-highlight-border-radius);\n  font-feature-settings: normal;\n}\n\n.vscode-highlight-code {\n  display: inline-block;\n  min-width: 100%;\n}\n\n.vscode-highlight-line {\n  display: inline-block;\n  box-sizing: border-box;\n  width: 100%;\n  padding-left: 1.5rem;\n  padding-left: var(--vscode-highlight-padding-left);\n  padding-right: 1.5rem;\n  padding-right: var(--vscode-highlight-padding-right);\n}\n\n.vscode-highlight-line-highlighted {\n  background-color: var(--vscode-highlight-line-highlighted-background-color);\n  box-shadow: inset var(--vscode-highlight-line-highlighted-border-width) 0 0 0 var(--vscode-highlight-line-highlighted-border-color);\n}\n.default-dark {\nbackground-color: #1E1E1E;\ncolor: #D4D4D4;\n}\n\n.default-dark .mtk1 { color: #D4D4D4; }\n.default-dark .mtk2 { color: #1E1E1E; }\n.default-dark .mtk3 { color: #6A9955; }\n.default-dark .mtk4 { color: #569CD6; }\n.default-dark .mtk5 { color: #D16969; }\n.default-dark .mtk6 { color: #D7BA7D; }\n.default-dark .mtk7 { color: #B5CEA8; }\n.default-dark .mtk8 { color: #CE9178; }\n.default-dark .mtk9 { color: #646695; }\n.default-dark .mtk10 { color: #4EC9B0; }\n.default-dark .mtk11 { color: #DCDCAA; }\n.default-dark .mtk12 { color: #9CDCFE; }\n.default-dark .mtk13 { color: #000080; }\n.default-dark .mtk14 { color: #F44747; }\n.default-dark .mtk15 { color: #C586C0; }\n.default-dark .mtk16 { color: #6796E6; }\n.default-dark .mtk17 { color: #808080; }\n.default-dark .mtki { font-style: italic; }\n.default-dark .mtkb { font-weight: bold; }\n.default-dark .mtku { text-decoration: underline; text-underline-position: under; }</style>","excerpt":"위 이야기에 이어, async 작업과 then 작업 간의 상태 공유에 대해서 알아보자.async에서 then으로 상태를 전달하는 가장 기본적인 방법은 반환값을 사용하는 방법이다. 다른 방법으로는 lambda function에 의한 variable…","fields":{"date":"November 19, 2013","shortdesc":""},"frontmatter":{"title":"비동기 프로그래밍 패턴 2","tags":["async","design"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2013/11/19/asynchronous-programming-pattern-2/"}}}