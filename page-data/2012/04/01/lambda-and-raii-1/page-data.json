{"componentChunkName":"component---src-templates-page-tsx","path":"/2012/04/01/lambda-and-raii-1/","webpackCompilationHash":"86a6406c6b4e5482e871","result":{"data":{"site":{"siteMetadata":{"title":"Lacti's Archive","description":"All about I learned","author":{"name":"Jaeyoung, Choi","url":"https://twitter.com/lacti"}}},"markdownRemark":{"html":"<p>C++11 에서 도입된 lambda expression을 통한 RAII 구현 방식의 한 예와, 단위 전략을 통한 RAII 구현을 통해 장단점을 비교해보자.</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization\">Wiki: Resource Acquisition Is Initialization(RAII)</a>는 scope 내의 정적으로 할당되는 객체의 생존 주기로 생성자와 소멸자가 쌍으로 호출되는 것을 사용하는 자원 관리 기법이다. 보통</p>\n<ul>\n<li>IO (열었으면 닫아야하니까),</li>\n<li>메모리 (할당했으면 해제해야하니까, shared_ptr도 AddReference 했으면 ReleaseReference)</li>\n<li>Lock (Lock 걸었으면 Unlock 해줘야하니까)</li>\n</ul>\n<p>등에서 사용된다.</p>\n<p>본 글에서는 Lock을 사용하여 예를 들어보자.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">class</span><span class=\"mtk1\"> </span><span class=\"mtk10\">lock_t</span><span class=\"mtk1\"> {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">public:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">void</span><span class=\"mtk1\"> </span><span class=\"mtk11\">lock</span><span class=\"mtk1\">();</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">void</span><span class=\"mtk1\"> </span><span class=\"mtk11\">unlock</span><span class=\"mtk1\">();</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">};</span></span></code></pre>\n<p>위와 같은 <code>lock_t</code> class가 정의되어 있다. 어떤 class에서 저 객체를 쓴다고 해보자.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">class</span><span class=\"mtk1\"> </span><span class=\"mtk10\">item_t</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">typedef</span><span class=\"mtk1\"> __int64 </span><span class=\"mtk10\">item_id_t</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">typedef</span><span class=\"mtk1\"> </span><span class=\"mtk10\">std</span><span class=\"mtk1\">::shared_ptr&lt;</span><span class=\"mtk10\">item_t</span><span class=\"mtk1\">&gt; item_ref;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">class</span><span class=\"mtk1\"> </span><span class=\"mtk10\">inventory_t</span><span class=\"mtk1\"> {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">public:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk10\">item_ref</span><span class=\"mtk1\"> </span><span class=\"mtk11\">find</span><span class=\"mtk1\">(</span><span class=\"mtk10\">item_id_t</span><span class=\"mtk1\"> </span><span class=\"mtk12\">item_id</span><span class=\"mtk1\">);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">private:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk10\">lock_t</span><span class=\"mtk1\"> lock;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk10\">std</span><span class=\"mtk1\">::vector&lt;item_ref&gt; items;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">};</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk10\">item_ref</span><span class=\"mtk1\"> </span><span class=\"mtk10\">inventory_t</span><span class=\"mtk1\">::</span><span class=\"mtk11\">find</span><span class=\"mtk1\">(</span><span class=\"mtk10\">item_id_t</span><span class=\"mtk1\"> </span><span class=\"mtk12\">item_id</span><span class=\"mtk1\">) {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk12\">lock</span><span class=\"mtk1\">.</span><span class=\"mtk11\">lock</span><span class=\"mtk1\">();</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">auto</span><span class=\"mtk1\"> iter = </span><span class=\"mtk10\">std</span><span class=\"mtk1\">::</span><span class=\"mtk11\">find</span><span class=\"mtk1\">(</span><span class=\"mtk12\">items</span><span class=\"mtk1\">.</span><span class=\"mtk11\">begin</span><span class=\"mtk1\">(), </span><span class=\"mtk12\">items</span><span class=\"mtk1\">.</span><span class=\"mtk11\">end</span><span class=\"mtk1\">(), </span><span class=\"mtk11\">find_item_by_id</span><span class=\"mtk1\">(item_id));</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (iter != </span><span class=\"mtk12\">items</span><span class=\"mtk1\">.</span><span class=\"mtk11\">end</span><span class=\"mtk1\">())</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> (*iter);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk12\">lock</span><span class=\"mtk1\">.</span><span class=\"mtk11\">unlock</span><span class=\"mtk1\">();</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk11\">item_ref</span><span class=\"mtk1\">(</span><span class=\"mtk4\">NULL</span><span class=\"mtk1\">);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">}</span></span></code></pre>\n<p>inventory가 가지고 있는 item에 대한 정보는 item의 <code>vector</code>로 관리하고 있다. 저 inventory 객체를 여러 Thread에서 접근한다고 하면, <code>std::find()</code>에 의해 <code>vector</code>를 순회하다가 접근 위반이 발생할 가능성이 있다. (한 thread 는 순회하고, 한 thread 는 vector 에 삽입/삭제할 경우)\n따라서 lock을 사용하여 해당 container 를 보호해준다.</p>\n<p>하지만 위 코드는 문제가 있다.<br>\n<code>lock</code>을 사용하여 <code>items</code>로의 접근을 보호하지만, 실제 item을 찾은 다음 return 문을 수행하기 전에 <code>unlock</code>을 수행하지 않았기 때문이다. 이러한 문제는 <code>find</code> 함수가 좀만 길어지면, 혹은 조금만 신경을 쓰지 않게 되면 흔히 발생할 수 있는 문제이다.</p>\n<p>따라서 이러한 문제를 해결하기 위해 정적 객체의 생존 주기를 활용한다.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">class</span><span class=\"mtk1\"> </span><span class=\"mtk10\">scope_lock_t</span><span class=\"mtk1\"> {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">public:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk11\">scope_lock_t</span><span class=\"mtk1\">(</span><span class=\"mtk10\">lock_t</span><span class=\"mtk4\">*</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_lock</span><span class=\"mtk1\">) : </span><span class=\"mtk11\">lock</span><span class=\"mtk1\">(_lock) { </span><span class=\"mtk12\">lock</span><span class=\"mtk1\">-&gt;</span><span class=\"mtk11\">lock</span><span class=\"mtk1\">(); }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk11\">~scope_lock_t</span><span class=\"mtk1\">() { </span><span class=\"mtk12\">lock</span><span class=\"mtk1\">-&gt;</span><span class=\"mtk11\">unlock</span><span class=\"mtk1\">(); }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">private:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk10\">lock_t</span><span class=\"mtk1\">* lock;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">};</span></span></code></pre>\n<p>멤버로 <code>lock_t</code>에 대한 pointer를 갖고, 생성자에서 <code>lock()</code>을 부르고 소멸자에서 <code>unlock()</code>을 부르도록 하는 <code>scope_lock_t</code> class를 설계한다. 그러면 코드가 아래와 같이 바뀐다.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk10\">item_ref</span><span class=\"mtk1\"> </span><span class=\"mtk10\">inventory_t</span><span class=\"mtk1\">::</span><span class=\"mtk11\">find</span><span class=\"mtk1\">(</span><span class=\"mtk10\">item_id_t</span><span class=\"mtk1\"> </span><span class=\"mtk12\">item_id</span><span class=\"mtk1\">) {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk10\">scope_lock_t</span><span class=\"mtk1\"> </span><span class=\"mtk11\">scope_lock</span><span class=\"mtk1\">(&amp;lock);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">auto</span><span class=\"mtk1\"> iter = </span><span class=\"mtk10\">std</span><span class=\"mtk1\">::</span><span class=\"mtk11\">find</span><span class=\"mtk1\">(</span><span class=\"mtk12\">items</span><span class=\"mtk1\">.</span><span class=\"mtk11\">begin</span><span class=\"mtk1\">(), </span><span class=\"mtk12\">items</span><span class=\"mtk1\">.</span><span class=\"mtk11\">end</span><span class=\"mtk1\">(), </span><span class=\"mtk11\">find_item_by_id</span><span class=\"mtk1\">(item_id));</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (iter != </span><span class=\"mtk12\">items</span><span class=\"mtk1\">.</span><span class=\"mtk11\">end</span><span class=\"mtk1\">())</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> (*iter);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk11\">item_ref</span><span class=\"mtk1\">(</span><span class=\"mtk4\">NULL</span><span class=\"mtk1\">);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">}</span></span></code></pre>\n<p><code>scope_lock_t</code> 객체가 멤버 변수인 <code>lock</code>을 가지고 생성된다. 생성될 때 <code>scope_lock_t</code>의 생성자에서 <code>lock()</code> 함수가 불린다. 그리고 실제 로직이 아래에서 수행되고 <code>inventory_t::find()</code> 함수가 종료되는 시점, 즉 <code>scope_lock_t</code> 객체가 소멸되는 시점에 <code>unlock()</code> 함수가 불린다.</p>\n<p>생성자와 소멸자는 해당 객체의 생성/소멸 시점에 컴파일러가 알아서 불러주므로, 위와 같이 <code>scope_lock_t</code>를 만들어 쓰면 중간에 return을 해도, goto를 해도, 1년 뒤에 코드를 고쳐도! lock-unlock쌍이 잘 맞게 된다.\n<a href=\"%7B%25%20post_url%202011-07-20-object-ctor-dtor-with-goto%20%25%7D\">(객체 생성/소멸자와 goto 에 대한 이야기)</a></p>\n<style class=\"vscode-highlight-styles\">:root {\n  --vscode-highlight-padding-v: 1rem;\n  --vscode-highlight-padding-h: 1.5rem;\n  --vscode-highlight-padding-top: var(--vscode-highlight-padding-v);\n  --vscode-highlight-padding-right: var(--vscode-highlight-padding-h);\n  --vscode-highlight-padding-bottom: var(--vscode-highlight-padding-v);\n  --vscode-highlight-padding-left: var(--vscode-highlight-padding-h);\n  --vscode-highlight-border-radius: 8px;\n\n  --vscode-highlight-line-highlighted-background-color: transparent;\n  --vscode-highlight-line-highlighted-border-width: 4px;\n  --vscode-highlight-line-highlighted-border-color: transparent;\n}\n\n.vscode-highlight {\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n  padding-top: 1rem;\n  padding-top: var(--vscode-highlight-padding-top);\n  padding-bottom: 1rem;\n  padding-bottom: var(--vscode-highlight-padding-bottom);\n  border-radius: 8px;\n  border-radius: var(--vscode-highlight-border-radius);\n  font-feature-settings: normal;\n}\n\n.vscode-highlight-code {\n  display: inline-block;\n  min-width: 100%;\n}\n\n.vscode-highlight-line {\n  display: inline-block;\n  box-sizing: border-box;\n  width: 100%;\n  padding-left: 1.5rem;\n  padding-left: var(--vscode-highlight-padding-left);\n  padding-right: 1.5rem;\n  padding-right: var(--vscode-highlight-padding-right);\n}\n\n.vscode-highlight-line-highlighted {\n  background-color: var(--vscode-highlight-line-highlighted-background-color);\n  box-shadow: inset var(--vscode-highlight-line-highlighted-border-width) 0 0 0 var(--vscode-highlight-line-highlighted-border-color);\n}\n.default-dark {\nbackground-color: #1E1E1E;\ncolor: #D4D4D4;\n}\n\n.default-dark .mtk1 { color: #D4D4D4; }\n.default-dark .mtk2 { color: #1E1E1E; }\n.default-dark .mtk3 { color: #6A9955; }\n.default-dark .mtk4 { color: #569CD6; }\n.default-dark .mtk5 { color: #D16969; }\n.default-dark .mtk6 { color: #D7BA7D; }\n.default-dark .mtk7 { color: #B5CEA8; }\n.default-dark .mtk8 { color: #CE9178; }\n.default-dark .mtk9 { color: #646695; }\n.default-dark .mtk10 { color: #4EC9B0; }\n.default-dark .mtk11 { color: #DCDCAA; }\n.default-dark .mtk12 { color: #9CDCFE; }\n.default-dark .mtk13 { color: #000080; }\n.default-dark .mtk14 { color: #F44747; }\n.default-dark .mtk15 { color: #C586C0; }\n.default-dark .mtk16 { color: #6796E6; }\n.default-dark .mtk17 { color: #808080; }\n.default-dark .mtki { font-style: italic; }\n.default-dark .mtkb { font-weight: bold; }\n.default-dark .mtku { text-decoration: underline; text-underline-position: under; }</style>","excerpt":"C++11 에서 도입된 lambda expression을 통한 RAII 구현 방식의 한 예와, 단위 전략을 통한 RAII 구현을 통해 장단점을 비교해보자. Wiki: Resource Acquisition Is Initialization(RAII…","fields":{"date":"April 01, 2012","shortdesc":""},"frontmatter":{"title":"lambda와 RAII 1","tags":["c++"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2012/04/01/lambda-and-raii-1/"}}}