{"componentChunkName":"component---src-templates-page-tsx","path":"/2012/10/31/member-data-pointer-casting-safety/","webpackCompilationHash":"cdfa71eb19fc14d91b48","result":{"data":{"site":{"siteMetadata":{"title":"Lacti's Archive","description":"All about I learned","author":{"name":"Jaeyoung, Choi","url":"https://twitter.com/lacti"}}},"markdownRemark":{"html":"<p>어제 동아리 친구와 이야기를 나누다 run-time에서는 float array를 float pointer로 casting하여 사용할 수 있는데 compile time에서는 왜 그럴 수 없냐는 이야기가 나왔다.</p>\n<p>질문이 좀 미묘한데, 좀 더 정확히 정의하자면 <em>float array type의 member data pointer를 float pointer type의 member data pointer로 casting하여 사용할 수 없냐</em>는 이야기이다.</p>\n<p><strong>일단 결론부터 이야기하자면, casting은 가능하지만 정의되지 않은 동작을 한다.</strong></p>\n<p>예제 코드를 간단히 꾸려보면 다음과 같다.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">enum</span><span class=\"mtk1\"> stat_speed { ss_walk, ss_run, ss_max };</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">struct</span><span class=\"mtk1\"> </span><span class=\"mtk10\">stat_t</span><span class=\"mtk1\"> {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk11\">stat_t</span><span class=\"mtk1\">() {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        std::</span><span class=\"mtk11\">fill</span><span class=\"mtk1\">(speed, speed + ss_max, </span><span class=\"mtk7\">0.0f</span><span class=\"mtk1\">);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">float</span><span class=\"mtk1\"> </span><span class=\"mtk12\">speed</span><span class=\"mtk1\">[ss_max];</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">};</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">template</span><span class=\"mtk1\"> &lt;float* stat_t::*</span><span class=\"mtk4\">dataptr</span><span class=\"mtk1\">&gt;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">struct</span><span class=\"mtk1\"> </span><span class=\"mtk10\">accessor</span><span class=\"mtk1\"> {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">static</span><span class=\"mtk1\"> </span><span class=\"mtk4\">float</span><span class=\"mtk1\"> </span><span class=\"mtk11\">get</span><span class=\"mtk1\">(</span><span class=\"mtk10\">stat_t</span><span class=\"mtk1\">&amp; </span><span class=\"mtk12\">obj</span><span class=\"mtk1\">) {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> *(</span><span class=\"mtk12\">obj.*dataptr</span><span class=\"mtk1\">);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">};</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">int</span><span class=\"mtk1\"> </span><span class=\"mtk11\">_tmain</span><span class=\"mtk1\">(</span><span class=\"mtk4\">int</span><span class=\"mtk1\"> </span><span class=\"mtk12\">argc</span><span class=\"mtk1\">, _TCHAR* </span><span class=\"mtk12\">argv</span><span class=\"mtk1\">[])</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">{</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">typedef</span><span class=\"mtk1\"> </span><span class=\"mtk4\">float</span><span class=\"mtk1\">* stat_t::*fpointer_ptr;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// fpointer_ptr aptr = static_cast&lt;fpointer_ptr&gt;(&amp;stat_t::speed); // cannot convert</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    fpointer_ptr aptr = </span><span class=\"mtk11\">reinterpret_cast</span><span class=\"mtk1\">&lt;</span><span class=\"mtk4\">fpointer_ptr</span><span class=\"mtk1\">&gt;(&amp;stat_t::speed);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk10\">stat_t</span><span class=\"mtk1\"> stat;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">typedef</span><span class=\"mtk1\"> accessor&lt;</span><span class=\"mtk4\">reinterpret_cast</span><span class=\"mtk1\">&lt;</span><span class=\"mtk4\">float</span><span class=\"mtk1\">* stat_t::*&gt;(&amp;stat_t::speed)&gt; accessor;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    std::cout &lt;&lt; accessor::</span><span class=\"mtk11\">get</span><span class=\"mtk1\">(stat) &lt;&lt; std::endl;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">}</span></span></code></pre>\n<p><code>stat_t</code>의 <code>speed</code>는 <code>float (stat_t::*)[ss_max]</code> type이다. 이것을 <code>float* stat_t::*</code> type으로 바꿔볼 것이다. 당연한 이야기이지만 이 두 개의 type은 완전히 다르기 때문에 <code>static_cast</code>로는 형 변환이 안된다. 때문에 <code>reinterpret_cast</code>를 사용해서 강제 형 변환을 유도해야 한다.</p>\n<p>(run-time에서 메모리에 존재하는 배열과 그곳을 접근하기 위한 주소 값의 의미인 포인터로 둘이 동일하게 동작하는 것으로 생각할 수는 있지만, compiler가 생각하는 type 입장에서는 완전 다른 type이다.)</p>\n<p>template parameter로 넘겨줄 때에도 <code>reinterpret_cast</code>를 사용해서 넘겨주면 형식 안정성을 다 무시하고 그냥 넘겨줄 수 있다. 때문에 위 <code>accessor::get()</code> 함수가 호출되는 위 코드 전체에는 아무런 compile error가 없다.</p>\n<p>template programming을 하는 이유가 compile time에 검사해주는 type check를 사용하여 형식 안정성을 보장해주기 위함인데, <code>reinterpret_cast</code>가 들어간 시점에서 위 코드는 그냥 망했다.</p>\n<p>뭐 일단 casting해서 template parameter를 넘길 수 있냐 없냐를 보여주기 위한 억지 예제이기는 하다. 이제 compile 성공 여부를 떠나서 위 코드가 제대로 실행되는지 보자.</p>\n<p>일단 member data pointer가 어떤 구조를 가졌는지를 설명해야 하는데, 자세한 내용은 대충 이 pdf의 chapter 3에서 확인하고 요점만 이야기해보자.</p>\n<ul>\n<li><a href=\"https://www.dsi.fceia.unr.edu.ar/downloads/informatica/info_II/c++../inside.the.c++.object.model.pdf\">PDF: Inside the C++ object model</a></li>\n</ul>\n<p>member function pointer를 보면, 단순히 어떤 클래스의 함수의 주소 값만 가지고 있으면 될 것 같지만 이게 vfptr를 참조해야 하는지, 그리고 그 상속 구조가 다중 상속 혹은 virtual 상속 구조인지에 따라서 내부 구성이 좀 달라진다. 그런데 이게 c++ 표준에 명세만 있고 구현이 없어서 컴파일러마다 구현체가 제각각이다. (즉 무슨 짓을 해놓는지 모름)</p>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Thunk#Object-oriented_programming\">Wiki: Thunk (object-oriented programming)</a></li>\n</ul>\n<p>위와 동일한 개념이 member data pointer에도 적용된다고 보면 된다. 때문에 member data pointer가 단순 offset_of의 개념이라고 생각하면 안된다. (사실 고백하자면, 이 예제를 이해하는데 위 내용을 다 알아야 할 필요는 없지만 그냥 기회가 되었으니 공부하는 셈 치고 보면 좋다)</p>\n<p>즉, 위 예제에서 <code>float (stat_t::*)[ss_max]</code>를 <code>float* stat_t::*</code>으로 casting하고, 그것을 dereferencing한 <code>float*</code> 값을 다시 dereferencing했을 때 <code>speed[ss_walk]</code>가 나오지 않는다는 이야기다. (즉 run-time에서 우리가 해왔던 것과는 조금 다르게 동작한다)</p>\n<p>심지어 예제를 돌려보면 잘못된 메모리 접근으로 프로그램이 계속 죽는다!</p>\n<p>시간이 부족한 관계로 위 예제가 실제로 어떻게 동작하는지 disassemble해서 살펴 보는 것과 그러면 어떻게 이해를 해야 하고 어떻게 코드를 고치면 위 문제를 풀어볼 수 있을지에 대해서는 다음 글에서 알아보자.</p>\n<style class=\"vscode-highlight-styles\">:root {\n  --vscode-highlight-padding-v: 1rem;\n  --vscode-highlight-padding-h: 1.5rem;\n  --vscode-highlight-padding-top: var(--vscode-highlight-padding-v);\n  --vscode-highlight-padding-right: var(--vscode-highlight-padding-h);\n  --vscode-highlight-padding-bottom: var(--vscode-highlight-padding-v);\n  --vscode-highlight-padding-left: var(--vscode-highlight-padding-h);\n  --vscode-highlight-border-radius: 8px;\n\n  --vscode-highlight-line-highlighted-background-color: transparent;\n  --vscode-highlight-line-highlighted-border-width: 4px;\n  --vscode-highlight-line-highlighted-border-color: transparent;\n}\n\n.vscode-highlight {\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n  padding-top: 1rem;\n  padding-top: var(--vscode-highlight-padding-top);\n  padding-bottom: 1rem;\n  padding-bottom: var(--vscode-highlight-padding-bottom);\n  border-radius: 8px;\n  border-radius: var(--vscode-highlight-border-radius);\n  font-feature-settings: normal;\n}\n\n.vscode-highlight-code {\n  display: inline-block;\n  min-width: 100%;\n}\n\n.vscode-highlight-line {\n  display: inline-block;\n  box-sizing: border-box;\n  width: 100%;\n  padding-left: 1.5rem;\n  padding-left: var(--vscode-highlight-padding-left);\n  padding-right: 1.5rem;\n  padding-right: var(--vscode-highlight-padding-right);\n}\n\n.vscode-highlight-line-highlighted {\n  background-color: var(--vscode-highlight-line-highlighted-background-color);\n  box-shadow: inset var(--vscode-highlight-line-highlighted-border-width) 0 0 0 var(--vscode-highlight-line-highlighted-border-color);\n}\n.default-dark {\nbackground-color: #1E1E1E;\ncolor: #D4D4D4;\n}\n\n.default-dark .mtk1 { color: #D4D4D4; }\n.default-dark .mtk2 { color: #1E1E1E; }\n.default-dark .mtk3 { color: #6A9955; }\n.default-dark .mtk4 { color: #569CD6; }\n.default-dark .mtk5 { color: #D16969; }\n.default-dark .mtk6 { color: #D7BA7D; }\n.default-dark .mtk7 { color: #B5CEA8; }\n.default-dark .mtk8 { color: #CE9178; }\n.default-dark .mtk9 { color: #646695; }\n.default-dark .mtk10 { color: #4EC9B0; }\n.default-dark .mtk11 { color: #DCDCAA; }\n.default-dark .mtk12 { color: #9CDCFE; }\n.default-dark .mtk13 { color: #000080; }\n.default-dark .mtk14 { color: #F44747; }\n.default-dark .mtk15 { color: #C586C0; }\n.default-dark .mtk16 { color: #6796E6; }\n.default-dark .mtk17 { color: #808080; }\n.default-dark .mtki { font-style: italic; }\n.default-dark .mtkb { font-weight: bold; }\n.default-dark .mtku { text-decoration: underline; text-underline-position: under; }</style>","excerpt":"어제 동아리 친구와 이야기를 나누다 run-time에서는 float array를 float pointer로 casting하여 사용할 수 있는데 compile time…","fields":{"date":"October 31, 2012","shortdesc":""},"frontmatter":{"title":"멤버 데이터 포인터의 casting과 안정성 1","tags":["c++"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2012/10/31/member-data-pointer-casting-safety/"}}}