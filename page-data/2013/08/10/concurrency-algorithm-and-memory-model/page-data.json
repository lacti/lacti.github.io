{"componentChunkName":"component---src-templates-page-tsx","path":"/2013/08/10/concurrency-algorithm-and-memory-model/","webpackCompilationHash":"906e474feba7d651d076","result":{"data":{"site":{"siteMetadata":{"title":"Lacti's Archive","description":"All about I learned","author":{"name":"Jaeyoung, Choi","url":"https://twitter.com/lacti"}}},"markdownRemark":{"html":"<p>오늘 스터디에서 공부한 내용을 간략히 정리해보자.</p>\n<p>원래 의도는,</p>\n<ul>\n<li>peterson’s algorithm을 보고 여기서 비순차 실행이 일어날 때 발생하는 문제를 보고,</li>\n<li>memory consistency model의 memory order를 통해 문제를 어떻게 해결할 수 있는지 본 후에,</li>\n<li>lock free stack, lock free queue algorithm을 보고 문제를 파악한 후에 이를 해결하기 위해</li>\n<li>hazard pointer를 보려고 했는데</li>\n</ul>\n<p>순서가 꼬였다-_-\n아무튼 의도했던 순서로 정리하겠음</p>\n<h2>peterson’s algorithm</h2>\n<p><a href=\"https://en.wikipedia.org/wiki/Peterson&#x27;s_algorithm\">Wiki: Peterson’s algorithm</a></p>\n<p>그냥 눈에 보이는대로 코드가 수행되면 문제가 발생하지 않는데, 비순차 실행에 의해 <code>flag[my_index] = true; turn = other_index;</code> 대입의 순서가 뒤집히면 critical section에 두 thread가 진입할 수 있는 문제가 발생한다.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk1\">P0: turn = </span><span class=\"mtk7\">1</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk12\">flag</span><span class=\"mtk1\">[</span><span class=\"mtk7\">0</span><span class=\"mtk1\">] = </span><span class=\"mtk4\">true</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk15\">while</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">flag</span><span class=\"mtk1\">[</span><span class=\"mtk7\">1</span><span class=\"mtk1\">] == </span><span class=\"mtk4\">true</span><span class=\"mtk1\"> &amp;&amp; turn == </span><span class=\"mtk7\">1</span><span class=\"mtk1\">)</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk3\">        // busy wait</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk3\">    // critical section</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    ...</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk3\">    // end of critical section</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk12\">flag</span><span class=\"mtk1\">[</span><span class=\"mtk7\">0</span><span class=\"mtk1\">] = </span><span class=\"mtk4\">false</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">P1: turn = </span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk12\">flag</span><span class=\"mtk1\">[</span><span class=\"mtk7\">1</span><span class=\"mtk1\">] = </span><span class=\"mtk4\">true</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk15\">while</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">flag</span><span class=\"mtk1\">[</span><span class=\"mtk7\">0</span><span class=\"mtk1\">] == </span><span class=\"mtk4\">true</span><span class=\"mtk1\"> &amp;&amp; turn == </span><span class=\"mtk7\">0</span><span class=\"mtk1\">)</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk3\">        // busy wait</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk3\">    // critical section</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    ...</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk3\">    // end of critical section</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk12\">flag</span><span class=\"mtk1\">[</span><span class=\"mtk7\">1</span><span class=\"mtk1\">] = </span><span class=\"mtk4\">false</span><span class=\"mtk1\">;</span></span></code></pre>\n<p>위 코드에 대해 아래와 같은 수행 흐름이 나오면 critical section이 보호되지 않는다.</p>\n<table>\n<thead>\n<tr>\n<th>turn</th>\n<th>flag_0</th>\n<th>flag_1</th>\n<th>진행</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>false</td>\n<td>false</td>\n<td>초기상태</td>\n</tr>\n<tr>\n<td>1</td>\n<td>false</td>\n<td>false</td>\n<td>p0: turn = 1</td>\n</tr>\n<tr>\n<td>0</td>\n<td>false</td>\n<td>false</td>\n<td>p1: turn = 0</td>\n</tr>\n<tr>\n<td>0</td>\n<td>false</td>\n<td>true</td>\n<td>p1: flag_1 = true // p1 진입</td>\n</tr>\n<tr>\n<td>0</td>\n<td>true</td>\n<td>true</td>\n<td>p2: flag_0 = true // p0 진입</td>\n</tr>\n</tbody>\n</table>\n<h2>memory consistency model</h2>\n<p>비순차 실행에 의해 의존성이 없다고 판단되는 연산의 순서가 뒤집히는 것을 방지하기 위해 memory consistency model을 고민해야 한다.</p>\n<ul>\n<li><a href=\"https://www.hpl.hp.com/techreports/Compaq-DEC/WRL-95-7.pdf\">WRL RR: Shared MEmory Consistency Models: A Tutorial</a></li>\n<li><a href=\"https://www.boost.org/doc/libs/release/doc/html/atomic/thread_coordination.html\">Boost: Thread coordination using Boost.Atomic</a></li>\n<li><a href=\"https://en.cppreference.com/w/cpp/atomic/memory_order\">Cppref: std::memory_order</a></li>\n</ul>\n<p>메모리 가시성 개념도 포함되어 있음. fence를 경계로 비순차 수행 가능 범위의 경계가 생김.<br>\n인텔 x86-64 core를 쓰면 알아서 해주기 때문에 프로그래머가 신경 쓸 필요가 없다.</p>\n<p>표준에서 설명하는 <code>memory_order_consume</code>, <code>memory_order_acquire</code>의 차이를 잘 모르겠음.\n그리고 boost thread_coordination 문서의 마지막 예제 내용을 잘 모르겠음.</p>\n<p>위 질문에 대한 [summerlight]님의 답변</p>\n<blockquote>\n<p>consume와 acquire 시멘틱에 대한 차이: DEC alpha에서 작업할거 아니면 그냥 acquire로 통일하면 됨.</p>\n</blockquote>\n<h2>lock free algorithm과 aba problem</h2>\n<ul>\n<li>lock free algorithm과 aba problem: <a href=\"https://sites.google.com/site/doc4code/Non-Blocking%20Algorithm.pdf\">Non<em>Blocking</em>Algorithm.pdf</a></li>\n<li>obstruction-free, lock-free, wait-free 개념 구분</li>\n<li>CAS, CAS2(CASW), DCAS, TSX, RTM 대충</li>\n<li>aba problem이 잘 설명되어 있다. CAS를 node pointer로만 하기 때문에 그 주소값만 같으면 해당 주소가 가리키는 객체의 상태가 어떻게 변했어도 작업이 진행될 수 있는 것이 문제.<br>\n(즉 stack/queue를 나갔다가 다시 들어왔을 때, 해제되었다가 다시 할당되었는데 그 주소가 같을 때)\nw\n즉, 객체의 pointer 비교만으로는 객체의 상태 비교가 안되므로 count를 넣어서 객체의 버전관리(?)를 한다. CAS할 때마다 count를 증가시켜 이전과는 다른 객체라고 기록해주는 것. 여기서 CAS2가 쓰인다.</li>\n</ul>\n<p>근데 InterlockedSList는 가난한 시절이라 CAS2 못 쓰고 memory alignment해서 남는 하위 4bit를 count로 쓴 것으로 알고 있다.<br>\n(어설픈 기억으로는 MPMC concurrency queue를 lock free algorithm으로 만들 때 CAS 뭔가 잘못써서 aba problem 발생하면 해당 node가 다른 queue로 들어간 시점에도 뭔가 오동작하여 해당 queue까지 파괴했던 시나리오가 있었는데(…) 자세히 기억이 안 난다.)</p>\n<h2><a href=\"https://www.drdobbs.com/lock-free-data-structures-with-hazard-po/184401890\">hazard pointer</a></h2>\n<p>오늘 출력해간 논문보다 위 링크가 더 읽기 좋다. 완전 오늘 헛소리한 듯-_- 나중에 다시 자세히 읽어보고 정리하겠음</p>\n<p>어쨌든 위 lock free algorithm 설명할 때 node를 언제 해제할 지는 굉장히 골치아픈 문제이다. 아직 어떤 thread가 그 node를 접근하고 있을 수 있는데 마음대로 delete했다가는 access violation이 발생하기 때문. 따라서 이를 안전하게 지울 수 있도록(safe memory reclamation) 여러 방법이 고안되었는데 그 중 하나가 hazard pointer이다.</p>\n<h2>환형큐의 concurrency 문제</h2>\n<ul>\n<li><a href=\"%7B%25%20post_url%202012-02-23-thread-unsafety-problem-in-circular-queue%20%25%7D\">환형큐의 thread unsafety 문제</a></li>\n</ul>\n<h2><a href=\"%7B%25%20post_url%202011-08-11-synchronize-function-execution-in-each-object%20%25%7D\">객체별 수행 동기화</a> 글 코드의 문제</h2>\n<p>[angdev]님의 문제 해결법</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk12\">mJobQueue</span><span class=\"mtk1\">.</span><span class=\"mtk11\">push</span><span class=\"mtk1\">(</span><span class=\"mtk11\">RequestJobPtr</span><span class=\"mtk1\">(</span><span class=\"mtk15\">new</span><span class=\"mtk1\"> </span><span class=\"mtk11\">_RequestJobImpl</span><span class=\"mtk1\">(functor)));</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk15\">while</span><span class=\"mtk1\"> (!</span><span class=\"mtk12\">mJobQueue</span><span class=\"mtk1\">.</span><span class=\"mtk11\">empty</span><span class=\"mtk1\">() &amp;&amp; </span><span class=\"mtk11\">InterlockedExchange</span><span class=\"mtk1\">(&amp;mExclusiveFlag, </span><span class=\"mtk7\">1</span><span class=\"mtk1\">) == </span><span class=\"mtk7\">0</span><span class=\"mtk1\">) {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk15\">for</span><span class=\"mtk1\"> (RequestJobPtr job = </span><span class=\"mtk4\">nullptr</span><span class=\"mtk1\">; </span><span class=\"mtk12\">mJobQueue</span><span class=\"mtk1\">.</span><span class=\"mtk11\">try_pop</span><span class=\"mtk1\">(job); ) {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        (*job)();</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk15\">delete</span><span class=\"mtk1\"> job;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk11\">InterlockedExchange</span><span class=\"mtk1\">(&amp;mExclusiveFlag, </span><span class=\"mtk7\">0</span><span class=\"mtk1\">);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">}</span></span></code></pre>\n<h2>과제 풀이법</h2>\n<ul>\n<li>제빵사와 먹깨비 Actor가 주기적으로 공유자원 Basket을 감지하여 동작하는 방법</li>\n<li>제빵사와 먹깨비와 바구니까지 모두 Actor이고 메시지를 잘 주고 받으면서 동기화</li>\n<li>제빵사, 먹깨비 Actor가 모두 각자의 thread를 갖고 공유자원 Basket을 blocking-wait하면서 동작</li>\n</ul>\n<style class=\"vscode-highlight-styles\">:root {\n  --vscode-highlight-padding-v: 1rem;\n  --vscode-highlight-padding-h: 1.5rem;\n  --vscode-highlight-padding-top: var(--vscode-highlight-padding-v);\n  --vscode-highlight-padding-right: var(--vscode-highlight-padding-h);\n  --vscode-highlight-padding-bottom: var(--vscode-highlight-padding-v);\n  --vscode-highlight-padding-left: var(--vscode-highlight-padding-h);\n  --vscode-highlight-border-radius: 8px;\n\n  --vscode-highlight-line-highlighted-background-color: transparent;\n  --vscode-highlight-line-highlighted-border-width: 4px;\n  --vscode-highlight-line-highlighted-border-color: transparent;\n}\n\n.vscode-highlight {\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n  padding-top: 1rem;\n  padding-top: var(--vscode-highlight-padding-top);\n  padding-bottom: 1rem;\n  padding-bottom: var(--vscode-highlight-padding-bottom);\n  border-radius: 8px;\n  border-radius: var(--vscode-highlight-border-radius);\n  font-feature-settings: normal;\n}\n\n.vscode-highlight-code {\n  display: inline-block;\n  min-width: 100%;\n}\n\n.vscode-highlight-line {\n  display: inline-block;\n  box-sizing: border-box;\n  width: 100%;\n  padding-left: 1.5rem;\n  padding-left: var(--vscode-highlight-padding-left);\n  padding-right: 1.5rem;\n  padding-right: var(--vscode-highlight-padding-right);\n}\n\n.vscode-highlight-line-highlighted {\n  background-color: var(--vscode-highlight-line-highlighted-background-color);\n  box-shadow: inset var(--vscode-highlight-line-highlighted-border-width) 0 0 0 var(--vscode-highlight-line-highlighted-border-color);\n}\n.default-dark {\nbackground-color: #1E1E1E;\ncolor: #D4D4D4;\n}\n\n.default-dark .mtk1 { color: #D4D4D4; }\n.default-dark .mtk2 { color: #1E1E1E; }\n.default-dark .mtk3 { color: #6A9955; }\n.default-dark .mtk4 { color: #569CD6; }\n.default-dark .mtk5 { color: #D16969; }\n.default-dark .mtk6 { color: #D7BA7D; }\n.default-dark .mtk7 { color: #B5CEA8; }\n.default-dark .mtk8 { color: #CE9178; }\n.default-dark .mtk9 { color: #646695; }\n.default-dark .mtk10 { color: #4EC9B0; }\n.default-dark .mtk11 { color: #DCDCAA; }\n.default-dark .mtk12 { color: #9CDCFE; }\n.default-dark .mtk13 { color: #000080; }\n.default-dark .mtk14 { color: #F44747; }\n.default-dark .mtk15 { color: #C586C0; }\n.default-dark .mtk16 { color: #6796E6; }\n.default-dark .mtk17 { color: #808080; }\n.default-dark .mtki { font-style: italic; }\n.default-dark .mtkb { font-weight: bold; }\n.default-dark .mtku { text-decoration: underline; text-underline-position: under; }</style>","excerpt":"오늘 스터디에서 공부한 내용을 간략히 정리해보자. 원래 의도는, peterson’s algorithm을 보고 여기서 비순차 실행이 일어날 때 발생하는 문제를 보고, memory consistency model의 memory order…","fields":{"date":"August 10, 2013","shortdesc":""},"frontmatter":{"title":"concurrency 알고리즘과 memory model","tags":["concurrency","memory","study"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2013/08/10/concurrency-algorithm-and-memory-model/"}}}