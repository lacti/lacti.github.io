{"componentChunkName":"component---src-templates-page-tsx","path":"/2011/07/20/implement-call-stack-trace-at-c++/","webpackCompilationHash":"b0f2540cd746525aebe2","result":{"data":{"site":{"siteMetadata":{"title":"Lacti's Archive","description":"All about I learned","author":{"name":"Jaeyoung, Choi","url":"https://twitter.com/lacti"}}},"markdownRemark":{"html":"<p>이전에 Macro와 inline을 사용하여 log를 찍는 이야기를 했었다. 좀 더 나아가면 여러가지 재밌는 일을 할 수 있어 소개해보고자 한다.<br>\n다룰 내용은 <code>__FUNCSIG__</code>와 <code>__if_exists</code>이다. Visual Studio 전용일거다. gcc 유저는 저리가라</p>\n<p>지인의 이야기를 들어보니 x64에서 디버깅을 할 경우 Call Stack이 알 수 없게 쌓인다고 한다. 따라서 x64 용 디버깅을 위해 Call Stack Trace 를 만들어본다는 마음으로 글을 읽어보자</p>\n<p><code>__FUNCSIG__</code>는 Visual C++ compiler가 제공하는 <a href=\"https://msdn.microsoft.com/en-us/library/b0084kay.aspx\">Predefined Macro</a>중 하나이다.\n말 그대로 Function Signature를 <code>const char *</code> 형태로 넣어주는 것이다. 컴파일러가 해당 함수를 parsing 하다가 <code>__FUNCSIG__</code>를 만나면, code generation을 할 때 그걸 그 Function Signature로 static한 <code>const char</code> 배열을 만들고 그 주소값을 넣어주는게 아닐까. 요즘은 신통하게 <code>_T()</code> 매크로랑 같이 쓰면 <code>wchar_t</code> 형태로도 준다. 만세!</p>\n<p><a href=\"https://msdn.microsoft.com/en-us/library/x7wy9xh3.aspx\"><code>__if_exists</code></a>는 해당 지점에서 그 symbol이 존재하는지를 확인하기 위한 것이다. 당연히 컴파일러가 컴파일 단계에서 확인하는 것이고, 런타임 용은 아니다. <code>else</code> 를 쓸 수는 없고 <code>__if_not_exists</code>를 써야 한다.<br>\n이 문서에서는 this symbol 여부를 확인하기 위해 쓸거다.</p>\n<p>Call Stack 을 쌓기 위해 먼저 <code>StackElement</code>부터 만들어야한다. 가볍게, 파일명, 줄 수, this 주소 정도를 받아보자.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">struct</span><span class=\"mtk1\"> </span><span class=\"mtk10\">StackElement</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">{</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    LPCTSTR FileName;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    UINT    Line;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    LPCTSTR FunctionSignature;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    PVOID    This;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk11\">StackElement</span><span class=\"mtk1\">(LPCTSTR </span><span class=\"mtk12\">fileName</span><span class=\"mtk1\">, UINT </span><span class=\"mtk12\">line</span><span class=\"mtk1\">, LPCTSTR </span><span class=\"mtk12\">functionSignature</span><span class=\"mtk1\">, PVOID </span><span class=\"mtk12\">_this</span><span class=\"mtk1\"> = </span><span class=\"mtk4\">NULL</span><span class=\"mtk1\">)</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        : </span><span class=\"mtk11\">FileName</span><span class=\"mtk1\">(fileName), </span><span class=\"mtk11\">Line</span><span class=\"mtk1\">(line), </span><span class=\"mtk11\">FunctionSignature</span><span class=\"mtk1\">(functionSignature), </span><span class=\"mtk11\">This</span><span class=\"mtk1\">(_this) {}</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">};</span></span></code></pre>\n<p>그리고 Stack을 구현해야하지만 귀찮으니까 <code>std::deque</code>를 쓰자.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">typedef</span><span class=\"mtk1\"> std::deque&lt;StackElement&gt; CallStackType;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">CallStackType CallStack;</span></span></code></pre>\n<p>만약 Multi-Thread환경에서 작업한다면 전역 변수로 Call Stack을 관리한다는건 미친 짓이다. 적절히 Thread 별로 자료구조를 구현하거나(index 를 발급한다던지), Tls를 써주는게 좋겠다. 이 내용은 다음에 다루자.</p>\n<p>그러면 이제 해당 logging을 위한 매크로를 작성하는 일만 남았다.<br>\n왜 매크로를 작성해야하냐 하면은, <code>__FILE__</code>, <code>__LINE__</code>, <code>__FUNCSIG__</code>와 <code>__if_exits</code>를 문맥이 변경되지 않게 사용해야 하기 때문이다. <code>inline function</code>을 쓰면 해당 function이 호출되어버리니까 함수 문맥이 바뀌어버려서 안된다.</p>\n<p>고로 매크로를 써야한다.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk15\">#define</span><span class=\"mtk4\"> </span><span class=\"mtk11\">START_TRACE</span><span class=\"mtk4\">() </span><span class=\"mtk6\">\\</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">    </span><span class=\"mtk15\">do</span><span class=\"mtk4\"> { </span><span class=\"mtk6\">\\</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">        PVOID __this </span><span class=\"mtk1\">=</span><span class=\"mtk4\"> NULL; </span><span class=\"mtk6\">\\</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">        </span><span class=\"mtk11\">__if_exists</span><span class=\"mtk4\"> (this) { </span><span class=\"mtk6\">\\</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">            __this </span><span class=\"mtk1\">=</span><span class=\"mtk4\"> this; </span><span class=\"mtk6\">\\</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">        } </span><span class=\"mtk6\">\\</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">        </span><span class=\"mtk12\">CallStack</span><span class=\"mtk4\">.</span><span class=\"mtk11\">push_front</span><span class=\"mtk4\">(</span><span class=\"mtk11\">StackElement</span><span class=\"mtk4\">(</span><span class=\"mtk11\">_T</span><span class=\"mtk4\">(__FILE__), __LINE__, </span><span class=\"mtk11\">_T</span><span class=\"mtk4\">(__FUNCSIG__), __this)); </span><span class=\"mtk6\">\\</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">    } </span><span class=\"mtk15\">while</span><span class=\"mtk4\"> (false)</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk15\">#define</span><span class=\"mtk4\"> </span><span class=\"mtk11\">END_TRACE</span><span class=\"mtk4\">() </span><span class=\"mtk6\">\\</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">    </span><span class=\"mtk12\">CallStack</span><span class=\"mtk4\">.</span><span class=\"mtk11\">pop_front</span><span class=\"mtk4\">()</span></span></code></pre>\n<p>약간 길어서 마음에 안 들기는 하다. 먼저 this symbol이 있는지 <code>__if_exists</code>로 검사한다. 있다면 그 주소를 <code>__this</code>변수에 넣고, 아니면 <code>NULL</code>로 유지한다. 그리고 <code>__FILE__</code>, <code>__LINE__</code>, <code>__FUNCSIG__</code>와 <code>__this</code> 정보를 <code>StackElement</code>에 담아서 CallStack 변수의 가장 위(push_front)에 넣는다.</p>\n<p>그리고 함수 호출이 끝나서 빼는 경우에는 앞에서 뺀다(pop_front).</p>\n<p>여기까지 읽다보면 실망하는 사람이 있을 것이다.\n신통하게 뭔가 매크로만 하나 맨 위에 선언해두면 알아서 CallStack이 쌓이는 줄 알았는데, 이거 매크로를 각 함수마다 덕지덕지 발라야할 조짐을 느꼈기 때문일 것이다. 맞는 이야기이다.</p>\n<p>간단한 예제를 보자.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">class</span><span class=\"mtk1\"> </span><span class=\"mtk10\">Pot</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">{</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">public:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk11\">Pot</span><span class=\"mtk1\">(</span><span class=\"mtk4\">void</span><span class=\"mtk1\">) : </span><span class=\"mtk11\">size</span><span class=\"mtk1\">(</span><span class=\"mtk11\">rand</span><span class=\"mtk1\">())</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk11\">START_TRACE</span><span class=\"mtk1\">();</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk11\">END_TRACE</span><span class=\"mtk1\">();</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">int</span><span class=\"mtk1\"> </span><span class=\"mtk11\">Size</span><span class=\"mtk1\">()</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk11\">START_TRACE</span><span class=\"mtk1\">();</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk11\">END_TRACE</span><span class=\"mtk1\">();</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> size;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">private:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">int</span><span class=\"mtk1\"> size;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">};</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">int</span><span class=\"mtk1\"> </span><span class=\"mtk11\">_tmain</span><span class=\"mtk1\">(</span><span class=\"mtk4\">int</span><span class=\"mtk1\"> </span><span class=\"mtk12\">argc</span><span class=\"mtk1\">, _TCHAR* </span><span class=\"mtk12\">argv</span><span class=\"mtk1\">[])</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">{</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk11\">START_TRACE</span><span class=\"mtk1\">();</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk15\">for</span><span class=\"mtk1\"> (</span><span class=\"mtk4\">int</span><span class=\"mtk1\"> i = </span><span class=\"mtk7\">0</span><span class=\"mtk1\">; i &lt; </span><span class=\"mtk7\">100</span><span class=\"mtk1\">; i++) {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        Pot pot;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">pot</span><span class=\"mtk1\">.</span><span class=\"mtk11\">Size</span><span class=\"mtk1\">() &gt; </span><span class=\"mtk7\">100</span><span class=\"mtk1\">)</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">            </span><span class=\"mtk11\">printf</span><span class=\"mtk1\"> (</span><span class=\"mtk8\">&quot;over 100!</span><span class=\"mtk6\">\\n</span><span class=\"mtk8\">&quot;</span><span class=\"mtk1\">);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk11\">END_TRACE</span><span class=\"mtk1\">();</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">}</span></span></code></pre>\n<p>각 함수의 맨 위에 <code>START_TRACE()</code> 매크로를 사용하고, 함수가 끝날 때 <code>END_TRACE()</code> 를 사용한다. 그러면 Stack Trace 정보가 CallStack 변수에 쌓이는 것을 볼 수 있다.</p>\n<p>하지만 위의 구조는 문제점이 있다. 알아챘는가? 아직이라면 한 5초 정도 생각해보자 -_-\n답은 바로 밑에 이어진다.</p>\n<p>위의 경우에서는 <code>END_TRACE()</code>를 안 불러준 채 함수를 탈출(return)해버리면 CallStack이 난장판이 된다. 즉, 위 방법은 결국 모든 return 구문 앞에다가 <code>END_TRACE()</code>를 붙여주어야 한다는 것. <code>START_TRACE()</code>와 <code>END_TRACE()</code>를 붙여주는 것만으로도 엄청난 스트레스인데 이건 너무하다!</p>\n<p>그런고로 이전 글에서 이야기한 생성자, 소멸자의 가호를 받아 위 문제를 RAII 방식으로 접근해서 풀어보도록 하자.<br>\n<code>StackElement</code>의 생존을 관리하는, 즉 CallStack 변수에 생성할 때 <code>push_front</code>를 했다가 소멸할 때 <code>pop_front</code>를 하는 Functor 를 하나 만들자.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">struct</span><span class=\"mtk1\"> </span><span class=\"mtk10\">StackElementPushFunctor</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">{</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk11\">StackElementPushFunctor</span><span class=\"mtk1\">(</span><span class=\"mtk4\">const</span><span class=\"mtk1\"> StackElement&amp; </span><span class=\"mtk12\">element</span><span class=\"mtk1\">)</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk12\">CallStack</span><span class=\"mtk1\">.</span><span class=\"mtk11\">push_front</span><span class=\"mtk1\">(element);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk11\">~StackElementPushFunctor</span><span class=\"mtk1\">(</span><span class=\"mtk4\">void</span><span class=\"mtk1\">)</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk12\">CallStack</span><span class=\"mtk1\">.</span><span class=\"mtk11\">pop_front</span><span class=\"mtk1\">();</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">};</span></span></code></pre>\n<p>이 Functor는 생성시 <code>StackElement</code>를 받아서 CallStack에 <code>push_front</code>로 앞에 넣어주고, 소멸될 때 <code>pop_front</code>로 빼준다. 그러면 함수가 시작할 때 이 객체를 만들었다가, 함수가 끝날 때 소멸시키면 되겠구나!</p>\n<p>그래서 매크로가 다음과 같이 수정되어야 한다.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk15\">#define</span><span class=\"mtk4\"> </span><span class=\"mtk11\">TRACE</span><span class=\"mtk4\">() </span><span class=\"mtk6\">\\</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">    PVOID __this </span><span class=\"mtk1\">=</span><span class=\"mtk4\"> NULL; </span><span class=\"mtk6\">\\</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">    </span><span class=\"mtk11\">__if_exists</span><span class=\"mtk4\"> (this) { </span><span class=\"mtk6\">\\</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">        __this </span><span class=\"mtk1\">=</span><span class=\"mtk4\"> this; </span><span class=\"mtk6\">\\</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">    } </span><span class=\"mtk6\">\\</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">    StackElementPushFunctor </span><span class=\"mtk11\">__push__</span><span class=\"mtk4\"> (</span><span class=\"mtk11\">StackElement</span><span class=\"mtk4\">(</span><span class=\"mtk11\">_T</span><span class=\"mtk4\">(__FILE__), __LINE__, </span><span class=\"mtk11\">_T</span><span class=\"mtk4\">(__FUNCSIG__), __this));</span></span></code></pre>\n<p>직접 CallStack 변수에다가 <code>StackElement</code>를 넣었던 것과 달리 <code>StackElementPushFunctor</code>에 대한 객체를 하나 만든다. 이 때 Functor 객체가 함수 내에서 지역 변수로 존재하기 때문에 함수가 끝나면 알아서 소멸자가 호출되어 CallStack에서 현재 함수에 대한 <code>StackElement</code>가 빠져나간다.</p>\n<p>덕분에 위의 <code>Object::size</code> 함수나 <code>_tmain</code> 함수에서 <code>END_TRACE</code>가 있었어야만 했던 것에 반해, 여기서는 아예 안 넣어도 되기 때문에 코드 작성하기도 한결 간단하다</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">int</span><span class=\"mtk1\"> </span><span class=\"mtk11\">_tmain</span><span class=\"mtk1\">(</span><span class=\"mtk4\">int</span><span class=\"mtk1\"> </span><span class=\"mtk12\">argc</span><span class=\"mtk1\">, _TCHAR* </span><span class=\"mtk12\">argv</span><span class=\"mtk1\">[])</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">{</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk11\">TRACE</span><span class=\"mtk1\">();</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// 로직 코드</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">}</span></span></code></pre>\n<p>매크로 함수 형태로 들어가있으니까 상당히 어색한데, 그냥 함수 취급 안하고 () 를 빼버리도록 매크로를 만드는 것도 하나의 방법이겠다. 아무튼 위의 코드는 전처리기에 의해 다음처럼 변한다.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">int</span><span class=\"mtk1\"> </span><span class=\"mtk11\">_tmain</span><span class=\"mtk1\">(</span><span class=\"mtk4\">int</span><span class=\"mtk1\"> </span><span class=\"mtk12\">argc</span><span class=\"mtk1\">, _TCHAR* </span><span class=\"mtk12\">argv</span><span class=\"mtk1\">[])</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">{</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// this 얻기</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    StackElementPushFunctor </span><span class=\"mtk11\">__push__</span><span class=\"mtk1\"> (</span><span class=\"mtk3\">/* 생략 */</span><span class=\"mtk1\">);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// 로직 코드</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// 함수 scope 가 끝나므로 __push__::~StackElementPushFunctor() 호출됨</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">}</span></span></code></pre>\n<p>이렇게 CallStack 구축할 수 있고, DEBUG가 아닐 경우에는 그냥 TRACE 매크로를 빈 걸로 교체해두면 성능적 문제도 전혀 없겠다. 어차피 디버깅 용이니까.</p>\n<style class=\"vscode-highlight-styles\">:root {\n  --vscode-highlight-padding-v: 1rem;\n  --vscode-highlight-padding-h: 1.5rem;\n  --vscode-highlight-padding-top: var(--vscode-highlight-padding-v);\n  --vscode-highlight-padding-right: var(--vscode-highlight-padding-h);\n  --vscode-highlight-padding-bottom: var(--vscode-highlight-padding-v);\n  --vscode-highlight-padding-left: var(--vscode-highlight-padding-h);\n  --vscode-highlight-border-radius: 8px;\n\n  --vscode-highlight-line-highlighted-background-color: transparent;\n  --vscode-highlight-line-highlighted-border-width: 4px;\n  --vscode-highlight-line-highlighted-border-color: transparent;\n}\n\n.vscode-highlight {\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n  padding-top: 1rem;\n  padding-top: var(--vscode-highlight-padding-top);\n  padding-bottom: 1rem;\n  padding-bottom: var(--vscode-highlight-padding-bottom);\n  border-radius: 8px;\n  border-radius: var(--vscode-highlight-border-radius);\n  font-feature-settings: normal;\n}\n\n.vscode-highlight-code {\n  display: inline-block;\n  min-width: 100%;\n}\n\n.vscode-highlight-line {\n  display: inline-block;\n  box-sizing: border-box;\n  width: 100%;\n  padding-left: 1.5rem;\n  padding-left: var(--vscode-highlight-padding-left);\n  padding-right: 1.5rem;\n  padding-right: var(--vscode-highlight-padding-right);\n}\n\n.vscode-highlight-line-highlighted {\n  background-color: var(--vscode-highlight-line-highlighted-background-color);\n  box-shadow: inset var(--vscode-highlight-line-highlighted-border-width) 0 0 0 var(--vscode-highlight-line-highlighted-border-color);\n}\n.default-dark {\nbackground-color: #1E1E1E;\ncolor: #D4D4D4;\n}\n\n.default-dark .mtk1 { color: #D4D4D4; }\n.default-dark .mtk2 { color: #1E1E1E; }\n.default-dark .mtk3 { color: #6A9955; }\n.default-dark .mtk4 { color: #569CD6; }\n.default-dark .mtk5 { color: #D16969; }\n.default-dark .mtk6 { color: #D7BA7D; }\n.default-dark .mtk7 { color: #B5CEA8; }\n.default-dark .mtk8 { color: #CE9178; }\n.default-dark .mtk9 { color: #646695; }\n.default-dark .mtk10 { color: #4EC9B0; }\n.default-dark .mtk11 { color: #DCDCAA; }\n.default-dark .mtk12 { color: #9CDCFE; }\n.default-dark .mtk13 { color: #000080; }\n.default-dark .mtk14 { color: #F44747; }\n.default-dark .mtk15 { color: #C586C0; }\n.default-dark .mtk16 { color: #6796E6; }\n.default-dark .mtk17 { color: #808080; }\n.default-dark .mtki { font-style: italic; }\n.default-dark .mtkb { font-weight: bold; }\n.default-dark .mtku { text-decoration: underline; text-underline-position: under; }</style>","excerpt":"이전에 Macro와 inline을 사용하여 log를 찍는 이야기를 했었다. 좀 더 나아가면 여러가지 재밌는 일을 할 수 있어 소개해보고자 한다.다룰 내용은 __FUNCSIG__와 __if_exists이다. Visual Studio 전용일거다. gcc…","fields":{"date":"July 20, 2011","shortdesc":""},"frontmatter":{"title":"MSVC call stacktrace 구현","tags":["c++"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2011/07/20/implement-call-stack-trace-at-c++/"}}}