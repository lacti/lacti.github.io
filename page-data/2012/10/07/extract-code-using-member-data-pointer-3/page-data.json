{"componentChunkName":"component---src-templates-page-tsx","path":"/2012/10/07/extract-code-using-member-data-pointer-3/","webpackCompilationHash":"809a166b1e846cf5f86f","result":{"data":{"site":{"siteMetadata":{"title":"Lacti's Archive","description":"All about I learned","author":{"name":"Jaeyoung, Choi","url":"https://twitter.com/lacti"}}},"markdownRemark":{"html":"<p>지난 두 글에서 사용한 전략은, 멤버에 접근하기 위한 방법을 동일한 인터페이스로 맞춰서 (첫 번째 글에서는 멤버 데이터 포인터, 두 번째 글에서는 멤버 함수 포인터) <code>BuffType</code>과 그 인터페이스를 대응시키는 방법을 사용하였다.</p>\n<p>동일한 인터페이스를 사용하기 위해서 그들을 하나의 동일한 타입으로 지칭하는 방법을 사용하였고, 그렇기 때문에 서로 다른 type, int 변수와 float 변수, 그리고 그에 대한 배열 변수가 있을 때에는 사용할 수 없는 방법이었다.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">struct</span><span class=\"mtk1\"> </span><span class=\"mtk10\">Stat</span><span class=\"mtk1\"> {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">int</span><span class=\"mtk1\"> hp;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">float</span><span class=\"mtk1\"> attack;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">};</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">typedef</span><span class=\"mtk1\"> </span><span class=\"mtk4\">float</span><span class=\"mtk1\"> Stat::*DataPtr;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">DataPtr ptr = &amp;Stat::hp; </span><span class=\"mtk3\">// Error!</span></span></code></pre>\n<p>이번 글에서는 형식 삭제(<a href=\"https://en.wikipedia.org/wiki/Type_erasure\">type erasure</a>)를 사용하여 보다 다양한 type을 지원하면서, 확장 가능한 방법에 대해 알아보도록 하겠다.</p>\n<p>형식 삭제라고 하면 뭔가 어려워 보이지만, 그 결과물을 보면 굉장히 친숙하다. C++에서 형식 삭제를 하는 방법은 가상 함수를 통한 다형성을 사용하는 것인데, 예를 들면 다음과 같다.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">struct</span><span class=\"mtk1\"> </span><span class=\"mtk10\">ValueHolder</span><span class=\"mtk1\"> {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">virtual</span><span class=\"mtk1\"> </span><span class=\"mtk4\">float</span><span class=\"mtk1\"> </span><span class=\"mtk11\">GetValue</span><span class=\"mtk1\">() </span><span class=\"mtk4\">const</span><span class=\"mtk1\"> = </span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">virtual</span><span class=\"mtk1\"> </span><span class=\"mtk4\">void</span><span class=\"mtk1\"> </span><span class=\"mtk11\">SetValue</span><span class=\"mtk1\">(</span><span class=\"mtk4\">float</span><span class=\"mtk1\"> </span><span class=\"mtk12\">value</span><span class=\"mtk1\">) = </span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">}</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">struct</span><span class=\"mtk1\"> </span><span class=\"mtk10\">IntValueHolder</span><span class=\"mtk1\"> : </span><span class=\"mtk4\">public</span><span class=\"mtk1\"> </span><span class=\"mtk10\">ValueHolder</span><span class=\"mtk1\"> {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">virtual</span><span class=\"mtk1\"> </span><span class=\"mtk4\">float</span><span class=\"mtk1\"> </span><span class=\"mtk11\">GetValue</span><span class=\"mtk1\">() </span><span class=\"mtk4\">const</span><span class=\"mtk1\"> { </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk11\">static_cast</span><span class=\"mtk1\">&lt;</span><span class=\"mtk4\">float</span><span class=\"mtk1\">&gt;(value); }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">virtual</span><span class=\"mtk1\"> </span><span class=\"mtk4\">void</span><span class=\"mtk1\"> </span><span class=\"mtk11\">SetValue</span><span class=\"mtk1\">(</span><span class=\"mtk4\">float</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_value</span><span class=\"mtk1\">) { value = </span><span class=\"mtk11\">static_cast</span><span class=\"mtk1\">&lt;</span><span class=\"mtk4\">int</span><span class=\"mtk1\">&gt;(_value); }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">int</span><span class=\"mtk1\"> value;</span></span></code></pre>\n<p><code>ValueHolder</code>는 concrete class가 어떤 값을 들고 있던, <code>GetValue()</code> 함수를 통해 float type의 변수를 반환하도록 하거나, <code>SetValue()</code> 함수를 통해 float 값을 받아서 자신의 값을 변경하도록 할 수 있는 interface이다.</p>\n<p>이전 글과 이어서 생각해 볼때, 위와 같은 방법을 사용하여 int, float, 혹은 그에 대한 배열 멤버 변수들을 Get, Set 할 수 있도록 구조를 잡으면 이 문제를 해결할 수 있다는 이야기이다.</p>\n<p>그런데 왜 형식 삭제라는 골치 아픈 용어를 사용할까?<br>\nchar, short, int, long, float, double에 대한 모든 type에 대해 ValueHolder concrete class를 작성하는 것은 매우 귀찮은 일이다. 그렇다면 template을 사용하여 그 귀찮음을 해결해보자.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">template</span><span class=\"mtk1\"> &lt;</span><span class=\"mtk4\">typename </span><span class=\"mtk10\">_Ty</span><span class=\"mtk1\">&gt;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">struct</span><span class=\"mtk1\"> </span><span class=\"mtk10\">ValueHolderImpl</span><span class=\"mtk1\"> : </span><span class=\"mtk4\">public</span><span class=\"mtk1\"> </span><span class=\"mtk10\">ValueHolder</span><span class=\"mtk1\"> {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">virtual</span><span class=\"mtk1\"> </span><span class=\"mtk4\">float</span><span class=\"mtk1\"> </span><span class=\"mtk11\">GetValue</span><span class=\"mtk1\">() </span><span class=\"mtk4\">const</span><span class=\"mtk1\"> { </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk11\">static_cast</span><span class=\"mtk1\">&lt;</span><span class=\"mtk4\">float</span><span class=\"mtk1\">&gt;(value); }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">virtual</span><span class=\"mtk1\"> </span><span class=\"mtk4\">void</span><span class=\"mtk1\"> </span><span class=\"mtk11\">SetValue</span><span class=\"mtk1\">(</span><span class=\"mtk4\">float</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_value</span><span class=\"mtk1\">) { value = </span><span class=\"mtk11\">static_cast</span><span class=\"mtk1\">&lt;</span><span class=\"mtk4\">_Ty</span><span class=\"mtk1\">&gt;(_value); }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    _Ty value;</span></span></code></pre>\n<p>이제 <code>ValueHolderImpl&#x3C;></code> class를 사용하면 float type과 <code>static_cast</code> 호환이 되는 모든 형식에 대해 <code>ValueHolder</code>를 만들 수 있다.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk1\">ValueHolder* intHolder = new ValueHolderImpl&lt;</span><span class=\"mtk4\">int</span><span class=\"mtk1\">&gt;;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">ValueHolder* floatHolder = new ValueHolderImpl&lt;</span><span class=\"mtk4\">float</span><span class=\"mtk1\">&gt;;</span></span></code></pre>\n<p>concrete class들은 <code>ValueHolderImpl&#x3C;int></code>와 같이 type 정보를 가진 채로 명시되지만 <code>ValueHolder</code> interface으로 지칭이 가능하다. 즉, runtime에는 concrete class의 type 정보 없이 그것들을 사용할 수 있게 되는 것이다.</p>\n<p>덕분에 서로 다른 type인 <code>ValueHolderImpl&#x3C;int></code>, <code>ValueHolderImpl&#x3C;float></code>에 대해 <code>ValueHolder</code>라는 공통된 접근을 할 수 있고, compile-time에 존재하던 형식 정보(type information)가 runtime에서 제거되었으므로 이를 형식 삭제라고 하는 것이다.</p>\n<p>이제 필요한 이론을 모두 습득하였으니 즐거운 코딩을 해보자. 형식 삭제를 위한 interface를 먼저 설계해보자.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">template</span><span class=\"mtk1\"> &lt;</span><span class=\"mtk4\">typename </span><span class=\"mtk10\">_Class</span><span class=\"mtk1\">&gt;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">class</span><span class=\"mtk1\"> </span><span class=\"mtk10\">IAccessor</span><span class=\"mtk1\"> {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">public:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">virtual</span><span class=\"mtk1\"> </span><span class=\"mtk4\">float</span><span class=\"mtk1\"> </span><span class=\"mtk11\">GetValue</span><span class=\"mtk1\">(</span><span class=\"mtk4\">const</span><span class=\"mtk1\"> _Class&amp;) </span><span class=\"mtk4\">const</span><span class=\"mtk1\"> = </span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">virtual</span><span class=\"mtk1\"> </span><span class=\"mtk4\">void</span><span class=\"mtk1\"> </span><span class=\"mtk11\">SetValue</span><span class=\"mtk1\">(_Class&amp;, </span><span class=\"mtk4\">float</span><span class=\"mtk1\"> </span><span class=\"mtk12\">value</span><span class=\"mtk1\">) </span><span class=\"mtk4\">const</span><span class=\"mtk1\"> = </span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">};</span></span></code></pre>\n<p>위 <code>ValueHolder</code>처럼 값을 넣고, 빼는 함수를 갖는다. 차이가 있다면, 이 Accessor 들은 구체적인 값을 가지는 것(Holding)이 아니라 멤버 데이터 포인터를 갖고, 특정 class의 instance를 인자로 받아 그 값을 넣고 빼는 구조라는 것이다. 일반적인 설계를 위해, 어떤 class에 대한 Accessor를 만들 것인지를 template parameter로 남겨두었다.</p>\n<p>배열이 아닌 type에 대한 Accessor를 보면 이해하기가 쉽겠다. 다음 코드를 보자.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">template</span><span class=\"mtk1\"> &lt;</span><span class=\"mtk4\">typename </span><span class=\"mtk10\">_Class</span><span class=\"mtk4\">,</span><span class=\"mtk1\"> </span><span class=\"mtk4\">typename </span><span class=\"mtk10\">_Ty</span><span class=\"mtk1\">&gt;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">class</span><span class=\"mtk1\"> </span><span class=\"mtk10\">SingleAccessor</span><span class=\"mtk1\"> : </span><span class=\"mtk4\">public</span><span class=\"mtk1\"> </span><span class=\"mtk10\">IAccessor</span><span class=\"mtk1\">&lt;_Class&gt; {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">public:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">virtual</span><span class=\"mtk1\"> </span><span class=\"mtk4\">float</span><span class=\"mtk1\"> </span><span class=\"mtk11\">GetValue</span><span class=\"mtk1\">(</span><span class=\"mtk4\">const</span><span class=\"mtk1\"> _Class&amp; </span><span class=\"mtk12\">obj</span><span class=\"mtk1\">) </span><span class=\"mtk4\">const</span><span class=\"mtk1\"> {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk11\">static_cast</span><span class=\"mtk1\">&lt;</span><span class=\"mtk4\">float</span><span class=\"mtk1\">&gt;(</span><span class=\"mtk12\">obj.*dataPtr</span><span class=\"mtk1\">);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">virtual</span><span class=\"mtk1\"> </span><span class=\"mtk4\">void</span><span class=\"mtk1\"> </span><span class=\"mtk11\">SetValue</span><span class=\"mtk1\">(_Class&amp; </span><span class=\"mtk12\">obj</span><span class=\"mtk1\">, </span><span class=\"mtk4\">float</span><span class=\"mtk1\"> </span><span class=\"mtk12\">value</span><span class=\"mtk1\">) </span><span class=\"mtk4\">const</span><span class=\"mtk1\"> {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk12\">obj.*dataPtr</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">static_cast</span><span class=\"mtk1\">&lt;</span><span class=\"mtk4\">_Ty</span><span class=\"mtk1\">&gt;(value);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk11\">SingleAccessor</span><span class=\"mtk1\">(_Ty _Class::*</span><span class=\"mtk12\">_dataPtr</span><span class=\"mtk1\">)</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        : </span><span class=\"mtk11\">dataPtr</span><span class=\"mtk1\">(_dataPtr) {}</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">private:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    _Ty _Class::*dataPtr;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">};</span></span></code></pre>\n<p>생성자로 멤버 데이터 포인터를 받는다. 그리고 그 멤버 데이터 포인터가 어떤 type일지는 template parameter로 남겨둔다. 그리고 Get/SetValue 함수에서 object를 받아 자신이 가지고 있는 멤버 데이터 포인터를 사용하여 값을 가져오거나, 지정하는 작업을 수행한다.</p>\n<p>이제 이 <code>SingleAccessor</code>를 사용하여 int 변수이든, float 변수이든 멤버 변수의 type에 상관없이 접근할 수 있는 <code>IAccessor</code>를 만들 수 있는 것이다.</p>\n<p>멤버 변수의 타입이 배열인 것은 배열에 대한 크기와, 몇 번째 element에 접근할지에 대한 index 값이 같이 필요하다.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">template</span><span class=\"mtk1\"> &lt;</span><span class=\"mtk4\">typename </span><span class=\"mtk10\">_Class</span><span class=\"mtk4\">,</span><span class=\"mtk1\"> </span><span class=\"mtk4\">typename </span><span class=\"mtk10\">_Ty</span><span class=\"mtk4\">,</span><span class=\"mtk1\"> </span><span class=\"mtk4\">size_t </span><span class=\"mtk10\">_Size</span><span class=\"mtk1\">&gt;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">class</span><span class=\"mtk1\"> </span><span class=\"mtk10\">ArrayAccessor</span><span class=\"mtk1\"> : </span><span class=\"mtk4\">public</span><span class=\"mtk1\"> </span><span class=\"mtk10\">IAccessor</span><span class=\"mtk1\">&lt;_Class&gt; {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">public:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">virtual</span><span class=\"mtk1\"> </span><span class=\"mtk4\">float</span><span class=\"mtk1\"> </span><span class=\"mtk11\">GetValue</span><span class=\"mtk1\">(</span><span class=\"mtk4\">const</span><span class=\"mtk1\"> _Class&amp; </span><span class=\"mtk12\">obj</span><span class=\"mtk1\">) </span><span class=\"mtk4\">const</span><span class=\"mtk1\"> {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk11\">static_cast</span><span class=\"mtk1\">&lt;</span><span class=\"mtk4\">float</span><span class=\"mtk1\">&gt;((</span><span class=\"mtk12\">obj.*arrayPtr</span><span class=\"mtk1\">)[index]);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">virtual</span><span class=\"mtk1\"> </span><span class=\"mtk4\">void</span><span class=\"mtk1\"> </span><span class=\"mtk11\">SetValue</span><span class=\"mtk1\">(_Class&amp; </span><span class=\"mtk12\">obj</span><span class=\"mtk1\">, </span><span class=\"mtk4\">float</span><span class=\"mtk1\"> </span><span class=\"mtk12\">value</span><span class=\"mtk1\">) </span><span class=\"mtk4\">const</span><span class=\"mtk1\"> {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        (</span><span class=\"mtk12\">obj.*arrayPtr</span><span class=\"mtk1\">)[index] = </span><span class=\"mtk11\">static_cast</span><span class=\"mtk1\">&lt;</span><span class=\"mtk4\">_Ty</span><span class=\"mtk1\">&gt;(value);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">typedef</span><span class=\"mtk1\"> std::array&lt;_Ty, _Size&gt; _Class::*ArrayPtrType;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk11\">ArrayAccessor</span><span class=\"mtk1\">(ArrayPtrType </span><span class=\"mtk12\">_arrayPtr</span><span class=\"mtk1\">, </span><span class=\"mtk4\">int</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_index</span><span class=\"mtk1\">)</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        : </span><span class=\"mtk11\">arrayPtr</span><span class=\"mtk1\">(_arrayPtr), </span><span class=\"mtk11\">index</span><span class=\"mtk1\">(_index) {}</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">private:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    ArrayPtrType arrayPtr;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">int</span><span class=\"mtk1\"> index;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">};</span></span></code></pre>\n<p><code>GetValue</code>/<code>SetValue</code> 함수의 구조는 <code>SingleAccessor</code>와 크게 차이가 없다. 배열 타입의 멤버 데이터 포인터 변수와 index를 생성자로 받아서 가지고 있고, <code>GetValue</code>/<code>SetValue</code> 함수가 불리는 시점에 해당 배열의 위치에 접근하여 값을 가져오거나 넣는다.</p>\n<p>이제 Accessor들과 enum 값을 연관지어 관리할 관리자를 만들어보자.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">template</span><span class=\"mtk1\"> &lt;</span><span class=\"mtk4\">typename </span><span class=\"mtk10\">_Class</span><span class=\"mtk1\">&gt;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">class</span><span class=\"mtk1\"> </span><span class=\"mtk10\">AccessorManager</span><span class=\"mtk1\"> {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">public:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">typedef</span><span class=\"mtk1\"> std::shared_ptr&lt;IAccessor&lt;_Class&gt;&gt; AccessorImpl;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">typedef</span><span class=\"mtk1\"> std::map&lt;</span><span class=\"mtk4\">int</span><span class=\"mtk1\">, AccessorImpl&gt; AccessorImplMap;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">template</span><span class=\"mtk1\"> &lt;</span><span class=\"mtk4\">typename </span><span class=\"mtk10\">_Class</span><span class=\"mtk4\">,</span><span class=\"mtk1\"> </span><span class=\"mtk4\">typename </span><span class=\"mtk10\">_Ty</span><span class=\"mtk1\">&gt;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">void</span><span class=\"mtk1\"> </span><span class=\"mtk11\">Register</span><span class=\"mtk1\">(</span><span class=\"mtk4\">int</span><span class=\"mtk1\"> </span><span class=\"mtk12\">type</span><span class=\"mtk1\">, _Ty _Class::*</span><span class=\"mtk12\">dataPtr</span><span class=\"mtk1\">) {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk12\">implMap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">insert</span><span class=\"mtk1\">(std::</span><span class=\"mtk11\">make_pair</span><span class=\"mtk1\">(type, </span><span class=\"mtk4\">new</span><span class=\"mtk1\"> </span><span class=\"mtk11\">SingleAccessor</span><span class=\"mtk1\">&lt;</span><span class=\"mtk4\">_Class</span><span class=\"mtk1\">, </span><span class=\"mtk4\">_Ty</span><span class=\"mtk1\">&gt;(dataPtr)));</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">template</span><span class=\"mtk1\"> &lt;</span><span class=\"mtk4\">typename </span><span class=\"mtk10\">_Class</span><span class=\"mtk4\">,</span><span class=\"mtk1\"> </span><span class=\"mtk4\">typename </span><span class=\"mtk10\">_Ty</span><span class=\"mtk4\">,</span><span class=\"mtk1\"> </span><span class=\"mtk4\">size_t </span><span class=\"mtk10\">_Size</span><span class=\"mtk1\">&gt;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">void</span><span class=\"mtk1\"> </span><span class=\"mtk11\">Register</span><span class=\"mtk1\">(</span><span class=\"mtk4\">int</span><span class=\"mtk1\"> </span><span class=\"mtk12\">type</span><span class=\"mtk1\">, std::array&lt;_Ty, _Size&gt; _Class::*</span><span class=\"mtk12\">arrayPtr</span><span class=\"mtk1\">, </span><span class=\"mtk4\">int</span><span class=\"mtk1\"> </span><span class=\"mtk12\">index</span><span class=\"mtk1\">) {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk12\">implMap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">insert</span><span class=\"mtk1\">(std::</span><span class=\"mtk11\">make_pair</span><span class=\"mtk1\">(type,</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">            </span><span class=\"mtk4\">new</span><span class=\"mtk1\"> </span><span class=\"mtk11\">ArrayAccessor</span><span class=\"mtk1\">&lt;</span><span class=\"mtk4\">_Class</span><span class=\"mtk1\">, </span><span class=\"mtk4\">_Ty</span><span class=\"mtk1\">, </span><span class=\"mtk4\">_Size</span><span class=\"mtk1\">&gt;(arrayPtr, index)));</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    AccessorImpl operator [] (</span><span class=\"mtk4\">int</span><span class=\"mtk1\"> </span><span class=\"mtk12\">type</span><span class=\"mtk1\">) {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk11\">assert</span><span class=\"mtk1\">(</span><span class=\"mtk12\">implMap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">find</span><span class=\"mtk1\">(type) != </span><span class=\"mtk12\">implMap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">end</span><span class=\"mtk1\">());</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">implMap</span><span class=\"mtk1\">[type];</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">private:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    AccessorImplMap implMap;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">};</span></span></code></pre>\n<p><code>AccessorManager</code>는 int(BuffType)와 <code>shared_ptr&#x3C;IAccessor></code>의 map을 갖고 이들을 <code>Register</code> 해주거나 enum 값으로 <code>IAccessor</code>를 찾아주는 작업을 한다.</p>\n<p>재미있는 것은 <code>Register()</code> 함수들이다. <code>Register()</code> 함수는 인자로 들어오는 값을 통해 template parameter들이 deduce하고, 이렇게 deduce된 template parameter들을 <code>SingleAccessor</code>나 <code>ArrayAccessor</code>의 template parameter로 넘겨준다.</p>\n<p>이제 다음과 같이 쓸 수 있다.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk1\">AccessorManager&lt;Stat&gt; manager;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">manager.</span><span class=\"mtk11\">Register</span><span class=\"mtk1\">(BUFF_HP, &amp;Stat::hp);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">manager.</span><span class=\"mtk11\">Register</span><span class=\"mtk1\">(BUFF_RUN_SPEED, &amp;Stat::movingSpeed, MST_RUN);</span></span></code></pre>\n<p>첫 번째 <code>Register</code> 호출은 <code>SingleAccessor</code>를 생성하는 <code>Register</code> 함수가 호출된다. 그리고 <code>hp</code> 멤버의 type이 적절히 deduce되어 <code>SingleAccessor</code>가 만들어진다.</p>\n<p>두 번째 <code>Register</code> 호출은 <code>ArrayAccessor</code>를 생성하는 <code>Register</code> 함수가 호출된다. 그리고 <code>movingSpeed</code> 멤버 type과 배열의 크기가 적절히 deduce되어 <code>ArrayAccessor</code>가 만들어진다. 이 때 index인 <code>MST_RUN</code>이 같이 <code>ArrayAccessor</code>로 전달되어, <code>BUFF_RUN_SPEED</code> 의해서 <code>movingSpeed[MST_RUN]</code>의 값을 제어할 수 있게 되는 것이다.</p>\n<p>생각해보니, 이러한 Manager class는 전역으로 하나만 있으면 좋겠다. 따라서 다음과 같이 간단한 singleton을 만들어서 써보자.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">template</span><span class=\"mtk1\"> &lt;</span><span class=\"mtk4\">typename </span><span class=\"mtk10\">_Class</span><span class=\"mtk1\">&gt;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">AccessorManager&lt;_Class&gt;&amp; </span><span class=\"mtk11\">Accessor</span><span class=\"mtk1\">() {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">static</span><span class=\"mtk1\"> AccessorManager&lt;_Class&gt; instance;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> instance;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">}</span></span></code></pre>\n<p>이는 thread-safe하지 않을 수 있는데, <code>AccessorManager</code>에 <code>Register</code> 하는 과정은 처음 프로그램이 초기화될 때 딱 한 번만 수행하면 되는 작업이고, 그 이후에는 전부 <code>operator []</code>로 access만 하면 되므로 thread-safe를 걱정할 필요는 없어 보인다.</p>\n<p>이제 지난 글에서 정의한 <code>BUFF_ENUM</code>과 <code>BUFF_ENUM_A</code>를 다음과 같이 정의하여 마무리를 지어보자.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk15\">#define</span><span class=\"mtk4\"> </span><span class=\"mtk11\">BUFF_ENUM</span><span class=\"mtk4\">(</span><span class=\"mtk12\">type, member</span><span class=\"mtk4\">) Accessor</span><span class=\"mtk1\">&lt;</span><span class=\"mtk4\">Stat</span><span class=\"mtk1\">&gt;</span><span class=\"mtk4\">().</span><span class=\"mtk11\">Register</span><span class=\"mtk4\">(type, member);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk15\">#define</span><span class=\"mtk4\"> </span><span class=\"mtk11\">BUFF_ENUM_A</span><span class=\"mtk4\">(</span><span class=\"mtk12\">type, member, index</span><span class=\"mtk4\">) Accessor</span><span class=\"mtk1\">&lt;</span><span class=\"mtk4\">Stat</span><span class=\"mtk1\">&gt;</span><span class=\"mtk4\">().</span><span class=\"mtk11\">Register</span><span class=\"mtk4\">(type, member, index);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk15\">#include</span><span class=\"mtk4\"> </span><span class=\"mtk8\">&quot;BuffType.inl&quot;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk15\">#undef</span><span class=\"mtk4\"> </span><span class=\"mtk11\">BUFF_ENUM</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk15\">#undef</span><span class=\"mtk4\"> </span><span class=\"mtk11\">BUFF_ENUM_A</span></span></code></pre>\n<p>BuffType.inl의 내용은 지난 글과 동일하다. 이제 위와 같은 코드가 프로그램이 시작될 때 수행될 수 있도록 전역 구조체 변수의 생성자로 넣어놓는 방법 등을 사용하여 잘 배치해두면, Stat 구조체 내의 변수와 BuffType을 엮을 수 있다는 것이다.</p>\n<p>매번 <code>AccessorManager</code>에게 enum 값을 넘겨서 <code>IAccessor</code>를 받은 후, 그 <code>IAccessor</code>와 <code>Stat</code> 구조체 변수를 엮어서 값을 주고 받는 코딩을 하는 것은 너무 더럽고 귀찮다. 따라서 간단히 이 둘을 연결해줄 수 있는 <code>Accessible</code>을 만들어보자.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">template</span><span class=\"mtk1\"> &lt;</span><span class=\"mtk4\">typename </span><span class=\"mtk10\">_Class</span><span class=\"mtk1\">&gt;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">class</span><span class=\"mtk1\"> </span><span class=\"mtk10\">Accessible</span><span class=\"mtk1\"> {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">public:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk11\">Accessible</span><span class=\"mtk1\">(_Class&amp; </span><span class=\"mtk12\">_object</span><span class=\"mtk1\">)</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        : </span><span class=\"mtk11\">object</span><span class=\"mtk1\">(_object) {}</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">float</span><span class=\"mtk1\"> </span><span class=\"mtk11\">GetValue</span><span class=\"mtk1\">(</span><span class=\"mtk4\">int</span><span class=\"mtk1\"> </span><span class=\"mtk12\">type</span><span class=\"mtk1\">) {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk11\">Accessor</span><span class=\"mtk1\">&lt;</span><span class=\"mtk4\">_Class</span><span class=\"mtk1\">&gt;()[type]-&gt;</span><span class=\"mtk11\">GetValue</span><span class=\"mtk1\">(object);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">void</span><span class=\"mtk1\"> </span><span class=\"mtk11\">SetValue</span><span class=\"mtk1\">(</span><span class=\"mtk4\">int</span><span class=\"mtk1\"> </span><span class=\"mtk12\">type</span><span class=\"mtk1\">, </span><span class=\"mtk4\">float</span><span class=\"mtk1\"> </span><span class=\"mtk12\">value</span><span class=\"mtk1\">) {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk11\">Accessor</span><span class=\"mtk1\">&lt;</span><span class=\"mtk4\">_Class</span><span class=\"mtk1\">&gt;()[type]-&gt;</span><span class=\"mtk11\">SetValue</span><span class=\"mtk1\">(object, value);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk11\">Accessible</span><span class=\"mtk1\">(</span><span class=\"mtk4\">const</span><span class=\"mtk1\"> Accessible&amp; </span><span class=\"mtk12\">that</span><span class=\"mtk1\">)</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        : </span><span class=\"mtk11\">object</span><span class=\"mtk1\">(that.object) {}</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">private:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    Accessible&amp; operator = (</span><span class=\"mtk4\">const</span><span class=\"mtk1\"> Accessible&amp;);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">private:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    _Class&amp; object;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">};</span></span></code></pre>\n<p><code>Accessible</code>은 class를 template parameter로 받고, <code>IAccessor</code>를 통해 접근할 object를 멤버로 갖는 class이다. 그리고 <code>Accessor&#x3C;></code>를 통해 <code>IAccessor</code>를 불러와서 멤버로 가지고 있는 object와 연결하여 <code>GetValue</code>/<code>SetValue</code>를 할 수 있게 만들어준다.</p>\n<p>이제 다음과 같이 사용할 수 있다.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk1\">Accessible&lt;Stat&gt; </span><span class=\"mtk11\">accessible</span><span class=\"mtk1\">(stat);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk15\">switch</span><span class=\"mtk1\"> (buffMethod) {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk15\">case</span><span class=\"mtk1\"> METHOD_SET: </span><span class=\"mtk12\">accessible</span><span class=\"mtk1\">.</span><span class=\"mtk11\">SetValue</span><span class=\"mtk1\">(buffType, buffValue); </span><span class=\"mtk15\">break</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk15\">case</span><span class=\"mtk1\"> METHOD_ADD: </span><span class=\"mtk12\">accessible</span><span class=\"mtk1\">.</span><span class=\"mtk11\">SetValue</span><span class=\"mtk1\">(buffType, </span><span class=\"mtk12\">accessible</span><span class=\"mtk1\">.</span><span class=\"mtk11\">GetValue</span><span class=\"mtk1\">(buffType) + buffValue); </span><span class=\"mtk15\">break</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk15\">case</span><span class=\"mtk1\"> METHOD_RATE: </span><span class=\"mtk12\">accessible</span><span class=\"mtk1\">.</span><span class=\"mtk11\">SetValue</span><span class=\"mtk1\">(buffType, </span><span class=\"mtk12\">accessible</span><span class=\"mtk1\">.</span><span class=\"mtk11\">GetValue</span><span class=\"mtk1\">(buffType) * buffValue); </span><span class=\"mtk15\">break</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">}</span></span></code></pre>\n<p>그렇다면 이것이 지난 번 방법에 비해 왜 더 느릴까?\n지난 글에서 서술한 방법들은 멤버 데이터 포인터나 멤버 함수 포인터를 사용하여 객체의 지정된 값을 가져오거나 지정하는 방법이었다. 만약 <code>Stat</code> 구조체가 POD 형태라면, 이들은 offset에 의한 데이터 접근을 하게 되거나 function-call 1번 수행(그나마도 inline 화 될 수 있는)하면 끝나는 형태이다.</p>\n<p>그렇지만 이번 글에 소개된 방법은 <code>IAccessor</code>라는 interface를 통해 concrete의 동작을 위해 vfptr을 사용하는 방식으로 가상 함수 호출을 위한 부담을 추가로 가지게 되는 것이다. 이 호출 부담 때문에 더 느릴 수 밖에 없는 것이다.</p>\n<p>다 쓰고 보니 <code>AccessorManager</code>가 굳이 map을 사용하지 않고, <code>BUFF_MAX</code>를 받아 배열로 <code>IAccessor</code>를 관리하는 것이 더 낫겠다 싶다. 하지만 굳이 위와 같이 냅둔 이유는 <a href=\"%7B%25%20post_url%202012-06-09-using-reflection-at-cpp-3%20%25%7D\">c++에서 reflection 사용하기 3</a>와 형식이 유사해지기 때문에 코드 읽기가 좀 더 나을지도 모르겠다는 생각과, <code>AccessorManager</code>에서 배열의 크기를 template parameter로 받아서 배열을 생성해주기 약간 귀찮았기 때문이다-_-a</p>\n<style class=\"vscode-highlight-styles\">:root {\n  --vscode-highlight-padding-v: 1rem;\n  --vscode-highlight-padding-h: 1.5rem;\n  --vscode-highlight-padding-top: var(--vscode-highlight-padding-v);\n  --vscode-highlight-padding-right: var(--vscode-highlight-padding-h);\n  --vscode-highlight-padding-bottom: var(--vscode-highlight-padding-v);\n  --vscode-highlight-padding-left: var(--vscode-highlight-padding-h);\n  --vscode-highlight-border-radius: 8px;\n\n  --vscode-highlight-line-highlighted-background-color: transparent;\n  --vscode-highlight-line-highlighted-border-width: 4px;\n  --vscode-highlight-line-highlighted-border-color: transparent;\n}\n\n.vscode-highlight {\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n  padding-top: 1rem;\n  padding-top: var(--vscode-highlight-padding-top);\n  padding-bottom: 1rem;\n  padding-bottom: var(--vscode-highlight-padding-bottom);\n  border-radius: 8px;\n  border-radius: var(--vscode-highlight-border-radius);\n  font-feature-settings: normal;\n}\n\n.vscode-highlight-code {\n  display: inline-block;\n  min-width: 100%;\n}\n\n.vscode-highlight-line {\n  display: inline-block;\n  box-sizing: border-box;\n  width: 100%;\n  padding-left: 1.5rem;\n  padding-left: var(--vscode-highlight-padding-left);\n  padding-right: 1.5rem;\n  padding-right: var(--vscode-highlight-padding-right);\n}\n\n.vscode-highlight-line-highlighted {\n  background-color: var(--vscode-highlight-line-highlighted-background-color);\n  box-shadow: inset var(--vscode-highlight-line-highlighted-border-width) 0 0 0 var(--vscode-highlight-line-highlighted-border-color);\n}\n.default-dark {\nbackground-color: #1E1E1E;\ncolor: #D4D4D4;\n}\n\n.default-dark .mtk1 { color: #D4D4D4; }\n.default-dark .mtk2 { color: #1E1E1E; }\n.default-dark .mtk3 { color: #6A9955; }\n.default-dark .mtk4 { color: #569CD6; }\n.default-dark .mtk5 { color: #D16969; }\n.default-dark .mtk6 { color: #D7BA7D; }\n.default-dark .mtk7 { color: #B5CEA8; }\n.default-dark .mtk8 { color: #CE9178; }\n.default-dark .mtk9 { color: #646695; }\n.default-dark .mtk10 { color: #4EC9B0; }\n.default-dark .mtk11 { color: #DCDCAA; }\n.default-dark .mtk12 { color: #9CDCFE; }\n.default-dark .mtk13 { color: #000080; }\n.default-dark .mtk14 { color: #F44747; }\n.default-dark .mtk15 { color: #C586C0; }\n.default-dark .mtk16 { color: #6796E6; }\n.default-dark .mtk17 { color: #808080; }\n.default-dark .mtki { font-style: italic; }\n.default-dark .mtkb { font-weight: bold; }\n.default-dark .mtku { text-decoration: underline; text-underline-position: under; }</style>","excerpt":"지난 두 글에서 사용한 전략은, 멤버에 접근하기 위한 방법을 동일한 인터페이스로 맞춰서 (첫 번째 글에서는 멤버 데이터 포인터, 두 번째 글에서는 멤버 함수 포인터) BuffType…","fields":{"date":"October 07, 2012"},"frontmatter":{"title":"멤버 데이터 포인터를 사용하여 연산식 묶어내기 3","tags":["c++","refactor"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2012/10/07/extract-code-using-member-data-pointer-3/"}}}