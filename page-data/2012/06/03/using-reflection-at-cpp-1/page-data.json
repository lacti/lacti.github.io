{"componentChunkName":"component---src-templates-blog-js","path":"/2012/06/03/using-reflection-at-cpp-1","webpackCompilationHash":"69d4b35bc62b6069aa17","result":{"data":{"markdownRemark":{"html":"<p>mmo-server에서 attribute를 json serialize하기 위해 attribute가 가지고 있는 field의 정보를 enumerate 해야할 일이 생겼다. 그런데 c++은 reflection이 없잖아?</p>\n<p>그렇게 고민하다가 예전에 쓴 글을 발견했다.</p>\n<ul>\n<li><a href=\"%7B%25%20post_url%202011-09-30-using-rtti-at-cpp%20%25%7D\">c++에서 구조체 RTTI 정보 남기기</a></li>\n</ul>\n<p>기본 아이디어는 다음과 같다. 각 class마다 자신의 field에 대한 정보를 갖는다. 이름과 멤버 변수 포인터 쌍을 가진다고 보면 된다. 여기서 골치가 아픈건 저 field에 대한 정보를 어떻게 표기하냐인데, 멤버 변수 포인터라는 type을 좀 generic하게 관리해줄 방법이 필요하다. 제대로 하려면 코드가 복잡해질테니 대충 다음과 같이 틀만 잡았다.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">class</span><span class=\"mtk1\"> </span><span class=\"mtk10\">field_t</span><span class=\"mtk1\"> {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">public:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk11\">field_t</span><span class=\"mtk1\">(std::string </span><span class=\"mtk12\">_name</span><span class=\"mtk1\">) : </span><span class=\"mtk11\">field_name</span><span class=\"mtk1\">(_name) {}</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">template</span><span class=\"mtk1\"> &lt;</span><span class=\"mtk4\">typename </span><span class=\"mtk10\">_FieldTy</span><span class=\"mtk4\">,</span><span class=\"mtk1\"> </span><span class=\"mtk4\">typename </span><span class=\"mtk10\">_ObjTy</span><span class=\"mtk1\">&gt;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    _FieldTy&amp; </span><span class=\"mtk11\">ref</span><span class=\"mtk1\">(_ObjTy* </span><span class=\"mtk12\">obj</span><span class=\"mtk1\">) {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        _FieldTy* address = </span><span class=\"mtk4\">reinterpret_cast</span><span class=\"mtk1\">&lt;_FieldTy*&gt;(</span><span class=\"mtk11\">ptr</span><span class=\"mtk1\">(obj));</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> *address;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">const</span><span class=\"mtk1\"> </span><span class=\"mtk4\">char</span><span class=\"mtk1\">* </span><span class=\"mtk11\">name</span><span class=\"mtk1\">() </span><span class=\"mtk4\">const</span><span class=\"mtk1\"> { </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">field_name</span><span class=\"mtk1\">.</span><span class=\"mtk11\">c_str</span><span class=\"mtk1\">(); }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">protected:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">virtual</span><span class=\"mtk1\"> </span><span class=\"mtk4\">void</span><span class=\"mtk1\">* </span><span class=\"mtk11\">ptr</span><span class=\"mtk1\">(</span><span class=\"mtk4\">void</span><span class=\"mtk1\">* </span><span class=\"mtk12\">obj</span><span class=\"mtk1\">) </span><span class=\"mtk4\">const</span><span class=\"mtk1\"> = </span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">protected:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    std::string field_name;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">};</span></span></code></pre>\n<p>핵심 함수가 <code>ref()</code>인 것 같지만 잘 보면 저건 훼이크 함수다. 인자로 받은 object를 <code>ptr()</code>이라는 의미심장한 virtual 함수에게 넘겨주고 자신은 그냥 그걸 적절한 field type으로 casting해서 반환해줄 뿐이다.</p>\n<p>게다가 템플릿 함수! <code>field_t</code>라는 고정 type으로 모든 field에 대한 정보는 관리하고 싶지만, 그 field가 관리하는 멤버 변수 포인터가 반환하는 값은 모두 다르기에 별로 더 좋은 생각도 안 나고 <del>귀찮아서</del>어쩔 수 없이 저렇게 작성했다.</p>\n<p>때문에 <code>reinterpret_cast</code>가 등장했는데 함수에 대한 템플릿 인자를 클래스까지 확장하지 않고서는 객체의 type이나 field의 type 정보를 구체 구현 class까지 넘겨줄 방법이 없으므로 대충 <code>reinterpret_cast</code>로 때운 것이다. (덕분에 실 사용 type 검증 로직은 하나도 없고, 잘못 사용하면 안드로메다를 보게 된다.)</p>\n<p>이제 저 <code>ptr()</code>을 구현하는 구체 클래스를 만들면 된다. 역시 대충 만들었다.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">template</span><span class=\"mtk1\"> &lt;</span><span class=\"mtk4\">typename </span><span class=\"mtk10\">_ObjTy</span><span class=\"mtk4\">,</span><span class=\"mtk1\"> </span><span class=\"mtk4\">typename </span><span class=\"mtk10\">_FieldTy</span><span class=\"mtk4\">,</span><span class=\"mtk1\"> typename _FieldTy (_ObjTy::*Field)&gt;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">class</span><span class=\"mtk1\"> </span><span class=\"mtk10\">field_impl_t</span><span class=\"mtk1\"> : </span><span class=\"mtk4\">public</span><span class=\"mtk1\"> </span><span class=\"mtk10\">field_t</span><span class=\"mtk1\"> {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">public:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk11\">field_impl_t</span><span class=\"mtk1\">(std::string </span><span class=\"mtk12\">_name</span><span class=\"mtk1\">) : </span><span class=\"mtk10\">field_t</span><span class=\"mtk1\">(_name) {}</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">protected:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">virtual</span><span class=\"mtk1\"> </span><span class=\"mtk4\">void</span><span class=\"mtk1\">* </span><span class=\"mtk11\">ptr</span><span class=\"mtk1\">(</span><span class=\"mtk4\">void</span><span class=\"mtk1\">* </span><span class=\"mtk12\">obj_addr</span><span class=\"mtk1\">) </span><span class=\"mtk4\">const</span><span class=\"mtk1\"> {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        _ObjTy* obj = </span><span class=\"mtk4\">reinterpret_cast</span><span class=\"mtk1\">&lt;_ObjTy*&gt;(obj_addr);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> &amp;(</span><span class=\"mtk12\">obj-&gt;*Field</span><span class=\"mtk1\">);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">};</span></span></code></pre>\n<p>예전 글에서는 offset을 직접 계산해서 거길 다시 접근하는 무시무시하고 소름끼치는 방법을 썼는데, 이번 글에서는 template의 힘을 빌린 멤버 변수 포인터를 써서 조금이나마 우아하고 안정적인 방법을 썼다. 하지만 현실은 <code>reinterpret_cast</code> [...]</p>\n<p>실제 <code>ptr()</code> 함수 구현체는 그냥 object를 <code>field_impl_t</code> class가 아는 object type으로 강제 casting한 후, 거기서 찾고자 하는 멤버 field의 위치 주소를 찾아서 반환해주는 것이다.</p>\n<p><code>field_t</code>와 <code>field_impl_t</code>의 관계에서 볼 수 있듯이 둘은 object의 type으로는 엮여있지 않고, 덕분에 <code>reinterpret_cast</code>를 쓴다. 이 때문에 잘못된 object가 들어가면 굉장한 광경을 볼 수 있다! (게다가 실행해보기 전까지는 모른다는게 함정!)<br>\n... 물론 <code>ref()</code> 함수의 반환 타입만 잘못 지정해도 무시무시한 일이 벌어진다.</p>\n<p>이제 저 <code>field_t</code>를 관리하는 관리 class를 만들어보자. 귀찮으니까 코드를 먼저 보자.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">template</span><span class=\"mtk1\"> &lt;</span><span class=\"mtk4\">typename </span><span class=\"mtk10\">_Ty</span><span class=\"mtk1\">&gt;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">struct</span><span class=\"mtk1\"> </span><span class=\"mtk10\">field_info_map_t</span><span class=\"mtk1\"> {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">protected:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">typedef</span><span class=\"mtk1\"> _Ty impl_type;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">typedef</span><span class=\"mtk1\"> std::map&lt;std::string, </span><span class=\"mtk10\">field_t</span><span class=\"mtk1\">*&gt; </span><span class=\"mtk10\">_info_map_t</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">static</span><span class=\"mtk1\"> </span><span class=\"mtk10\">_info_map_t</span><span class=\"mtk1\"> _info_map;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">template</span><span class=\"mtk1\"> &lt;</span><span class=\"mtk4\">typename </span><span class=\"mtk10\">_FieldTy</span><span class=\"mtk4\">,</span><span class=\"mtk1\"> typename _FieldTy (_Ty::*Field)&gt;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">static</span><span class=\"mtk1\"> </span><span class=\"mtk4\">void</span><span class=\"mtk1\"> </span><span class=\"mtk11\">_register_field</span><span class=\"mtk1\">(std::string </span><span class=\"mtk12\">name</span><span class=\"mtk1\">) {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk12\">_info_map</span><span class=\"mtk1\">.</span><span class=\"mtk11\">insert</span><span class=\"mtk1\">(std::</span><span class=\"mtk11\">make_pair</span><span class=\"mtk1\">(name, </span><span class=\"mtk4\">new</span><span class=\"mtk1\"> </span><span class=\"mtk11\">field_impl_t</span><span class=\"mtk1\">&lt;</span><span class=\"mtk4\">_Ty</span><span class=\"mtk1\">, </span><span class=\"mtk4\">_FieldTy</span><span class=\"mtk1\">, </span><span class=\"mtk4\">Field</span><span class=\"mtk1\">&gt;(name)));</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">public:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">typedef</span><span class=\"mtk1\"> std::map&lt;std::string, </span><span class=\"mtk10\">field_t</span><span class=\"mtk1\">*&gt;::iterator </span><span class=\"mtk10\">field_iterator_t</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">static</span><span class=\"mtk1\"> </span><span class=\"mtk10\">field_t</span><span class=\"mtk1\">* </span><span class=\"mtk11\">get_field</span><span class=\"mtk1\">(std::string </span><span class=\"mtk12\">name</span><span class=\"mtk1\">) {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_info_map</span><span class=\"mtk1\">[name];</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">static</span><span class=\"mtk1\"> </span><span class=\"mtk10\">field_iterator_t</span><span class=\"mtk1\"> </span><span class=\"mtk11\">get_field_begin</span><span class=\"mtk1\">() { </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_info_map</span><span class=\"mtk1\">.</span><span class=\"mtk11\">begin</span><span class=\"mtk1\">(); }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">static</span><span class=\"mtk1\"> </span><span class=\"mtk10\">field_iterator_t</span><span class=\"mtk1\"> </span><span class=\"mtk11\">get_field_end</span><span class=\"mtk1\">() { </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_info_map</span><span class=\"mtk1\">.</span><span class=\"mtk11\">end</span><span class=\"mtk1\">(); }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">};</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">template</span><span class=\"mtk1\"> &lt;</span><span class=\"mtk4\">typename </span><span class=\"mtk10\">_Ty</span><span class=\"mtk1\">&gt;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">typename</span><span class=\"mtk1\"> field_info_map_t&lt;</span><span class=\"mtk4\">_Ty</span><span class=\"mtk1\">&gt;::</span><span class=\"mtk10\">_info_map_t</span><span class=\"mtk1\"> field_info_map_t&lt;</span><span class=\"mtk4\">_Ty</span><span class=\"mtk1\">&gt;::_info_map;</span></span></code></pre>\n<p>지난 글에서 했던 것처럼, 동일하게 map을 사용해서 이름과 <code>field_t*</code>에 대한 정보를 가지고 있다. 특이한건 모든 멤버가 다 static인데 template parameter를 가지고 있다는 것이다. 그 이유는 CRTP를 써서 register 과정에서 어떤 type인지에 대한 정보를 생략하기 위함이다. (이는 실 사용 부분에서 자세히 보자.)</p>\n<p>이제 각 field를 어떻게 등록할 것인지, helper macro를 먼저 보자.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk15\">#define</span><span class=\"mtk4\"> </span><span class=\"mtk11\">REGISTER_FIELD_BEGIN</span><span class=\"mtk4\">() </span><span class=\"mtk6\">\\</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">    struct </span><span class=\"mtk10\">__register</span><span class=\"mtk4\"> { </span><span class=\"mtk6\">\\</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">        </span><span class=\"mtk11\">__register</span><span class=\"mtk4\">() { </span><span class=\"mtk6\">\\</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">            static bool init </span><span class=\"mtk1\">=</span><span class=\"mtk4\"> false; </span><span class=\"mtk6\">\\</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">            </span><span class=\"mtk15\">if</span><span class=\"mtk4\"> (init) </span><span class=\"mtk15\">return</span><span class=\"mtk4\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk15\">#define</span><span class=\"mtk4\"> </span><span class=\"mtk11\">REGISTER_FIELD_END</span><span class=\"mtk4\">() </span><span class=\"mtk6\">\\</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">        } </span><span class=\"mtk6\">\\</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">    } _register_auto;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk15\">#define</span><span class=\"mtk4\"> </span><span class=\"mtk11\">REGISTER_FIELD</span><span class=\"mtk4\">(</span><span class=\"mtk12\">type, name</span><span class=\"mtk4\">) </span><span class=\"mtk6\">\\</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">            impl_type::_register_field</span><span class=\"mtk1\">&lt;</span><span class=\"mtk4\">type, </span><span class=\"mtk1\">&amp;</span><span class=\"mtk4\">impl_type::name</span><span class=\"mtk1\">&gt;</span><span class=\"mtk4\">(</span><span class=\"mtk12\">#name</span><span class=\"mtk4\">);</span></span></code></pre>\n<p>역시 지난 글에서와 동일하게 struct 생성자 코드 + static 변수로 중복 실행 방지를 사용해서 해당 구조체에 접근할 때 바로 field 정보가 register 되도록 구성할 것이다.</p>\n<p>재밌는 부분은 <code>REGISTER_FIELD</code> 부분이다. 이전 글과는 다르게 어떤 class인지에 대한 정보가 빠져있다. 그게 빠질 수 있는 이유는 실제 type을 언급하는 대신 <code>impl_type</code>이라는 이름을 사용하고 있기 때문인데, 이것을 위해서 <code>field_type_info_map_t</code>가 template parameter를 갖는 것이고, 그 type을 굳이 <code>impl_type</code>이라고 typedef 해 준 것이다.</p>\n<p>즉, 멤버 포인터 변수를 작성할 때의 문법이 <code>className::*memberName</code>인데 className을 한 번 더 써주기 싫어서 만든 장치이다(...)</p>\n<p>이제 다 만들었으니까 사용해보자.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">struct</span><span class=\"mtk1\"> </span><span class=\"mtk10\">user_t</span><span class=\"mtk1\"> : </span><span class=\"mtk10\">field_info_map_t</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">user_t</span><span class=\"mtk1\">&gt; {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">int</span><span class=\"mtk1\"> index;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    std::string name;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk11\">REGISTER_FIELD_BEGIN</span><span class=\"mtk1\">()</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk11\">REGISTER_FIELD</span><span class=\"mtk1\">(</span><span class=\"mtk4\">int</span><span class=\"mtk1\">, index)</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk11\">REGISTER_FIELD</span><span class=\"mtk1\">(std::string, name)</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk11\">REGISTER_FIELD_END</span><span class=\"mtk1\">()</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">};</span></span></code></pre>\n<p><code>user_t</code>라는 구조체는 <code>index</code>, <code>name</code>라는 변수를 갖는다. 그리고 <code>REGISTER</code> 매크로를 통해 두 변수 모두 field 정보를 등록했다. 물론 매크로를 약간 고치면 지난 글처럼 매크로만으로 구조체 선언까지 가능해진다. 그런데 별로 그건 취향이 아니고-_- 구조체 내 변수가 깔끔하게 안 나온다. <em>(struct 변수 때문에 지저분해진다)</em></p>\n<p>좀 더 깔끔한 방법이 있을 것 같은데, 피곤하니 일단 저 정도에서 타협! 이제 다음과 같이 사용할 수 있다.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk10\">user_t</span><span class=\"mtk1\"> user;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">user.index = </span><span class=\"mtk7\">100</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">user.name = </span><span class=\"mtk8\">&quot;choi&quot;</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk11\">assert</span><span class=\"mtk1\">(</span><span class=\"mtk11\">user_t::get_field</span><span class=\"mtk1\">(</span><span class=\"mtk8\">&quot;index&quot;</span><span class=\"mtk1\">)-&gt;ref&lt;</span><span class=\"mtk4\">int</span><span class=\"mtk1\">&gt;(&amp;user) == user.index);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk11\">assert</span><span class=\"mtk1\">(</span><span class=\"mtk11\">user_t::get_field</span><span class=\"mtk1\">(</span><span class=\"mtk8\">&quot;name&quot;</span><span class=\"mtk1\">)-&gt;ref&lt;std::string&gt;(&amp;user) == user.name);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">std::</span><span class=\"mtk11\">for_each</span><span class=\"mtk1\">(</span><span class=\"mtk11\">user_t::get_field_begin</span><span class=\"mtk1\">(), user_t::</span><span class=\"mtk11\">get_field_end</span><span class=\"mtk1\">(), [&amp;] (std::pair&lt;std::string, </span><span class=\"mtk10\">field_t</span><span class=\"mtk1\">*&gt; pair) {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk11\">printf</span><span class=\"mtk1\">(</span><span class=\"mtk8\">&quot;%s</span><span class=\"mtk6\">\\n</span><span class=\"mtk8\">&quot;</span><span class=\"mtk1\">, </span><span class=\"mtk12\">pair</span><span class=\"mtk1\">.</span><span class=\"mtk12\">first</span><span class=\"mtk1\">.</span><span class=\"mtk11\">c_str</span><span class=\"mtk1\">());</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">});</span></span></code></pre>\n<p><code>get_field()</code> 함수를 사용해서 대응되는 <code>field_t</code>를 가져올 수 있고, 거기에 객체의 주소를 넣어 값을 가져올 수 있다. 그리고 등록된 모든 field를 열거할 수 있다.</p>\n<p>하지만 여기에는 지난 번 글에서와 마찬가지로 한 가지 문제점이 있다. 바로 <code>user_t</code>가 한 번도 생성된 적이 없다면 <code>user_t::get_field_begin()</code>, <code>user_t::get_field_end()</code>로 접근할 수 있는 field가 하나도 등록되지 않는다는 점이다. 즉, 무조건 <code>user_t</code> 객체가 한 번이라도 생성되어야 field가 등록된다는 것이다.</p>\n<p>위 문제로 인해 deserialize를 제대로 수행할 수 없는 문제가 발생한다. 다음 글에서는 이 문제를 어떻게 해결할 수 있는지 알아보도록 하자.</p>\n<style class=\"vscode-highlight-styles\">:root {\n  --vscode-highlight-padding-v: 1rem;\n  --vscode-highlight-padding-h: 1.5rem;\n  --vscode-highlight-padding-top: var(--vscode-highlight-padding-v);\n  --vscode-highlight-padding-right: var(--vscode-highlight-padding-h);\n  --vscode-highlight-padding-bottom: var(--vscode-highlight-padding-v);\n  --vscode-highlight-padding-left: var(--vscode-highlight-padding-h);\n  --vscode-highlight-border-radius: 8px;\n\n  --vscode-highlight-line-highlighted-background-color: transparent;\n  --vscode-highlight-line-highlighted-border-width: 4px;\n  --vscode-highlight-line-highlighted-border-color: transparent;\n}\n\n.vscode-highlight {\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n  padding-top: 1rem;\n  padding-top: var(--vscode-highlight-padding-top);\n  padding-bottom: 1rem;\n  padding-bottom: var(--vscode-highlight-padding-bottom);\n  border-radius: 8px;\n  border-radius: var(--vscode-highlight-border-radius);\n  font-feature-settings: normal;\n}\n\n.vscode-highlight-code {\n  display: inline-block;\n  min-width: 100%;\n}\n\n.vscode-highlight-line {\n  display: inline-block;\n  box-sizing: border-box;\n  width: 100%;\n  padding-left: 1.5rem;\n  padding-left: var(--vscode-highlight-padding-left);\n  padding-right: 1.5rem;\n  padding-right: var(--vscode-highlight-padding-right);\n}\n\n.vscode-highlight-line-highlighted {\n  background-color: var(--vscode-highlight-line-highlighted-background-color);\n  box-shadow: inset var(--vscode-highlight-line-highlighted-border-width) 0 0 0 var(--vscode-highlight-line-highlighted-border-color);\n}\n.default-dark {\nbackground-color: #1E1E1E;\ncolor: #D4D4D4;\n}\n\n.default-dark .mtk1 { color: #D4D4D4; }\n.default-dark .mtk2 { color: #1E1E1E; }\n.default-dark .mtk3 { color: #6A9955; }\n.default-dark .mtk4 { color: #569CD6; }\n.default-dark .mtk5 { color: #D16969; }\n.default-dark .mtk6 { color: #D7BA7D; }\n.default-dark .mtk7 { color: #B5CEA8; }\n.default-dark .mtk8 { color: #CE9178; }\n.default-dark .mtk9 { color: #646695; }\n.default-dark .mtk10 { color: #4EC9B0; }\n.default-dark .mtk11 { color: #DCDCAA; }\n.default-dark .mtk12 { color: #9CDCFE; }\n.default-dark .mtk13 { color: #000080; }\n.default-dark .mtk14 { color: #F44747; }\n.default-dark .mtk15 { color: #C586C0; }\n.default-dark .mtk16 { color: #6796E6; }\n.default-dark .mtk17 { color: #808080; }\n.default-dark .mtki { font-style: italic; }\n.default-dark .mtkb { font-weight: bold; }\n.default-dark .mtku { text-decoration: underline; text-underline-position: under; }</style>","fields":{"date":"June 03, 2012","path":"/2012/06/03/using-reflection-at-cpp-1"},"frontmatter":{"title":"c++에서 reflection 사용하기 1","tags":["c++","reflection"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}