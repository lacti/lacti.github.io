{"componentChunkName":"component---src-templates-page-tsx","path":"/2011/07/01/nonsense-of-iterator-incremental-operator/","webpackCompilationHash":"fe0540f452ea4d417b3b","result":{"data":{"site":{"siteMetadata":{"title":"Lacti's Archive","description":"All about I learned","author":{"name":"Jaeyoung, Choi","url":"https://twitter.com/lacti"}}},"markdownRemark":{"html":"<p>반복문에서 반복자를 증가시킬 때, <code>for ( ; ; i++)</code>과 <code>for ( ; ; ++i)</code>를 이야기할 때, 뭐가 빠르네 느리네 이야기가 왜 나왔을까?<br>\n간단히 생각해보면, <code>i++</code>과 <code>++i</code>는 동작이 약간 다르다. 연산자 우선순위는 <code>i++</code>이 좀 더 빠르지만, 실행 측면에서 본다면</p>\n<p><code>i++</code>은</p>\n<ol>\n<li>자신의 상태를 저장한다</li>\n<li>자신의 상태를 변화한다</li>\n<li>저장한 예전 상태를 반환한다</li>\n</ol>\n<p><code>++i</code>는</p>\n<ol>\n<li>자신의 상태를 변화한다</li>\n<li>자신 자체를 반환한다.</li>\n</ol>\n<p><code>i++</code>의 3)과 <code>++i</code>의 2)를 보면 <code>i++</code>의 경우 복사해둔 것을 반환하지만, <code>++i</code>의 경우는 자기 자체(reference)를 반환한다. <code>i++++</code>은 안되지만 <code>++++i</code>는 되는 이유가 그것이다.<br>\n함수 prototype으로 치자면</p>\n<ul>\n<li>전항연산의 <code>int &#x26; operator ++ (void)</code>와</li>\n<li>후항연산의 <code>int operator ++ (int dummy)</code>의</li>\n</ul>\n<p>차이랄까. 반환 값의 type이 다르다.</p>\n<p>이게 단순 primitive type이면서 value type일 때는, <code>i++</code>의 3)과 <code>++i</code>의 2) 가 결국 복사된 값이므로 저기서 발생하는 부담은 같지만, 이를 수행하기 위한 instruction 차이가 난다.</p>\n<p>하지만 이게 wrapper class에 의한 object이면 좀 달라진다.<br>\n<code>i++</code>의 경우 반환하기 위한 임시 객체를 복사해서 준비해야하고, 자신을 변화시킨 후, 복사해둔 객체를 반환해야한다. 하지만 <code>++i</code>는? 그냥 자기 자신 (*this) 을 반환하면 된다.</p>\n<p>객체의 복사라는게 객체의 크기에 따라 안드로메다급으로 걸릴 수 있는 일인데다가 <code>obj next = current++;</code>와 같이 작성할 경우</p>\n<ol>\n<li>++ 함수 내부에서 임시 객체 생성 위한 복사 1번</li>\n<li>++ 함수 반환 값에서 next 로 대입되기 위한 복사 1번</li>\n<li>재수없다면 next 객체 생성 따로 ++ 함수 반환 값 대입 연산 따로 까지 칠 경우 1번</li>\n</ol>\n<p>총 2번 (컴파일러가 바보면 3번) 복사 짓을 해야한다는 것이다. 메모리도 그렇고 명령어도 그렇고 낭비가 심하다.</p>\n<p>STL의 iterator 같은 걸 쓸 때 iterator는 object이다. 따라서 전항 ++ 이 후항 ++ 보다 성능이 빠르다는 이야기가 위 근거에 의해 성립되는 것이다.</p>\n<p>자 그럼 이게 왜 헛소리인지 보자. 일단 <strong>컴파일러가 그렇게 멍청하지 않다.</strong><br>\nfor 문에서 int 변수를 <code>i++</code> 하나 <code>++i</code> 하나 컴파일러가 바보가 아닌 이상에야 <code>INC instruction</code> 넣어주면 된다.</p>\n<p>저게 iterator 같은 class라면?</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk15\">#include</span><span class=\"mtk4\"> </span><span class=\"mtk8\">&lt;iostream&gt;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">class</span><span class=\"mtk1\"> </span><span class=\"mtk10\">serial</span><span class=\"mtk1\"> {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">public:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    serial &amp; operator ++ (</span><span class=\"mtk4\">void</span><span class=\"mtk1\">) {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        std::cout &lt;&lt; </span><span class=\"mtk8\">&quot;prefix&quot;</span><span class=\"mtk1\"> &lt;&lt; std::endl;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> (*</span><span class=\"mtk4\">this</span><span class=\"mtk1\">);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    serial &amp; operator ++ (</span><span class=\"mtk4\">int</span><span class=\"mtk1\"> </span><span class=\"mtk12\">dummy</span><span class=\"mtk1\">) {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        std::cout &lt;&lt; </span><span class=\"mtk8\">&quot;postfix&quot;</span><span class=\"mtk1\"> &lt;&lt; std::endl;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> (*</span><span class=\"mtk4\">this</span><span class=\"mtk1\">);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">};</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">int</span><span class=\"mtk1\"> </span><span class=\"mtk11\">main</span><span class=\"mtk1\"> (</span><span class=\"mtk4\">int</span><span class=\"mtk1\"> </span><span class=\"mtk12\">argc</span><span class=\"mtk1\">, </span><span class=\"mtk4\">char</span><span class=\"mtk1\">* </span><span class=\"mtk12\">argv</span><span class=\"mtk1\">[])</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">{</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    serial s;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    ++++s;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    s++++;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">}</span></span></code></pre>\n<p>재밌게도 후항(postfix) ++ 연산을 overloading할 때 반환 값에 대해서 신경을 쓰지 않아도 된다. 그런고로 전항(prefix) ++ 연산과 동일한 동작을 수행하게 하면 성능상 문제가 없다 할 수 있겠다.</p>\n<p>물론,</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk1\">serial &amp; operator ++ (</span><span class=\"mtk4\">int</span><span class=\"mtk1\"> </span><span class=\"mtk12\">dummy</span><span class=\"mtk1\">) { </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> ++(*</span><span class=\"mtk4\">this</span><span class=\"mtk1\">); }</span></span></code></pre>\n<p>와 같이 후항 연산에서 전항 연산을 호출해버려도 되고, (컴파일러가 함수 호출은 최적화시켜 줄거라 믿자)</p>\n<p>Visual Studio 2010에서 해본 결과 아예 후항 ++ 연산 함수를 정의하지 않으면 알아서 전항 ++ 함수를 호출해버린다-_-\n(g++ 4.5.2에서는 error: no ‘operator++(int)’ declared for postfix ’++’ 와 같이 에러를 띄운다)</p>\n<p>그런고로 값 타입이든 객체 타입이든 반복문 등에서 반복자를 증가시킬 때 ++을 앞에 쓰냐 뒤에 쓰냐는 성능에 영향이 없다는 소리. 물론 컴파일러에 따라 다를 수 있다는 말이 제일 정답일 것이다만-_-</p>\n<style class=\"vscode-highlight-styles\">:root {\n  --vscode-highlight-padding-v: 1rem;\n  --vscode-highlight-padding-h: 1.5rem;\n  --vscode-highlight-padding-top: var(--vscode-highlight-padding-v);\n  --vscode-highlight-padding-right: var(--vscode-highlight-padding-h);\n  --vscode-highlight-padding-bottom: var(--vscode-highlight-padding-v);\n  --vscode-highlight-padding-left: var(--vscode-highlight-padding-h);\n  --vscode-highlight-border-radius: 8px;\n\n  --vscode-highlight-line-highlighted-background-color: transparent;\n  --vscode-highlight-line-highlighted-border-width: 4px;\n  --vscode-highlight-line-highlighted-border-color: transparent;\n}\n\n.vscode-highlight {\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n  padding-top: 1rem;\n  padding-top: var(--vscode-highlight-padding-top);\n  padding-bottom: 1rem;\n  padding-bottom: var(--vscode-highlight-padding-bottom);\n  border-radius: 8px;\n  border-radius: var(--vscode-highlight-border-radius);\n  font-feature-settings: normal;\n}\n\n.vscode-highlight-code {\n  display: inline-block;\n  min-width: 100%;\n}\n\n.vscode-highlight-line {\n  display: inline-block;\n  box-sizing: border-box;\n  width: 100%;\n  padding-left: 1.5rem;\n  padding-left: var(--vscode-highlight-padding-left);\n  padding-right: 1.5rem;\n  padding-right: var(--vscode-highlight-padding-right);\n}\n\n.vscode-highlight-line-highlighted {\n  background-color: var(--vscode-highlight-line-highlighted-background-color);\n  box-shadow: inset var(--vscode-highlight-line-highlighted-border-width) 0 0 0 var(--vscode-highlight-line-highlighted-border-color);\n}\n.default-dark {\nbackground-color: #1E1E1E;\ncolor: #D4D4D4;\n}\n\n.default-dark .mtk1 { color: #D4D4D4; }\n.default-dark .mtk2 { color: #1E1E1E; }\n.default-dark .mtk3 { color: #6A9955; }\n.default-dark .mtk4 { color: #569CD6; }\n.default-dark .mtk5 { color: #D16969; }\n.default-dark .mtk6 { color: #D7BA7D; }\n.default-dark .mtk7 { color: #B5CEA8; }\n.default-dark .mtk8 { color: #CE9178; }\n.default-dark .mtk9 { color: #646695; }\n.default-dark .mtk10 { color: #4EC9B0; }\n.default-dark .mtk11 { color: #DCDCAA; }\n.default-dark .mtk12 { color: #9CDCFE; }\n.default-dark .mtk13 { color: #000080; }\n.default-dark .mtk14 { color: #F44747; }\n.default-dark .mtk15 { color: #C586C0; }\n.default-dark .mtk16 { color: #6796E6; }\n.default-dark .mtk17 { color: #808080; }\n.default-dark .mtki { font-style: italic; }\n.default-dark .mtkb { font-weight: bold; }\n.default-dark .mtku { text-decoration: underline; text-underline-position: under; }</style>","excerpt":"반복문에서 반복자를 증가시킬 때, for ( ; ; i++)과 for ( ; ; ++i)를 이야기할 때, 뭐가 빠르네 느리네 이야기가 왜 나왔을까?간단히 생각해보면, i++과 ++i는 동작이 약간 다르다. 연산자 우선순위는 i…","fields":{"date":"July 01, 2011","shortdesc":""},"frontmatter":{"title":"반복자 i++과 ++i에 대한 헛소리","tags":["c++"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2011/07/01/nonsense-of-iterator-incremental-operator/"}}}