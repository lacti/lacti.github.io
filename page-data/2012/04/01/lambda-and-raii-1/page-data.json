{"componentChunkName":"component---src-templates-page-tsx","path":"/2012/04/01/lambda-and-raii-1/","result":{"data":{"site":{"siteMetadata":{"title":"Lacti's Archive","description":"All about I learned","author":{"name":"Jaeyoung, Choi","url":"https://twitter.com/lacti"}}},"markdownRemark":{"html":"<p>C++11 에서 도입된 lambda expression을 통한 RAII 구현 방식의 한 예와, 단위 전략을 통한 RAII 구현을 통해 장단점을 비교해보자.</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization\">Wiki: Resource Acquisition Is Initialization(RAII)</a>는 scope 내의 정적으로 할당되는 객체의 생존 주기로 생성자와 소멸자가 쌍으로 호출되는 것을 사용하는 자원 관리 기법이다. 보통</p>\n<ul>\n<li>IO (열었으면 닫아야하니까),</li>\n<li>메모리 (할당했으면 해제해야하니까, shared_ptr도 AddReference 했으면 ReleaseReference)</li>\n<li>Lock (Lock 걸었으면 Unlock 해줘야하니까)</li>\n</ul>\n<p>등에서 사용된다.</p>\n<p>본 글에서는 Lock을 사용하여 예를 들어보자.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"cpp\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">class</span><span class=\"mtk1\"> </span><span class=\"mtk10\">lock_t</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">public:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">void</span><span class=\"mtk1\"> </span><span class=\"mtk11\">lock</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">void</span><span class=\"mtk1\"> </span><span class=\"mtk11\">unlock</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">};</span></span></span></code></pre>\n<p>위와 같은 <code>lock_t</code> class가 정의되어 있다. 어떤 class에서 저 객체를 쓴다고 해보자.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"cpp\" data-index=\"1\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">class</span><span class=\"mtk1\"> </span><span class=\"mtk10\">item_t</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">typedef</span><span class=\"mtk1\"> __int64 </span><span class=\"mtk10\">item_id_t</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">typedef</span><span class=\"mtk1\"> </span><span class=\"mtk10\">std</span><span class=\"mtk1\">::shared_ptr&lt;</span><span class=\"mtk10\">item_t</span><span class=\"mtk1\">&gt; item_ref;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">class</span><span class=\"mtk1\"> </span><span class=\"mtk10\">inventory_t</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">public:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk10\">item_ref</span><span class=\"mtk1\"> </span><span class=\"mtk11\">find</span><span class=\"mtk1\">(</span><span class=\"mtk10\">item_id_t</span><span class=\"mtk1\"> </span><span class=\"mtk12\">item_id</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">private:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk10\">lock_t</span><span class=\"mtk1\"> lock;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk10\">std</span><span class=\"mtk1\">::vector&lt;item_ref&gt; items;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">};</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk10\">item_ref</span><span class=\"mtk1\"> </span><span class=\"mtk10\">inventory_t</span><span class=\"mtk1\">::</span><span class=\"mtk11\">find</span><span class=\"mtk1\">(</span><span class=\"mtk10\">item_id_t</span><span class=\"mtk1\"> </span><span class=\"mtk12\">item_id</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">lock</span><span class=\"mtk1\">.</span><span class=\"mtk11\">lock</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">auto</span><span class=\"mtk1\"> iter = </span><span class=\"mtk10\">std</span><span class=\"mtk1\">::</span><span class=\"mtk11\">find</span><span class=\"mtk1\">(</span><span class=\"mtk12\">items</span><span class=\"mtk1\">.</span><span class=\"mtk11\">begin</span><span class=\"mtk1\">(), </span><span class=\"mtk12\">items</span><span class=\"mtk1\">.</span><span class=\"mtk11\">end</span><span class=\"mtk1\">(), </span><span class=\"mtk11\">find_item_by_id</span><span class=\"mtk1\">(item_id));</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (iter != </span><span class=\"mtk12\">items</span><span class=\"mtk1\">.</span><span class=\"mtk11\">end</span><span class=\"mtk1\">())</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> (*iter);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">lock</span><span class=\"mtk1\">.</span><span class=\"mtk11\">unlock</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk11\">item_ref</span><span class=\"mtk1\">(</span><span class=\"mtk4\">NULL</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>inventory가 가지고 있는 item에 대한 정보는 item의 <code>vector</code>로 관리하고 있다. 저 inventory 객체를 여러 Thread에서 접근한다고 하면, <code>std::find()</code>에 의해 <code>vector</code>를 순회하다가 접근 위반이 발생할 가능성이 있다. (한 thread 는 순회하고, 한 thread 는 vector 에 삽입/삭제할 경우)\n따라서 lock을 사용하여 해당 container 를 보호해준다.</p>\n<p>하지만 위 코드는 문제가 있다.\n<code>lock</code>을 사용하여 <code>items</code>로의 접근을 보호하지만, 실제 item을 찾은 다음 return 문을 수행하기 전에 <code>unlock</code>을 수행하지 않았기 때문이다. 이러한 문제는 <code>find</code> 함수가 좀만 길어지면, 혹은 조금만 신경을 쓰지 않게 되면 흔히 발생할 수 있는 문제이다.</p>\n<p>따라서 이러한 문제를 해결하기 위해 정적 객체의 생존 주기를 활용한다.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"cpp\" data-index=\"2\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">class</span><span class=\"mtk1\"> </span><span class=\"mtk10\">scope_lock_t</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">public:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">scope_lock_t</span><span class=\"mtk1\">(</span><span class=\"mtk10\">lock_t</span><span class=\"mtk4\">*</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_lock</span><span class=\"mtk1\">) : </span><span class=\"mtk11\">lock</span><span class=\"mtk1\">(_lock) { </span><span class=\"mtk12\">lock</span><span class=\"mtk1\">-&gt;</span><span class=\"mtk11\">lock</span><span class=\"mtk1\">(); }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">~scope_lock_t</span><span class=\"mtk1\">() { </span><span class=\"mtk12\">lock</span><span class=\"mtk1\">-&gt;</span><span class=\"mtk11\">unlock</span><span class=\"mtk1\">(); }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">private:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk10\">lock_t</span><span class=\"mtk1\">* lock;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">};</span></span></span></code></pre>\n<p>멤버로 <code>lock_t</code>에 대한 pointer를 갖고, 생성자에서 <code>lock()</code>을 부르고 소멸자에서 <code>unlock()</code>을 부르도록 하는 <code>scope_lock_t</code> class를 설계한다. 그러면 코드가 아래와 같이 바뀐다.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"cpp\" data-index=\"3\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk10\">item_ref</span><span class=\"mtk1\"> </span><span class=\"mtk10\">inventory_t</span><span class=\"mtk1\">::</span><span class=\"mtk11\">find</span><span class=\"mtk1\">(</span><span class=\"mtk10\">item_id_t</span><span class=\"mtk1\"> </span><span class=\"mtk12\">item_id</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk10\">scope_lock_t</span><span class=\"mtk1\"> </span><span class=\"mtk11\">scope_lock</span><span class=\"mtk1\">(&amp;lock);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">auto</span><span class=\"mtk1\"> iter = </span><span class=\"mtk10\">std</span><span class=\"mtk1\">::</span><span class=\"mtk11\">find</span><span class=\"mtk1\">(</span><span class=\"mtk12\">items</span><span class=\"mtk1\">.</span><span class=\"mtk11\">begin</span><span class=\"mtk1\">(), </span><span class=\"mtk12\">items</span><span class=\"mtk1\">.</span><span class=\"mtk11\">end</span><span class=\"mtk1\">(), </span><span class=\"mtk11\">find_item_by_id</span><span class=\"mtk1\">(item_id));</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (iter != </span><span class=\"mtk12\">items</span><span class=\"mtk1\">.</span><span class=\"mtk11\">end</span><span class=\"mtk1\">())</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> (*iter);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk11\">item_ref</span><span class=\"mtk1\">(</span><span class=\"mtk4\">NULL</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p><code>scope_lock_t</code> 객체가 멤버 변수인 <code>lock</code>을 가지고 생성된다. 생성될 때 <code>scope_lock_t</code>의 생성자에서 <code>lock()</code> 함수가 불린다. 그리고 실제 로직이 아래에서 수행되고 <code>inventory_t::find()</code> 함수가 종료되는 시점, 즉 <code>scope_lock_t</code> 객체가 소멸되는 시점에 <code>unlock()</code> 함수가 불린다.</p>\n<p>생성자와 소멸자는 해당 객체의 생성/소멸 시점에 컴파일러가 알아서 불러주므로, 위와 같이 <code>scope_lock_t</code>를 만들어 쓰면 중간에 return을 해도, goto를 해도, 1년 뒤에 코드를 고쳐도! lock-unlock쌍이 잘 맞게 된다.\n<a href=\"/2011/07/20/object-ctor-dtor-with-goto/\">(객체 생성/소멸자와 goto 에 대한 이야기)</a></p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n  .default-dark {\n    background-color: #1E1E1E;\n    color: #D4D4D4;\n  }\n  .default-dark .mtk4 { color: #569CD6; }\n  .default-dark .mtk1 { color: #D4D4D4; }\n  .default-dark .mtk10 { color: #4EC9B0; }\n  .default-dark .mtk11 { color: #DCDCAA; }\n  .default-dark .mtk12 { color: #9CDCFE; }\n  .default-dark .mtk15 { color: #C586C0; }\n  .default-dark .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(255, 255, 255, 0.1));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(255, 255, 255, 0.5));\n  }\n</style>","excerpt":"C++11 에서 도입된 lambda expression을 통한 RAII 구현 방식의 한 예와, 단위 전략을 통한 RAII 구현을 통해 장단점을 비교해보자. Wiki: Resource Acquisition Is Initialization(RAII…","fields":{"date":"April 01, 2012","shortdesc":"","slug":"/2012/04/01/lambda-and-raii-1/"},"frontmatter":{"title":"lambda와 RAII 1","tags":["c++"]}}},"pageContext":{"slug":"/2012/04/01/lambda-and-raii-1/","older":{"slug":"/2012/03/18/asynchronous-programming-and-async-await/","title":"asynchronous programming과 async, await"},"newer":{"slug":"/2012/05/12/lambda-and-raii-2/","title":"lambda와 RAII 2"}}},"staticQueryHashes":["848695393"]}