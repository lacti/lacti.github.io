<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="author" content="lacti">

	<meta name="description" content="async asynchronous programming과 async, await 18 Mar 2012 async 함수를 호출하는 코드를 작성한다고 해보자. synchronous하게 호출하는 방법이 있고, asynchronous하게 호출하는 방법이 있다. (보통 후자는 호출이라고 하기보다는 요청을 한다고 할 것이다) 코드를 작성하는 프로그래머 입장에서는 당연히 synchronous한 로직이 훨씬 직관적이고 이해하기 편한다. 위에서부터 아래로 코드를 읽어내리기만 해도 이게 무슨 동작을 하는 코드인지 이해하기가 쉽기 때문이다. 하지만 여러 성능적 이슈로 인해 많은 함수들이 asynchronous하게 작성된다. 이럴 synchronous한 호출 구조를 갖는 코드에 비해 로직을 이해하기 힘들어진다. (callback 의 callback 의 callback 의 ... 를 부르는 함수 구조를 읽어나가면, 어떤 상황에서 어떤 코드가 실행되는지 조차 파악하기 힘들다) 이 글에서는 간단하게 RPC(remote procedure call) 예제를 통해 위 내용을 살펴보겠다. call_result request_call(call_context ctx) { sock_write(socket_, ctx.serialize()); BYTE result_buffer[RESULT_SIZE]; sock_read(socket_, &amp;result_buffer); return call_result.parse(result_buffer); } 위 request_call이라는 함수는..." />

	<meta name="keywords" content="" />

	<meta name="robots" content="INDEX,FOLLOW" />
	<title>lacti's blog</title>
	<link href="http://yui.yahooapis.com/pure/0.5.0/pure-min.css" rel="stylesheet">
	<link href="http://yui.yahooapis.com/pure/0.5.0/grids-responsive-min.css" rel="stylesheet">
	<link href="/css/markdownpad-github.css" rel="stylesheet">
	<link href="/css/syntax.css" rel="stylesheet">
	<link href="/css/blog-post.css" rel="stylesheet">
	<link href="http://netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">
</head>
<body>
	<div id="head">
		<div class="pure-g">
			<div class="pure-u-1 pure-u-md-1-2">
				<a href="/" title="home"><i class="fa fa-home fa-lg"></i></a>
				<a href="/about/" title="about"><i class="fa fa-male fa-lg"></i></a>
				<a href="/archives/" title="archives"><i class="fa fa-file-text-o fa-lg"></i></a>
				<a href="/tags/" title="tags"><i class="fa fa-tags fa-lg"></i></a>
			</div>
			<div class="pure-u-1 pure-u-md-1-2 text-right">
				<a href="https://github.com/lacti" title="github" rel="nofollow"><i class="fa fa-github fa-lg"></i></a>
				<a href="https://twitter.com/lacti" title="twitter" rel="nofollow"><i class="fa fa-twitter fa-lg"></i></a>
				<a href="http://www.slideshare.net/lactrious/presentations" title="slideshare" rel="nofollow"><i class="fa fa-toggle-right fa-lg"></i></a>
				<a href="http://www.linkedin.com/pub/jaeyoung-choi/99/243/861" title="linkedin" rel="nofollow"><i class="fa fa-linkedin fa-lg"></i></a>
				<a href="https://facebook.com/lactrious" title="facebook" rel="nofollow"><i class="fa fa-facebook fa-lg"></i></a>
				<a href="/atom.xml" title="atom" rel="nofollow"><i class="fa fa-rss fa-lg"></i></a>
			</div>
		</div>
	</div>
	<div class="container">
		<div class="pure-g">
			<div class="pure-u-1">
				
				
				
				
					
					
					
					
					
					
					
						
				<h1><a id="async" href="#async">async</a></h1>
				<hr />
				<div class="page-breaker"></div>
							
						
				<h1 class="page-title">asynchronous programming과 async, await</h1>
				<p class="page-date">18 Mar 2012</p>
				<p class="page-tags">
						
						
					<code class="tag">async</code>
						
						
						
						
				</p>
				<div class="content"><p>함수를 호출하는 코드를 작성한다고 해보자. synchronous하게 호출하는 방법이 있고, asynchronous하게 호출하는 방법이 있다. (보통 후자는 호출이라고 하기보다는 요청을 한다고 할 것이다)</p>

<p>코드를 작성하는 프로그래머 입장에서는 당연히 synchronous한 로직이 훨씬 직관적이고 이해하기 편한다. 위에서부터 아래로 코드를 읽어내리기만 해도 이게 무슨 동작을 하는 코드인지 이해하기가 쉽기 때문이다.</p>

<p>하지만 여러 성능적 이슈로 인해 많은 함수들이 asynchronous하게 작성된다. 이럴 synchronous한 호출 구조를 갖는 코드에 비해 로직을 이해하기 힘들어진다. (callback 의 callback 의 callback 의 ... 를 부르는 함수 구조를 읽어나가면, 어떤 상황에서 어떤 코드가 실행되는지 조차 파악하기 힘들다)</p>

<p>이 글에서는 간단하게 RPC(remote procedure call) 예제를 통해 위 내용을 살펴보겠다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">call_result</span> <span class="nf">request_call</span><span class="p">(</span><span class="n">call_context</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sock_write</span><span class="p">(</span><span class="n">socket_</span><span class="p">,</span> <span class="n">ctx</span><span class="p">.</span><span class="n">serialize</span><span class="p">());</span>

    <span class="n">BYTE</span> <span class="n">result_buffer</span><span class="p">[</span><span class="n">RESULT_SIZE</span><span class="p">];</span>
    <span class="n">sock_read</span><span class="p">(</span><span class="n">socket_</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result_buffer</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">call_result</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="n">result_buffer</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>위 <code>request_call</code>이라는 함수는 함수 호출 정보(<code>call_context</code>)를 인자로 받아서, 원격지(remote)와 연결된 소켓(<code>socket_</code>)으로 해당 내용을 전송한다(<code>sock_write</code>). 그리고 그에 대한 응답이 올 때까지 동기적(synchronous)으로 기다려서 데이터를 읽고(<code>sock_read</code>) 그 결과(<code>call_result</code>)를 반환한다.</p>

<p>이렇듯 synchronous하게 수행되는 코드는 (절차지향적이므로) 위부터 아래로 읽어나가면 이 코드가 무슨 행동을 하는지 파악하기 쉽다. 하지만 위처럼 <code>sock_read</code>라는 대기(blocking) 함수를 사용하여 동기적 수행을 만들 경우 위 함수의 처리 효율은 굉장히 나빠진다. <strong>왜냐하면 결과가 올 때까지 해당 스레드는 아무 작업을 못하고 기다리기 때문이다.</strong></p>

<p>이 문제를 개선하려면 요청 후 결과가 올 때까지 기다리지 않으면 된다.<br>
즉, RPC 함수 요청이 발생하면 그 요청 객체(<code>call_context</code>)를 만들어서 원격지에 보내되 그로부터 결과가 오는 것은 기다리지 않고, 다만 그것에 대한 결과를 미래에(future) 받을 것이라고 약속(promise)만 한다.</p>

<p>그리고 원격지로부터 데이터를 읽는 thread들은 데이터가 도착하면 그 요청 결과(<code>call_result</code>)가 어떤 요청(<code>call_context</code>)에 대한 것인지 확인하여 그 요청을 기다리는 thread에게 알려준다(asynchronous notification)</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">request_call</span><span class="p">(</span><span class="n">call_context</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">request_id</span> <span class="o">=</span> <span class="n">register_request</span><span class="p">(</span><span class="n">thread_id</span><span class="p">());</span>
    <span class="n">send_request</span><span class="p">(</span><span class="n">request_id</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">receive_result</span><span class="p">(</span><span class="n">call_result</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">thread_id</span> <span class="o">=</span> <span class="n">remove_request</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">request_id</span><span class="p">);</span>
    <span class="n">thread_post</span><span class="p">(</span><span class="n">thread_id</span><span class="p">,</span> <span class="n">rpc_callback</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p><code>request_call</code> 함수는 요청 객체를 보내기 전에 일단 자기 <code>thread_id</code>에 대해 <code>request_id</code>를 발급 받는다. 그리고 그걸 원격지로 보내기만 하고 바로 반환된다. 그에 대한 응답이 도착하면 read thread가 그 결과(<code>call_result</code>)를 읽어서 해당 결과가 어떤 thread가 요청한 것인지 찾는다. 그리고 그 thread 에게 <code>rpc_callback</code> 함수를 수행하라고 통지(notification) 해준다.</p>

<p>동기적인 수행 구조를 갖는 코드보다 확실히 코드가 복잡해졌다. 그리고 <code>rpc_callback</code> 이라는 함수가 어느 시점에 호출될지 모른다는 점에서 공유 자원 관리에 대한 문제가 추가로 발생하기도 한다.</p>

<p>위 내용을 요약해보면,</p>

<ul>
<li>동기적 코드를 작성하는 것이 비동기적 흐름의 코드를 작성하는 것보다 더 쉽고, 이해하기도 쉽다. 즉 버그가 덜 생기고 문제가 생겨도 고치기 쉽다.</li>
<li>하지만 동기적 수행을 위해서 흐름이 blocking 되는 것은 그 동안 다른 일처리를 못한다는 관점에서 굉장히 비효율적이다.</li>
</ul>

<p>효율성을 위해 비동기적 코드를 작성한다면, 여러 고민할 것들이 늘어나고, 코드 복잡도가 증가하고, ... 여러모로 힘들어진다.</p>

<p>이에 대해 가장 좋은 방법은 동기적으로 코드를 작성하되 비동기적으로 수행되는 것이다.</p>

<p>예를 들면 컵라면을 끓이고 햇반을 데워서 먹는다고 하자. 컵라면을 다 끓일 때까지 기다리고, 컵라면이 다 끓은 다음 햇반을 전자레인지에 데우는 것보다는, 컵라면에 물을 붓고 햇반을 전자레인지에 돌리는 것이 시간상 더욱 효율적일 것이다.</p>

<p>즉, 수행 흐름에 대기(blocking)하여 기다려야 할 요소가 있다면 해당 작업에 대한 완료 통지(completion notification)가 올 때까지 수행을 멈추고, 그 시간에 다른 작업이 있다면 그걸 꺼내서 하는거다.</p>

<p>다시 위의 코드로 예시를 들면,</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">async</span> <span class="n">call_result</span> <span class="nf">request_call</span><span class="p">(</span><span class="n">call_context</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sock_write</span><span class="p">(</span><span class="n">socket_</span><span class="p">,</span> <span class="n">ctx</span><span class="p">.</span><span class="n">serialize</span><span class="p">());</span>

    <span class="n">BYTE</span> <span class="n">result_buffer</span><span class="p">[</span><span class="n">RESULT_SIZE</span><span class="p">];</span>
    <span class="n">await</span> <span class="n">sock_read</span><span class="p">(</span><span class="n">socket_</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result_buffer</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">call_result</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="n">result_buffer</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p><code>request_call</code> 함수는 async 함수다. async 함수는 중간에 await을 수행할 수 있는 함수이다. 위 코드에서는 <code>sock_read</code>라는 blocking 작업이 완료될 때까지 await을 한다는 것 외에는 동기적 코드와 다를 것이 없다. 하지만 수행 흐름을 보면 위 코드는 비동기적으로 수행된다.</p>

<p><code>sock_read</code> 함수를 await하게 호출하였으므로 해당 thread는 <code>sock_read</code> 함수에 대해 완료 통지가 올 때까지 해당 수행 흐름을 중단한다. 그리고 다른 수행할 작업이 있는지 찾아보고 수행한다(context switch). 그 작업을 수행하는 도중에 아까 요청한 <code>sock_read</code> 에 대한 완료 통지가 온다면 적절한 타이밍에(scheduling) 아까 멈췄던 실행 흐름부터 이어서 수행을 한다.</p>

<p>즉, 동기적 흐름의 코드 형태를 띄지만 실제로는 비동기적으로 돌아간다는 것이며, 코드 작성의 용이성과 수행의 효율성을 모두 확보한다는 야심찬 방법이다. 실제로 위 문법은 C# 5.0 에서 지원하는 asynchronous programming에 포함되어있다.</p>

<p>다음 글에서는 async와 await가 동작할 수 있는 원리에 대해 간단히 살펴보고, 간단한 job queue와 thread-pool 모델을 사용하여 해당 방식을 흉내내어 보도록 하자.</p>

<h3>참고</h3>

<ul>
<li><a href="http://reedcopsey.com/2010/10/28/c-5-async-part-1-simplifying-asynchrony-that-for-which-we-await">C# 5 Async, Part 1: Simplifying Asynchrony – That for which we await</a></li>
</ul>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">c++11 async, corotuine, io 스터디</h1>
				<p class="page-date">18 Aug 2013</p>
				<p class="page-tags">
						
						
					<code class="tag">async</code>
						
						
						
					<code class="tag">io</code>
						
						
						
					<code class="tag">study</code>
						
						
						
						
				</p>
				<div class="content"><p>오늘 스터디에서 공부한 내용을 간단히 정리해보자.</p>

<h3>async, future</h3>

<ul>
<li><a href="http://en.cppreference.com/w/cpp/thread/future">future, promise</a>는 비동기로 실행되는 수행 결과를 받아오기 위한 개념이다.</li>
<li><a href="http://en.cppreference.com/w/cpp/thread/async"><code>async</code></a>는 내부적으로 <code>promise</code>를 사용하여 결과를 <code>set()</code>할 비동기 작업을 수행시키고, future를 반환한다.</li>
<li><a href="http://en.cppreference.com/w/cpp/thread/packaged_task"><code>packaged_task</code></a>는 비동기 작업을 수행할 수 있는 task 객체를 만들어준다. task 객체로부터 future를 가져올 수 있다.</li>
<li>vs2012 기준으로 내부 구현 분석한 내용: <a href="http://www.slideshare.net/lactrious/synchronizing-concurrent-threads">async, future, promise in c++</a></li>
</ul>

<p>vs2012 쪽 문제인지 <code>std::async</code>를 수행할 때 <code>std::launch</code>enum 값을 주지 않으면 <code>std::launch::any</code>로 수행하게 되는데 이 때 <code>deferred</code>로 수행되면서 <code>future</code>를 통해 값을 가져오게 될 경우 문제가 발생하는 것 같다. 내가 개념을 잘못 이해하고 있는 것인지 모르겠는데 문제가 발생하지 않으려면 <code>std::launch::async</code>로 policy를 주고 실행해야 할 듯</p>

<ul>
<li><a href="http://stackoverflow.com/questions/9389409/vs-11-with-stdfuture-is-this-a-bug">Stackoverflow: VS11 with std::future - is this a bug?</a></li>
</ul>

<h3>spawn</h3>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Cilk">Wiki: Cilk</a></li>
<li>fork/join

<ul>
<li><a href="http://minjang.egloos.com/834885">minjang: 왜 fork, join이라는 이름일까?</a></li>
<li><a href="http://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html">Java: Fork/Join</a></li>
</ul></li>
</ul>

<p>상호 의존관계가 없는 작업 집합을 실행할 때, 작업 구간을 여러 개로 나누고(partitioning), 해당 작업을 수행할 작업자(thread)를 만들어서(spawn/fork) 동시에 작업이 수행되도록 한다. 그리고 모든 작업자의 작업이 완료될 때까지 기다려서(join) 그 결과를 하나로 합친다.</p>

<h3>c# async/await</h3>

<p>비동기 작업을 위해 작업을 수행할 Task를 만든다. 해당 Task가 완료되면 다음 작업을 수행할 수 있도록 Task를 엮는다(Task Continuation)</p>

<ul>
<li><a href="http://msdn.microsoft.com/en-us/library/dd460717.aspx">MSDN: Task Parallel Library</a></li>
</ul>

<p>특정 Task의 결과를 획득할 수 있을 때까지 대기한다. 이 때 할 수 있는 다른 일이 있다면 찾아본다(await). 이는 단순히 compiler가 await하는 코드들을 하나의 state machine으로 묶어서 state를 변화시키면서 해당 함수를 계속 불러주는 방식으로 만들어주는 것이다.</p>

<ul>
<li><a href="http://weblogs.asp.net/dixin/archive/2012/11/02/understanding-c-async-await-1-compilation.aspx">Dixin: Understanding C# async / await Compliation</a></li>
</ul>

<p>실제 코드가 각각 어떤 thread에서 수행될 수 있는지에 대해서는 약간 복잡할 수 있는데 이에 대해서는 다루지 않았다. 요약하면, 비동기 logic을 동기적으로 작성하기 위한 async/await는 결과적으로 state machine code로 compiler에 의해 변환되어 .net thread-pool에 들어갔다 나왔다하면서 코드가 수행된다는 것.</p>

<p>아래와 같이 코드가 작성되면 연결되는 모든 connection에 대해서 결과를 console에 출력해줄 수 있다.</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="k">async</span> <span class="k">void</span> <span class="nf">Listen</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">var</span> <span class="n">serverSocket</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Socket</span><span class="p">(...);</span>
    <span class="n">Socket</span> <span class="n">clientSocket</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">clientSocket</span> <span class="p">=</span> <span class="k">await</span> <span class="n">serverSocket</span><span class="p">.</span><span class="n">AcceptAsync</span><span class="p">())</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
        <span class="n">ProcessSocket</span><span class="p">(</span><span class="n">clientSocket</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">async</span> <span class="k">void</span> <span class="nf">ProcessSocket</span><span class="p">(</span><span class="n">Socket</span> <span class="n">clientSocket</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">string</span> <span class="n">line</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">line</span> <span class="p">=</span> <span class="k">await</span> <span class="n">clientSocket</span><span class="p">.</span><span class="n">ReadLineAsync</span><span class="p">())</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
        <span class="k">await</span> <span class="n">Console</span><span class="p">.</span><span class="n">WriteLineAsync</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>약간 설명을 추가하면,</p>

<ul>
<li><code>serverSocket.AcceptAsync()</code> 함수를 await할 때 Listen StateMachine이 accept completion state를 대기.</li>
<li>accept에 성공한 후 ProcessSocket StateMachine이 read line completion state를 대기.</li>
<li>그런데 Listen StateMachine과 ProcessSocket StateMachine은 await하는 관계가 없으므로 서로 다른 Task가 되어 동시에 <code>Accept</code>도 하고 <code>ReadLine</code>도 할 수 있는 것이다. (즉 작업 흐름 단위가 아니라 Task 단위)</li>
</ul>

<h3>coroutine</h3>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Coroutine">Wiki: Coroutine</a></li>
<li><a href="http://en.wikipedia.org/wiki/Generator_%28computer_science%29">Wiki: Generator</a></li>
<li><a href="http://www.unitystudy.net/bbs/board.php?bo_table=writings&amp;wr_id=43">UnityStudy: Coroutine의 기본 개념 및 활용</a></li>
</ul>

<blockquote>
<p>allow multiple entry points for suspending and resuming execution at certain locations</p>
</blockquote>

<p>정의 자체가 위와 같기 때문에 가장 낮은 수준에서 생각해보면 cpu context를 마음대로 치환할 수 있으면 coroutine을 쉽게 만들 수 있겠다! (user mode context switching)<br>
boost는 boost context를 먼저 만들어서 cpu context를 capture할 수 있게 한 다음 그것을 사용해서 boost coroutine을 만들었다.</p>

<p>그런데 그런 구현 방법 뿐만 아니라 generator를 이용해서 대충 coroutine처럼 사용할 수 있도록 할 수도 있다. c#의 yield return이 그런 형태인데, 이건 그냥 compiler가 해당 코드를 state machine으로 만들어서 다시 부르면 다음 코드부터 이어서 실행될 수 있도록 만들어 주는 것.</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">MyGenerator</span><span class="p">()</span> <span class="p">{</span>
    <span class="cm">/* do something 1 */</span>
    <span class="k">yield</span> <span class="k">return</span> <span class="cm">/* first value */</span><span class="p">;</span>
    <span class="cm">/* do something 2 */</span>
    <span class="k">yield</span> <span class="k">return</span> <span class="cm">/* second value */</span><span class="p">;</span>
    <span class="cm">/* do something 3 */</span>
    <span class="k">yield</span> <span class="k">return</span> <span class="cm">/* third value */</span><span class="p">;</span>
    <span class="cm">/* do something 4 */</span>
    <span class="k">yield</span> <span class="k">return</span> <span class="cm">/* forth value */</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>위와 같이 yield 코드를 작성하면 compiler가 아래와 같이 코드를 만들어준다.</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="k">struct</span> <span class="nc">MyGeneratorStateMachine</span> <span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Current</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">bool</span> <span class="nf">MoveNext</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">_state</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="m">0</span><span class="p">:</span> <span class="cm">/* do something 1 */</span> <span class="n">Current</span> <span class="p">=</span> <span class="cm">/* first value */</span><span class="p">;</span> <span class="n">_state</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span> <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="k">case</span> <span class="m">1</span><span class="p">:</span> <span class="cm">/* do something 2 */</span> <span class="n">Current</span> <span class="p">=</span> <span class="cm">/* second value */</span><span class="p">;</span> <span class="n">_state</span> <span class="p">=</span> <span class="m">2</span><span class="p">;</span> <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="k">case</span> <span class="m">2</span><span class="p">:</span> <span class="cm">/* do something 3 */</span> <span class="n">Current</span> <span class="p">=</span> <span class="cm">/* third value */</span><span class="p">;</span> <span class="n">_state</span> <span class="p">=</span> <span class="m">3</span><span class="p">;</span> <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="k">case</span> <span class="m">3</span><span class="p">:</span> <span class="cm">/* do something 4 */</span> <span class="n">Current</span> <span class="p">=</span> <span class="cm">/* forth value */</span><span class="p">;</span> <span class="n">_state</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span> <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>
<p>그러면 함수 호출자에서는 <code>MyGeneratorStateMachine</code> 객체를 만들어서 <code>MoveNext()</code>가 false일 때까지 불러가며 <code>Current</code> 값을 접근하면 되는 것이다. gb님께서 이야기하셨던 것 중 python의 <code>range</code>, <code>xrange</code>의 차이를 보는 것도 도움이 될 듯. (lazy evaluation)</p>

<p>개인적으로는 user mode context switching 지지자인데 그게 구현되었다면 c#에서도 async/await같은 trick을 쓰지 않고 진정 막장 구현이 가능했을 것이라고 본다...만 .net에서는 지원할 생각이 없는 것 같다.</p>

<h3>io</h3>

<p><code>user -&gt; kernel (kernel + device driver) -&gt; physical -&gt; kernel -&gt; user</code>로 이어지는 장대한 여행</p>

<ul>
<li><a href="http://www.youtube.com/watch?v=PBWhzz_Gn10">Warriors of the Net</a></li>
</ul>

<p>약간 거리가 있지만</p>

<ul>
<li><a href="/2011/08/07/asynchronous-io/">비동기 IO 함수</a></li>
<li><a href="/2011/08/14/io-and-memory-copy/">IO와 메모리 복사</a></li>
</ul>

<p>어쨌든 io는 request 과정과 completion을 처리하는 과정 두 개로 나누어 생각해볼 수 있다. 하나의 io 함수가 두 개를 모두 처리한다면 (보통은) blocking function이 될 것이고, 이 둘을 나누어서 처리한다면 non-blocing function이 될 것이다.</p>

<p>예를 들어 아래와 같은 코드는 blocking function을 사용한 동기적 코드이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">ret</span> <span class="nf">sync_io</span><span class="p">(...)</span> <span class="p">{</span>
    <span class="n">request</span><span class="p">(...);</span>
    <span class="n">wait_for_completion</span><span class="p">(</span><span class="n">infinite</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">result_from_completion</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>아래와 같은 코드는 non-blocking function과 callback을 사용한 비동기적 코드이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">async_io_req_callback</span><span class="p">(...)</span> <span class="p">{</span>
    <span class="n">register_callback</span><span class="p">();</span>
    <span class="n">request</span><span class="p">(...);</span>
<span class="p">}</span>
<span class="n">ret</span> <span class="nf">async_io_callback</span><span class="p">(...)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">result_from_completion</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>아래와 같은 코드는 non-blocking function을 사용하면서 그 completion에 대한 queue롤 통해 명시적으로 그 결과를 처리하는 코드이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">async_io_req_completion_queue</span><span class="p">(...)</span> <span class="p">{</span>
    <span class="n">request</span><span class="p">(...);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">worker_loop</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">var</span> <span class="n">completion</span> <span class="o">=</span> <span class="n">dequeue_completion_from_queue</span><span class="p">();</span>
        <span class="c1">// process completion</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>정리하면,</p>

<ul>
<li>async io 방식은 callback을 등록해서 완료 시 callback이 호출되는 방식과,</li>
<li>io가 완료된 시점에 completion이 어떤 queue에 들어가면, 그 queue로부터 하나씩 직접 꺼내서 처리하는 방법이 있다.</li>
</ul>

<p>callback에 의한 io는 해당 callback이 언제 불러줄지 모른다. 때문에 callback이 불렸을 때 공유 자원을 보호해주는 방법도 좀 까다롭고 코드를 읽기도 쉽지 않다. 하지만 library 제작자 입장에서는 scheduling이 편하다는 장점이 있다.</p>

<p>completion queue를 사용하는 방법(iocp)은 직접 thread-loop를 작성하여 명시적으로 completion을 처리할 수 있다는 점에서 callback보다는 실행 흐름 제어가 조금 편하다(?)는 장점이 있다고 할 수 있다. 그렇지만 코드를 읽는 측면에서는 callback에 비해서 request와 completion의 거리가 더 멀리 떨어지기 때문에 더 좋지 않을 수도 있다.</p>

<h3>reactor &amp; proactor</h3>

<p>async io를 논할 때 reactor와 proactor 개념이 나온다.</p>

<ul>
<li>reactor는 io의 장치가 준비(ready)된 상태를 감지하여 알려주는 것이고,</li>
<li>proactor는 io 요청을 받아서 처리해주고 그 결과(completion)를 비동기로 알려준다는 것이다.</li>
</ul>

<p>대표적으로 epoll()를 써서 reactor를 구현된 모델을 생각해보거나, proactor 패턴으로 구현된 IOCP를 생각해보면 되겠다.</p>

<h3>asio</h3>

<p>asio는 boost library로 async io를 cross-platform으로 사용할 수 있게 해주는 좋은 library이다. 크고 아름다운 ace framework과 비교되어 쓰기 좋다는 평을 받고 있다.</p>

<p>asio는 proactor pattern으로 구현된 것인데, windows에서는 iocp를 쓰니까 그냥 wrapping만 하면 되고, linux에서는 epoll()을 잘 감싸서 proactor pattern을 user mode에서 구현한 것으로 알고 있다. 요약하면 비동기를 요청하고, completion을 callback으로 받아서 처리한다는 것.</p>

<p>asio 코딩을 통해 async request/completion의 개념을 이해하면 좋을 것 같아 넣어봤다. 자세한 내용은 asio document이 워낙 잘 되어 있으니 그 쪽을 보면 좋다.</p>

<ul>
<li><a href="http://www.boost.org/doc/libs/release/doc/html/boost_asio.html">Boost.Asio</a></li>
</ul>

<h3><a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa365198.aspx">IOCP</a>: <del>Windows의 자랑</del></h3>

<p>request와 completion을 분리한 비동기 io 함수와 분리된 두 문맥을 연결해주기 위해 준비되는 overlapped 구조체는 iocp 이전부터 존재했던 windows api이다(apc 포함). 다만 callback이 불리는 시점도 애매하고 흐름이 눈에 잘 띄지 않으니 completion queue를 api로 노출시켜 접근할 수 있게 만들어준 것.</p>

<p>요약하면,</p>

<ol>
<li><em>[user]</em> completion port를 만든다.</li>
<li><em>[user]</em> completion port에 io device handle을 (socket 등) 연결(mapping)한다.</li>
<li><em>[user]</em> 해당 handle에 대해 비동기 io 요청을 한다.</li>
<li><em>[user]</em> thread를 만들어서 completion port에 대기시킨다. (<code>GetQueuedCompletionStatus</code>)</li>
<li><em>[kernel]</em> 해당 io 요청이 완료되면 completion port에 completion을 넣어준다.</li>
<li><em>[user]</em> completion port에 대기 중인 thread 중 하나가 깨어나서 해당 completion을 처리한다.</li>
</ol>

<p>수행 흐름을 명시적으로 관리할 수 있다는 점,
그리고 completion port에 대기 중인 thread를 kernel이 잘 관리하여 적절한 녀석(대충 LIFO 방식)을 깨워서 작업을 시킨다는 점이 iocp의 장점이라 하겠다.</p>

<p>뭐, kernel이 io 작업 다 해주고 user는 completion만 처리하면 되니 다른 일에 집중할 수 있어 더 좋은건 당연한 소리</p>

<h3><a href="http://www.serverframework.com/asynchronousevents/2011/10/windows-8-registered-io-networking-extensions.html">RIO</a></h3>

<p>iocp를 만들고 열심히 profiling을 해보니 3가지 문제가 있댄다.</p>

<ol>
<li>async io 요청할 때 전달되는 memory를 non-paged-pool에 넣기 위해 lock거는 비용</li>
<li><code>GetQueuedCompletionStatus()</code> 함수 등의 api를 부를 때 kernel mode switching 비용</li>
<li>request/completion 마다 device handle에 mapping된 completion port handle을 찾는 비용(handle table lookup)</li>
</ol>

<p>1번의 경우는 zero-byte receive 기법으로 대충 우회가 된다. locked page가 뭔 소리인지는 대충 다음 링크에서 보자. <a href="/2011/08/14/io-and-memory-copy/">IO와 메모리 복사</a></p>

<p>rio는 각 문제를 다음과 같이 해결했다.</p>

<ol>
<li>프로그램 시작 시 미리 buffer를 만들고 lock을 잡아놓고 쓰자. 그러면 그 이후 요청할 때에는 이미 lock된 memory를 쓰니까 매 요청마다 lock을 걸 필요가 없으니 비용문제 해결</li>
<li>request/completion queue를 user mode에 노출시켜 user mode에 존재하는 queue만 보고도 작업이 될 수 있도록 한다. 그런데 user mode로 노출된 queue는 thread-safe하게 보호해주지 않으니 알아서 잘 보호해서 써라. (그런데 이 queue들이 어떻게 kernel 자료구조와 mapping되는지는 아직 잘 모르겠음-_-)</li>
<li>iocp는 device handle로 요청하고 completion port로 completion이 와야하기 때문에 handle lookup이 일어나는데, rio에서는 이걸 미리 queue를 각자 다 따로 만들어서 연결해두기 때문에 handle lookup 과정이 없다는 것</li>
</ol>

<ul>
<li><a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms740642.aspx">MSDN: What&#39;s New for Windows Sockets</a></li>
<li><a href="http://channel9.msdn.com/Events/Build/BUILD2011/SAC-593T">Channel9: New techniques to develop low-latency network apps</a></li>
</ul>

<p>사실 성능에 좀 의문이 있기는 했는데, 이걸로 실험해본 사람이 iocp보다 30~40% 성능 향상을 경험했다고 한다. 좀 미묘한 설계이기는 했는데 나중에 기회가 되면 글 쓰겠음.</p>

<h3>마무리</h3>

<p>병렬성과 비동기는 연관성이 있는 내용이라고 생각했기 때문에 위와 같은 keyword를 던저보았다. 그나마 친숙한 비동기 함수는 비동기 io라서 주제로 잡은 것도 있지만, 다음 주제가 distributed system이니 적어도 network programming은 알아야 한다고 생각해서 밀어붙였던 것도 있다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">다중 입출력에 대한 효율적 처리</h1>
				<p class="page-date">07 Aug 2011</p>
				<p class="page-tags">
						
						
					<code class="tag">async</code>
						
						
						
					<code class="tag">io</code>
						
						
						
						
				</p>
				<div class="content"><p>다중 입출력 함수는 POSIX의 select 함수를 공부하면서 가장 많이 보게 되는 함수이다. 다중 입출력 함수라는 것은 영어로 바꿔보면 multiplex io function인데 말 그대로 여러 개의 io 를 하나의 함수로 처리한다는 것이다.</p>

<p>지난 글의 동기와 비동기에 이어서 여러 개의 io를 어떻게 처리하는 것이 효율적인지 알아보자.
<a href="/2011/08/07/asynchronous-io/">비동기 IO 함수</a></p>

<p>지난 번에 봤던 함수들은 하나의 IO에 대해서만 사용 가능한 함수들이었다.
대표적으로 <code>scanf</code>는 stdin(표준 입력 스트림)으로부터 값을 읽어오도록 되어있고, <code>ReadFile</code>은 열려있는 하나의 File Handle 로부터 값을 읽는다. <code>WSARecv</code> 함수는 연결되어있는 하나의 Socket으로부터 데이터를 읽는다.</p>

<p>만약 채팅방을 만든다고 해보자. 채팅방에는 여러 사람이 접속해서 데이터를 주고 받는다. 따라서 n명의 사람이 연결되어있다면, 채팅 서버는 적어도 n개의 Socket과 데이터를 주고 받아야할 것이다. 어떻게 처리해야 좋을까?</p>

<h3>blocking + multi-threading</h3>

<ul>
<li>각 Socket 마다 처리하는 Thread를 따로 만든다. 왜냐하면 <code>Recv</code> 함수가 blocking이기 때문에, 이걸 단일 thread에서 처리할 경우 하나의 socket에서 데이터가 안 들어오면 다른 socket은 데이터가 들어오건 말건 읽을 수가 없기 때문이다.</li>
</ul>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">recv</span><span class="p">(</span><span class="n">hSocket1</span><span class="p">,</span> <span class="n">lpBuffer</span><span class="p">,</span> <span class="p">...)</span> <span class="c1">// block !</span>
<span class="n">recv</span><span class="p">(</span><span class="n">hSocket2</span><span class="p">,</span> <span class="n">lpBuffer</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">recv</span><span class="p">(</span><span class="n">hSocket3</span><span class="p">,</span> <span class="n">lpBuffer</span><span class="p">,</span> <span class="p">...)</span>
</code></pre></div>
<p>따라서 각각의 Recv 수행은 다른 Recv 에 의해 방해받으면 안되기 때문에 여러 개의 thread 를 사용한다.</p>

<h3>non-blocking + single-threading</h3>

<ul>
<li><code>Recv</code> 함수를 non blocking으로 만든다. 그러면 하나의 thread로도 처리가 가능하다.</li>
</ul>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">socketCount</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nb_recv</span><span class="p">(</span><span class="n">hSocket</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lpBuffer</span><span class="p">,</span> <span class="p">...)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 데이터 처리</span>
</code></pre></div>
<p>동기적으로 처리되지만 함수 수행은 non blocking이다. 코드 작성하기는 편하겠지만 매번 데이터가 있나없나 물어보는게 꽤나 고역이 될 것 같다. 특히 채팅 서버처럼 모든 사람이 대화를 하지 않을 때 아무 일도 하지 않아도 되는 서버라면 계속 입력이 있는지 검사하는 것은 쓸데없는 작업이 될 것이다.<br>
<span style="color: #888;">(그나마 게임 서버는 남는 시간에 AI 를 돌리는 등 로직이라도 수행하는데 말이다)</span></p>

<h3>non-blocking + asynchronous</h3>

<ul>
<li>non blocking에 asynchronous한 <code>Recv</code>를 사용해본다. 로직 작성하기는 어려워지지만 효율은 괜찮아진다.</li>
</ul>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="c1">// 클라이언트 연결을 수락하는 함수</span>
<span class="kt">void</span> <span class="nf">accept_client</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 클라이언트의 연결을 수락함.</span>
    <span class="c1">// 이로써 클라이언트와 통신 가능한 Socket 을 얻을 수 있다.</span>
    <span class="n">HANDLE</span> <span class="n">hSocket</span> <span class="o">=</span> <span class="n">Accept</span> <span class="p">(...);</span>
    <span class="c1">// 연결 수락시 딱 한 번의 Recv 요청을 해둔다.</span>
    <span class="n">async_recv</span><span class="p">(</span><span class="n">hSocket</span><span class="p">,</span> <span class="n">lpBuffer</span><span class="p">,</span> <span class="n">recv_callback</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 클라이언트 데이터를 처리하는 callback</span>
<span class="kt">void</span> <span class="nf">recv_callback</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">lpBuffer</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 받은 데이터 처리 코드 (생략)</span>
    <span class="c1">// 다시 Recv 요청, 이 때 hSocket 객체는 잘 관리해서 접근 가능해야한다.</span>
    <span class="n">async_recv</span><span class="p">(</span><span class="n">hSocket</span><span class="p">,</span> <span class="n">lpBuffer</span><span class="p">,</span> <span class="n">recv_callback</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>실제 thread가 어떻게 돌아가는지 상관 없이 깔끔하게 코드가 작성된다. 물론 비동기적으로 돌아가기 때문에 데이터 처리하는 코드 작성이 좀 더러워진다. 채팅프로그램을 가정할 경우 어떤 클라이언트로부터 받은 데이터를 다른 클라이언트들에게 보내주어야 하므로, 클라이언트 연결 목록이라는 공유 자원이 생긴다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="c1">// 클라이언트 연결을 수락하는 함수</span>
<span class="kt">void</span> <span class="nf">accept_client</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">HANDLE</span> <span class="n">hSocket</span> <span class="o">=</span> <span class="n">Accept</span> <span class="p">(...);</span>
    <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gClients</span><span class="p">);</span>
    <span class="n">gClients</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">hSocket</span><span class="p">);</span>
    <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gClients</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">recv_callback</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">lpBuffer</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 받은 데이터 처리 코드</span>
    <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gClients</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SOCKET</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">gClients</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
        <span class="n">it</span> <span class="o">!=</span> <span class="n">gClients</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">async_send</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">,</span> <span class="n">lpBuffer</span><span class="p">,</span> <span class="p">...);</span>
    <span class="p">}</span>
    <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gClients</span><span class="p">);</span>
</code></pre></div>
<p>따라서 위의 코드를 보면 공유 자원인 <code>gClients</code>란 변수에 접근하기 위해 lock을 걸고 사용하는 것을 알 수 있다. 별로 효율상 좋아보이지 않는데 저 자료구조를 lock free하게 작성하는 것 말고는 딱히 좋은 방법도 떠오르지 않는다. (이 문제는 thread를 쓰던 non blocking io를 쓰던 모두 발생하는 문제다)</p>

<p>아무튼 저렇게 non blocking이면서 asynchronous로 작성할 경우 모든 연결에 대해 thread를 만드는 것보다, 그리고 모든 non blocking 연결에 대해 일일히 확인하는 것보다 효율은 좋을 것이다.<br>
(당연한 이야기이지만 asynchronous 로 작성하는 경우 non blocking 일 수밖에 없다.)</p>

<h3>multiplexing</h3>

<ul>
<li>다중 입출력 함수라고 불리는 select 함수를 사용한다. 이 함수는 여러 Socket에 대해 감시를 수행할 수 있고, 적절히 timeout 값을 지정해서 그 시간동안 IO가 없으면 반환해버리는 구조의 함수이다. 따라서 blocking, non blocking 양 쪽으로 모두 사용할 수 있다.

<ul>
<li><a href="http://kldp.org/node/112275">http://kldp.org/node/112275</a></li>
<li><a href="http://www.joinc.co.kr/modules/moniwiki/wiki.php/Site/Network_Programing/Documents/select">http://www.joinc.co.kr/modules/moniwiki/wiki.php/Site/Network_Programing/Documents/select</a></li>
<li><a href="http://www.joinc.co.kr/modules/moniwiki/wiki.php/man/2/select">http://www.joinc.co.kr/modules/moniwiki/wiki.php/man/2/select</a></li>
</ul></li>
</ul>

<p><code>select</code>는 이 글에서 다루기는 좀 애매하니까 넘어가자. 간략히 설명하면 여러 IO를 동시에 감시하고 그에 대해 통보 받을 수 있다는 것이다. 이는 asynchronous IO 함수를 쓰지 않고, non blocking IO들을 무의미하게 loop 돌면서 검사하지 않아도 어느정도 효율적으로 IO를 관리할 수 있고, 게다가 동기적으로(하나의 scope 내에서) 로직을 작성할 수 있으므로 코드를 작성하기도 편하다.<br>
동기적으로 작성되면 scope에 의해 context(변수 등)가 공유되고 실행 흐름을 파악하기 쉽기 때문에 문제가 발생할 확률이 적기 때문이다. 예를 들어 다음의 코드를 보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">while</span> <span class="p">(</span><span class="n">select</span> <span class="p">(...)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">ACCEPT</span>: <span class="n">clients</span><span class="p">.</span><span class="n">push_back</span> <span class="p">(</span><span class="n">socket</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">RECV</span>:
        <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SOCKET</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">clients</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
            <span class="n">it</span> <span class="o">!=</span> <span class="n">clients</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 모종의 작업</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
</code></pre></div>
<p>의사코드 수준이지만 위의 코드를 보면 accept를 수행하는 부분과 recv를 수행하는 부분이 하나의 흐름이다. 따라서 저 로직에서는 굳이 client들의 socket을 저장하는 자료구조가 전역일 필요도 없고 lock 또한 필요하지 않다. 게다가 파악하기도 힘든 thread수행 흐름에 의한 문제가 발생할 일도 없다.</p>

<h3>어떤 것을 써야 할까?</h3>

<p>IO 요청의 빈번성과 프로그램의 특성에 따라 위 서술한 것들 중 효율적인 것을 골라서 사용하면 된다.</p>

<ul>
<li><p>공유되는 자원이 없고 IO 요청이 드문드문 일어나는 경우, 예를 들면 웹 서버 같은 경우이면 non blocking에 asynchronous IO를 사용하는 것이 효율적일 것이다. 웹 서버는 stateless하니까 각 연결마다 공유되어야하는 자료도 없고, 각 연결이 자주 있지도 않기 때문이다.</p></li>
<li><p>공유되는 자원도 많고 IO 요청도 잦은 경우라면 non blocking에 synchronous IO 모델을 사용하는 것이 효율적일 것이다. logic 코드와 IO 코드를 같은 문맥(context)에서 실행하면서 IO 역시 효율적으로 수행하기 때문이다. 그리고 공유되는 자원도 많기 때문에 asynchronous에 의한 callback 으로 작성하면 코드가 많이 복잡해질 것이고, 처리 순서 보장이 중요하기 때문에 왠만하면 동기적으로 처리하는게 안전하다.</p></li>
</ul>

<p>하지만 이 가정들은 single thread 로 돌아간다고 가정할 때의 이야기이다.</p>

<h3>with multi-thread</h3>

<p>multi thread 를 생각해보자.</p>

<ul>
<li><p>blocking IO를 사용하는 경우는 처음부터 multi thread 모델이었다. 5,000개의 연결이 이루어진다면 thread도 5,000개이다. 그러면 이걸 scheduling하는 CPU는 context switching 부담이 너무 커져서 효율이 좋을리가 없다.</p></li>
<li><p>non blocking IO를 사용하는 경우 thread마다 감시해야하는 socket의 수를 나눈다. 즉 어디선가 load balancing을 해주어야하는데 그 과정 역시 부담이 되고 간단하지가 않다.</p></li>
<li><p>asynchronous IO를 사용하는 경우는 thread고 뭐고 어차피 kernel에서 callback으로 불러주는거니까 해당 프로그램에서 돌고 있는 thread 중 적절한 것을 골라서 호출해 줄 것이다. 따라서 얘는 multi thread든 말든 그닥 직접 제어하는 thread랑 연관이 없어 보인다.</p></li>
<li><p>select를 사용한다고 해도, select 하나가 감시할 수 있는 socket에는 한계가 있고, 게다가 그 개수가 많아지면 select의 처리 속도가 느려지기까지 한다. 역시 얘도 여러 thread에서 처리할 socket을 분리하고, 각 thread가 select로 처리해야한다는 것인데 2번과 동일한 문제가 발생한다.</p></li>
</ul>

<p><span style="color: #888">apache 웹 서버는 내부에서 select로 처리를 하다가 처리량이 많아지면 fork를 수행한다. 리눅스의 fork 자체는 그리 비싼 비용이 아니지만 어쨌든 부담이 있다. 물론 fork해서 process가 많아지기 때문에 전체적으로 apache군이 cpu scheduling 을 받을 확률은 증가하지만, 이 글에서 이야기할 건 아닌 것 같다.</font></p>

<p>발상을 약간 전환해보자.<br>
multi core가 있는 환경에서 어떤 프로그램이 가장 빠르게 수행하기 위한 thread의 개수는 몇 개일까?
물론 반드시 한 프로그램만 수행된다는 보장이 없으므로 단언할 수 없고 수행 결과를 통해 tuning해봐야겠지만, 이상적으로 논한다면 core의 개수 만큼 thread를 갖으면 각 core마다 thread 1개씩 맡아서 수행해주니까 가장 빠를 것이다.</p>

<p>바꿔말하면, 다중 입출력을 수행하기 위해 thread를 여러 개 사용한다고 했을 때 입력 요청이 빈번하든 그렇지 않든 어차피 동시에 처리할 수 있는 thread의 개수는 core(processor)의 개수만큼이라는 것이다.</p>

<p>또한 위의 상황들을 비교해볼 때, 뭔가 IO 요청은 non blocking으로 요청하지만 완료 통지(completion notification)는 동기적(synchronous)으로 받아보고 싶다는 생각을 할 수 있다. 어찌보면 장점만 모으는 것인데, IO 함수가 다른 실행 흐름을 방해하지도 않으면서, 그 결과는 내가 직접 물어보고 처리하니까 처리 문맥도 보존이 되니 코딩하기도 편하다.<br>
그리고 이것들을 처리하는 thread 까지 core 개수에 맞춘다면? 그렇다면 그걸 효율적인 처리라고 할 수 있지 않을까.</p>

<p>그래서 나온게 IOCP(Input Output Completion Port)이다. 사실 얘가 하는 일은 크게 없는데,</p>

<ul>
<li>운영체제 내부에 IO 요청을 쌓는 Queue를 만든다.</li>
<li>운영체제 내부에 IO 완료를 쌓는 Queue를 만든다.</li>
</ul>

<p>정도로 이해하면 편하다.<br>
<span style="color: #888">(Windows Internals 나 Windows via C/C++ 을 보면 더 자세히 설명이 나오지만 이 글에서는 저정도로만 설명해보자. 어차피 IOCP 설명하는 글은 아니다.)</span></p>

<ul>
<li><p>thread를 core개수만큼 만들었다. 그럼 이제 각 thread 는 IO 요청을 하고, 또한 각 요청이 완료되면 그 결과를 처리해야한다. 그리고 그것들은 <strong>순서가 보장되어야 한다</strong>.</p></li>
<li><p>각 thread들이 Send나 Recv등을 요청한다. 즉 IO 요청을 하면 각 요청들이 kernel 내부의 IO 요청 queue에 쌓인다. 그러면 kernel에서는 그 요청들을 하나씩 꺼내서 처리한다. 각 요청을 Queue에다가 넣어주기만 하기 때문에 Send나 Recv를 요청하는 함수는 <strong>즉시 반환된다.(non blocking)</strong>.</p></li>
<li><p>kernel에서 그 요청이 완료되면, 완료되었다고 그것을 완료 queue에 넣는다. 그러면 각 thread는 <code>GetQueuedCompletionStatus</code>라는 함수를 통해 하나씩 꺼내서 확인한다. 그리고 IO 작업 완료를 <strong>직접 확인했으니까</strong> 그에 대한 처리를 진행한다. 이는 asynchronous IO 모델이 callback 함수를 언제 부를지 모르는 것에 비해, 직접 완료된 IO 가 있는지 확인하는 것이기 때문에 synchronous IO 모델이라고 할 수 있는 것이다.</p></li>
</ul>

<p>즉, IO 의 요청은 모두 non blocking으로 진행되고, 각 요청이 완료되었는지를 직접 확인하여 처리하는 thread가 core의 개수만큼 있으므로 효율적으로 IO 를 처리할 수 있다는 것이다.<br>
<span style="color: #888;">(물론 언어 자체에서 thread를 효율적으로 관리해주고 하면 완전 asynchronous하게 동작하는 서버가 더 효율적일 수 있을 것 같다.)</span></p>

<p>IO 프로그래밍을 할 때 요청과 완료 통지를 별개로 생각해보면 효율적 향상점을 찾을 수 있다. 물론 non blocking에 asynchronous한 모델이 더 생각하기도 어렵고 문제없이 작성하기도 어렵다.<br>
예를 들면, 상대와 메세지를 주거니 받거니 해야하는 경우 blocking이라면 주거니 받거니 하는 코드를 한 scope 내에서 작성하면 절차적으로 쓰고, 읽고, 쓰고, ... 순으로 수행이 되겠지만 non blocking이라면 그 요청이 끝날 때까지 기다려야하니 복잡해진다. 그래서 내부적으로 어디까지 받았는지 state로 관리해주던가 하는 부가적인 일을 더 해야하는 것이다.</p>

<h3>마무리</h3>

<p>글 자체에서 IOCP 와 select 에 대해 거의 다루지 않고, 요청과 완료 통지의 분리에 대해서만 급하게 설명하다보니 제대로 그 의도가 전달되었는가 모르겠다. 최근에 봤던 어떤 글에서 IO 함수의 blocking과 non blocking, 그리고 그것을 처리하는 방식의 synchronous, asynchronous에 대해서 혼동하고 있기에 이전 글과 이번 글로 그 개념을 구분하는데 어느 정도 도움이 되었기를 바라면서 썼는데, 쓰다보니 내용이 별로인 것 같다 [...]</p>

<p>빠른 서버를 구성함에 있어 각 서버의 특성상 알맞는 모델을 채택하는 경우가 있으니까 IOCP까지는 공부를 해두면 좋다. 그래야 apache나 다른 웹 서버가 어떤 차이에 의해서 왜 빠른지 이해하는데 도움이 될 수 있다고 생각하기 때문이다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">비동기 IO 함수</h1>
				<p class="page-date">07 Aug 2011</p>
				<p class="page-tags">
						
						
					<code class="tag">async</code>
						
						
						
					<code class="tag">io</code>
						
						
						
						
				</p>
				<div class="content"><p>IO 함수라고 하면 생소하게 느끼는 경우가 많다. IO 함수는 input / output 함수의 줄임말인데 우리가 흔히 봐왔던 함수로는 scanf와 printf가 있겠다. <code>scanf</code>는 keyboard에서 글자를 읽어(input) 오는 것이고, <code>printf</code>는 문자열을 화면으로 출력(print)하는 함수다.<br>
이 뿐만 아니라 <code>fprintf</code>, <code>fscanf</code> 등의 파일 입출력 관련의 함수 역시 io 함수들이고, 파일 관련 Windows API인 <code>ReadFile</code>, <code>WriteFile</code>, 네트워크 통신을 위한 <code>WSARecv</code>, <code>WSASend</code>, 기타 등등 입출력 장치와 통신하기 위한 함수들은 io 함수라고 보면 된다.</p>

<h3>blocking</h3>

<p>IO 함수들은 기본적으로 blocking 모드로 동작하게 되어있다.
blocking 모드는 프로그램의 수행을 멈추는 것으로 간단한 예를 보면 다음과 같다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 테트리스 블럭을 내린다</span>
    <span class="c1">// 벽돌 간 충돌 검사를 한다</span>
    <span class="c1">// 사용자의 키 입력을 받는다.</span>
    <span class="n">scanf</span> <span class="p">(</span><span class="s">&quot;%c&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
    <span class="c1">// 키 입력에 대한 처리를 한다.</span>
</code></pre></div>
<p>혹시나 테트리스를 짜면서 위와 같은 코드를 짜본 경험이 있는 사람들은 금방 이해가 될 것이다. 완벽하다고 생각했던 위 코드는 제대로 동작하지 않는다. 키를 누르고 enter key를 누르기 전까지는 테트리스 블럭이 다음 줄로 내려가지 않기 때문이다.<br>
또한 재밌는 것은, 키를 여러번 누르고 enter key를 눌러 input stream을 flush해주면 블럭이 아까 키 눌렀던만큼 쉬지 않고 한 순간에 움직이는 것을 볼 수 있다.</p>

<p>이렇게 <strong>수행 흐름을 중단시키는 것을 blocking 함수</strong>라고 한다. 학부 때 기초 프로그래밍을 하면서 다루게 되는 io 함수는 <code>scanf</code>나 <code>printf</code>, <code>fscanf</code>나 <code>fprintf</code>인데 여기서 blocking이라는 것을 느낄 만한 것은 <code>scanf</code> 정도이고, 그나마도 당연히 흐름이 멈춰야만 하는 프로그램에서 <code>scanf</code>를 쓰는 것이기 때문에 blocking이라는 개념이 친숙하지 않을 수 있다.</p>

<p>하지만 조금 더 나아가서 게임을 만들어보려한다던가(테트리스 등), 아니면 네트워크 프로그래밍을 하면서 <code>read</code>, <code>send</code> 함수를 쓰려고 하다보면 해당 함수를 호출했을 때 흐름이 막히는 특성으로 인해 당황하는 경우가 있다.<br>
보통은 blocking 함수로 프로그램의 흐름이 멈추게 되어 생각했던대로 동작하지 않는 것을 막기 위해 다른 흐름을 만드는 방법을 시도한다. 즉 multi thread를 사용하는 것이고 몇가지 경우에서 이 시도는 꽤 괜찮아 보인다. 하지만 이 글에서는 비동기 IO 함수라는 것이 어떤 것이고 그게 왜 필요하고, 왜 더 효율적인가를 알아보고자 한다.<br>
(물론 테트리스 게임 등을 만들 때는 대부분 입력을 위한 thread를 따로 만드는 것이 아니라 <code>GetAsyncKeyState</code>와 같은 비동기 API 를 쓰게 된다.)</p>

<h3>scanf 대탐험</h3>

<p>먼저 blocking 함수의 동작 원리에 대해 간단히 살펴보자. 이를 위해 간단한 선행지식 하나가 필요하다. 우리가 쓰고 있는 운영체제라는 물건은 하드웨어의 자원을 관리하고 다른 응용 프로그램이 이를 직접 접근하지 못하게 막고, 쓰고 싶을 때는 운영체제에 요청하면, 본인이 직접 접근해서 일을 처리하고, 그 결과를 응용 프로그램에게 돌려준다는 것이다.</p>

<p>키보드, 네트워크, 하드디스크, 모니터, 마우스 등은 모두 하드웨어이다. 우리가 이러한 기기로부터 정보를 얻거나 출력하려면 당연히 운영체제에게 허락을 받아야한다. 그것을 허용해주기 위해 운영체제가 제공해주는 것이 API인 것이다. 본 문서는 Windows 대상이니까 명확하게 Windows API라고 하자.</p>

<p>이렇게 분리한 이유 중 하나는 응용 프로그램이 하드웨어를 직접 마구 접근하여 시스템에 손상을 가하는 것으로부터 보호하기 위함이다. 운영체제는 여러 개의 프로그램을 동시에 안전하게 돌려줘야할 의무가 있는데, 어떤 악의적인 프로그램이 다른 프로그램을 모두 손상시키거나, 아니면 하드웨어를 독점하면 안되기 때문이다.</p>

<p>CPU 는 한 순간에 하나의 명령만 수행하기 때문에 운영체제의 코드와 응용 프로그램의 코드를 수행하는 시점에는 구분할 수가 없다. 따라서 코드가 메모리에 존재하는 영역(segment) 자체에 레벨을 설정하여 권한을 갖고(privileged) 수행할 수 있는 영역과 그렇지 않은 영역을 구분한다. 운영체제는 응용 프로그램을 실행할 때 그 코드를 권한을 갖지 못한 영역(user)에 올리기 때문에 그 코드는 하드웨어에 직접 접근하지 못하고, 운영체제에게 요청하여 원하는 값을 얻어갈 수 있도록 하는 것이다.</p>

<ul>
<li><a href="http://duartes.org/gustavo/blog/post/cpu-rings-privilege-and-protection">http://duartes.org/gustavo/blog/post/cpu-rings-privilege-and-protection</a></li>
<li><a href="http://en.wikipedia.org/wiki/Privilege_level">http://en.wikipedia.org/wiki/Privilege_level</a></li>
<li><a href="http://en.wikipedia.org/wiki/Ring_(computer_security">http://en.wikipedia.org/wiki/Ring_(computer_security)</a>)</li>
</ul>

<p>또한 이러한 ring level이 변경되기 위해서, 즉 user 영역에서 실행되던 코드가 privileged 영역의 kernel 코드가 실행되도록 권한이 변경되어야 하는데, 그러기 위해서 kernel mode로 진입하는 switch 과정이 일어나야한다. 이 과정이 mode switching 과정인데 이 글에서 자세히 다루기에는 양이 너무 많고, 아무튼 복잡하고 부담이 큰 작업이라는 정도로만 이야기를 해보자.<br>
<span style="color: #888;">이 때문에 io 함수를 작은 버퍼 단위로 자주 호출하는 것이나, 짧은 lock 을 사용하는 시점에 kernel에서 관리해주는 lock 작업인 semaphore를 쓰는 것이 효율이 좋지 않다는 이야기가 나오는 것이다. (자주 mode switching 가 발생하기 때문에 그렇다)</span></p>

<p>길고도 지루한 기반 지식은 다 마련되었다. 이제 <code>scanf</code> 함수가 어떤 방식으로 이루어지는지 간략한 개요를 보자.</p>

<ol>
<li>응용 프로그램은 사용자의 입력을 알고 싶기에 <code>scanf</code> 함수를 호출한다.</li>
<li><code>scanf</code> 함수는 CRT(c runtime) 내의 입력 버퍼(inputstream buffer)에 값이 있는지 확인한다.</li>
<li>입력 값이 없기 때문에 keyboard 버퍼로부터 값을 읽어야겠다. kernel에게 부탁해보자.<br>
<em>이제 kernel 모드로 진입한다. (mode switching)</em></li>
<li>keyboard 버퍼를 확인해본다. 입력이 없다면 프로세스를 재운다(대기시킨다).<br>
응용 프로그램을 wait queue로 빼서 scheduling 대상에서 제외한다.<br>
이 지점에서 응용 프로그램은 그 <strong>수행을 멈추고 blocking이 된다</strong>.</li>
<li>사용자가 keyboard를 쳤다! 일단 kernel 버퍼에 keyboard 버퍼 값을 복사해온다.</li>
<li>사용자의 메모리가 swap out 되었다면 복구해주고, 거기에 kernel 버퍼의 값을 복사해준다.</li>
<li>kernel mode를 벗어난다.<br>
<em>이제 user 모드로 진입한다. (mode switching)</em></li>
<li><code>scanf</code> 함수는 kernel이 반환한 결과를 본다. enter key가 없다!</li>
<li>다시 kernel에게 keyboard 버퍼 값을 읽어달라고 요청한다.<br>
<em>이제 kernel 모드로 진입한다. (mode switching)</em> <strong>그리고 4번부터 반복</strong></li>
<li><code>scanf</code> 함수는 드디어 enter key를 찾게 되었다. 이제 응용 프로그램으로 반환해야겠다.</li>
<li>서식 문자열(formatted string, %c 같은 것)에 맞춰서 입력 버퍼에 있는 값을 반환해준다.</li>
<li>응용 프로그램은 오랜 인고의 시간을 거쳐 <code>scanf</code> 함수 수행을 마치고 다음 줄을 실행한다</li>
</ol>

<p>장황한 <code>scanf</code> 수행 로직이 나왔다. 물론 12번 이후에 또 <code>scanf</code>를 요청하면 입력 버퍼(inputstream)에 데이터가 있으니 바로 수행이 이루어질 것이다.
이 때문에 테트리스를 <code>scanf</code> 기반으로 작성했을 때 키를 여러 번 누르고 enter key를 누르면 모아놨던 동작이 <code>scanf</code>에 의해 개방되면서 여러 움직임이 순식간에 일어나게 되는 것이다.</p>

<p>아무튼 핵심은,
1. 응용 프로그램은 IO 작업을 위해 kernel에게 요청한다
2. kernel은 IO 작업이 완료될 때까지 응용 프로그램의 수행을 중단시킨다 <strong>(blocking)</strong>
3. kernel은 IO 작업이 완료된 후 응용 프로그램을 깨우고(wakeup)
4. 그 결과를 응용 프로그램의 메모리에 복사(copy) 해준다.
5. 그리고 IO 함수를 끝내고 수행 흐름을 응용 프로그램에게 돌려준다 <strong>(완료 통지 completion notification)</strong></p>

<p>4번은 좀 나중에 할 이야기이다. 왜냐하면 IO 의 효율을 이야기할 때 메모리 복사는 빠질 수 없는 주제이기 때문이다. 아무튼 2번과 5번에 대한 이야기를 해보자</p>

<h3>blocking</h3>

<p>kernel 함수는 응용 프로그램의 IO 요청이 있을 때 IO 작업이 완료될 때까지 응용 프로그램의 수행을 중단시킨다. 그리고 IO 작업이 완료되면, 다시 흐름을 재개시킨다.<br>
즉, IO 함수의 완료 통지를 함수의 반환을 통해 하기 때문에 수행 흐름을 멈췄다가 재개하는, blocking 방식을 사용하는 것이다. 왜냐하면 그 방법이 운영체제 입장에서 훨씬 효율적이기 때문이다.</p>

<p>운영체제는 여러 프로그램을 동시에 실행시켜줘야하는 의무가 있다. 프로그램은 작업 성향에 따라서 CPU-bound 작업과 IO-bound 작업으로 나뉘는데, 데이터를 갖고 단순한 계산을 반복하는 작업의 경우 CPU만 소모하는 작업일 것이고, 대화상자와 같은 응용 프로그램은 사용자와의 interaction이 중요하니까 IO-bound 작업이 될 것이다.</p>

<p>후자의 경우 어차피 사용자의 입력이 없으면 더 이상 수행할 게 없으니까 사용자의 입력이 들어올 때까지, 즉 응용 프로그램이 kernel에 입력 받아달라고 요청하면 kernel은 그 입력이 들어올 때까지 해당 응용 프로그램을 재워(sleep)버리는 것이다. 그리고 CPU 소모하는 작업들만 열심히 작업할 수 있게 처리(scheduling) 해주다가 IO 작업 완료가 되면, 그 응용 프로그램을 깨워(wakeup)서 <strong>결과를 통보(함수 반환)해주는 것</strong>이다.</p>

<p>그런데 게임 같은 프로그램 때문에 일이 틀어졌다. 이것들은 IO 작업도 많이 쓰고 CPU도 많이 쓴다. 게다가 IO 개수도 한 두개가 아니다. 네트워크도 쓰고 키보드, 마우스도 쓰고, 화면으로 출력도 하고, 파일도 쓴다.</p>

<p>이런 프로그램일 경우에는 IO 함수 요청했는데 데이터가 없으니까 프로그램 멈추면 안된다. IO가 없으면 없는거고 게임 로직은 계속 수행해야 한다. 1인용 테트리스야 enter key 눌러야만 벽돌이 움직입니다 이러면 실소로 끝나지만, 실시간 MMORPG에서 유저가 행동을 해야만 AI가 동작한다는 것은 말이 되지 않기 때문이다.</p>

<p>이런 이유로 인해서 수행 흐름을 막지 않는 IO 함수가 필요해졌다. 데이터가 들어올 때까지 기다리는 것이 아니라 데이터가 없으면 그냥 -1반환해버리고 함수가 끝나는 것이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 테트리스 블럭을 내린다</span>
    <span class="c1">// 벽돌 간 충돌 검사를 한다</span>
    <span class="c1">// 사용자의 키 입력을 받는다.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nb_scanf</span> <span class="p">(</span><span class="s">&quot;%c&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 키 입력에 대한 처리를 한다.</span>
</code></pre></div>
<p>저 <code>nb_scanf</code> 함수는 마법의 함수이어서 키보드 입력이 없으면 -1을 반환하고, 그렇지 않으면 그 결과값을 key 변수로 돌려받는다. 이와 같이 짜면 테트리스가 우리가 생각했던 대로 돌아간다. 그래서 우리는 <code>scanf</code>를 쓰지 않고 conio.h의 <code>getch</code> 함수를 쓰게 되는 것이다.</p>

<p>그런데 뭔가 찜찜하다. 확실히 non blocking 함수를 쓰면 흐름이 중단되지 않으니까 전체 로직 수행 흐름에 영향을 안 주니까 따로 thread 를 안 써도 좋다. 그런데 그럼 값이 있든 없든 <strong>매번 물어봐야하니까 낭비 아닌가</strong>?</p>

<p>낭비라고 생각할 수 있다. 저 수행 방식은 non-blocking이기는 하지만 비동기(asynchronous)는 아니다. non-blocking으로 돌아가지만 <strong>동기(synchronous)적으로 계속 물어보는 방법</strong>이다. 로직을 처리하는 구문과 IO를 처리하는 흐름이 하나되어 돌아간다. 그렇다면 비동기적으로 돌아가는 것은 어떤 것일까?</p>

<h3>asynchronous</h3>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 테트리스 블럭을 내린다</span>
    <span class="c1">// 벽돌 간 충돌 검사를 한다</span>
    <span class="c1">// 사용자의 키 입력을 받는다.</span>
    <span class="n">async_read</span> <span class="p">(</span><span class="n">stdin</span><span class="p">,</span> <span class="n">async_callback</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">async_callback</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 키 입력에 대한 처리를 한다.</span>
</code></pre></div>
<p><code>async_read</code> 함수는 마법같은 함수로 호출할 당시에는 아무 일도 일어나지 않는다. 하지만 kernel에서 IO 작업이 완료되면 그 통지를 인자로 넘긴 callback 함수를 통해 호출해주는 것이다.</p>

<p>어찌보면 interrupt handler 같은 방식으로 동작한다. 이 때 <code>async_callback</code> 함수는 어떤 흐름에 의해 실행될지 모른다. 단일 thread 프로그램이라면 테트리스 logic을 처리하고 있다가 <strong>중간에 갑자기</strong> <code>async_callback</code> 함수가 수행될 것이고, 여러 thread라면 logic이 수행되면서 <strong>동시에 callback 이 수행</strong>될 수 있을 것이다.</p>

<p>아무튼 저런 복잡한 사정은 무시하더라도 여기에 문제가 있다. 테트리스 logic을 처리하는 while 문의 scope와 키보드의 입력을 처리하는 <code>async_callback</code> 함수는 완전히 <strong>다른 scope</strong>이다. 따라서 변수를 공유해주기 위해 전역변수를 써야한다든가 하는 여러가지 귀찮은 문제가 발생하게 된다.</p>

<p>더 큰 문제가 있다. 저 while 문에서 <code>async_read</code>가 지속적으로 호출되는데, 정녕 이것은 괜찮단 말인가? 그렇지 않다!<br>
운영체제는 <code>async_read</code> 작업 요청을 자신의 작업 queue 같은 곳에 착실히 쌓아놨다가 나중에 더 이상 <code>async_read</code>를 요청하지 않아도 키보드 입력이 들어오면 <strong>아까 요청한 작업이 남아서 계속 callback 이 호출</strong>될 수 있겠다. 즉, gameover 가 떴는데 아직 처리되지 않은 키보드 입력이 계속 처리될 수 있다는 것이다.</p>

<p>더 무서운 이야기는, thread scheduling은 우리가 직접 제어하는게 아니라서 문제가 발생할 수 있다는 것이다. 사용자가 키 입력을 했다(KEY1), 그리고 또 입력을 했다(KEY2). 이 둘은 순서에 의해(order) IO 완료 통지가 날아온다. 즉 callback 함수는 KEY1, KEY2 순으로 호출이 된다.<br>
그런데 문제는 KEY1 의 callback 과 KEY2 의 callback이 <em>다른 thread에서 수행되어버린다면</em>(전자를 Thread 1, 후자를 Thread 2라고 해보자) 분명 Thread 1이 KEY1에 대한 callback을 먼저 수행하기 시작했는데, 운 나쁘게도 자신의 시간을 모두 소모(time out)해버리고 다른 thread가 수행되도록 switching 이 되어버린 것이다. 이 때다 싶은 Thread 2는 자신이 Thread 1보다 늦게 KEY 2의 callback이 호출되었음에도 불구하고 Thread 1이 잠든 틈을 타서 자신이 먼저 수행을 끝낼 수도 있다는 것이다.</p>

<p>이러한 <strong>순서 문제(out of order)</strong>에 의해서 문제가 크게 발생할 수 있다. 나는 분명히 왼쪽 키(KEY1)를 누른 다음에 회전 키(KEY2)를 눌렀는데, 이게 위의 문제에 의해서 회전 키(KEY2)가 먼저 동작하고 왼쪽 키(KEY1) 이 나중에 동작해버리면 사용자는 당황할 것이다.</p>

<h3>순서 문제</h3>

<p>내용이 너무 길다. 잠깐 정리해보자.<br>
동기화된 프로그래밍은 로직을 작성하기 쉽지만 매번 물어보는 부담이 있기 때문에 효율을 위해 blocking을 사용한다. 경우에 따라 non blocking 함수를 사용해야할 경우에 그 부담을 해소하기 위해 비동기 IO 함수를 사용한다.<br>
비동기 IO 함수는 다 좋은데 여러번 호출할 경우 완료 통지 후 처리의 순서 보장이 안될 가능성이 있다. 이를 해결하기 위한 가장 좋은 방법은 무엇일까?</p>

<p>네트워크의 경우 주고받는 데이터 자체에 모종의 정보를 기록해서 순서를 맞춰주는 방법이 있는데 이건 너무 복잡하다. 대충 쉬운 방법은 바로 <strong>하나의 callback 요청이 끝난 다음에 다음 async IO 요청을 한다</strong>인 것이다. 다음과 같다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isIOCompletion</span><span class="p">)</span>
        <span class="n">async_read</span> <span class="p">(</span><span class="n">stdin</span><span class="p">,</span> <span class="n">async_callback</span><span class="p">);</span>
    <span class="c1">// 생략</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">async_callback</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">isIOCompletion</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="c1">// 생략</span>
    <span class="n">isIOCompletion</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>좋은 방법인 것 같다. 그런데 flag를 사용할 경우 발생하는 문제가 있다. 여러 thread에서 저 flag 값이 바로 반영되지 않아서 생길 수 있는 문제인데 이에 대해서는 다음의 글을 보자. <a href="/2011/08/02/volatile-interlocked-operation/">volatile-interlocked-operation</a></p>

<p>보다 좋은 방법은 없을까?</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">async_read</span> <span class="p">(</span><span class="n">stdin</span><span class="p">,</span> <span class="n">async_callback</span><span class="p">);</span>
<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 로직 처리</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">async_callback</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 생략</span>
    <span class="n">async_read</span> <span class="p">(</span><span class="n">stdin</span><span class="p">,</span> <span class="n">async_callback</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>명쾌하다! 처음에 딱 한번 read 요청을 한다. 그러면 keyboard 입력이 들어오면 <code>async_callback</code> 함수가 수행될 것이다. 그리고 그 함수의 모든 수행이 끝나면 다시 <code>async_read</code> 함수를 통해 다음 입력을 읽어올 수 있도록 요청하는 것이다.</p>

<p>이러한 방법을 통해 비동기적 IO 요청에 대해 순서 보장을 고려해줄 수 있다.</p>

<h3>마무리</h3>

<p>다시 요약해보자.<br>
IO의 효율을 위해 비동기 IO를 사용했다. 그 이유는 흐름이 막히는(blocking) 것을 방지하기 위함이고, 또 무의미하게 IO 완료 여부를 확인(non-blocking 에서 무한 루프를 통한 질의)를 막기 위함이다.</p>

<p>하지만 효율적으로 동작하기는 해도, 비동기적으로 처리하는 것은 callback 함수가 언제 호출되어야할지 모르기 때문에 여전히 로직 작성에 어려움이 있다. callback이 수행되는 thread에서 lock을 사용할 경우 dead lock에도 주의를 해주어야하고, 선행 수행 의존성이라도 있으면 이걸 제어하기 위해 엄청난 흐름 제어용 lock을 사용해야하기 때문이다.</p>

<p>그리고 결정적으로 하나의 IO가 아닌 여러 IO를 감시해야할 때 비동기 IO가 얼마나 더 효용성이 있는지에 대한 언급이 이 글에는 없다. 오로지 테트리스를 예제로 동기 IO와 비동기 IO에 대해서 비교를 하는 글이니까.</p>

<p>따라서 다음 글에서는 그 방향대로 이야기를 진행해볼까 한다.
비동기 IO의 문제점을 어떻게 해결하고, 효율적으로 여러 IO를 어떻게 처리할 수 있는지에 대해서 말이다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">비동기 프로그래밍 패턴 1</h1>
				<p class="page-date">09 Oct 2013</p>
				<p class="page-tags">
						
						
					<code class="tag">async</code>
						
						
						
					<code class="tag">design</code>
						
						
						
						
				</p>
				<div class="content"><p>일련의 순서로 호출되어야 하는 비동기 함수들이 있다. 이 때 사용되는 method chaining을 사용한 async/then 패턴과 수행할 비동기 context를 갖고 직접 비동기 수행을 연쇄적으로 진행하는 async_worker 패턴을 알아보자.</p>

<p>연속적인 비동기 작업을 처리할 때에는 동기적 프로그래밍과는 다르게 코드를 순차적으로 서술할 수 없다. 만약 아래와 같이 작성된다면, <code>async_work2</code>나 <code>async_work3</code>는 그 위의 <code>async_work1</code> 혹은 <code>async_work2</code>가 완료되기 전에 시작될 것이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">async_work1</span><span class="p">();</span>
<span class="n">async_work2</span><span class="p">();</span>
<span class="n">async_work3</span><span class="p">();</span>
</code></pre></div>
<p>간단하게 생각해볼 수 있는 방법은 하나의 작업이 끝난 후에 다음 작업을 호출하도록 하는 것이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">entry_point</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">async_work1</span><span class="p">();</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">async_work1</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// do something</span>
    <span class="n">async_work2</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>그런데 만약 <code>async_work1</code>이 끝난 후 <code>async_work2</code>가 아니라 다른 <em>일반적인 작업</em>을 수행하게 하고 싶을 경우에는 위와 같이 구현할 수 없다. 그래서 선택하는 방법이 callback이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">entry_point</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">async_work1</span><span class="p">(</span><span class="n">async_work2</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">async_work1</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">callback</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// do something</span>
    <span class="n">callback</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>위와 같이 코드를 작성하는 것은 꽤 타당해 보인다. 하지만 처음 문제로 돌아가서 1, 2, 3을 순서대로 실행하려면 코드가 좀 복잡해진다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">async_work1</span><span class="p">([]</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">async_work2</span><span class="p">([]</span> <span class="p">()</span> <span class="p">{</span>
        <span class="n">async_work3</span><span class="p">(</span><span class="n">callback_none</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">});</span>
</code></pre></div>
<p>즉 연쇄적인 작업을 수행하기 위해 callback에 callback을 넣는 형태로 코드를 작성하게 된다는 것이다.</p>

<ul>
<li>nodejs 계열에서 코드를 작성할 때에 위와 같이 작성하는 경향이 있다. nodejs는 비동기 io 기반이므로 간단한 서버 프로그래밍을 해도 중첩 callback에 의해 금새 tab depth가 깊어지는 것을 볼 수 있다.</li>
<li><a href="http://blog.fegs.kr/" title="blog.fegs.kr">angdev</a>님의 글을 보면 이를 해결하기 위한 라이브러리가 존재함을 볼 수 있다. 그 라이브러리는 아래 소개할 async/then 패턴을 nodejs에 적용한 것이라 볼 수 있겠다.</li>
</ul>

<p>async/then 패턴은 task continuation을 생각하면 좋다. 비동기 작업을 추상화한 객체가 있고, 그 객체의 method chaining으로 이후 할 작업을 연결하는 형태이다.</p>

<ul>
<li><a href="http://msdn.microsoft.com/en-us/library/vstudio/ee372288.aspx">MSDN: Continuation Tasks</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3558.pdf">A Standardized Representation of Asynchronous Operations</a></li>
</ul>

<p>즉 asynchronous하게 호출된 작업 뒤에 할 일을 이어서 붙이는 것이다.</p>

<ul>
<li><strong>c#</strong>의 경우 비동기 요청을 할 경우 <code>Task</code> 객체를 반환하는데, <code>Task</code>의 method인 <code>ContinueWith()</code>으로 다음 할 일을 잇는 형태이다.</li>
<li><strong>c++</strong>의 경우 (표준이 의도한 바에 따르면) <code>std::async()</code>을 통해 비동기 요청을 수행하는데 이 때의 반환값은 <code>std::future</code>이다. 따라서 <code>future</code>에 <code>then()</code> method를 통해 다음 할 비동기 작업을 잇는다는 것이다.</li>
</ul>

<p><a href="http://doodoori2.tistory.com/" title="Doodoori2&#39;s Blog">doodoori2</a>님께서 질문해준 것과 같이 <code>async()</code>로 시작된 작업에 대해 <code>then()</code>으로 이어서 할 작업을 추가해줄 때 동시성 문제가 발생할 수 있기 때문에 이를 적절히 잘 제어해주는 것도 중요하다.
<code>async()</code>로 시작된 작업에 <code>then()</code>을 추가할 때, 다음의 상태 중 하나일 수 있다.</p>

<ol>
<li>다른 thread에 의해 작업이 시작된 상태</li>
<li>작업이 완료된 상태</li>
<li>작업이 취소된 상태</li>
</ol>

<ul>
<li>2번(완료)일 경우 이미 완료되었으니 동시성 문제가 발생하지 않는다. <code>then()</code>을 연결하는 순간 그 callback을 실행해도 되고, 아니면 그 작업을 threadpool에 던져서 아무 thread나 수행(async)하게 만들어도 된다.</li>
<li>3번(취소)일 경우 <code>then()</code>을 연결하는 순간 예외를 발생시키는 등 추가할 수 없다고 적절히 알려주면 되겠다.</li>
<li>1번(진행)일 경우 동시성 문제가 발생할 수 있다. 간단히 then() 코드를 생각해보자.</li>
</ul>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">then</span><span class="p">(</span><span class="kt">function_t</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">execute</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// execute something</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_next</span> <span class="o">!=</span> <span class="n">nullptr</span><span class="p">)</span> <span class="n">_next</span><span class="p">(</span><span class="n">_result</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>문제가 발생할 수 있는 부분은 _next를 대입하는 곳과 _next를 호출하는 부분이다. 이 부분만 lock으로 잘 감싸서 동시성 문제를 해결하면 되겠다. 아래 링크의 자료를 보면 vs2012 기준 future는 내부에 StateManger라는 객체가 lock으로 보호하는 구조로 작성되어 있다. 같은 방법으로 <code>then()</code>으로 연결할 함수도 보호해줄 수 있을 것이다.<br>
<a href="http://www.slideshare.net/lactrious/synchronizing-concurrent-threads">async, future, promise in c++</a></p>

<p>async/then 패턴은 stateless한 일련의 비동기 작업을 서술할 때 편하다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">req_async</span><span class="p">(</span><span class="n">case1</span><span class="p">).</span><span class="n">then</span><span class="p">(</span><span class="n">case1_1</span><span class="p">).</span><span class="n">then</span><span class="p">(</span><span class="n">case1_2</span><span class="p">);</span>
<span class="n">req_async</span><span class="p">(</span><span class="n">case2</span><span class="p">).</span><span class="n">then</span><span class="p">(</span><span class="n">case2_1</span><span class="p">);</span>
<span class="n">req_async</span><span class="p">(</span><span class="n">case3</span><span class="p">).</span><span class="n">then</span><span class="p">(</span><span class="n">case3_1</span><span class="p">).</span><span class="n">then</span><span class="p">(</span><span class="n">case3_2</span><span class="p">).</span><span class="n">then</span><span class="p">(</span><span class="n">case3_3</span><span class="p">);</span>
</code></pre></div>
<p><code>req_async()</code>에 의해 비동기로 수행되는 작업(task)들은 내부의 task-scheduler에 의해 적절한 thread를 할당받아 작업이 동시에 처리될 것이다(task-parallelism)</p>

<p>만약 각 case에서 수행되는 작업들이 io-boundary 등의 system 작업들이라면 위 코드는 단일 thread에서도 동작할 수 있다. thread 하나가 모든 <code>req_async</code> 작업을 요청한 후 각각의 completion을 대기한 후 <code>case*_1</code> 함수를 이어서 불러주면 되기 때문이다(nginx 등)</p>

<p>위 이야기에 이어, async 작업과 then 작업 간의 상태 공유에 대해서 알아보자.<br>
<code>async</code>에서 <code>then</code>으로 상태를 전달하는 가장 기본적인 방법은 <em>반환값</em>을 사용하는 방법이다. 다른 방법으로는 lambda function에 의한 variable capture가 있겠다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">비동기 프로그래밍 패턴 2</h1>
				<p class="page-date">19 Nov 2013</p>
				<p class="page-tags">
						
						
					<code class="tag">async</code>
						
						
						
					<code class="tag">design</code>
						
						
						
						
				</p>
				<div class="content"><p>위 이야기에 이어, async 작업과 then 작업 간의 상태 공유에 대해서 알아보자.<br>
async에서 then으로 상태를 전달하는 가장 기본적인 방법은 반환값을 사용하는 방법이다. 다른 방법으로는 lambda function에 의한 variable capture가 있겠다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="c1">// method 1: using return value</span>
<span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">([]</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">})</span>
    <span class="p">.</span><span class="n">then</span><span class="p">([]</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">f</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">})</span>
    <span class="p">.</span><span class="n">then</span><span class="p">([]</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">f</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">});</span>

<span class="c1">// method 2: using variable capture by lambda function</span>
<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">([</span><span class="o">&amp;</span><span class="n">result</span><span class="p">]</span> <span class="p">()</span> <span class="p">{</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">})</span>
    <span class="p">.</span><span class="n">then</span><span class="p">([]</span> <span class="p">()</span> <span class="p">{</span> <span class="o">++</span><span class="n">result</span><span class="p">;</span> <span class="p">})</span>
    <span class="p">.</span><span class="n">then</span><span class="p">([]</span> <span class="p">()</span> <span class="p">{</span> <span class="o">++</span><span class="n">result</span><span class="p">;</span> <span class="p">});</span>
</code></pre></div>
<p>반환 값으로 모든 context를 전달하는 것에는 한계가 있기 때문에 capture를 통한 방법이 더 편할 수 있다.</p>

<p>하지만 capture되는 변수라는 것도 결국 접근 가능한 scope 내에 있을 때 컴파일러가 해줄 수 있는 것이기 때문에 요청해야 할 비동기 작업들이 여러 함수에 걸쳐서 분포할 경우에는 위 방법으로 구현하기도 간단하지는 않다. 따라서 직접 context와 수행할 작업을 묶어 <code>async_worker</code> class를 구현하는 경우도 있다.</p>

<p>async_worker는 대충 context + async_work라고 생각하면 된다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">my_async_worker</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// async works</span>
    <span class="kt">void</span> <span class="n">work1</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">work2</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">work3</span><span class="p">();</span>
<span class="nl">private:</span>
    <span class="c1">// contexts</span>
    <span class="kt">int</span> <span class="n">_context1</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">_context2</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>즉 수행할 작업을 모두 멤버 함수로 넣고, 필요한 정보를 멤버 변수로 넣는다. 그리고 객체를 생성하고, 각 작업들을 비동기로 수행하고, 모두 완료되면 객체를 메모리에서 해제한다.</p>

<p>async_worker 개념은 단순하고 직관적이다. 마치 functor를 만들기 위해 struct를 하나 만들고 <code>operator ()</code>를 구현하는 것과 비슷하다. 그리고 struct functor를 lambda function으로 바꾸듯, 대부분의 경우 async_worker는 async/then 패턴으로 코드를 정리할 수 있을 것이다.</p>

<p>약간의? 차이가 있다면</p>

<ul>
<li>async는 그 자체가 오래 걸리는 작업인 경우가 많은데,</li>
<li>async_worker의 <code>work()</code> 함수들은 다른 비동기 작업의 완료(completion)에 의해 callback으로 불리는 경우도 있고,</li>
<li>각기 다른 <a href="/2011/08/11/synchronize-function-execution-in-each-object/">객체의 수행 흐름</a>에서 불리는 경우도 있다.</li>
</ul>

<p>async_worker 패턴은 stackless coroutine 구현으로도 사용될 수 있다. stackless coroutine은 stack을 갖지 않는 coroutine으로 c#의 async/await을 생각하면 된다. 즉 instruction pointer와 stack pointer를 치환하는 방식의 coroutine이 아닌 compiler의 code generation을 통해 multiple entry/return을 구현하는 방식이라고 생각하면 되겠다.<br>
(자세한 이야기는 coroutine 이야기에서 다루도록 하겠다)</p>

<p>쉬운 접근을 위해 <code>my_async_worker</code> 코드를 다음과 같이 고쳐보도록 하겠다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">my_async_worker</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">execute</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_state</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">work1</span><span class="p">();</span> <span class="n">_state</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_state</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="n">work2</span><span class="p">();</span> <span class="n">_state</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_state</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="n">work3</span><span class="p">();</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">_state</span><span class="p">;</span>
    <span class="c1">// functions</span>
    <span class="c1">// contexts</span>
</code></pre></div>
<p>비동기 함수의 context와 function을 private으로 갖고, execute() 함수만 노출되어 있다. 그리고 <code>execute()</code> 함수가 불릴 때마다 state가 전이되어 차례로 work1, 2, 3이 호출될 수 있도록 해준다.</p>

<ul>
<li>즉 <code>my_async_worker::execute()</code>를 처음 불러서 <code>work1()</code> 작업을 수행한다.</li>
<li>그리고 <code>work1()</code> 작업에 대한 completion이 도착하면 다시 <code>execute()</code>를 불러서 <code>work2()</code> 작업을 수행한다.</li>
<li>그리고 <code>work2()</code> 작업에 대한 completion이 도착하면 다시 <code>execute()</code>를 불러서 <code>work3()</code> 작업을 수행한다.</li>
<li>이 때 <code>execute()</code>는 return을 반환하므로 더 이상 수행할 작업이 없는 것이다. 따라서 <code>my_async_worker</code> 객체를 메모리에서 제거한다.</li>
</ul>

<p>위와 같은 state machine은 기계적으로 생성이 가능하기 때문에 compiler에서 위와 같은 방법을 사용하여 구현한 c#의 async/await이 있는가 하면 <a href="http://www.chiark.greenend.org.uk/%7Esgtatham/coroutines.html">c에서는 macro으로 구현한 것</a>도 있다.</p>

<p>async를 통해 비동기 작업을 시작한 후 then으로 이어할 작업을 설정하는 async/then 패턴과, 수행할 비동기 작업과 context를 묶어서 하나의 객체로 구성하는 async_worker 패턴을 간단히 알아보았다.</p>

<p>각자의 기본 개념을 적절히 이해하여 각 상황에 맞게 적절히 사용하면 되겠다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1><a id="c" href="#c">c</a></h1>
				<hr />
				<div class="page-breaker"></div>
							
						
				<h1 class="page-title">닫힌 descriptor와 write, SIGPIPE</h1>
				<p class="page-date">08 Jan 2011</p>
				<p class="page-tags">
						
						
					<code class="tag">c</code>
						
						
						
					<code class="tag">io</code>
						
						
						
						
				</p>
				<div class="content"><p>예전에도 엄청 고생했던 것인데, <code>socket</code>이나 pipe 등에서
<code>read</code>와 <code>write</code>로 IO를 수행할 때 상대쪽(opposite endpoint)이 닫혔다면 어떤 현상이 벌어질까?</p>

<ul>
<li><code>read</code>는 -1을 반환한다</li>
<li><code>write</code>는 SIGPIPE를 받는다.</li>
</ul>

<p>하지만 프로그램이 <code>signal handler</code>를 만들지 않았다면 그 프로그램은 죽는다.<br>
SIGTERM이나 SIGQUIT를 받은게 아니기 때문에 <strong>조용히 죽는다.</strong></p>

<p><code>send</code>/<code>recv</code>를 사용해서 옵션을 주면 깔끔하게 <code>EPIPE</code>를 반환하게 할 수 있는데 <code>write</code>, <code>read</code>는 그런 옵션이 생략된 <em>범용적</em> 함수라서 <code>signal handler</code>를 설치하는 수 밖에 없다.</p>

<p>stackoverflow에 나와있는 <a href="http://stackoverflow.com/questions/108183/how-to-prevent-sigpipes-or-handle-them-properly">how to prevent sigpipes or handle them properly</a>를 보면</p>
<div class="highlight"><pre><code class="c language-c" data-lang="c"><span class="kt">int</span> <span class="n">set</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">setsockopt</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_NOSIGPIPE</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">set</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</code></pre></div>
<p>와 같이 해결가능하다고 하는데 범용적이지는 않다.</p>

<p>그래서 결국 <code>sigaction</code>으로 handler 설치해주고 작업을 해야하는데
단, signal 함수를 써서 handler를 지정했다가는 <strong>os에 따라서 한번밖에 handler가 설정 안되는 경우가 있으므로 주의</strong>가 필요하다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">당연하지만 간과하는 size_t ssize_t</h1>
				<p class="page-date">08 Jan 2011</p>
				<p class="page-tags">
						
						
					<code class="tag">c</code>
						
						
						
						
				</p>
				<div class="content"><p>IO 함수를 사용함에 있어서 그 근간이 되는 것은 <code>read</code>와 <code>write</code> 함수이다.<br>
이 함수는 모두 <code>ssize_t</code>를 반환하는데, 보통은 너무나 축복받은 환경에 있기 때문에 저게 왜 <code>ssize_t</code> 인지 모르는 경우가 많다.</p>

<p><code>size_t</code>는 size를 나타내기 위한 type으로 보통의 32bit machine에서는 32bit, 즉 <code>unsigned int</code>로 되어있다. 가장 유명한 <code>sizeof</code>라는 연산자가 반환하는 값을 담기 위한 type으로 보면 되는데 이 역시 크기를 의미하므로 많은 IO 함수에서 사용된다.</p>

<p><code>ssize_t</code>는 <code>signed size type</code>으로 보통의 32bit machine에서는 간단히 말해 <code>int</code>다. IO 함수의 반환값으로 많이 사용되는데 그 이유는 <strong>해당 IO 함수의 실패를 알려주기 위해서</strong>이다.</p>

<p><code>errno</code>라는 개념은 표준 C 함수 수행도중 오류가 발생했을 때 그 함수는 -1을 반환하고 errno라는 전역변수에 어떤 에러가 발생했는지에 대한 값을 넣는 구조의 개념이다.<br>
그래서 주로 <code>perror</code>를 통해 이 <code>errno</code>이 의미하는 문자열을 보는데, <code>read</code>나 <code>write</code> 함수는 실패할 경우에 -1을 반환해야하기 때문에 <code>ssize_t</code>를 반환 type으로 쓰는 것이다.</p>

<p>간단히 네트워크 환경으로 예를 들어보면, 내가 읽으려는 <code>socket</code>이 닫히면 <code>read</code>는 -1을 반환한다.
동일한 개념으로 <code>write</code> 역시 쓰고자 하는 <code>socket</code>이 닫히면 -1을 반환하는 것이다.
이렇게 <code>socket</code>의 닫힘을 깨닫고 해당 socket 관련 작업 내역(context)을 제거해주어야 하는데 보통은 안 그런다.</p>

<p>어차피 학교에서 짜는 정도이면 네트워크가 그리 끊어질 일도 없고(wired network에 전원 걱정 없는 server이니) 프로그램을 껐다 켜기 쉬우니까.</p>

<p>그래서 연구실 아르바이트할 때 작성했던 io 함수들이 <code>size_t</code>를 반환하도록 설계되어있다. (내가 그랬다 ㅠㅠ)</p>

<p>이게 buffered stream이면 문제가 복잡해진다. <code>read</code>는 불가능해도 내부 buffer에 남아있는 것에서 자료를 뺄 수는 있으니까. <code>write</code> 역시 내부의 자료를 보존해줄지 초기화해줄지를 고민해야하지만 Java의 Exception 에 익숙해져있다보니 막상 c로 설계를 할 때는 그런걸 고민을 하나도 안해버렸다 [......]</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">프로그램 세그먼트</h1>
				<p class="page-date">21 May 2011</p>
				<p class="page-tags">
						
						
					<code class="tag">c</code>
						
						
						
					<code class="tag">memory</code>
						
						
						
						
				</p>
				<div class="content"><p>(리눅스 커널의 이해 개정 3판 810쪽)<br>
유닉스 프로그램의 선형 주소 공간은 논리적인 관점으로 볼 때 몇 개의 선형 주소 구간으로 나뉘어있다</p>

<ul>
<li><strong>텍스트 세그먼트</strong>는 실행 코드를 포함하고,</li>
<li><strong>초기화된 데이터 세그먼트</strong>는 초기화된 데이터, 즉 <a href="http://en.wikipedia.org/wiki/Static_variable">정적 변수(static variable)</a>와 <a href="http://en.wikipedia.org/wiki/Global_variable">전역 변수(global variable)</a>의 초기 값이 지정된 경우 그 값 자체가 실행 파일에 저장되어 포함되고,</li>
<li><strong>초기화되지 않은 데이터 세그먼트</strong>는 초기화되지 않은 데이터, 즉 초기값을 지정하지 않은 모든 전역 변수를 포함하고,</li>
<li><strong>스택 세그먼트</strong>는 반환주소, 매개변수, 실행하는 함수의 지역 변수 등을 담은 프로그램 스택을 포함한다.</li>
</ul>

<p>이에 대해 linux에서는 memory descriptor (mm_struct 구조체)에서 관리를 하는데,<br>
이번에 면접을 볼 때, 지나가는 형식으로 해당 문제가 나왔다.</p>

<ul>
<li>함수 내 static 변수와, 전역(global) 변수가 같은 메모리 공간에 할당되는가?<br>

<ul>
<li>내 대답은 <em>그럴 것 같군요</em> 이었고,</li>
<li>문제를 내신 분께서는 <em>사실은 그렇지 않다</em> 라고 답변을 주셨다.</li>
<li><em>(물론 나중에 확인해보니 내가 문제를 잘못 이해한 것이었다)</em></li>
</ul></li>
</ul>

<p>그래서 그냥 그러려니 하다가, 마침 잠도 깼고 할 일도 없어서 ULK를 보다가 이상함을 느끼고 직접 실험을 해봤다.</p>
<div class="highlight"><pre><code class="c language-c" data-lang="c"><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="cp">#define PRINT_ADDR_AND_VALUE(var_name) \</span>
<span class="cp">  printf (&quot;%40s (%16p -&gt; %d)\n&quot;, #var_name, &amp;var_name, var_name)</span>

<span class="kt">int</span> <span class="n">_global_not_initialized</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">_global</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">_global_static_not_initialized</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">_global_static</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">function</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">_static_in_function_not_initialized</span><span class="p">;</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">_static_in_function</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">_local_in_function_not_initialized</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">_local_in_function</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

  <span class="n">PRINT_ADDR_AND_VALUE</span> <span class="p">(</span><span class="n">_static_in_function_not_initialized</span><span class="p">);</span>
  <span class="n">PRINT_ADDR_AND_VALUE</span> <span class="p">(</span><span class="n">_static_in_function</span><span class="p">);</span>
  <span class="n">PRINT_ADDR_AND_VALUE</span> <span class="p">(</span><span class="n">_local_in_function_not_initialized</span><span class="p">);</span>
  <span class="n">PRINT_ADDR_AND_VALUE</span> <span class="p">(</span><span class="n">_local_in_function</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">_static_in_main_not_initialized</span><span class="p">;</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">_static_in_main</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">_local_in_main_not_initialized</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">_local_in_main</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

  <span class="n">PRINT_ADDR_AND_VALUE</span> <span class="p">(</span><span class="n">_global_static_not_initialized</span><span class="p">);</span>
  <span class="n">PRINT_ADDR_AND_VALUE</span> <span class="p">(</span><span class="n">_global_static</span><span class="p">);</span>
  <span class="n">PRINT_ADDR_AND_VALUE</span> <span class="p">(</span><span class="n">_global_not_initialized</span><span class="p">);</span>
  <span class="n">PRINT_ADDR_AND_VALUE</span> <span class="p">(</span><span class="n">_global</span><span class="p">);</span>

  <span class="n">PRINT_ADDR_AND_VALUE</span> <span class="p">(</span><span class="n">_static_in_main_not_initialized</span><span class="p">);</span>
  <span class="n">PRINT_ADDR_AND_VALUE</span> <span class="p">(</span><span class="n">_static_in_main</span><span class="p">);</span>
  <span class="n">PRINT_ADDR_AND_VALUE</span> <span class="p">(</span><span class="n">_local_in_main_not_initialized</span><span class="p">);</span>
  <span class="n">PRINT_ADDR_AND_VALUE</span> <span class="p">(</span><span class="n">_local_in_main</span><span class="p">);</span>

  <span class="n">function</span> <span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>실험 방법은 위의 코드를 사용하여 전역적(global), 정적(static), 그리고 초기화된(initialized), 초기화되지 않은(not initialized) 마지막으로 함수 stack 변수까지 메모리 주소와 그 값을 비교해보도록 하였다.</p>

<p>실행 결과는 다음과 같고,</p>
<div class="highlight"><pre><code class="c language-c" data-lang="c">          <span class="n">_global_static_not_initialized</span> <span class="p">(</span>        <span class="mh">0x601040</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="p">)</span>
                          <span class="n">_global_static</span> <span class="p">(</span>        <span class="mh">0x601024</span> <span class="o">-&gt;</span> <span class="mi">100</span><span class="p">)</span>
                 <span class="n">_global_not_initialized</span> <span class="p">(</span>        <span class="mh">0x60104c</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="p">)</span>
                                 <span class="n">_global</span> <span class="p">(</span>        <span class="mh">0x601020</span> <span class="o">-&gt;</span> <span class="mi">100</span><span class="p">)</span>
         <span class="n">_static_in_main_not_initialized</span> <span class="p">(</span>        <span class="mh">0x601044</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="p">)</span>
                         <span class="n">_static_in_main</span> <span class="p">(</span>        <span class="mh">0x601028</span> <span class="o">-&gt;</span> <span class="mi">100</span><span class="p">)</span>
          <span class="n">_local_in_main_not_initialized</span> <span class="p">(</span>  <span class="mh">0x7fffde739c6c</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="p">)</span>
                          <span class="n">_local_in_main</span> <span class="p">(</span>  <span class="mh">0x7fffde739c68</span> <span class="o">-&gt;</span> <span class="mi">100</span><span class="p">)</span>
     <span class="n">_static_in_function_not_initialized</span> <span class="p">(</span>        <span class="mh">0x601048</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="p">)</span>
                     <span class="n">_static_in_function</span> <span class="p">(</span>        <span class="mh">0x60102c</span> <span class="o">-&gt;</span> <span class="mi">100</span><span class="p">)</span>
      <span class="n">_local_in_function_not_initialized</span> <span class="p">(</span>  <span class="mh">0x7fffde739c3c</span> <span class="o">-&gt;</span> <span class="mi">32705</span><span class="p">)</span>
                      <span class="n">_local_in_function</span> <span class="p">(</span>  <span class="mh">0x7fffde739c38</span> <span class="o">-&gt;</span> <span class="mi">100</span><span class="p">)</span>
</code></pre></div>
<p>위 문제와 연결지어 정리하면 이와 같다. 위 쪽이 memory의 high address이고 아래 쪽이 low address이다. 세 개의 영역으로 구분지었는데, 위에서부터 <a href="http://en.wikipedia.org/wiki/Data_segment#Stack">스택(Stack)</a>, <a href="http://en.wikipedia.org/wiki/Data_segment#BSS">초기화되지 않은 영역(BSS)</a>, <a href="http://en.wikipedia.org/wiki/Data_segment#Data">초기화된 영역(Data)</a>이다.</p>
<div class="highlight"><pre><code class="c language-c" data-lang="c">          <span class="n">_local_in_main_not_initialized</span> <span class="p">(</span>  <span class="mh">0x7fffde739c6c</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="p">)</span>
                          <span class="n">_local_in_main</span> <span class="p">(</span>  <span class="mh">0x7fffde739c68</span> <span class="o">-&gt;</span> <span class="mi">100</span><span class="p">)</span>
      <span class="n">_local_in_function_not_initialized</span> <span class="p">(</span>  <span class="mh">0x7fffde739c3c</span> <span class="o">-&gt;</span> <span class="mi">32705</span><span class="p">)</span>
                      <span class="n">_local_in_function</span> <span class="p">(</span>  <span class="mh">0x7fffde739c38</span> <span class="o">-&gt;</span> <span class="mi">100</span><span class="p">)</span>

                 <span class="n">_global_not_initialized</span> <span class="p">(</span>        <span class="mh">0x60104c</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="p">)</span>
     <span class="n">_static_in_function_not_initialized</span> <span class="p">(</span>        <span class="mh">0x601048</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="p">)</span>
         <span class="n">_static_in_main_not_initialized</span> <span class="p">(</span>        <span class="mh">0x601044</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="p">)</span>
          <span class="n">_global_static_not_initialized</span> <span class="p">(</span>        <span class="mh">0x601040</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="p">)</span>

                     <span class="n">_static_in_function</span> <span class="p">(</span>        <span class="mh">0x60102c</span> <span class="o">-&gt;</span> <span class="mi">100</span><span class="p">)</span>
                         <span class="n">_static_in_main</span> <span class="p">(</span>        <span class="mh">0x601028</span> <span class="o">-&gt;</span> <span class="mi">100</span><span class="p">)</span>
                          <span class="n">_global_static</span> <span class="p">(</span>        <span class="mh">0x601024</span> <span class="o">-&gt;</span> <span class="mi">100</span><span class="p">)</span>
                                 <span class="n">_global</span> <span class="p">(</span>        <span class="mh">0x601020</span> <span class="o">-&gt;</span> <span class="mi">100</span><span class="p">)</span>
</code></pre></div>
<p>이 결과로 볼 때 세 가지 영역으로 구분할 수 있다.</p>

<ul>
<li>첫 번째는 <strong>스택 공간</strong>으로 지역 변수, 함수 인자, 반환 주소 등이 들어가는 공간이다. 본 실험과 크게 상관없는 부분으로 <a href="http://en.wikipedia.org/wiki/Call_Stack">call stack</a>에 따라 아래(low address)로 증가하는 것을 확인할 수 있다.</li>
<li>두 번째는 <strong>초기화되지 않은 데이터 세그먼트</strong>, 즉 저 유명한 <a href="http://en.wikipedia.org/wiki/.bss">BSS(Block Started by Symbol)</a> 영역이다. 메모리 주소의 순서를 보면 global 영역에서 선언된 변수와 static하게 함수 내에서 선언된 변수가 사이좋게 같은 영역 내에 할당된 것을 확인할 수 있다.

<ul>
<li>단, 재밌는 것은 static하게 선언된 global 변수보다 그냥 global 변수가 더 메모리 상위 주소 공간에 할당된다는 것이다. 이는 단일 파일 내에서 접근되는 메모리 변수 영역과 <a href="http://en.wikipedia.org/wiki/External_variable">다른 모든 파일 내에서 접근되는 메모리 변수 영역</a>을 분리함으로써 효율성을 도모한 시도로 추측된다. <span style="color: #ccc;">(본 내용에 관해서는 추후 확인할 예정이다)</span></li>
</ul></li>
<li>세 번째는 <strong>초기화된 데이터 세그먼트</strong>이다. 함수 내 static 변수나 프로그램 global 변수나 static한 global 변수나 사이좋게 선형적 주소 공간을 가짐을 확인할 수 있다. 재미있는 것은 초기화된 데이터가 메모리에 쌓이는 순서는 순전히 코드 내의 순서에 의존한다는 것이다.<span style="color: #ccc;">(본 내용에 관해서도 추후 확인할 예정이다)</span></li>
</ul>

<p>파생되는 이야기가 많아졌는데, 결론을 내리자면<br>
static 변수나 global 변수가 <strong>같은 공간</strong>에 할당된다는 것이다. 물론 <strong>초기화된 변수와 초기화되지 않은 변수</strong>는 다른 공간에 분리되어 선언된다.</p>

<p><a href="http://en.wikipedia.org/wiki/Data_segment#Data">http://en.wikipedia.org/wiki/Data_segment#Data</a></p>

<blockquote>
<p>static int i = 10; will be stored in data segment and global int i = 10; will be stored in data segment</p>
</blockquote>

<p>물론 메모리 할당 순서가 컴파일러 의존적일 것이라고는 생각되고, 본 실험이 철저히 gcc 기반으로 수행되었기 때문에 다른 컴파일러에서도 그럴 것이다라고 단정 지을 수는 없을 것이다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
						
				<h1 class="page-title">함수 값 반환 방법[어셈블리]</h1>
				<p class="page-date">18 Oct 2009</p>
				<p class="page-tags">
						
						
					<code class="tag">c</code>
						
						
						
						
				</p>
				<div class="content"><p>함수에서의 값 반환이 실제로 기계어 수준에서는 어떻게 이루어지는지 알아보자.</p>

<h3>참고</h3>

<p>assembly 정도는 알고 있어야 무얼 이야기하고자 하는지 알 수 있다.
아래의 코드들은 <code>gcc((Debian 4.3.4-5) 4.3.4)</code> + <code>gdb(6.8.50.20090628-cvs-debian)</code>인 curs-server에서 실험한 것이다.
vs환경에서 해보면 좀 다를 것 같다.</p>

<h3>본문</h3>

<p>함수는 1-2 공전계 시간에 배우고, 함수 호출 원리는 2-1 컴퓨터시스템 시간에 PC 조작과 스택에 return address를 어떻게 넣고 불러오느냐로 배우고, 그걸 직접 짜보는 것은 3-1 CA 시간에 해보았지만,</p>

<p>의외로 함수 값 반환 방법은 자세히 배워본 적이 없다.</p>

<p>보통 우리가 알고 있는 함수 값 반환 방식은 <code>eax</code>에다 반환할 값을 넣고 함수 코드를 <code>ret</code>하면 호출지점 코드에서 <code>eax</code>에 있는 값을 가져오는 것이다.<br>
하지만 <code>eax</code>는 IA32 register로 그 크기가 32bit, 즉 4byte인데 <strong>이 크기를 넘어가는 걸 반환하는건 어떻게 할 것인가</strong>가 이 글에서 확인해보려는 점이다.<br>
(실제로 이건 내가 무슨 세미나인가를 할 때 참관한 선배님께서 질문해주신 건데, 모른다고 하셨으나 분명히 알고 계셨을것이라, 당시에는 대충 포인터로 넘겨서 어디선가 복사하겠죠, 라고 대답했는데 갑자기 생각나서 해당 코드를 만들어 disassemble)</p>
<div class="highlight"><pre><code class="c language-c" data-lang="c"><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>

<span class="k">struct</span> <span class="n">Me</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Me</span> <span class="nf">me</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">Me</span> <span class="n">m</span><span class="p">;</span>
    <span class="n">strncpy</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;lacti&quot;</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
    <span class="n">m</span><span class="p">.</span><span class="n">age</span> <span class="o">=</span> <span class="mi">23</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">m</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">Me</span> <span class="n">m</span> <span class="o">=</span> <span class="n">me</span> <span class="p">();</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;name = %s, age = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">age</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>이런 코드가 있다.
여기서 main의 첫째줄 코드와 me() 함수의 값 반환 코드를 보면 될것이다.</p>

<p>gdb를 써줘서 disassemble 코드를 보자. [gdb, disassemble main]</p>
<div class="highlight"><pre><code class="c language-c" data-lang="c"><span class="mh">0x08048420</span> <span class="o">&lt;</span><span class="n">me</span><span class="o">+</span><span class="mi">44</span><span class="o">&gt;:</span>     <span class="n">mov</span>    <span class="o">-</span><span class="mh">0x14</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">),</span><span class="o">%</span><span class="n">eax</span>
<span class="mh">0x08048423</span> <span class="o">&lt;</span><span class="n">me</span><span class="o">+</span><span class="mi">47</span><span class="o">&gt;:</span>     <span class="n">mov</span>    <span class="o">%</span><span class="n">eax</span><span class="p">,(</span><span class="o">%</span><span class="n">ebx</span><span class="p">)</span>
<span class="mh">0x08048425</span> <span class="o">&lt;</span><span class="n">me</span><span class="o">+</span><span class="mi">49</span><span class="o">&gt;:</span>     <span class="n">mov</span>    <span class="o">-</span><span class="mh">0x10</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">),</span><span class="o">%</span><span class="n">eax</span>
<span class="mh">0x08048428</span> <span class="o">&lt;</span><span class="n">me</span><span class="o">+</span><span class="mi">52</span><span class="o">&gt;:</span>     <span class="n">mov</span>    <span class="o">%</span><span class="n">eax</span><span class="p">,</span><span class="mh">0x4</span><span class="p">(</span><span class="o">%</span><span class="n">ebx</span><span class="p">)</span>
<span class="mh">0x0804842b</span> <span class="o">&lt;</span><span class="n">me</span><span class="o">+</span><span class="mi">55</span><span class="o">&gt;:</span>     <span class="n">mov</span>    <span class="o">-</span><span class="mh">0xc</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">),</span><span class="o">%</span><span class="n">eax</span>
<span class="mh">0x0804842e</span> <span class="o">&lt;</span><span class="n">me</span><span class="o">+</span><span class="mi">58</span><span class="o">&gt;:</span>     <span class="n">mov</span>    <span class="o">%</span><span class="n">eax</span><span class="p">,</span><span class="mh">0x8</span><span class="p">(</span><span class="o">%</span><span class="n">ebx</span><span class="p">)</span>
<span class="mh">0x08048431</span> <span class="o">&lt;</span><span class="n">me</span><span class="o">+</span><span class="mi">61</span><span class="o">&gt;:</span>     <span class="n">mov</span>    <span class="o">-</span><span class="mh">0x8</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">),</span><span class="o">%</span><span class="n">eax</span>
<span class="mh">0x08048434</span> <span class="o">&lt;</span><span class="n">me</span><span class="o">+</span><span class="mi">64</span><span class="o">&gt;:</span>     <span class="n">mov</span>    <span class="o">%</span><span class="n">eax</span><span class="p">,</span><span class="mh">0xc</span><span class="p">(</span><span class="o">%</span><span class="n">ebx</span><span class="p">)</span>
</code></pre></div>
<p>반환 부분 코드다.</p>

<p><code>-0x14(%ebp)</code>부터 지역변수 <code>struct Me m</code>의 시작인데, 이게 <code>-0x08(%ebp)</code>까지해서 총 4byte(왜냐하면 struct Me는 char[12] + int이니까)를 차례대로 <code>%ebx</code>의 0x00부터 0x0c까지 집어넣는것이다.
즉 memcpy.</p>

<p>그리고 </p>
<div class="highlight"><pre><code class="c language-c" data-lang="c"><span class="mh">0x08048437</span> <span class="o">&lt;</span><span class="n">me</span><span class="o">+</span><span class="mi">67</span><span class="o">&gt;:</span>     <span class="n">mov</span>    <span class="o">%</span><span class="n">ebx</span><span class="p">,</span><span class="o">%</span><span class="n">eax</span>
</code></pre></div>
<p>그 <code>ebx</code> 값, 즉 메모리 주소인데 어떤 메모리 주소냐하면 지역변수 <code>m</code>에 담긴 정보가 <strong>복사</strong>된 곳의 메모리 주소가 <code>eax</code>에 담겨서 반환된다는 것이다.<br>
여기까지 한줄로 요약하면 <strong>지역변수가 반환될 때 메모리에 복사되어 그 주소값이 eax로 넘어간다</strong>가 되는 것이다.</p>

<p>지역변수가 왜 지역변수냐? 하면 함수 호출이 끝나고 다 없어지기 때문이다. 어떻게 없어지나 하면</p>
<div class="highlight"><pre><code class="c language-c" data-lang="c"><span class="mh">0x080483f5</span> <span class="o">&lt;</span><span class="n">me</span><span class="o">+</span><span class="mi">1</span><span class="o">&gt;:</span>      <span class="n">mov</span>    <span class="o">%</span><span class="n">esp</span><span class="p">,</span><span class="o">%</span><span class="n">ebp</span>
<span class="mh">0x080483f8</span> <span class="o">&lt;</span><span class="n">me</span><span class="o">+</span><span class="mi">4</span><span class="o">&gt;:</span>      <span class="n">sub</span>    <span class="err">$</span><span class="mh">0x24</span><span class="p">,</span><span class="o">%</span><span class="n">esp</span>
</code></pre></div>
<p>처음에 쓸 만큼 stack pointer를 계산해두고, <code>ebp</code>에 stack 시작점을 담아서, <code>ebp</code>부터 <code>esp</code>까지의 영역을 지역변수를 사용하는 공간으로 쓰다가,</p>
<div class="highlight"><pre><code class="c language-c" data-lang="c"><span class="mh">0x08048439</span> <span class="o">&lt;</span><span class="n">me</span><span class="o">+</span><span class="mi">69</span><span class="o">&gt;:</span>     <span class="n">add</span>    <span class="err">$</span><span class="mh">0x24</span><span class="p">,</span><span class="o">%</span><span class="n">esp</span>
</code></pre></div>
<p>함수가 끝날 때 stack pointer를 다시 복원하면서, 아까 사용하는 공간을 폐기하는 것이다. 그래서 함수가 반환될 때 공간이 폐기되므로 반환 시 그 값을 <strong>복사</strong> 한 것이다.</p>

<p>그렇다면 <code>ebx</code>는 어디를 가리키고 있단 말인가?</p>
<div class="highlight"><pre><code class="c language-c" data-lang="c"><span class="mh">0x080483fb</span> <span class="o">&lt;</span><span class="n">me</span><span class="o">+</span><span class="mi">7</span><span class="o">&gt;:</span>      <span class="n">mov</span>    <span class="mh">0x8</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">),</span><span class="o">%</span><span class="n">ebx</span>
</code></pre></div>
<p>이 코드를 보면 <code>ebx</code>는 <code>ebp</code>의 <code>+0x08</code> 지점을 가리키고 있는데, 또 그럼 여기가 어디냐라는 문제가 있다만 간단히 생각해보면
지역변수를 사용할 때는 보통 ebp에 -값을 더해서 썼다. 즉 <code>-0x14(%ebp)</code> 등과 같이 썼다는 것이다.<br>
즉, <code>esp = ebp - 0x24</code>였으므로 <code>ebp</code>부터 <code>ebp - 0x24</code>까지가 지역변수 영역이라 지역변수는 다 <code>ebp</code> 기준으로 - 영역에 있는 것이다. 근데 저건 + 이니까 지역변수가 아니란 말씀.</p>

<p>그럼 어디냐? <em><code>me()</code> 함수를 호출한 main의 영역</em>이다.</p>

<p>여기서 이제</p>
<div class="highlight"><pre><code class="c language-c" data-lang="c"><span class="mh">0x08048452</span> <span class="o">&lt;</span><span class="n">main</span><span class="o">+</span><span class="mi">17</span><span class="o">&gt;:</span>   <span class="n">lea</span>    <span class="o">-</span><span class="mh">0x14</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">),</span><span class="o">%</span><span class="n">eax</span>
</code></pre></div>
<p>이 코드를 통해
<code>me()</code> 함수 내에서의 <code>%ebx</code> 값이 <code>main()</code> 함수에서 설정한 <code>-0x14(%ebp)</code>의 주소로 결국 main() 함수의 지역변수 영역이라는 것만 설명하면 될텐데 집에서 점심먹으러 나간다고 빨리 준비하란다</p>

<p>그래서 일단 정지</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1><a id="c#" href="#c#">c#</a></h1>
				<hr />
				<div class="page-breaker"></div>
							
						
				<h1 class="page-title">c# binary 파일을 사용해 csv 파일 빨리 읽기</h1>
				<p class="page-date">09 Jul 2014</p>
				<p class="page-tags">
						
						
					<code class="tag">c#</code>
						
						
						
					<code class="tag">data</code>
						
						
						
						
				</p>
				<div class="content"><p>데이터 분석을 위해 데이터를 열심히 수집해서 몇 개의 csv 파일을 얻었고, 이 csv 파일들은 각각 약 1GB 정도로 조금 큰 수준이라고 해보자. 데이터베이스가 있으면 데이터를 넣고 적절한 쿼리를 넣으면 되니 편하게 작업을 진행할 수가 있다. 하지만 데이터베이스가 없는 시스템에서 이 데이터들을 분석하거나, 쿼리로는 데이터 분석을 하기가 좀 어려운 상황이라고 할 경우에는 적어도 다음의 방법을 사용하여 분석을 진행해 볼 것이다.</p>

<ol>
<li>csv를 parsing하여 메모리에 올린다.</li>
<li>메모리에 올린 모델을 적절히 aggregation하여 원하는 결과를 찾아본다.</li>
</ol>

<p>각 부분에 대한 프로그램을 작성하는 것은 별로 큰 부담이 아니다. c#을 사용할 경우, 충분히 추상화된 io 함수와 문자열 라이브러리와 linq가 있기 때문이다.</p>

<p>문제는 <strong>csv parsing</strong> 시간이 꽤 오래 걸린다는 것이다. 연산을 잘못하여 aggregation 로직을 수정할 경우 매번 csv parsing이 다시 일어나기 때문에 데이터 분석을 위한 시간은 계속 길어질 수 밖에 없다. 본 글에서는 이 과정을 빠르게 하기 위한 csv 데이터의 binary serialize 과정을 알아보도록 하겠다.</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="k">struct</span> <span class="nc">ItemData</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Timestamp</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">long</span> <span class="n">DbId</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">long</span> <span class="n">UserDbId</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">TemplateId</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Amount</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>이라는 자료구조가 있다고 해보자. 이에 대한 테스트 데이터를 csv로 대충 만들기 위해 다음과 같은 generator를 만들었다. 별 의미 없이 random 값을 <code>ItemData</code>에 담아서 10M개의 데이터를 csv로 만들어주는 것이다. 약 362MB 정도이다. (timestamp로 정렬한 것은 그럴싸하게 만들기 위함이지 별다른 뜻은 없다.)</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">items</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ItemData</span><span class="p">&gt;();</span>
<span class="kt">var</span> <span class="n">random</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Random</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span> <span class="p">*</span> <span class="m">1024</span> <span class="p">*</span> <span class="m">1024</span><span class="p">;</span> <span class="p">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">items</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="k">new</span> <span class="n">ItemData</span>
    <span class="p">{</span>
        <span class="n">Timestamp</span> <span class="p">=</span> <span class="n">random</span><span class="p">.</span><span class="n">Next</span><span class="p">(</span><span class="m">1404715000</span><span class="p">,</span> <span class="m">1404716000</span><span class="p">),</span>
        <span class="n">DbId</span> <span class="p">=</span> <span class="n">random</span><span class="p">.</span><span class="n">Next</span><span class="p">(</span><span class="m">10000</span><span class="p">,</span> <span class="m">30000</span><span class="p">),</span>
        <span class="n">UserDbId</span> <span class="p">=</span> <span class="n">random</span><span class="p">.</span><span class="n">Next</span><span class="p">(),</span>
        <span class="n">TemplateId</span> <span class="p">=</span> <span class="n">random</span><span class="p">.</span><span class="n">Next</span><span class="p">(</span><span class="m">1000</span><span class="p">,</span> <span class="m">4000</span><span class="p">),</span>
        <span class="n">Amount</span> <span class="p">=</span> <span class="n">random</span><span class="p">.</span><span class="n">Next</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">50</span><span class="p">)</span>
    <span class="p">});</span>
<span class="p">}</span>
<span class="n">items</span><span class="p">.</span><span class="n">Sort</span><span class="p">((</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">left</span><span class="p">.</span><span class="n">Timestamp</span> <span class="p">-</span> <span class="n">right</span><span class="p">.</span><span class="n">Timestamp</span><span class="p">);</span>
<span class="kt">var</span> <span class="n">path</span> <span class="p">=</span> <span class="n">Path</span><span class="p">.</span><span class="n">Combine</span><span class="p">(</span><span class="n">workspace</span><span class="p">,</span> <span class="s">&quot;item.csv&quot;</span><span class="p">);</span>
<span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">writer</span> <span class="p">=</span> <span class="k">new</span> <span class="n">StreamWriter</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="k">false</span><span class="p">))</span>
<span class="p">{</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">e</span> <span class="k">in</span> <span class="n">items</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">writer</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="kt">string</span><span class="p">.</span><span class="n">Join</span><span class="p">(</span><span class="s">&quot;,&quot;</span><span class="p">,</span>
            <span class="n">e</span><span class="p">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">DbId</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">UserDbId</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">TemplateId</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">Amount</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h4>csv reader 1</h4>

<p>362MB의 csv 파일을 parsing하여 <code>ItemData</code>에 넣는 코드를 작성해보자. 간단하게</p>

<ol>
<li>csv 파일을 열고,</li>
<li>줄 단위로 읽으면서</li>
<li>comma 문자로 분리하고</li>
<li>int나 long으로 Parse하는</li>
</ol>

<p>코드를 생각해볼 수 있겠다.</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">items</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ItemData</span><span class="p">&gt;();</span>
<span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">reader</span> <span class="p">=</span> <span class="k">new</span> <span class="n">StreamReader</span><span class="p">(</span><span class="n">csvPath</span><span class="p">))</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">reader</span><span class="p">.</span><span class="n">BaseStream</span><span class="p">.</span><span class="n">Position</span> <span class="p">&lt;</span> <span class="n">reader</span><span class="p">.</span><span class="n">BaseStream</span><span class="p">.</span><span class="n">Length</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">parts</span> <span class="p">=</span> <span class="n">reader</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">().</span><span class="n">Split</span><span class="p">(</span><span class="sc">&#39;,&#39;</span><span class="p">);</span>
        <span class="n">items</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="k">new</span> <span class="n">ItemData</span>
        <span class="p">{</span>
            <span class="n">Timestamp</span> <span class="p">=</span> <span class="kt">int</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="m">0</span><span class="p">]),</span>
            <span class="n">DbId</span> <span class="p">=</span> <span class="kt">long</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="m">1</span><span class="p">]),</span>
            <span class="n">UserDbId</span> <span class="p">=</span> <span class="kt">long</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="m">2</span><span class="p">]),</span>
            <span class="n">TemplateId</span> <span class="p">=</span> <span class="kt">int</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="m">3</span><span class="p">]),</span>
            <span class="n">Amount</span> <span class="p">=</span> <span class="kt">int</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="m">4</span><span class="p">]),</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>파일을 접근하기 위해 <code>StreamReader</code>를 열고, 한 줄씩 읽어서 <code>Split</code>한 후 <code>int.Parse</code>를 사용했다. 시간을 재보면 딱히 어떤 부분이 많이 걸리는 것 같지는 않다. 그냥 전체적으로 많이 호출되어서 느린 것 같아 보인다. 좀 더 자세히 보자.</p>

<ul>
<li><code>StreamReader</code>는 지정한 파일을 연 후 내부의 buffer를 갖고 파일을 읽을 수 있게 해주는 객체다.</li>
<li><code>ReadLine()</code>은 <code>StreamReader</code> 내부 buffer에서 newline 문자를 찾고, 그 이전까지의 string을 반환한다. 만약 buffer에 newline이 없다면, 파일에 다시 접근하여 파일을 좀 더 읽는다.</li>
<li><code>int.Parse()</code>나 <code>long.Parse()</code>는 입력받은 문자열이 올바른 숫자 형태인지 검사한 후, 그것을 적절히 int나 long type으로 변환(convert)해서 반환하는 함수이다.</li>
</ul>

<p>많이 불린 것은 맞지만 결국 모든 부분이 느리기 때문에 전체적으로 느려지는 것이다.</p>

<h4>csv reader 2</h4>

<p>일단 <code>StreamReader</code>에 의해 파일을 여러 번 접근하는 부분을 개선해보자. 즉, <code>File.ReadAllLines()</code> 함수를 써서 파일을 한 번에 모두 읽은 후 각 line 별로 접근하도록 해보자.</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">items</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ItemData</span><span class="p">&gt;();</span>
<span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">line</span> <span class="k">in</span> <span class="n">File</span><span class="p">.</span><span class="n">ReadAllLines</span><span class="p">(</span><span class="n">csvPath</span><span class="p">))</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">parts</span> <span class="p">=</span> <span class="n">line</span><span class="p">.</span><span class="n">Split</span><span class="p">(</span><span class="sc">&#39;,&#39;</span><span class="p">);</span>
    <span class="n">items</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="k">new</span> <span class="n">ItemData</span>
    <span class="p">{</span>
        <span class="n">Timestamp</span> <span class="p">=</span> <span class="kt">int</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="m">0</span><span class="p">]),</span>
        <span class="n">DbId</span> <span class="p">=</span> <span class="kt">long</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="m">1</span><span class="p">]),</span>
        <span class="n">UserDbId</span> <span class="p">=</span> <span class="kt">long</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="m">2</span><span class="p">]),</span>
        <span class="n">TemplateId</span> <span class="p">=</span> <span class="kt">int</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="m">3</span><span class="p">]),</span>
        <span class="n">Amount</span> <span class="p">=</span> <span class="kt">int</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="m">4</span><span class="p">]),</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div>
<p>코드가 좀 더 간단해졌다. <code>File.ReadAllLines()</code> 함수는 파일을 한 번에 다 읽어놓은 뒤 <code>IEnumerable&lt;string&gt;</code> 형태로 각 line을 반환해주는 c# 내장 함수이다. 따라서 위와 같이 수행해보면 <code>File.ReadAllLInes()</code>에서 걸리는 시간이 좀 길게 측정되지만 전체적으로는 첫 번째 예제보다 빨라진다.</p>

<p>재미있는 점은 위 프로그램을 두 번째 실행할 때에는 <code>File.ReadAllLines()</code> 수행이 꽤 빨라진다는 것이다. 그 이유는 첫 번째 수행 시 csv 파일이 io cache에 들어가서 두 번째 실행 시에는 상대적으로 io 부담이 줄어들기 때문이다. 이 성능 차이는 ssd보다 io 비용이 비싼 hdd에서 테스트할 때 보다 확실히 느낄 수 있다.</p>

<h4>binary serialize</h4>

<p>io 비용을 줄이기 위해 조금씩 io를 여러 번 부르는 것보다는 한 번에 다 읽어놓고 작업하는게 더 빠르다는 것을 알았다. (물론 메모리가 허용할 때의 이야기이다. 메모리가 허용하지 않는다면 <code>StreamReader</code>를 써야한다.)</p>

<p>이제 newline을 찾는 비용과 <code>int.Parse()</code> 비용을 줄이기 위한 방법을 생각해보자. 간단하다. <code>ItemData</code>는 고정 크기의 데이터이므로 데이터 그 자체를 binary로 쓰는 것이다. (c++에서는 보다 손쉽게 memory를 file로 dump할 수 있지만 c#은 vm 기반이므로 그렇지 않다.)</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">binPath</span> <span class="p">=</span> <span class="n">Path</span><span class="p">.</span><span class="n">Combine</span><span class="p">(</span><span class="n">workspace</span><span class="p">,</span> <span class="s">&quot;item.bin&quot;</span><span class="p">);</span>
<span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">fileStream</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FileStream</span><span class="p">(</span><span class="n">binPath</span><span class="p">,</span> <span class="n">FileMode</span><span class="p">.</span><span class="n">Create</span><span class="p">,</span> <span class="n">FileAccess</span><span class="p">.</span><span class="n">Write</span><span class="p">,</span> <span class="n">FileShare</span><span class="p">.</span><span class="n">None</span><span class="p">))</span>
<span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">writer</span> <span class="p">=</span> <span class="k">new</span> <span class="n">BinaryWriter</span><span class="p">(</span><span class="n">fileStream</span><span class="p">))</span>
<span class="p">{</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">items</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">writer</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">Timestamp</span><span class="p">);</span>
        <span class="n">writer</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">DbId</span><span class="p">);</span>
        <span class="n">writer</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">UserDbId</span><span class="p">);</span>
        <span class="n">writer</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">TemplateId</span><span class="p">);</span>
        <span class="n">writer</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">Amount</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p><code>FileStream</code>으로 내보낼 파일에 대한 stream을 만들고 <code>BinaryWriter</code>를 사용해서 각 field 별로 <code>Write()</code>를 해주면 된다. 이제 item.bin 파일에는 순서대로, timestamp / dbid / userdbid / templateid / amount가 기록된다. 한 row의 크기가 28(4+8+8+4+4)인 고정 크기의 record가 연속적으로 기록된 binary 파일이라고 생각하면 된다.</p>

<p>이렇게 작성된 bin 파일의 크기는 280MB이다. 비록 고정 길이 record이지만 newline과 comma 문자가 빠져서 득을 많이 보았다. 이제 읽어보자.</p>

<h4>binary reader 1</h4>

<p>간단히 구현해보면, csv 파일을 읽을 때와 동일한 구조가 나온다.</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">items</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ItemData</span><span class="p">&gt;();</span>
<span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">fileStream</span> <span class="p">=</span> <span class="n">File</span><span class="p">.</span><span class="n">OpenRead</span><span class="p">(</span><span class="n">binPath</span><span class="p">))</span>
<span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">reader</span> <span class="p">=</span> <span class="k">new</span> <span class="n">BinaryReader</span><span class="p">(</span><span class="n">fileStream</span><span class="p">))</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">fileStream</span><span class="p">.</span><span class="n">Position</span> <span class="p">&lt;</span> <span class="n">fileStream</span><span class="p">.</span><span class="n">Length</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">items</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="k">new</span> <span class="n">ItemData</span>
        <span class="p">{</span>
            <span class="n">Timestamp</span> <span class="p">=</span> <span class="n">reader</span><span class="p">.</span><span class="n">ReadInt32</span><span class="p">(),</span>
            <span class="n">DbId</span> <span class="p">=</span> <span class="n">reader</span><span class="p">.</span><span class="n">ReadInt64</span><span class="p">(),</span>
            <span class="n">UserDbId</span> <span class="p">=</span> <span class="n">reader</span><span class="p">.</span><span class="n">ReadInt64</span><span class="p">(),</span>
            <span class="n">TemplateId</span> <span class="p">=</span> <span class="n">reader</span><span class="p">.</span><span class="n">ReadInt32</span><span class="p">(),</span>
            <span class="n">Amount</span> <span class="p">=</span> <span class="n">reader</span><span class="p">.</span><span class="n">ReadInt32</span><span class="p">(),</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>단지 <code>ReadLine()</code>과 <code>Parse()</code> 대신 <code>BinaryReader</code> 객체를 사용하여 해당 파일을 다 읽을 때까지 각 field의 크기에 맞게 byte를 읽어주는 것이 다르다.</p>

<p>두 번째 예제에 비해 속도 향상이 있기는 하지만 큰 차이는 아니다. 그 이유는 <code>FileStream</code>이 내부 buffer를 사용하는 구조이므로 첫 번째 예제와 동일하게 io를 여러 번 발생시키기 때문이다. 이 구조를 좀 더 개선해보자.</p>

<h4>binary reader 2</h4>

<p>방법은 간단하다. 미리 binary bytes를 다 읽어두고 <code>FileStream</code> 대신 <code>MemoryStream</code>을 사용하는 것이다.</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">items</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ItemData</span><span class="p">&gt;();</span>
<span class="kt">var</span> <span class="n">bytes</span> <span class="p">=</span> <span class="n">File</span><span class="p">.</span><span class="n">ReadAllBytes</span><span class="p">(</span><span class="n">binPath</span><span class="p">);</span>
<span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">memoryStream</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MemoryStream</span><span class="p">(</span><span class="n">bytes</span><span class="p">))</span>
<span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">reader</span> <span class="p">=</span> <span class="k">new</span> <span class="n">BinaryReader</span><span class="p">(</span><span class="n">memoryStream</span><span class="p">))</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">memoryStream</span><span class="p">.</span><span class="n">Position</span> <span class="p">&lt;</span> <span class="n">memoryStream</span><span class="p">.</span><span class="n">Length</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">items</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="k">new</span> <span class="n">ItemData</span>
        <span class="p">{</span>
            <span class="n">Timestamp</span> <span class="p">=</span> <span class="n">reader</span><span class="p">.</span><span class="n">ReadInt32</span><span class="p">(),</span>
            <span class="n">DbId</span> <span class="p">=</span> <span class="n">reader</span><span class="p">.</span><span class="n">ReadInt64</span><span class="p">(),</span>
            <span class="n">UserDbId</span> <span class="p">=</span> <span class="n">reader</span><span class="p">.</span><span class="n">ReadInt64</span><span class="p">(),</span>
            <span class="n">TemplateId</span> <span class="p">=</span> <span class="n">reader</span><span class="p">.</span><span class="n">ReadInt32</span><span class="p">(),</span>
            <span class="n">Amount</span> <span class="p">=</span> <span class="n">reader</span><span class="p">.</span><span class="n">ReadInt32</span><span class="p">(),</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p><code>File.ReadAllBytes()</code>는 c# 내장 라이브러리로 지정된 파일의 모든 bytes를 한 번에 읽어 메모리로 올린다. <code>BinaryReader</code>는 Stream 객체를 필요로 하므로 이 bytes를 Stream으로 만들어주기 위한 <code>MemoryStream</code>을 사용하는 것이다. io 비용을 처음 한 번에 다 지불하기 때문에 세 번째 예제에 비해 속도가 크게 향상된다.</p>

<p><code>BinaryReader</code> 때문이지만 필요하지도 않은 <code>MemoryStream</code> 객체를 만들어서 굳이 비용을 더 지불할 필요는 없다. 왜냐하면 <code>BitConverter</code>가 있기 때문이다. 좀 더 개선해보자.</p>

<h4>binary reader 3</h4>

<p><code>BitConverter</code>는 지정된 byte 배열의 위치(offset)로부터 지정된 형(type)으로 값을 읽어주는 c# 내장 라이브러리이다. 이를 사용하면 코드를 다음과 같이 작성할 수 있다.</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">items</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ItemData</span><span class="p">&gt;();</span>
<span class="kt">var</span> <span class="n">bytes</span> <span class="p">=</span> <span class="n">File</span><span class="p">.</span><span class="n">ReadAllBytes</span><span class="p">(</span><span class="n">binPath</span><span class="p">);</span>
<span class="kt">var</span> <span class="n">rowSize</span> <span class="p">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="p">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="p">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">offset</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">offset</span> <span class="p">&lt;</span> <span class="n">bytes</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">offset</span> <span class="p">+=</span> <span class="n">rowSize</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">items</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="k">new</span> <span class="n">ItemData</span>
    <span class="p">{</span>
        <span class="n">Timestamp</span> <span class="p">=</span> <span class="n">BitConverter</span><span class="p">.</span><span class="n">ToInt32</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">offset</span> <span class="p">+</span> <span class="m">0</span><span class="p">),</span>
        <span class="n">DbId</span> <span class="p">=</span> <span class="n">BitConverter</span><span class="p">.</span><span class="n">ToInt64</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">offset</span> <span class="p">+</span> <span class="m">4</span><span class="p">),</span>
        <span class="n">UserDbId</span> <span class="p">=</span> <span class="n">BitConverter</span><span class="p">.</span><span class="n">ToInt64</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">offset</span> <span class="p">+</span> <span class="m">12</span><span class="p">),</span>
        <span class="n">TemplateId</span> <span class="p">=</span> <span class="n">BitConverter</span><span class="p">.</span><span class="n">ToInt32</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">offset</span> <span class="p">+</span> <span class="m">20</span><span class="p">),</span>
        <span class="n">Amount</span> <span class="p">=</span> <span class="n">BitConverter</span><span class="p">.</span><span class="n">ToInt32</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">offset</span> <span class="p">+</span> <span class="m">24</span><span class="p">),</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div>
<p><code>ItemData</code>는 고정 길이 record이기 때문에 미리 row-size를 계산해둘 수 있다. 따라서 메모리에 다 읽어둔 byte 배열을 row-size만큼 증가시키면서 각 위치의 field를 적절히 변환해서 <code>ItemData</code> 객체에 넣어주면 되는 것이다. 이렇게 작성하면 네 번째 예제보다 (미약하지만) 성능 개선 효과를 얻을 수 있다.</p>

<h4>왜 c#인가</h4>

<p>사실 c++로 작성한다면 위 과정이 훨씬 간단해진다. 단순히 <code>ItemData</code> 배열을 할당한 다음 <code>fwrite()</code> 함수의 인자로 <code>ItemData</code> 배열의 주소를 넘겨서 dump를 하고, 읽을 때에는 file-size만큼 다 읽은 뒤 <code>ItemData*</code>로 casting해서 접근하면 되기 때문이다.</p>

<p>그럼에도 불구하고 c#을 고집한 이유는 다음과 같다.</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="n">items</span><span class="p">.</span><span class="n">GroupBy</span><span class="p">(</span><span class="n">e</span> <span class="p">=&gt;</span> <span class="n">e</span><span class="p">.</span><span class="n">TemplateId</span><span class="p">).</span><span class="n">Select</span><span class="p">(</span><span class="n">e</span> <span class="p">=&gt;</span>
    <span class="k">new</span> <span class="p">{</span> <span class="n">TemplateId</span> <span class="p">=</span> <span class="n">e</span><span class="p">,</span> <span class="n">SumOfAmount</span> <span class="p">=</span> <span class="n">e</span><span class="p">.</span><span class="n">Sum</span><span class="p">(</span><span class="n">i</span> <span class="p">=&gt;</span> <span class="n">i</span><span class="p">.</span><span class="n">Amount</span><span class="p">)</span> <span class="p">}).</span><span class="n">Dump</span><span class="p">();</span>
</code></pre></div>
<p>위 코드는 TemplateId 별 Amount의 총량을 구해서 보여주는 LINQ 코드이다. (<code>Dump()</code> 함수는 <a href="http://www.linqpad.net/">LINQPad</a>에서 지원하는 함수로 쿼리 수행 결과를 테이블로 이쁘게 보여주는 함수이다.)</p>

<p>물론 c++에 비해 다소 속도가 느리고 메모리가 많이 필요할 수는 있지만 데이터의 쿼리를 날리기에는 LINQ를 쓸 수 있는 c#이 c++에 비해 훨씬 작업하기가 좋다.</p>

<h4>속도 비교</h4>

<p>위 예제의 속도를 비교해보자. 속도는 내 컴퓨터(i5-4200U, 8GB) LinqPad AnyCPU를 기준으로 대충 측정하였다.</p>

<table><thead>
<tr>
<th>name</th>
<th>time (sec)</th>
</tr>
</thead><tbody>
<tr>
<td>csv #1</td>
<td>28</td>
</tr>
<tr>
<td>csv #2</td>
<td>17</td>
</tr>
<tr>
<td>bin #1</td>
<td>14</td>
</tr>
<tr>
<td>bin #2</td>
<td>2</td>
</tr>
<tr>
<td>bin #3</td>
<td>1</td>
</tr>
</tbody></table>

<p>고작 362MB의 데이터지만 충분한 속도 상승 효과가 나오고 있는 것을 볼 수 있다.</p>

<h4>마무리</h4>

<p>대용량의 csv 파일을 읽어서 작업해야 할 일이 있을 경우 그 구조가 간단하다고 해도 io 비용과 parsing 비용 때문에 loading 시간이 만만치 않다. 이 경우 위처럼 csv을 미리 parsing 해둔 binary 파일을 만들어서 보다 빠르게 작업을 진행할 수 있다.</p>

<p>하지만 여전히 문제가 있다.</p>

<ul>
<li>훨씬 더 큰 양의 데이터를 다뤄야할 때에는 vm에서 허용해주는 메모리의 한계를 넘을 수도 있는데 위 구조를 적용할 수 있을까?</li>
<li>loading 시간을 단축했지만 그조차도 클 경우에 사용할만한 좀 더 좋은 방법이 없을까?</li>
<li>매번 다른 자료구조에 대해서 매번 binary로 serialize해주고 deserialize해주는 코드를 작성해야 할까?</li>
</ul>

<p>이에 대해서는 추후 글에서 알아보도록 하자.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">c# 데이터 서버 라이브러리 구현</h1>
				<p class="page-date">15 Jul 2014</p>
				<p class="page-tags">
						
						
					<code class="tag">c#</code>
						
						
						
					<code class="tag">data</code>
						
						
						
						
				</p>
				<div class="content"><p>지난 글에서는 csv 데이터를 binary 파일로 serialize하여 데이터의 loading 속도를 올리는 방법에 대해 알아보았다. 해당 방법은 용량이 큰 csv 파일에 대해서도 효과가 크지만, 작게 분할된 많은 csv 파일을 다시 적절한 크기의 binary 파일로 재구성하여 작업할 때 더욱 효과를 크게 느낄 수 있다.</p>

<p>하지만 csv 파일의 용량이 너무 크거나, 아니면 csv 파일이 너무 많을 경우에는 해당 방법을 사용하기가 어렵다. <a href="http://stackoverflow.com/questions/1087982/single-objects-still-limited-to-2-gb-in-size-in-clr-4-0">.net vm은 x64 모드에서도 단일 객체에 대해 2GB 이상의 크기에 대한 메모리 할당 요청을 하면 <code>OutOfMemoryException</code>이 발생</a>하는데, 위 구조에서는 파일의 내용을 한 번에 <code>byte[]</code> 배열로 읽고, 그 결과물을 하나의 <code>List&lt;T&gt;</code>에 담는 구조이기 때문이다.</p>

<p>또한 이렇게 loading 시간을 단축한다고 해도 원본 데이터의 크기가 아주 클 경우에는 줄어든 loading 시간도 클 수 밖에 없다. 그리고 binary로 serialize/deserialize하는 기계적인 코드를 매번 수작업으로 입력해야 하는 것도 불필요한 부담이다.</p>

<p>따라서 본 글에서는 위에서 언급한 3가지 문제에 대해 어떻게 접근할지 알아보도록 하겠다.</p>

<h4>collection of IEnumerable</h4>

<p>데이터가 아주 크거나 많을 경우 .net vm 메모리 할당 한계로 인해 위 구조를 사용할 수 없는 문제가 있다. 이 문제를 해결하는 가장 간단한 방법은 binary 파일을 여러 개로 쪼갠 후 각각을 각기 다른 <code>List&lt;T&gt;</code>로 읽고, 이들에 대한 collection인 <code>List&lt;List&lt;T&gt;&gt;</code>에 대해 쿼리를 수행하는 방법일 것이다. 예를 들어, 위 예제에서 item*.bin 패턴으로 파일이 여러 개 있다고 할 경우,</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">itemsList</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">List</span><span class="p">&lt;</span><span class="n">ItemData</span><span class="p">&gt;&gt;();</span>
<span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">binPath</span> <span class="k">in</span> <span class="n">Directory</span><span class="p">.</span><span class="n">GetFiles</span><span class="p">(</span><span class="n">workspace</span><span class="p">,</span> <span class="s">&quot;item*.bin&quot;</span><span class="p">))</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">items</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ItemData</span><span class="p">&gt;();</span>
    <span class="kt">var</span> <span class="n">bytes</span> <span class="p">=</span> <span class="n">File</span><span class="p">.</span><span class="n">ReadAllBytes</span><span class="p">(</span><span class="n">binPath</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">offset</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">offset</span> <span class="p">&lt;</span> <span class="n">bytes</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">offset</span> <span class="p">+=</span> <span class="n">rowSize</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">items</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="k">new</span> <span class="n">ItemData</span>
        <span class="p">{</span>
            <span class="n">Timestamp</span> <span class="p">=</span> <span class="n">BitConverter</span><span class="p">.</span><span class="n">ToInt32</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">offset</span> <span class="p">+</span> <span class="m">0</span><span class="p">),</span>
            <span class="n">DbId</span> <span class="p">=</span> <span class="n">BitConverter</span><span class="p">.</span><span class="n">ToInt64</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">offset</span> <span class="p">+</span> <span class="m">4</span><span class="p">),</span>
            <span class="n">UserDbId</span> <span class="p">=</span> <span class="n">BitConverter</span><span class="p">.</span><span class="n">ToInt64</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">offset</span> <span class="p">+</span> <span class="m">12</span><span class="p">),</span>
            <span class="n">TemplateId</span> <span class="p">=</span> <span class="n">BitConverter</span><span class="p">.</span><span class="n">ToInt32</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">offset</span> <span class="p">+</span> <span class="m">20</span><span class="p">),</span>
            <span class="n">Amount</span> <span class="p">=</span> <span class="n">BitConverter</span><span class="p">.</span><span class="n">ToInt32</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">offset</span> <span class="p">+</span> <span class="m">24</span><span class="p">),</span>
        <span class="p">});</span>
    <span class="p">}</span>
    <span class="n">itemsList</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">items</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>와 같이 <code>List&lt;List&lt;ItemData&gt;&gt;</code>를 만들고 여러 개의 <code>List&lt;ItemData&gt;</code>를 담는 것이다. 이렇게 될 경우 각 <code>List&lt;ItemData&gt;</code>에서 할당하는 메모리의 크기는 2GB를 넘지 않게 한다면 위 문제를 적어도 <strong>읽는 과정에서는</strong> 회피할 수 있을 것이다.</p>

<p>예를 들어 <code>itemLists</code>에 존재하는 수량(Amount)이 10개 이상인 서로 다른 <code>TemplateId</code>의 개수를 확인하려면 다음과 같이 쿼리를 작성하면 된다.</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="n">itemsList</span><span class="p">.</span><span class="n">SelectMany</span><span class="p">(</span><span class="n">e</span> <span class="p">=&gt;</span> 
        <span class="n">e</span><span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">i</span> <span class="p">=&gt;</span> <span class="n">i</span><span class="p">.</span><span class="n">Amount</span> <span class="p">&gt;=</span> <span class="m">10</span><span class="p">).</span><span class="n">Select</span><span class="p">(</span><span class="n">i</span> <span class="p">=&gt;</span> <span class="n">i</span><span class="p">.</span><span class="n">TemplateId</span><span class="p">)</span>
    <span class="p">).</span><span class="n">Distinct</span><span class="p">().</span><span class="n">Count</span><span class="p">()</span>
</code></pre></div>
<p>이 경우 <code>SelectMany()</code>는 가지고 있는 각 <code>List&lt;ItemData&gt;</code>를 차례로 순회하면서 <code>yield return</code>으로 각각을 반환한다. 따라서 반환 시 추가적인 메모리 할당을 요구하지 않으며 데이터를 stream 형태로 제공하게 된다. 그 이후 연결되는 <code>Select()</code>,<code>Where()</code>이나 <code>Distinct()</code>, <code>Count()</code> 역시 stream 형태로 작업을 수행하는 연산자이므로 메모리 문제를 유발하지 않는다.</p>

<p>하지만 <code>GroupBy()</code>나 <code>OrderBy()</code> 연산자 등 stream에 존재하는 모든 데이터를 buffer에 담고 작업을 처리해야하는 연산자의 경우에는 위 collection에 존재하는 모든 데이터를 담기 위한 내부 buffer를 할당해야 하므로 이 크기가 제한을 넘어가 프로그램이 정상 동작하지 않을 수 있다.</p>

<p>.NET Framework 4.5부터는 <a href="http://msdn.microsoft.com/en-us/library/hh285054.aspx">gcAllowVeryLargeObjects</a> 옵션이 추가되었으므로 이 옵션을 통해 문제를 회피할 수 있다고도 한다.</p>

<h4>data server</h4>

<p>만약 데이터가 아주 커지고 더 많아질 경우 위와 같은 방법을 사용해도 여전히 loading 시간이 길어질 수 있다. 이 경우에는 지체없이 데이터베이스를 쓰면 된다 [...] 하지만 이왕 여기까지 왔으니 좀 더 나아가보자.</p>

<p>데이터를 매번 loading하는 것이 느리다면 한 번 띄워놓은 데이터를 계속 사용할 수 있으면 된다. 그러면 대충 다음의 방법을 생각해볼 수 있다.</p>

<ul>
<li>데이터를 다 읽어둔 서버가 데이터 쿼리를 수행할 클라이언트에게 ipc로 데이터를 전달한다.</li>
<li>데이터 서버가 읽어둔 데이터를 shared memory로 클라이언트와 공유한다.</li>
<li>데이터 서버에게 연결한 클라이언트가 서버에게 데이터 쿼리를 보내고, 서버는 그 처리 결과를 클라이언트에게 돌려준다.</li>
</ul>

<p>각 방법에 대해 살펴보도록 하자.</p>

<h4>all-data retrieving by ipc</h4>

<p>c# wcf는 잘 추상화되어 있으므로 IPC 통신 코드를 작성하는 것은 간단하다. 일단 교환을 위한 struct에 대해 <code>DataContract</code>를 명시해준다.</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="na">[DataContract]</span>
<span class="k">public</span> <span class="k">struct</span> <span class="nc">ItemData</span>
<span class="p">{</span>
<span class="na">    [DataMember]</span> <span class="k">public</span> <span class="kt">int</span> <span class="n">Timestamp</span><span class="p">;</span>
<span class="na">    [DataMember]</span> <span class="k">public</span> <span class="kt">long</span> <span class="n">DbId</span><span class="p">;</span>
<span class="na">    [DataMember]</span> <span class="k">public</span> <span class="kt">long</span> <span class="n">UserDbId</span><span class="p">;</span>
<span class="na">    [DataMember]</span> <span class="k">public</span> <span class="kt">int</span> <span class="n">TemplateId</span><span class="p">;</span>
<span class="na">    [DataMember]</span> <span class="k">public</span> <span class="kt">int</span> <span class="n">Amount</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>그리고 통신을 위한 interface를 선언한다. 위 struct와 아래 interface는 IPC 서버와 클라이언트가 모두 가지고 있어야 한다.</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="na">[ServiceContract]</span>
<span class="k">public</span> <span class="k">interface</span> <span class="n">IDataProvider</span>
<span class="p">{</span>
<span class="na">    [OperationContract]</span>
    <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">ItemData</span><span class="p">&gt;</span> <span class="n">RetrieveItems</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>이제 서버에서 위 interface를 구현하는 객체를 구현한다. 객체 생성 시 데이터를 읽어두고, <code>RetrieveItems()</code>를 부를 때 읽어놓은 데이터를 반환해주면 되겠다.</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">class</span> <span class="nc">DataProvider</span> <span class="p">:</span> <span class="n">IDataProvider</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ItemData</span><span class="p">&gt;</span> <span class="n">_items</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ItemData</span><span class="p">&gt;();</span>
    <span class="k">public</span> <span class="nf">DataProvider</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// load data</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">ItemData</span><span class="p">&gt;</span> <span class="n">RetrieveItems</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">_items</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>이제 필요한 모든 class 및 interface를 작성했으니 이를 IPC 서비스로 제공을 해주면 되겠다. 서버 쪽 구동 코드는 다음과 같다.</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">host</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ServiceHost</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">DataProvider</span><span class="p">),</span>
    <span class="k">new</span> <span class="n">Uri</span><span class="p">[]</span> <span class="p">{</span> <span class="k">new</span> <span class="n">Uri</span><span class="p">(</span><span class="s">&quot;net.pipe://localhost&quot;</span><span class="p">)</span> <span class="p">}))</span>
<span class="p">{</span>
    <span class="n">host</span><span class="p">.</span><span class="n">AddServiceEndpoint</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">IDataProvider</span><span class="p">),</span>
        <span class="k">new</span> <span class="n">NetNamedPipeBinding</span><span class="p">,</span> <span class="s">&quot;DataProvider&quot;</span><span class="p">);</span>
    <span class="n">host</span><span class="p">.</span><span class="n">Open</span><span class="p">();</span>

    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Server is running&quot;</span><span class="p">);</span>
    <span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">();</span>
    <span class="n">host</span><span class="p">.</span><span class="n">Close</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p><code>ServiceHost</code>로 서비스할 객체를 지정하고, 서비스를 수행할 Endpoint를 지정한다. 그리고 <code>Open()</code>을 불러주면 된다. <code>Open()</code> 함수는 비동기 수행 함수이므로 서버 종료를 막기 위해 <code>ReadLine()</code>을 넣었다.</p>

<p>클라이언트는 이제 <code>net.pipe://localhost/DataProvider</code>에 접근해서 <code>RetrieveItems()</code> 함수를 호출하면 된다.</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">pipeFactory</span> <span class="p">=</span>
    <span class="k">new</span> <span class="n">ChannelFactory</span><span class="p">&lt;</span><span class="n">IDataProvider</span><span class="p">&gt;(</span>
    <span class="k">new</span> <span class="n">NetNamedPipeBinding</span> <span class="p">{</span> <span class="n">MaxReceivedMessageSize</span> <span class="p">=</span> <span class="kt">int</span><span class="p">.</span><span class="n">MaxValue</span> <span class="p">},</span>
    <span class="k">new</span> <span class="nf">EndpointAddress</span><span class="p">(</span><span class="s">&quot;net.pipe://localhost/DataProvider&quot;</span><span class="p">));</span>

<span class="kt">var</span> <span class="n">provider</span> <span class="p">=</span> <span class="n">pipeFactory</span><span class="p">.</span><span class="n">CreateChannel</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">items</span> <span class="p">=</span> <span class="n">provider</span><span class="p">.</span><span class="n">RetrieveItems</span><span class="p">();</span>
</code></pre></div>
<p>다만 문제는 원래 이렇게 큰 객체를 주고 받기 위해 설계된 개념이 아니기 때문에 <code>MaxReceivedMessageSize</code> 값을 최대한 크게 설정해주어야 한다는 것이다. 그런데 이 값의 한계치가 <code>int.MaxValue</code>이므로 결국 데이터의 크기가 2GB보다 큰 것은 이 구현을 통해 받을 수가 없다는 것이다.</p>

<p>뿐만 아니라 위 코드를 동작시켜보면 local에서 자료를 직접 읽을 때보다 속도가 매우 느린 것을 확인할 수 있다. 심지어 이 글에서 계속 사용하고 있는 데이터 기준으로 첫 번째 예제보다 수행 속도가 느리다. 즉, 위와 같이 모든 <code>ItemData</code> 객체를 클라이언트에 받아서 쿼리를 수행하는 방식은 적절하지 않다는 것이다.</p>

<h4>all-data retrieving by shared memory</h4>

<p>위 IPC 통신이 느린 이유는 그렇게 쓰라고 만든 것이 아니기 때문인 이유도 있지만, IPC에서 객체를 주고 받을 때 발생하는 .NET serialize 비용이 꽤 크기 때문이다. .NET serializer는 전 글에서 구현한 <code>BinaryWriter</code> 수준의 Marshaling이 아닌 type 정보 등을 포함한 보다 복잡하고 큰 serializing을 수행한다. 때문에 느릴 수 밖에 없다.</p>

<p>그렇다면 IPC를 사용하지 않고 shared memory를 사용해서 문제를 해결할 수 있을까? 안타깝게도 별로 좋은 선택은 아니다. 왜냐하면 shared memory는 byte 수준의 메모리를 공유하는 기법이지 객체를 공유하기 위한 것이 아니기 때문이다.</p>

<p>즉 <code>List&lt;ItemData&gt;</code>를 서버 측에서 shared memory에 byte로 marshaling해서 올려놓든가 아니면 전 글에서 썼던 것처럼 <code>BinaryWriter</code>로 기록해놓고, 클라이언트는 이 byte를 다시 unmarshaling하거나 <code>BinaryReader</code>로 읽어야 한다. 그렇다면 기존과 비교하여 처음 binary 파일을 읽는 IO 비용만 없어지는 셈인데 이 방법은 구현 복잡도에 비해서 별로 큰 효과를 볼 수 있을 것 같지 않은 방법이다.</p>

<h4>execute query in server</h4>

<p>위 방법들이 별로 좋지 않은 이유는 클라이언트가 모든 객체에 대한 정보를 다 받은 뒤 클라이언트에서 쿼리를 수행하려 했기 때문이다. 이번에는 발상을 바꿔서 클라이언트에서 직접 쿼리를 하는 것이 아니라, <strong>쿼리 객체를 서버로 전달하여 수행한 그 결과를 반환하도록</strong> 설계해보자.</p>

<ul>
<li>서버는 데이터를 모두 읽어서 메모리에 올려놓는다.</li>
<li>그리고 쿼리 수행을 위한 Service(IPC 등)를 시작한다.</li>
<li>클라이언트는 수행할 LINQ에 대해 <code>ExpressionTree</code>를 만든다.</li>
<li><a href="http://expressiontree.codeplex.com/">ExpressionTree Serializer</a>를 사용하여 ExpressionTree를 서버로 전달한다.</li>
<li>서버는 전달 받은 <code>ExpressionTree</code> 객체에 대해 Query를 복원해서 읽어놓은 데이터에 대해 쿼리를 수행한다. 그리고 그 결과를 클라이언트에게 반환한다.</li>
<li>클라이언트는 결과를 받아서 적절히 보여준다.</li>
</ul>

<p>간단한 데이터 처리 API인 셈이다.</p>

<p><code>ExpressionTree</code> 자체는 Serializable하지 않으니 외부 라이브러리의 도움을 받는다. 그 외에는 위 IPC 예제와 동일하게 쿼리에 대한 <code>OperationContract</code> 하나 만들어주고 그 수행 결과를 반환 받도록 하면 된다. 이에 대해서는 이미 다음 라이브러리들이 적절한 예제를 구현해 놓았다.</p>

<ul>
<li><a href="http://expressiontree.codeplex.com/">ExpressionTree Serializer</a></li>
<li><a href="https://github.com/esskar/Serialize.Linq">Serialize.Linq</a></li>
</ul>

<h4>binary serializer</h4>

<p>이번에는 좀 다른 이야기를 해보자. 데이터를 serialize/deserialize하는 코드를 매번 손으로 직접 작성했다. 이는 굉장히 유사한 코드이지만 <code>ItemData</code>와 같은 struct가 추가될 때마다 그 struct에 대한 코드를 직접 작성해주어야 한다. 이를 개선해보자.</p>

<ul>
<li>Reflection에 의해 member type을 runtime에 확인하고 serialize를 수행하게 한다.</li>
<li>struct에 대한 metadata를 정의하고 code generator를 사용하여 serialize 코드를 생성한다.</li>
</ul>

<p>첫 번째 방법은 당연히 느리다. 데이터를 읽는 부분은 데이터의 개수만큼 수행되는 반복문 안에서 호출되는데 그 회수만큼 reflection을 사용하기 때문에 느릴 수 밖에 없다.</p>

<p>code generation은 나쁘지 않은 선택이다. 코드가 runtime 이전에 만들어지기 때문에 수행할 때에는 이미 작성된 코드로 동작하므로 손으로 작성한 것과 동일하게 빠른 동작을 보여줄 수 있다. 직접 generator를 만들어도 되고, vs랑 친한 T4를 사용하는 것도 가능하다. 하지만 코드 생성을 위해 build script를 수정해야 하는 귀찮은 문제가 있다. 만약 이 글에서 소개하는 동작을 위한 binary serailize를 라이브러리로 만들어 배포한다고 하면 해당 라이브러리 사용자가 build script 수정도 해야 하므로 별로 좋아보이지는 않는다.</p>

<p>둘의 장점을 모두 취해보자. code generator를 사용하지 않고 runtime에 reflection으로 struct의 구조를 파악하여 직접 CLR code를 생성하는 것이다. 즉, <code>Reflection.Emit</code>을 사용하여 <code>Dynamic Invoke</code>를 사용하는 것이다.</p>

<h4>Reflection.Emit</h4>

<p>IL 코드를 직접 다 공부해서 작성하는 방법도 좋지만 일단 c# 프로그램 작성 후 <strong>ILDASM</strong> 프로그램을 사용하여 얻어낸 IL을 기록하는 방법으로 작업하는 것이 편하다.</p>

<p>간단하게 <code>BitConverter</code>를 사용하여 binary로부터 특정 객체를 읽는 코드를 IL로 작성해보면 다음과 같다.</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">method</span> <span class="p">=</span> <span class="k">new</span> <span class="n">DynamicMethod</span><span class="p">(</span><span class="n">methodName</span><span class="p">,</span> <span class="k">typeof</span><span class="p">(</span><span class="n">IData</span><span class="p">),</span>
    <span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="k">typeof</span><span class="p">(</span><span class="kt">byte</span><span class="p">[]),</span> <span class="k">typeof</span><span class="p">(</span><span class="kt">int</span><span class="p">).</span><span class="n">MakeByRefType</span><span class="p">()</span> <span class="p">});</span>
<span class="kt">var</span> <span class="n">generator</span> <span class="p">=</span> <span class="n">method</span><span class="p">.</span><span class="n">GetILGenerator</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">localData</span> <span class="p">=</span> <span class="n">generator</span><span class="p">.</span><span class="n">DeclareLocal</span><span class="p">(</span><span class="n">valueType</span><span class="p">);</span>
<span class="n">generator</span><span class="p">.</span><span class="n">Emit</span><span class="p">(</span><span class="n">OpCodes</span><span class="p">.</span><span class="n">Ldloca_S</span><span class="p">,</span> <span class="n">localData</span><span class="p">);</span>
<span class="n">generator</span><span class="p">.</span><span class="n">Emit</span><span class="p">(</span><span class="n">OpCodes</span><span class="p">.</span><span class="n">Initobj</span><span class="p">,</span> <span class="n">valueType</span><span class="p">);</span>
<span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">field</span> <span class="k">in</span> <span class="n">valueType</span><span class="p">.</span><span class="n">GetFields</span><span class="p">())</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">field</span><span class="p">.</span><span class="n">FieldType</span> <span class="p">!=</span> <span class="k">typeof</span> <span class="p">(</span><span class="kt">string</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="c1">// read and set value</span>
        <span class="n">generator</span><span class="p">.</span><span class="n">Emit</span><span class="p">(</span><span class="n">OpCodes</span><span class="p">.</span><span class="n">Ldloca_S</span><span class="p">,</span> <span class="n">localData</span><span class="p">);</span>
        <span class="n">generator</span><span class="p">.</span><span class="n">Emit</span><span class="p">(</span><span class="n">OpCodes</span><span class="p">.</span><span class="n">Ldarg_0</span><span class="p">);</span>
        <span class="n">generator</span><span class="p">.</span><span class="n">Emit</span><span class="p">(</span><span class="n">OpCodes</span><span class="p">.</span><span class="n">Ldarg_1</span><span class="p">);</span>
        <span class="n">generator</span><span class="p">.</span><span class="n">Emit</span><span class="p">(</span><span class="n">OpCodes</span><span class="p">.</span><span class="n">Ldind_I4</span><span class="p">);</span>
        <span class="n">generator</span><span class="p">.</span><span class="n">Emit</span><span class="p">(</span><span class="n">OpCodes</span><span class="p">.</span><span class="n">Call</span><span class="p">,</span> <span class="n">BitConverterMap</span><span class="p">[</span><span class="n">field</span><span class="p">.</span><span class="n">FieldType</span><span class="p">]);</span>
        <span class="n">generator</span><span class="p">.</span><span class="n">Emit</span><span class="p">(</span><span class="n">OpCodes</span><span class="p">.</span><span class="n">Stfld</span><span class="p">,</span> <span class="n">field</span><span class="p">);</span>

        <span class="c1">// increase offset</span>
        <span class="n">generator</span><span class="p">.</span><span class="n">Emit</span><span class="p">(</span><span class="n">OpCodes</span><span class="p">.</span><span class="n">Ldarg_1</span><span class="p">);</span>
        <span class="n">generator</span><span class="p">.</span><span class="n">Emit</span><span class="p">(</span><span class="n">OpCodes</span><span class="p">.</span><span class="n">Dup</span><span class="p">);</span>
        <span class="n">generator</span><span class="p">.</span><span class="n">Emit</span><span class="p">(</span><span class="n">OpCodes</span><span class="p">.</span><span class="n">Ldind_I4</span><span class="p">);</span>
        <span class="n">generator</span><span class="p">.</span><span class="n">Emit</span><span class="p">(</span><span class="n">OpCodes</span><span class="p">.</span><span class="n">Ldc_I4</span><span class="p">,</span> <span class="n">TypeSizeMap</span><span class="p">[</span><span class="n">field</span><span class="p">.</span><span class="n">FieldType</span><span class="p">]);</span>
        <span class="n">generator</span><span class="p">.</span><span class="n">Emit</span><span class="p">(</span><span class="n">OpCodes</span><span class="p">.</span><span class="n">Add</span><span class="p">);</span>
        <span class="n">generator</span><span class="p">.</span><span class="n">Emit</span><span class="p">(</span><span class="n">OpCodes</span><span class="p">.</span><span class="n">Stind_I4</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="c1">// 생략</span>
<span class="p">}</span>
<span class="n">generator</span><span class="p">.</span><span class="n">Emit</span><span class="p">(</span><span class="n">OpCodes</span><span class="p">.</span><span class="n">Ldloc_0</span><span class="p">);</span>
<span class="n">generator</span><span class="p">.</span><span class="n">Emit</span><span class="p">(</span><span class="n">OpCodes</span><span class="p">.</span><span class="n">Box</span><span class="p">,</span> <span class="n">valueType</span><span class="p">);</span>
<span class="n">generator</span><span class="p">.</span><span class="n">Emit</span><span class="p">(</span><span class="n">OpCodes</span><span class="p">.</span><span class="n">Ret</span><span class="p">);</span>
</code></pre></div>
<p>지정된 type의 field를 순회하면서 그에 맞는 <code>BitConverter</code>의 함수를 호출한 후 값을 field에 넣어주는 코드이다. 만약 잘못 작성할 경우 <code>InvalidProgramException</code>이 발생하게 된다. 여러 type을 다루어야 할 수 있으므로 반환 시 boxing을 해줬다.</p>

<p>위와 같이 코드를 작성하고 <code>CreateDelegate()</code>로 delegate를 생성하면 다음과 같이 쓸 수 있다.</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="k">delegate</span> <span class="n">IData</span> <span class="nf">BinReader</span><span class="p">(</span><span class="kt">byte</span><span class="p">[]</span> <span class="n">bytes</span><span class="p">,</span> <span class="k">ref</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">);</span>
<span class="kt">var</span> <span class="n">reader</span> <span class="p">=</span> <span class="p">(</span><span class="n">BinReader</span><span class="p">)</span><span class="n">method</span><span class="p">.</span><span class="n">CreateDelegate</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">BinReader</span><span class="p">));</span>
<span class="kt">var</span> <span class="n">offset</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">offset</span> <span class="p">&lt;</span> <span class="n">bytes</span><span class="p">.</span><span class="n">Length</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">items</span><span class="p">.</span><span class="n">Add</span><span class="p">((</span><span class="n">ItemData</span><span class="p">)</span> <span class="n">reader</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="k">ref</span> <span class="n">offset</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>
<p>Reflection.Emit 관련된 내용을 여기서 서술하면 너무 길어질 수 있으므로 일단 넘어가도록 하겠다.</p>

<ul>
<li><a href="http://www.codeproject.com/Articles/13337/Introduction-to-Creating-Dynamic-Types-with-Reflec">Codeproject: Introduction to Creating Dynamic Types with Reflection.Emit</a></li>
<li><a href="http://www.codeproject.com/Articles/13969/Introduction-to-Creating-Dynamic-Types-with-Refl">Codeproject: Introduction to Creating Dynamic Types with Reflection.Emit: Part 2</a></li>
<li><a href="http://www.codeproject.com/Articles/9927/Fast-Dynamic-Property-Access-with-C">Codeproject: Fast Dynamic Property Access with C#</a></li>
</ul>

<h4>마무리</h4>

<p>단순히 데이터를 binary로 serialize하는 것을 넘어 data server를 구현하거나, 보다 일반적인 라이브러리를 위한 Reflection.Emit까지 다뤄보았다.</p>

<p>데이터를 처리함에 있어서 당연히 데이터베이스를 사용하면 좋갰지만, </p>

<ul>
<li>굳이 그럴 필요가 없는 정적인 데이터 (데이터시트 등)</li>
<li>가공된 데이터에 대한 cache</li>
<li>데이터베이스의 규격으로 담기 힘든 데이터</li>
</ul>

<p>등에 대해서는 위와 같은 방법으로 간단히 데이터 서버를 구축해서 사용하는 것도 괜찮지 않을까 생각한다. 일종의 <a href="http://en.wikipedia.org/wiki/Data_virtualization">Data Virtualization</a> 인 셈이다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">왜 c#으로 서버를 작성하려 하나?</h1>
				<p class="page-date">30 Jun 2014</p>
				<p class="page-tags">
						
						
					<code class="tag">c#</code>
						
						
						
					<code class="tag">server</code>
						
						
						
						
				</p>
				<div class="content"><p>본 글은 동아리 친구의 질문인 <em>&#39;왜 게임 서버를 c++이 아닌 c#으로 작성하려 하냐?&#39;</em>에 대한 답변이다.</p>

<p>간단히 c++과 c#의 차이를 통해 답변하면 이렇다.</p>

<ul>
<li>c++은 속도가 빠르다.</li>
<li>c#은 기본 라이브러리가 풍부하다.</li>
<li>c#은 표현력이 좋다. linq나 reflection의 도움을 받을 수도 있다.</li>
<li>c#은 native에서 벌어지는 access violation 등으로부터 다소 안전하다.</li>
</ul>

<p>즉, c#으로 프로그래밍할 경우 c++로 할 때에 비해서 보다 편하게, 보다 안전하게 프로그래밍을 할 수 있다고 생각한다. 그렇기 때문에 c#으로 작성한다고 답변한 것이다. (물론 도메인에 의한 판단이 우선이다. 속도가 중요한 서버인데 c#으로 짜라는 고집을 부리지는 않는다.)</p>

<p>게임 서버를 구현한다고 해보자. 게임 서버는 게임 + 서버이므로, 클라이언트를 처리하는 서버적 기능과 게임이적 요소를 포함하면 되겠다. 대충 다음과 같이 분류할 수 있을 것 같다.</p>

<ul>
<li>network: 클라이언트의 요청을 처리해야 한다.</li>
<li>persistence: 클라이언트의 정보를 저장해야 한다.</li>
<li>logging: 클라이언트의 행적을 기록하고 운영 대응을 해야 한다.</li>
<li>logic: 게임 내용을 위한 요소들(npc, 시야, 전투, 커뮤니티, 기타 컨텐츠 등)</li>
</ul>

<p>요소별로 생각해보자.</p>

<ul>
<li>network 코드는 기반 network 코드와 message handler 코드로 나눌 수 있다.

<ul>
<li>기반 network 코드는 message를 주고받는 부분이나, byte stream을 암호화하는 부분 등으로 나눌 수 있다.</li>
<li>message handler는 message를 설계하고 handler 코드를 구현/등록하는 부분으로 나눌 수 있다.</li>
</ul></li>
<li>persistence는 게임 object에 대한 crud에 대한 코드가 있다.</li>
<li>logging은 게임 object 혹은 content에 대해 기록을 남기는 코드일 것이다.</li>
<li>logic 코드는 데이터를 읽거나 상황을 판단해서 content 별로 적절히 처리하는 코드일 것이다.</li>
</ul>

<p>network나 message 쪽 코드는 워낙 generator도 많고 좋은 추상화된 라이브러리도 많아서 c++이나 c#이나 크게 차이가 없을 수 있겠다. c++도 protobuf에 asio 붙이면 코드가 그렇게 끔찍하지는 않다고 생각한다. 하지만 c#에서는 딱히 라이브러리 안 붙여도 core 코드를 적은 줄에 쉽게 작성할 수 있다. (약간의 성능을 포기하고 async/await을 쓰면 더 짧아진다.)</p>

<p>persistence 쪽 코드나 logging 코드는 (경험상) bolierplate 코드가 많았기 때문에 무의미한 반복 코딩을 하게되는 경우가 많았다. 하지만 이 쪽도 c++아니 c#이나 ORM이나 code generation 등으로 어느 정도 귀찮음을 줄일 수 있으므로 큰 차이가 없다고 생각할 수도 있겠다. (개인적으로는 reflection이 있기 때문에 c# 쪽이 더 편리한 점이 많다고 생각한다.)</p>

<p>하지만 위 부분들은 모두 전체 서버 코드에 큰 비율을 차지하지 않는다. 가장 많이 작성해야 하는 부분은 logic 코드 부분이다. 이 부분에서는 대부분 <em>데이터를 탐색하거나</em>, <em>연산을 하거나</em>, <em>객체를 가져와서 변경하는</em> 작업을 주로한다. 이러한 코드를 작성함에 있어 <del>과도할 정도로</del> 표현력이 풍부한 c#이 아무래도 c++보다 코딩하기 낫다고 생각하는 것이다.</p>

<p>요약하면 그냥 c#으로 두 줄 작성하면 되는 것을 c++로 작성하려면 열 줄, 스무 줄로 늘어나니 귀찮다는 것. 그래서 <em>가능하다면</em> <strong>c++보다는 c#으로 작성할 것</strong>이다.</p>

<h4>성능?</h4>

<p>약간 다른 이야기지만 c++과 c#의 성능 비교 이야기를 해보자. 현재 내가 알고 있는 범위에서 c#이 느린 부분은 다음과 같다.</p>

<ul>
<li>native에 비해 기본 연산이 느리다. 물론 그렇겠지만 JIT가 돌아가는 마당이니 큰 차이는 없다.</li>
<li>async/await가 느리다. DefaultTaskScheduler가 좀 대충 만들어져서 느린데 고쳐서 쓰거나 그냥 AsyncIO를 쓰면 어느 정도 회피할 수 있기는 하다.</li>
<li><strong>gc가 돌면 세상이 멈춘다.</strong></li>
</ul>

<p>c++에서 하던 식으로 모든 객체를 메모리에 올려두는 식으로 프로그래밍하다 보면 당연히 gen2에 쌓이는 객체가 많아진다. 때문에 gen2를 탐색하는 gc가 수행될 때 서버의 전체적인 throughput이 크게 떨어지는 문제가 발생할 수도 있다. 물론 <a href="http://msdn.microsoft.com/en-us/library/ee787088.aspx#concurrent_garbage_collection">concurrent gc</a>를 사용하거나, <a href="http://msdn.microsoft.com/en-us/library/ee787088.aspx#workstation_and_server_garbage_collection">server gc</a>를 잘 튜닝해서 사용하면 문제를 어느 정도 회피할 수 있다고는 하지만 간단해 보이지는 않는다.</p>

<p>gen2로 가는 객체의 수를 줄이는 것이 관건인데 이게 또 간단하지 않다.</p>

<ul>
<li>동접이 5,000명이라면 적어도 유저 객체 5,000개를 메모리에 올려놔야 한다는 것인데, 각 유저 객체마다 <code>Dictionary</code>나 <code>List</code>를 갖기 시작하면 그 내에서도 파편화된 수 많은 객체들이 존재할 수 있기 때문이다.</li>
<li>또한 게임 서버에서 사용되는 데이터들에 대해서도 서버 구동 시 미리 읽어두는 경우가 많은데 이 객체들이 모두 gen2로 넘어가게 된다.</li>
</ul>

<p>이들을 최적화하는 방법을 찾아야 좀 제대로된 서버를 만들 수 있을 것이다. 이 때문에 c++/cli 영역에서 메모리를 할당한 후 그것을 사용하는 사람도 있었고, 아니면 단순히 python으로 갈아타는 사람도 있었다.</p>

<p>위 문제를 열심히 고민하고 있는데 적절한 해결책을 찾지 못했다. 좀 더 고민해봐야 겠다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1><a id="c++" href="#c++">c++</a></h1>
				<hr />
				<div class="page-breaker"></div>
							
						
				<h1 class="page-title">c++ message dispatcher</h1>
				<p class="page-date">16 Nov 2013</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
					<code class="tag">template</code>
						
						
						
					<code class="tag">study</code>
						
						
						
						
				</p>
				<div class="content"><p>간단한 message dispatch 코드를 c++로 구현해보자. 일단 <code>std::function</code>을 안 쓰고 구현해보고, 그 다음에 <code>std::function</code>을 써서 구현해보자.</p>

<p>지난 번 글에서 <code>functor_ii</code>로 <code>handler_t</code>의 근간을 이미 설명했다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="kt">handler_t</span> <span class="p">{</span>
    <span class="kt">handler_t</span><span class="p">()</span>
        <span class="o">:</span> <span class="n">_impl</span><span class="p">(</span><span class="n">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">}</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
    <span class="kt">handler_t</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">_impl</span><span class="p">(</span><span class="k">new</span> <span class="kt">impl_t</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">))</span> <span class="p">{}</span>

    <span class="n">R</span> <span class="k">operator</span> <span class="p">()</span> <span class="p">(</span><span class="n">T</span> <span class="n">arg</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">_impl</span><span class="p">)(</span><span class="n">arg</span><span class="p">);</span>
    <span class="p">}</span>
<span class="nl">private:</span>
    <span class="k">struct</span> <span class="kt">wrapper_t</span> <span class="p">{</span>
        <span class="k">virtual</span> <span class="n">R</span> <span class="k">operator</span> <span class="p">()</span> <span class="p">(</span><span class="n">T</span> <span class="n">arg</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="kt">impl_t</span> <span class="o">:</span> <span class="k">public</span> <span class="kt">wrapper_t</span> <span class="p">{</span>
        <span class="kt">impl_t</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">)</span>
            <span class="o">:</span> <span class="n">_f</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="p">{}</span>
        <span class="k">virtual</span> <span class="n">R</span> <span class="k">operator</span> <span class="p">()</span> <span class="p">(</span><span class="n">T</span> <span class="n">arg</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">_f</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">F</span> <span class="n">_f</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">wrapper_t</span><span class="o">&gt;</span> <span class="n">_impl</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>interface인 <code>wrapper_t</code>, 실 구현체인 <code>impl_t</code>, 그리고 그것을 멤버로 갖는 type erasure가 적용된 대표 type인 <code>handler_t</code>이다. 1개의 인자와 반환 값을 가질 수 있으므로 이를 template parameter인 <code>R</code>과 <code>T</code>로 표현한 것이다.</p>

<p>각 message handler가 받을 message의 최상위 class를 만들고, 추후 코딩을 편하게 하기 위해 handler에 대한 typedef를 걸어준다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="kt">message_t</span> <span class="p">{</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="kt">message_t</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="kt">handler_t</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">,</span> <span class="k">const</span> <span class="kt">message_t</span><span class="o">&amp;&gt;</span> <span class="kt">msg_handler_t</span><span class="p">;</span>
</code></pre></div>
<p>이제 모든 작업이 완료되었다. <code>msg_handler_t</code>에 대한 <a href="http://en.cppreference.com/w/cpp/container/unordered_map">unordered_map</a> 객체 만들고, 적절히 불러주기만 하면 된다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">msg_handler_t</span><span class="o">&gt;</span> <span class="n">__handler_table</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">dispatch</span><span class="p">(</span><span class="kt">int</span> <span class="n">opcode</span><span class="p">,</span> <span class="k">const</span> <span class="kt">message_t</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">__handler_table</span><span class="p">[</span><span class="n">opcode</span><span class="p">](</span><span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p><code>std::function</code>을 사용할 경우 template parameter만 function type으로 넣어서 <code>msg_handler_t</code>에 대한 typedef을 바꿔주면 된다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span> <span class="p">(</span><span class="k">const</span> <span class="kt">message_t</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="kt">msg_handler_t</span><span class="p">;</span>
</code></pre></div>
<p>표준 라이브러리에서 인자를 저렇게 받는 이유는 저 표현식이 단순히 반환 타입, 인자 타입을 나열하는 것에 비해 더 가독성이 좋다고 판단했기 때문이다. 저렇게 받은 인자는 내부에서 <code>function_traits</code>에 의해 다시 반환 타입과 인자 타입이 분리되어 결국 <code>handler_t</code>와 같은 구현을 하게 된다.</p>

<p>위와 같이 코드를 구현하면 조금 아쉬운 점이 있다. 예를 들어 <code>message_t</code>를 상속받은 <code>int_msg_t</code>와 <code>string_msg_t</code>가 있다고 하자. 그리고 이를 처리하는 <code>int_msg_handler</code>, <code>string_msg_handler</code>가 있을 때 코드는 다음과 같다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">int_msg_handler</span><span class="p">(</span><span class="k">const</span> <span class="kt">message_t</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">int_msg_t</span><span class="o">&amp;</span> <span class="n">msg</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">int_msg_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
    <span class="c1">// do something with int_msg</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">string_msg_handler</span><span class="p">(</span><span class="k">const</span> <span class="kt">message_t</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">string_msg_t</span><span class="o">&amp;</span> <span class="n">msg</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">string_msg_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
    <span class="c1">// do something with string_msg</span>
<span class="p">}</span>
<span class="k">enum</span> <span class="n">msg_id</span> <span class="p">{</span>
    <span class="n">int_msg_id</span><span class="p">,</span>
    <span class="n">string_msg_id</span><span class="p">,</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">__handler_table</span><span class="p">[</span><span class="n">int_msg_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">int_msg_handler</span><span class="p">;</span>
    <span class="n">__handler_table</span><span class="p">[</span><span class="n">string_msg_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">string_msg_handler</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>먼저, 각 handler의 type은 모두 <code>void (const message_t&amp;)</code> 이기 때문에 실제 우리가 원하는 type으로 인자를 받을 수가 없다. 따라서 매번 casting해주는 과정이 필요하다.</li>
<li>그리고 각 msg가 추가될 때마다 <code>msg_id</code> 값을 정의해주어야 한다.</li>
<li>마지막으로 구현한 handler를 handler_table에다가 등록해주는 코드를 작성해야 한다.</li>
</ul>

<p>일단 <code>msg_id</code> 문제를 해결해보자. 여러가지 방법이 있겠지만 귀찮으니 <a href="http://en.cppreference.com/w/cpp/types/type_index">type_index</a>를 사용하자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">type_index</span><span class="p">,</span> <span class="kt">msg_handler_t</span><span class="o">&gt;</span> <span class="n">__handler_table</span><span class="p">;</span>
</code></pre></div>
<p><code>message_t</code>를 받는 함수와 원하는 type을 받는 함수를 분리하고, <code>__handler_table</code>에 함수를 프로그램 시작 시에 등록하기 위해 static 전역 변수를 사용해 코드를 정리하면 다음과 같다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Ty</span><span class="o">&gt;</span>
<span class="k">const</span> <span class="n">_Ty</span><span class="o">&amp;</span> <span class="n">cast</span><span class="p">(</span><span class="k">const</span> <span class="kt">message_t</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">_Ty</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">int_msg_handler</span><span class="p">(</span><span class="k">const</span> <span class="kt">int_msg_t</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">_int_msg_wrapper</span><span class="p">(</span><span class="k">const</span> <span class="kt">message_t</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">int_msg_handler</span><span class="p">(</span><span class="n">cast</span><span class="o">&lt;</span><span class="kt">int_msg_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">));</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">int_msg_handler</span><span class="p">(</span><span class="k">const</span> <span class="kt">int_msg_t</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// do something with int_msg_t</span>
<span class="p">}</span>
<span class="k">static</span> <span class="k">struct</span> <span class="kt">_table_register_t</span> <span class="p">{</span>
    <span class="kt">_table_table_t</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">__handler_table</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span>
            <span class="n">std</span><span class="o">::</span><span class="n">type_index</span><span class="p">(</span><span class="k">typeid</span><span class="p">(</span><span class="kt">int_msg_t</span><span class="p">)),</span> <span class="n">_int_msg_wrapper</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="n">__register1</span><span class="p">;</span>
</code></pre></div>
<p>일단 편하게 message를 casting하기 위한 cast 함수를 만들었다. 그냥 const reference 지키면서 static_cast를 해주는 함수이다.</p>

<ul>
<li>dynamic_cast를 하지 않은 이유는 항상 올바른 type만 casting을 요청할 것이라는 믿음을 갖고 불필요한 검사를 피하기 위함이다</li>
<li><code>_Ty</code>가 정말 <code>message_t</code>를 상속받았는지 보려면 <a href="http://en.cppreference.com/w/cpp/types/is_base_of">std::is_base_of</a>를 쓰면 되겠다.</li>
</ul>

<p>실제 작업을 수행할 함수인 <code>int_msg_handler</code>를 선언한다. 그리고 전달 함수인 <code>_int_msg_wrapper</code> 함수를 작성한다. <code>_int_msg_wrapper</code> 함수에서는 <code>message_t</code>를 <code>int_msg_t</code>로 casting만 해서 <code>int_msg_handler</code> 함수로 넘겨준다. 그리고 실질적인 작업은 <code>int_msg_handler</code>에서 <code>int_msg_t</code>를 인자로 받아 처리하게 된다.</p>

<p>프로그램 시작과 동시에 <code>__handler_table</code>에 등록하는 가장 좋은 방법은 전역 객체의 생성자를 사용하는 방법이다. 전역으로 정의된 객체의 생성자는 프로그램 시작 시에 호출된다는 점을 이용하는 것이다. 따라서 전역 객체 <code>__register1</code>를 정의한다. 그러면 프로그램 시작 시 <code>_table_register_t</code>의 생성자가 호출되고, 그 생성자에서 <code>__handler_table</code>에게 <code>int_msg_t</code>에 대한 <code>type_index</code>와 <code>_int_msg_wrapper</code>를 넣어주면 된다.</p>

<p>그런데 위 코드를 보면 <code>int_msg_t</code>에 해당하는 부분을 <code>string_msg_t</code>로 치환했을 때, <code>string_msg_t</code>를 위해서도 사용할 수 있는 것을 확인할 수 있다. 즉, <strong>대부분의 코드가 무의미하게 반복된다는 것이다</strong>. 이러한 boilerplate code를 적절히 제거하기 위해 반복되는 부분을 다음과 같이 macro로 묶어내자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Ty</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="kt">table_register_t</span> <span class="p">{</span>
    <span class="kt">table_register_t</span><span class="p">(</span><span class="kt">msg_handler_t</span> <span class="n">handler</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">handler_table</span><span class="p">().</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">type_index</span><span class="p">(</span><span class="k">typeid</span><span class="p">(</span><span class="n">_Ty</span><span class="p">)),</span> <span class="n">handler</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="cp">#define HANDLER(msg_type) \</span>
<span class="cp">    static void msg_type##_handler(const msg_type&amp; msg); \</span>
<span class="cp">    static void _##msg_type##_wrapper(const message_t&amp; m) { \</span>
<span class="cp">        msg_type##_handler(cast&lt;msg_type&gt;(m)); \</span>
<span class="cp">    } \</span>
<span class="cp">    static table_register_t&lt;msg_type&gt; __reg_##msg_type##(_##msg_type##_wrapper); \</span>
<span class="cp">    static void msg_type##_handler(const msg_type&amp; msg)</span>
</code></pre></div>
<p>이제 다음과 같이 사용할 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="kt">int_msg_t</span> <span class="o">:</span> <span class="k">public</span> <span class="kt">message_t</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">HANDLER</span><span class="p">(</span><span class="kt">int_msg_t</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">msg</span><span class="p">.</span><span class="n">a</span> <span class="o">+</span> <span class="n">msg</span><span class="p">.</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>이제 message를 하나 만들어서 날려보자. 이를 처리하는 dispatch 함수는 다음과 같이 간단하게 작성할 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Ty</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">dispatch</span><span class="p">(</span><span class="k">const</span> <span class="n">_Ty</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">__handler_table</span><span class="p">[</span><span class="n">std</span><span class="o">::</span><span class="n">type_index</span><span class="p">(</span><span class="k">typeid</span><span class="p">(</span><span class="n">_Ty</span><span class="p">))](</span><span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int_msg_t</span> <span class="n">msg</span><span class="p">;</span>
    <span class="n">msg</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="n">msg</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
    <span class="n">dispatch</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>아무 message 객체나 받아서 그 <code>type_index</code>로 적절한 handler를 
찾고, 그 handler에게 message 객체를 넘겨서 처리될 수 있도록 하는 것이다.</p>

<p>하지만 위 코드에는 문제가 있다. 전역 <code>table_register_t</code> 객체와 <code>__handler_table</code> 객체가 다른 번역 단위에 있을 경우, 두 객체의 생성자가 불리는 시점이 undefined이기 때문에 아직 <code>__handler_table</code> 객체가 초기화되지 않은 시점에서 register를 수행하다가 프로그램이 죽는 문제이다.</p>

<p>이 문제를 해결하는 가장 쉬운 방법은 <code>handler_table</code> 객체를 전역 변수 말고 singleton으로 만드는 것이다. 원칙적으로 singleton 객체는 처음 접근할 때 생성되기 때문에, 어떤 register 객체든 <code>handler_table</code> 객체를 처음 접근하는 때 <code>handler_table</code> 객체를 생성하게 되니 위 문제를 해결할 수 있다.</p>

<p>그리고 c++11에서는 간단하게 singleton을 구현할 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kr">inline</span> <span class="kt">handler_table_t</span><span class="o">&amp;</span> <span class="n">handler_table</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">static</span> <span class="kt">handler_table_t</span> <span class="n">_handler_table</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">_handler_table</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>코드 전문은 다음과 같다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="kt">message_t</span> <span class="p">{</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="kt">message_t</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span> <span class="p">(</span><span class="k">const</span> <span class="kt">message_t</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="kt">msg_handler_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">type_index</span><span class="p">,</span> <span class="kt">msg_handler_t</span><span class="o">&gt;</span> <span class="kt">handler_table_t</span><span class="p">;</span>

<span class="kr">inline</span> <span class="kt">handler_table_t</span><span class="o">&amp;</span> <span class="n">handler_table</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">static</span> <span class="kt">handler_table_t</span> <span class="n">_handler_table</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">_handler_table</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Ty</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="k">const</span> <span class="n">_Ty</span><span class="o">&amp;</span> <span class="n">cast</span><span class="p">(</span><span class="k">const</span> <span class="kt">message_t</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">_Ty</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Ty</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="kt">table_register_t</span> <span class="p">{</span>
    <span class="kt">table_register_t</span><span class="p">(</span><span class="kt">msg_handler_t</span> <span class="n">handler</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">handler_table</span><span class="p">().</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">type_index</span><span class="p">(</span><span class="k">typeid</span><span class="p">(</span><span class="n">_Ty</span><span class="p">)),</span> <span class="n">handler</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="cp">#define HANDLER(msg_type) \</span>
<span class="cp">    static void msg_type##_handler(const msg_type&amp; msg); \</span>
<span class="cp">    static void _##msg_type##_wrapper(const message_t&amp; m) { \</span>
<span class="cp">        msg_type##_handler(cast&lt;msg_type&gt;(m)); \</span>
<span class="cp">    } \</span>
<span class="cp">    static table_register_t&lt;msg_type&gt; __register_##msg_type##(_##msg_type##_wrapper); \</span>
<span class="cp">    static void msg_type##_handler(const msg_type&amp; msg)</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Ty</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">dispatch</span><span class="p">(</span><span class="k">const</span> <span class="n">_Ty</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">handler_table</span><span class="p">()[</span><span class="n">std</span><span class="o">::</span><span class="n">type_index</span><span class="p">(</span><span class="k">typeid</span><span class="p">(</span><span class="n">_Ty</span><span class="p">))](</span><span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>그리고 main 함수에서는 다음과 같이 사용한다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="kt">int_msg_t</span> <span class="o">:</span> <span class="k">public</span> <span class="kt">message_t</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">HANDLER</span><span class="p">(</span><span class="kt">int_msg_t</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">msg</span><span class="p">.</span><span class="n">a</span> <span class="o">+</span> <span class="n">msg</span><span class="p">.</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int_msg_t</span> <span class="n">msg</span><span class="p">;</span>
    <span class="n">msg</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="n">msg</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
    <span class="n">dispatch</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h3>정리</h3>

<p>이번 과제에서는 간단하게 c++의 message dispatch 코드를 구현해보았다. 위와 같은 코드는 queue를 붙여서 message pattern이나 event pattern을 구현할 때 쓰이거나 네트워크를 붙여서 서버의 packet dispatch 코드로도 사용된다. 언듯 보면 복잡해보일 수도 있으나 실상은 function map이고, 여기저기서 자주 만나게 될 개념이니 이번 기회에(?) 익숙해지도록 하자.</p>

<p>추가 과제였던 reflection 과제에 대한 풀이는 예전에 작성한 글에 대한 링크로 대신하겠다.</p>

<ul>
<li><a href="/2012/06/04/using-reflection-at-cpp-2/">c++에서 reflection 사용하기 2</a></li>
<li><a href="/2012/06/09/using-reflection-at-cpp-3/">c++에서 reflection 사용하기 3</a></li>
</ul>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">c++ 에서 구조체 RTTI 정보 남기기</h1>
				<p class="page-date">30 Sep 2011</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
						
				</p>
				<div class="content"><p>RTTI는 Run-time Type Information의 약자로, 실행 중에 어떤 type에 대한 정보를 알 수 있다는 것이다. 보통 type 에 대한 정보는 컴파일 타임에 다 사용되고, 실행 중에는 없어지는데, 실행 중에 이 정보를 얻을 수 있으면 재밌는 일을 많이 할 수 있다.</p>

<p>Java나 C#, 아니면 여타 동적 언어들은 당연히 이 기능을 지원하고 (보통 reflection 이라고 한다)
C, C++ 은 당연히 지원 안한다. 실행 중에 뭔가 정보를 더 남긴다는 것은 메모리도 많이 먹고 참조하려면 속도도 느려지니까!</p>

<p>그래서 구조체에 있는 정보만으로 xml read/write 가 자동으로 이루어지려면,
1. 타입 정보를 runtime 에 접근해서 동적으로 read/write 를 한다.
2. xml read/write 코드를 generator 를 통해 찍어낸다.</p>

<p>보통 성능을 위해 2번을 쓰지만 본 글에서는 1번 방법에 대해 서술하겠다.</p>

<h3>tstring</h3>

<p>RTTI는 string을 통해 각 정보를 가져오는 것이므로 먼저 char, wchar로부터 자유로워야 한다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">namespace</span> <span class="n">std</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="n">wstring</span>  <span class="n">tstring</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">wostream</span> <span class="n">tostream</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">wistream</span> <span class="n">tistream</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3>field info</h3>

<p>간단하게 type의 종류를 정의해보자. 여러 타입이 있겠지만 귀찮으니까 int, float만 정의하자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">enum</span> <span class="kt">type_t</span> <span class="p">{</span> <span class="n">NONE</span><span class="p">,</span> <span class="n">INT</span><span class="p">,</span> <span class="n">FLOAT</span> <span class="p">};</span>
</code></pre></div>
<p>구조체의 각 변수 정보를 남기기 위해 그 정보를 저장할 자료를 선언하자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="n">var_info</span>
<span class="p">{</span>
    <span class="n">var_info</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">tstring</span><span class="o">&amp;</span> <span class="n">_name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">type_t</span><span class="o">&amp;</span> <span class="n">_type</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">_offset</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">name</span> <span class="p">(</span><span class="n">_name</span><span class="p">),</span> <span class="n">type</span> <span class="p">(</span><span class="n">_type</span><span class="p">),</span> <span class="n">offset</span> <span class="p">(</span><span class="n">_offset</span><span class="p">)</span> <span class="p">{}</span>

    <span class="n">var_info</span> <span class="p">(</span><span class="k">const</span> <span class="n">var_info</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">name</span> <span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">name</span><span class="p">),</span> <span class="n">type</span> <span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">type</span><span class="p">),</span> <span class="n">offset</span> <span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">offset</span><span class="p">)</span> <span class="p">{}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">tstring</span> <span class="n">name</span><span class="p">;</span>
    <span class="kt">type_t</span>       <span class="n">type</span><span class="p">;</span>
    <span class="kt">size_t</span>       <span class="n">offset</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tstring</span><span class="p">,</span> <span class="n">var_info</span><span class="o">&gt;</span> <span class="kt">varmap_t</span><span class="p">;</span>
</code></pre></div>
<p>구조체 내의 변수의 이름과 타입 정보를 갖는 것은 당연하다.<br>
그런데 offset이라는 정보도 필요하다. 왜냐하면 xml read 를 수행할 때 읽은 데이터를 객체의 <strong>어느 공간</strong> 에 넣어야 할 지 그 위치를 계산해서 넣어야 하기 때문이다. 따라서 메모리 상에 그 변수가 객체의 시작 지점으로부터 얼마만큼 떨어져서 위치하는가를 알고 있어야 한다.</p>

<h3>struct info</h3>

<p>이제 구조체 정보를 저장해보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="n">struct_info</span>
<span class="p">{</span>
    <span class="n">struct_info</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">tstring</span><span class="o">&amp;</span> <span class="n">_name</span><span class="p">)</span> <span class="o">:</span> <span class="n">name</span> <span class="p">(</span><span class="n">_name</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">struct_info</span> <span class="p">(</span><span class="k">const</span> <span class="n">struct_info</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">)</span> <span class="o">:</span> <span class="n">name</span> <span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">struct_info</span> <span class="p">()</span> <span class="p">{}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">tstring</span> <span class="n">name</span><span class="p">;</span>
    <span class="kt">varmap_t</span> <span class="n">varmap</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>그냥 단순히 구조체에 대한 이름과 구조체에 대한 변수 목록을 map 객체로 갖고 있다.</p>

<h3>rtti</h3>

<p>rtti라는 단순한 객체를 정의해보자. 단순히 이건 각 구조체 이름에 대응되는 <code>struct_info</code> 객체를 갖고 있으면 되니까 map 이면 충분하다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tstring</span><span class="p">,</span> <span class="n">struct_info</span><span class="o">&gt;</span> <span class="kt">rtti_t</span><span class="p">;</span>
<span class="kt">rtti_t</span> <span class="n">rtti</span><span class="p">;</span>
</code></pre></div>
<h3>offset_of</h3>

<p>구조체 내의 어떤 변수가 구조체 객체의 시작 주소로부터 얼마나 떨어져 있나를 계산하는 것은 간단하다.
시작 주소를 0으로 만든 뒤 그 변수의 주소를 가져오면 되기 때문이다. 따라서 다음과 같은 매크로를 만들 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#define OFFSET_OF(_struct, _var) ((size_t) &amp;(((_struct *) NULL)-&gt;_var))</span>
</code></pre></div>
<p><code>NULL</code>을 구조체 주소로 casting해서 그 변수를 접근한다. 하지만 접근해서 값을 쓰는게 아니라 단순히 &amp; 연산자로 주소 값만 얻으니까 access violation은 없다. 그리고 저 주소 값이 얼마만큼 떨어졌는지의 값(offset)이다.</p>

<h3>DSEL</h3>

<p>이제 구조체를 정의하는 매크로를 만들어야 한다.
이게 약간 문제가 있는데, 본 문제를 출제한 <a href="http://libsora.so/" title="libsora.so">if1live</a>님의 요구 사항은 아래와 같다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">STRUCT_BEGIN</span><span class="p">(</span><span class="n">SampleStruct</span><span class="p">)</span>
    <span class="n">STRUCT_VAR_FLOAT</span><span class="p">(</span><span class="n">SampleStruct</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">STRUCT_VAR_INT</span><span class="p">(</span><span class="n">SampleStruct</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">STRUCT_END</span><span class="p">()</span>
</code></pre></div>
<p>보통 프로그램의 시작과 함께 초기화되는 정보를 구성할 경우에는 전역 변수를 많이 쓴다. 예를 들면,</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="n">__temp</span> <span class="p">{</span>
    <span class="n">__temp</span> <span class="p">()</span> <span class="p">{</span> <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;hello world!&quot;</span><span class="p">);</span> <span class="p">}</span>
<span class="p">}</span> <span class="n">___temp</span><span class="p">;</span>
</code></pre></div>
<p>와 같이 <code>__temp</code>라는 struct를 정의해서 <code>___temp</code> 라는 전역 변수를 만든다. 전역 변수는 프로그램이 시작될 때 초기화되고, 이 때 생성자가 불리면서 hello world 가 출력될 것이다.</p>

<p>하지만 구조체 각 변수는 구조체의 { } scope 안에 존재하기 때문에 전역 변수를 사용할 수 없는 공간이다. 따라서 좀 다른 방법을 써야한다.</p>

<p>구조체 내의 멤버 변수들은 구조체 객체가 처음 생성될 때, 그 생성자가 호출된다. 예를 들면,</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="n">Sample</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">__temp</span> <span class="p">{</span>
        <span class="n">__temp</span> <span class="p">()</span> <span class="p">{</span> <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;hello world&quot;</span><span class="p">);</span> <span class="p">}</span>
    <span class="p">}</span> <span class="n">___temp</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>위와 같이 <code>Sample</code> 구조체를 정의했다. 저 <code>Sample</code>의 변수를 하나라도 만드는 순간,
<code>Sample</code> 구조체 내의 변수들이 초기화된다. <code>___temp</code> 변수도 초기화된다. 따라서 <code>__temp</code>의 생성자가 호출된다. 따라서 <code>Sample</code> 구조체의 instance를 만들 때 마다 우리는 hello world를 볼 수 있을 것이다.</p>

<p>중복 실행을 막으려면 어떻게 해야할까? 간단히 static 변수를 하나 쓰면 된다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="n">Sample</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">__temp</span> <span class="p">{</span>
        <span class="n">__temp</span> <span class="p">()</span> <span class="p">{</span> 
            <span class="k">static</span> <span class="kt">bool</span> <span class="n">once</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">once</span><span class="p">)</span>
                <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;hello world&quot;</span><span class="p">);</span>
            <span class="n">once</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="n">___temp</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>그러면 hello world는 <code>Sample</code> 객체를 처음 만들 때는 나오겠지만 그 다음부터는 안 나올 것이다.
이 방법을 사용하여 각 변수들까지 RTTI에 등록할 것이다.</p>

<h3>register DSEL</h3>

<p>먼저 한 번만 등록하기 위한 매크로를 만들어보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#define REGISTER_ONLY_ONCE(_rtti, _name, _info) \</span>
<span class="cp">    static bool init = false; \</span>
<span class="cp">    if (!init) \</span>
<span class="cp">        _rtti.insert(std::make_pair(_T(#_name), _info)); \</span>
<span class="cp">    init = true;</span>
</code></pre></div>
<p>이 코드는 구조체와 구조체의 변수를 각각 RTTI에 등록할 때 사용될 것이다.</p>

<p>이제 구조체를 등록하는 매크로와 변수를 등록하는 매크로를 보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#define REGISTER_RTTI_STRUCT(_name) \</span>
<span class="cp">    REGISTER_ONLY_ONCE(rtti, _name, (struct_info (_T(#_name))))</span>

<span class="cp">#define REGISTER_RTTI_VAR(_struct, _var, _type) \</span>
<span class="cp">    REGISTER_ONLY_ONCE(rtti[_T(#_struct)].varmap, _var, (var_info (_T(#_var), _type, OFFSET_OF(_struct, _var))))</span>
</code></pre></div>
<p>구조체를 등록하는 매크로는 전역 <code>rtti_map</code> 객체에 <code>struct_info</code>를 넣어준다.
구조체의 변수를 등록하는 매크로는 자신이 속한 구조체 rtti 내의 <code>varmap</code> 객체에 <code>var_info</code>를 넣어준다.</p>

<p>구조체의 변수를 등록하려면, 결국 자기가 어느 struct에 속한지를 알아야, 전역 rtti에서 자신이 속한 <code>struct_info</code>를 얻어와서 거기에 변수 정보(<code>var_info</code>)를 등록할 수 있다는 것이다. 이 때문에 <a href="http://libsora.so/" title="libsora.so">if1live</a>님의 매크로의 변수 선언부를 보면, <code>STRUCT_VAR_FLOAT(SampleStruct, a)</code>와 같이 구조체의 이름과 변수의 이름이 같이 들어가는 것이다.</p>

<h3>declaration DSEL</h3>

<p>이제 기본 RTTI 등록 매크로가 완성되었으니, 구조체 선언 매크로와 구조체 변수 선언 매크로를 작성하면 된다.
구조체 선언 매크로는 다음과 같다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#define STRUCT_BEGIN(_name)    \</span>
<span class="cp">    struct _name \</span>
<span class="cp">    {    \</span>
<span class="cp">    private: \</span>
<span class="cp">        struct __register_init { __register_init () { REGISTER_RTTI_STRUCT(_name); } } ___register_init; \</span>
<span class="cp">    public: \</span>
<span class="cp">        static const std::tstring&amp; name() { static std::tstring __name(_T(#_name)); return __name; }</span>
</code></pre></div>
<p>지정된 이름으로 구조체를 시작한다.
멤버로 갖는 구조체의 생성자에서 RTTI 등록 매크로를 사용하여 구조체 정보를 등록하도록 한다.
이왕이면 private으로 만들어서 그 임시 변수는 접근을 못하게 하자.</p>

<p>나중에 xml read / write 를 할 때 구조체의 이름으로부터 RTTI 정보를 얻어와야 하므로 static 함수로 그 이름을 반환하도록 한다. 구조체의 이름으로 static string 변수를 하나 선언해놓고 그걸 반환해준다.</p>

<p>구조체 내 변수 선언 매크로는 다음과 같다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#define STRUCT_VAR(_struct, _var, _ctype, _type) \</span>
<span class="cp">    public: \</span>
<span class="cp">        _ctype _var; \</span>
<span class="cp">    private: \</span>
<span class="cp">        struct __register_##_var { __register_##_var () { REGISTER_RTTI_VAR(_struct, _var, _type); } } ___register_##_var; \</span>
<span class="cp">    public:</span>
</code></pre></div>
<p>인자로 받은 c-type으로 public 변수를 선언하고, RTTI에 등록하기 위한 임시 멤버 변수로 RTTI 등록 매크로를 불러준다. 이제 저 기본 매크로를 이용하여 type 별 선언 매크로를 만든다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#define STRUCT_VAR_INT(_struct, _var)        STRUCT_VAR(_struct, _var, int, INT)</span>
<span class="cp">#define STRUCT_VAR_FLOAT(_struct, _var)        STRUCT_VAR(_struct, _var, float, FLOAT)</span>
</code></pre></div>
<p>마지막으로 구조체 선언을 닫아주어야 하므로 마무리 매크로를 만든다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#define STRUCT_END()    };</span>
</code></pre></div>
<p>그러면 제시한 대로 매크로를 통해 RTTI가 등록된 구조체를 선언할 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">STRUCT_BEGIN</span><span class="p">(</span><span class="n">SampleStruct</span><span class="p">)</span>
    <span class="n">STRUCT_VAR_FLOAT</span><span class="p">(</span><span class="n">SampleStruct</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">STRUCT_VAR_INT</span><span class="p">(</span><span class="n">SampleStruct</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">STRUCT_END</span><span class="p">()</span>
</code></pre></div>
<p>저 <code>SampleStruct</code> 구조체는 <code>a</code>: float, <code>b</code>: int 변수를 가질 것이고, 그 정보들은 이름 문자열과 함께 rtti 변수에 저장될 것이다.</p>

<h3>xml reader/writer</h3>

<p>xml read / write를 구현해보자.
먼저, 저 Object를 받았을 때 <code>var_info</code>의 offset을 사용하여 어떻게 각 변수를 접근하나 보자.</p>

<p>offset 정보는 구조체의 시작 주소로부터 그 변수까지의 간격(거리)라고 했다.
그러면 그 변수에 접근하려면,</p>

<ol>
<li>구조체의 시작 주소를 구한다.</li>
<li>시작 주소에 offset 을 더한다.</li>
<li>그 주소를 변수의 pointer type 에 맞게 casting 한다.</li>
<li>그 pointer 를 dereferencing 해서 값을 넣거나 뺀다.</li>
</ol>

<p>여기서 주의해야 할 점은 구조체의 시작 주소를 구할 때, 그냥 &amp; 연산자만 쓰는게 아니라 char * 으로 casting 을 해주어야 한다는 것이다. 왜냐하면 offset 이란건 시작 주소로부터 그 변수까지 떨어진 <strong>바이트 수</strong>인데,</p>

<p>Object 시작 주소를 &amp; 연산자로 구해놓고 그 포인터에  + 연산을 수행하면 <strong>그 주소는 Object 의 크기만큼 증가한다</strong>. 따라서 바이트 단위로 증가시켜주기 위해 char * 로 casting 한다. (char * 와 int * 각각의 변수에 대해 + 연산자를 사용하면 증가하는 값이 다르다는 이야기인데, 다 알고 있겠지만 한 번 더 설명 해 봤다.)</p>

<p>그러면 아래와 같은 매크로를 만들 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#define GET_VAR_ADDR(_ctype, _obj, _offset) ((_ctype *) (((char*) &amp;_obj) + _offset))</span>
<span class="cp">#define GET_VAR(_ctype, _obj, _offset) (*(GET_VAR_ADDR(_ctype, _obj, _offset)))</span>
</code></pre></div>
<h3>xml writer</h3>

<p>xml write를 먼저 만들어보자. <code>std::ostream</code>을 쓸 예정이다.
자주 입력해야하는 문자열은 미리 매크로로 만들어두자. 귀찮다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#define XML_START_TAG(name)      _T(&quot;&lt;&quot;) &lt;&lt; name &lt;&lt; _T(&quot;&gt;&quot;)</span>
<span class="cp">#define XML_END_TAG(name)        _T(&quot;&lt;/&quot;) &lt;&lt; name &lt;&lt; _T(&quot;&gt;&quot;)</span>
<span class="cp">#define XML_TAB                  _T(&quot;\t&quot;)</span>
</code></pre></div>
<p>그런데 <code>ostream</code>은 뭐가 들어올지 모른다. 기본적으로 <code>wostream</code>과 그냥 <code>ostream</code>부터가 다르다.
그러니까 template을 쓴다. 그러면 &lt;&lt; 연산자만 overloading 되어있는 모든 대상에 대해 이 함수를 쓸 수 있다. (저걸 overloading하는 network 통신 용 객체가 있다면 네트워크로 바로 xml이 써질 것이다.)</p>

<p>그리고 xml로 작성해야할 대상 객체로부터도 general해야 하므로 그것도 template으로 정한다.</p>

<p>그래서 함수를 만들면 아래와 같다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_stream</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_struct</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">xml_write</span><span class="p">(</span><span class="n">_stream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">_struct</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rtti</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="n">name</span><span class="p">())</span> <span class="o">==</span> <span class="n">rtti</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">struct_info</span><span class="o">&amp;</span> <span class="n">si</span> <span class="o">=</span> <span class="n">rtti</span><span class="p">[</span><span class="n">_struct</span><span class="o">::</span><span class="n">name</span><span class="p">()];</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">XML_START_TAG</span><span class="p">(</span><span class="n">si</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">varmap_t</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">si</span><span class="p">.</span><span class="n">varmap</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">si</span><span class="p">.</span><span class="n">varmap</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">var_info</span><span class="o">&amp;</span> <span class="n">vi</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
        <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">XML_TAB</span> <span class="o">&lt;&lt;</span> <span class="n">XML_START_TAG</span><span class="p">(</span><span class="n">vi</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">vi</span><span class="p">.</span><span class="n">type</span><span class="p">)</span>
        <span class="p">{</span>
        <span class="k">case</span> <span class="n">INT</span>: <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">GET_VAR</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">vi</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">FLOAT</span>: <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">GET_VAR</span><span class="p">(</span><span class="kt">float</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">vi</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">XML_END_TAG</span><span class="p">(</span><span class="n">vi</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">XML_END_TAG</span><span class="p">(</span><span class="n">si</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>매우 간단하다. 멤버의 타입도 2개 밖에 없다고 한정지었고, 구조체 내의 구조체(nested struct)와 같은 구조도 전혀 고려하지 않았다.</p>

<p>단순히 정의된 구조체의 <code>name()</code>을 통해 구조체 이름을 얻어서 rtti에 접근해 구조체 정보를 얻는다.
거기서 각 멤버에 대한 정보를 순회하면서 그 값을 <code>GET_VAR</code>로 가져와 인자로 받은 stream 객체에 값을 쓴다.</p>

<h3>xml reader</h3>

<p>xml read는 write에 비해 훨씬 복잡해야 하지만 제대로 된 xml parser를 작성할 생각은 추호도 없다.</p>

<p>먼저 배열의 개수를 얻는 매크로를 보자. 크기는 <code>sizeof</code>로 얻을 수 있으니 개수를 얻으려면 아래와 같겠다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#define COUNT_OF(array)        (sizeof (array) / sizeof (array[0]))</span>
</code></pre></div>
<p>자, 이제 모든 준비가 끝났으니 xml read를 작성하자.
이번에도 역시 입력 스트림과 값을 읽을 객체에 대해 template 인자로 받는다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_stream</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_struct</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">xml_read</span><span class="p">(</span><span class="n">_stream</span><span class="o">&amp;</span> <span class="n">in</span><span class="p">,</span> <span class="n">_struct</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rtti</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="n">name</span><span class="p">())</span> <span class="o">==</span> <span class="n">rtti</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">struct_info</span><span class="o">&amp;</span> <span class="n">si</span> <span class="o">=</span> <span class="n">rtti</span><span class="p">[</span><span class="n">_struct</span><span class="o">::</span><span class="n">name</span><span class="p">()];</span>

    <span class="n">TCHAR</span> <span class="n">name</span><span class="p">[</span><span class="mi">1024</span><span class="p">],</span> <span class="n">value</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
    <span class="n">in</span><span class="p">.</span><span class="n">ignore</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="n">_T</span><span class="p">(</span><span class="sc">&#39;&gt;&#39;</span><span class="p">));</span> <span class="c1">// ignore root node</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">varmap_t</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">si</span><span class="p">.</span><span class="n">varmap</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">si</span><span class="p">.</span><span class="n">varmap</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">iter</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">in</span><span class="p">.</span><span class="n">ignore</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="n">_T</span><span class="p">(</span><span class="sc">&#39;&lt;&#39;</span><span class="p">));</span> <span class="c1">// ignore before start tag</span>
        <span class="n">in</span><span class="p">.</span><span class="n">getline</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">COUNT_OF</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">_T</span><span class="p">(</span><span class="sc">&#39;&gt;&#39;</span><span class="p">));</span>
        <span class="n">in</span><span class="p">.</span><span class="n">getline</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">COUNT_OF</span> <span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="n">_T</span><span class="p">(</span><span class="sc">&#39;&lt;&#39;</span><span class="p">));</span>

        <span class="k">const</span> <span class="n">var_info</span><span class="o">&amp;</span> <span class="n">vi</span> <span class="o">=</span> <span class="n">si</span><span class="p">.</span><span class="n">varmap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">tstring</span><span class="p">(</span><span class="n">name</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">vi</span><span class="p">.</span><span class="n">type</span><span class="p">)</span>
        <span class="p">{</span>
        <span class="k">case</span> <span class="n">INT</span>: <span class="n">GET_VAR</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">vi</span><span class="p">.</span><span class="n">offset</span><span class="p">)</span> <span class="o">=</span> <span class="n">_wtoi</span> <span class="p">(</span><span class="n">value</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">FLOAT</span>: <span class="n">GET_VAR</span><span class="p">(</span><span class="kt">float</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">vi</span><span class="p">.</span><span class="n">offset</span><span class="p">)</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">_wtof</span> <span class="p">(</span><span class="n">value</span><span class="p">));</span> <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>구조체의 이름으로 rtti 정보를 가져온다.
xml에 어떤 순서로 기록될지는 모르지만, 어쨌든 구조체 내 멤버만큼은 node가 있겠지, 라고 가정했다.
따라서 구조체 내 멤버 정보로 iteration을 수행하는데, 사실 그냥 개수만 세기 위한 훼이크다!</p>

<p>istream의 <code>ignore</code> 기능을 활용하여 쓸데 없는 whitespace 등을 무시하고, <code>getline</code> 함수의 delim을 적절히 활용하여 각 node의 이름과 값을 얻어서, 그 멤버 변수의 type에 따라 <code>GET_VAR</code>를 통해 그 값을 넣어준다.</p>

<p>그럼 아래와 같이 쓸 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">_tmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">_TCHAR</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">SampleStruct</span> <span class="n">s</span><span class="p">;</span>
    <span class="n">s</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
    <span class="n">s</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">xml_write</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">wcout</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">wifstream</span> <span class="n">in</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">&quot;test.xml&quot;</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">in</span><span class="p">)</span>
        <span class="n">xml_read</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>

    <span class="n">xml_write</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">wcout</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
</code></pre></div>
<p>문제는 구조체를 한 번도 만들지 않았다면 RTTI 정보도 없다는 것이다 -_-;</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
						
				<h1 class="page-title">c++에서 reflection 사용하기 1</h1>
				<p class="page-date">03 Jun 2012</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
					<code class="tag">reflection</code>
						
						
						
						
				</p>
				<div class="content"><p>mmo-server에서 attribute를 json serialize하기 위해 attribute가 가지고 있는 field의 정보를 enumerate 해야할 일이 생겼다. 그런데 c++은 reflection이 없잖아?</p>

<p>그렇게 고민하다가 예전에 쓴 글을 발견했다.</p>

<ul>
<li><a href="/2011/09/30/using-rtti-at-cpp/">c++에서 구조체 RTTI 정보 남기기</a></li>
</ul>

<p>기본 아이디어는 다음과 같다. 각 class마다 자신의 field에 대한 정보를 갖는다. 이름과 멤버 변수 포인터 쌍을 가진다고 보면 된다. 여기서 골치가 아픈건 저 field에 대한 정보를 어떻게 표기하냐인데, 멤버 변수 포인터라는 type을 좀 generic하게 관리해줄 방법이 필요하다. 제대로 하려면 코드가 복잡해질테니 대충 다음과 같이 틀만 잡았다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">field_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">field_t</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">_name</span><span class="p">)</span> <span class="o">:</span> <span class="n">field_name</span><span class="p">(</span><span class="n">_name</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_FieldTy</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_ObjTy</span><span class="o">&gt;</span>
    <span class="n">_FieldTy</span><span class="o">&amp;</span> <span class="n">ref</span><span class="p">(</span><span class="n">_ObjTy</span><span class="o">*</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_FieldTy</span><span class="o">*</span> <span class="n">address</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">_FieldTy</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">(</span><span class="n">obj</span><span class="p">));</span>
        <span class="k">return</span> <span class="o">*</span><span class="n">address</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">field_name</span><span class="p">.</span><span class="n">c_str</span><span class="p">();</span> <span class="p">}</span>

<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">obj</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">protected:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">field_name</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>핵심 함수가 <code>ref()</code>인 것 같지만 잘 보면 저건 훼이크 함수다. 인자로 받은 object를 <code>ptr()</code>이라는 의미심장한 virtual 함수에게 넘겨주고 자신은 그냥 그걸 적절한 field type으로 casting해서 반환해줄 뿐이다.</p>

<p>게다가 템플릿 함수! <code>field_t</code>라는 고정 type으로 모든 field에 대한 정보는 관리하고 싶지만, 그 field가 관리하는 멤버 변수 포인터가 반환하는 값은 모두 다르기에 별로 더 좋은 생각도 안 나고 <del>귀찮아서</del>어쩔 수 없이 저렇게 작성했다.</p>

<p>때문에 <code>reinterpret_cast</code>가 등장했는데 함수에 대한 템플릿 인자를 클래스까지 확장하지 않고서는 객체의 type이나 field의 type 정보를 구체 구현 class까지 넘겨줄 방법이 없으므로 대충 <code>reinterpret_cast</code>로 때운 것이다. (덕분에 실 사용 type 검증 로직은 하나도 없고, 잘못 사용하면 안드로메다를 보게 된다.)</p>

<p>이제 저 <code>ptr()</code>을 구현하는 구체 클래스를 만들면 된다. 역시 대충 만들었다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_ObjTy</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_FieldTy</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_FieldTy</span> <span class="p">(</span><span class="n">_ObjTy</span><span class="o">::*</span><span class="n">Field</span><span class="p">)</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">field_impl_t</span> <span class="o">:</span> <span class="k">public</span> <span class="kt">field_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">field_impl_t</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">_name</span><span class="p">)</span> <span class="o">:</span> <span class="kt">field_t</span><span class="p">(</span><span class="n">_name</span><span class="p">)</span> <span class="p">{}</span>

<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">obj_addr</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">_ObjTy</span><span class="o">*</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">_ObjTy</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">obj_addr</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;*</span><span class="n">Field</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>예전 글에서는 offset을 직접 계산해서 거길 다시 접근하는 무시무시하고 소름끼치는 방법을 썼는데, 이번 글에서는 template의 힘을 빌린 멤버 변수 포인터를 써서 조금이나마 우아하고 안정적인 방법을 썼다. 하지만 현실은 <code>reinterpret_cast</code> [...]</p>

<p>실제 <code>ptr()</code> 함수 구현체는 그냥 object를 <code>field_impl_t</code> class가 아는 object type으로 강제 casting한 후, 거기서 찾고자 하는 멤버 field의 위치 주소를 찾아서 반환해주는 것이다.</p>

<p><code>field_t</code>와 <code>field_impl_t</code>의 관계에서 볼 수 있듯이 둘은 object의 type으로는 엮여있지 않고, 덕분에 <code>reinterpret_cast</code>를 쓴다. 이 때문에 잘못된 object가 들어가면 굉장한 광경을 볼 수 있다! (게다가 실행해보기 전까지는 모른다는게 함정!)<br>
... 물론 <code>ref()</code> 함수의 반환 타입만 잘못 지정해도 무시무시한 일이 벌어진다.</p>

<p>이제 저 <code>field_t</code>를 관리하는 관리 class를 만들어보자. 귀찮으니까 코드를 먼저 보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Ty</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="kt">field_info_map_t</span> <span class="p">{</span>
<span class="nl">protected:</span>
    <span class="k">typedef</span> <span class="n">_Ty</span> <span class="n">impl_type</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">field_t</span><span class="o">*&gt;</span> <span class="kt">_info_map_t</span><span class="p">;</span>
    <span class="k">static</span> <span class="kt">_info_map_t</span> <span class="n">_info_map</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_FieldTy</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_FieldTy</span> <span class="p">(</span><span class="n">_Ty</span><span class="o">::*</span><span class="n">Field</span><span class="p">)</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">_register_field</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_info_map</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="k">new</span> <span class="kt">field_impl_t</span><span class="o">&lt;</span><span class="n">_Ty</span><span class="p">,</span> <span class="n">_FieldTy</span><span class="p">,</span> <span class="n">Field</span><span class="o">&gt;</span><span class="p">(</span><span class="n">name</span><span class="p">)));</span>
    <span class="p">}</span>

<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">field_t</span><span class="o">*&gt;::</span><span class="n">iterator</span> <span class="kt">field_iterator_t</span><span class="p">;</span>

    <span class="k">static</span> <span class="kt">field_t</span><span class="o">*</span> <span class="nf">get_field</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">_info_map</span><span class="p">[</span><span class="n">name</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">static</span> <span class="kt">field_iterator_t</span> <span class="nf">get_field_begin</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_info_map</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="p">}</span>
    <span class="k">static</span> <span class="kt">field_iterator_t</span> <span class="nf">get_field_end</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_info_map</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="p">}</span>
<span class="p">};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Ty</span><span class="o">&gt;</span>
<span class="k">typename</span> <span class="kt">field_info_map_t</span><span class="o">&lt;</span><span class="n">_Ty</span><span class="o">&gt;::</span><span class="kt">_info_map_t</span> <span class="kt">field_info_map_t</span><span class="o">&lt;</span><span class="n">_Ty</span><span class="o">&gt;::</span><span class="n">_info_map</span><span class="p">;</span>
</code></pre></div>
<p>지난 글에서 했던 것처럼, 동일하게 map을 사용해서 이름과 <code>field_t*</code>에 대한 정보를 가지고 있다. 특이한건 모든 멤버가 다 static인데 template parameter를 가지고 있다는 것이다. 그 이유는 CRTP를 써서 register 과정에서 어떤 type인지에 대한 정보를 생략하기 위함이다. (이는 실 사용 부분에서 자세히 보자.)</p>

<p>이제 각 field를 어떻게 등록할 것인지, helper macro를 먼저 보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#define REGISTER_FIELD_BEGIN() \</span>
<span class="cp">    struct __register { \</span>
<span class="cp">        __register() { \</span>
<span class="cp">            static bool init = false; \</span>
<span class="cp">            if (init) return;</span>

<span class="cp">#define REGISTER_FIELD_END() \</span>
<span class="cp">        } \</span>
<span class="cp">    } _register_auto;</span>

<span class="cp">#define REGISTER_FIELD(type, name) \</span>
<span class="cp">            impl_type::_register_field&lt;type, &amp;impl_type::name&gt;(#name);</span>
</code></pre></div>
<p>역시 지난 글에서와 동일하게 struct 생성자 코드 + static 변수로 중복 실행 방지를 사용해서 해당 구조체에 접근할 때 바로 field 정보가 register 되도록 구성할 것이다.</p>

<p>재밌는 부분은 <code>REGISTER_FIELD</code> 부분이다. 이전 글과는 다르게 어떤 class인지에 대한 정보가 빠져있다. 그게 빠질 수 있는 이유는 실제 type을 언급하는 대신 <code>impl_type</code>이라는 이름을 사용하고 있기 때문인데, 이것을 위해서 <code>field_type_info_map_t</code>가 template parameter를 갖는 것이고, 그 type을 굳이 <code>impl_type</code>이라고 typedef 해 준 것이다.</p>

<p>즉, 멤버 포인터 변수를 작성할 때의 문법이 <code>className::*memberName</code>인데 className을 한 번 더 써주기 싫어서 만든 장치이다-_-;</p>

<p>이제 다 만들었으니까 사용해보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="kt">user_t</span> <span class="o">:</span> <span class="kt">field_info_map_t</span><span class="o">&lt;</span><span class="kt">user_t</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>

    <span class="n">REGISTER_FIELD_BEGIN</span><span class="p">()</span>
        <span class="n">REGISTER_FIELD</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
        <span class="n">REGISTER_FIELD</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="n">REGISTER_FIELD_END</span><span class="p">()</span>
<span class="p">};</span>
</code></pre></div>
<p><code>user_t</code>라는 구조체는 <code>index</code>, <code>name</code>라는 변수를 갖는다. 그리고 <code>REGISTER</code> 매크로를 통해 두 변수 모두 field 정보를 등록했다. 물론 매크로를 약간 고치면 지난 글처럼 매크로만으로 구조체 선언까지 가능해진다. 그런데 별로 그건 취향이 아니고-_- 구조체 내 변수가 깔끔하게 안 나온다. <em>(struct 변수 때문에 지저분해진다)</em></p>

<p>좀 더 깔끔한 방법이 있을 것 같은데, 피곤하니 일단 저 정도에서 타협! 이제 다음과 같이 사용할 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">user_t</span> <span class="n">user</span><span class="p">;</span>
<span class="n">user</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="n">user</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;choi&quot;</span><span class="p">;</span>

<span class="n">assert</span><span class="p">(</span><span class="kt">user_t</span><span class="o">::</span><span class="n">get_field</span><span class="p">(</span><span class="s">&quot;index&quot;</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ref</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="p">)</span> <span class="o">==</span> <span class="n">user</span><span class="p">.</span><span class="n">index</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="kt">user_t</span><span class="o">::</span><span class="n">get_field</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ref</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="p">)</span> <span class="o">==</span> <span class="n">user</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="kt">user_t</span><span class="o">::</span><span class="n">get_field_begin</span><span class="p">(),</span> <span class="kt">user_t</span><span class="o">::</span><span class="n">get_field_end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">field_t</span><span class="o">*&gt;</span> <span class="n">pair</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pair</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
<span class="p">});</span>
</code></pre></div>
<p><code>get_field()</code> 함수를 사용해서 대응되는 <code>field_t</code>를 가져올 수 있고, 거기에 객체의 주소를 넣어 값을 가져올 수 있다. 그리고 등록된 모든 field를 열거할 수 있다.</p>

<p>하지만 여기에는 지난 번 글에서와 마찬가지로 한 가지 문제점이 있다. 바로 <code>user_t</code>가 한 번도 생성된 적이 없다면 <code>user_t::get_field_begin()</code>, <code>user_t::get_field_end()</code>로 접근할 수 있는 field가 하나도 등록되지 않는다는 점이다. 즉, 무조건 <code>user_t</code> 객체가 한 번이라도 생성되어야 field가 등록된다는 것이다.</p>

<p>위 문제로 인해 deserialize를 제대로 수행할 수 없는 문제가 발생한다. 다음 글에서는 이 문제를 어떻게 해결할 수 있는지 알아보도록 하자.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">c++에서 reflection 사용하기 2</h1>
				<p class="page-date">04 Jun 2012</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
					<code class="tag">reflection</code>
						
						
						
						
				</p>
				<div class="content"><p>지난 번 글의 문제점은 다음과 같다.</p>

<ul>
<li>class 정보가 없다. 따라서 이름으로부터 class에 대한 객체를 생성할 수가 없다.</li>
<li>field에 대한 정보가 구체 class에 묶여있다. 따라서 그 class를 모르면 field 정보를 얻어올 수 없다.</li>
</ul>

<p>그래서 이번에는 다음의 기능을 중점으로 구현하였다.</p>

<ul>
<li>이름(문자열)로 class 정보 찾기</li>
<li>class 정보는 class 객체를 생성할 수 있어야 함</li>
<li>class 정보는 field 정보를 이름(문자열)로 찾을 수 있어야 함</li>
<li>field 정보는 객체의 주소로부터 field 값을 가져오거나 설정할 수 있어야 함</li>
</ul>

<p>마지막 항목은 지난 글에서 구현했던 내용이니, 앞의 세 항목을 어떻게 구현했는지 보도록 하자.<br>
(본 글에서는 글 읽는 흐름과 상관없는 별로 안 중요한 코드는 생략한다.)</p>

<p>먼저 class 정보에 대응되는 class를 만들어보자. 요구사항에서 언급했듯이, 얘는 자신의 type정보로 객체를 생성 가능해야하며, 이름으로 특정 field를 찾을 수 있어야 한다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">class_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">class_t</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">_name</span><span class="p">);</span>
    <span class="k">const</span> <span class="kt">field_t</span><span class="o">*</span> <span class="n">get_field</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span> <span class="nf">add_field</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">field_t</span><span class="o">*</span> <span class="n">field</span><span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Class</span><span class="o">&gt;</span>
    <span class="n">_Class</span><span class="o">*</span> <span class="n">new_instance</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">_Class</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">new_instance_impl</span><span class="p">());</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="k">virtual</span> <span class="kt">void</span><span class="o">*</span> <span class="n">new_instance_impl</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">private:</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">field_t</span><span class="o">*&gt;</span> <span class="kt">field_map_t</span><span class="p">;</span>
    <span class="kt">field_map_t</span> <span class="n">field_map</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p><code>field_t*</code>에 대한 map을 가지고 <code>add_field()</code>/<code>get_field()</code> 할 수 있는 간단한 class이다. <code>add_field()</code>와 <code>get_field()</code> 함수 모두 public으로 공개되어 있으니 class 정보를 접근할 때 실행 도중에 field를 <code>add_field()</code> 할 수 있는 위험이 있지 않을까? 하는 생각이 들 수도 있는데, 일단 <code>class_t</code> 객체를 사용할 때는 무조건 <code>const class_t*</code>를 사용하게 하면 <code>add_field()</code> 함수는 const가 아니니까 적당히 괜찮지 않을까 싶다.</p>

<p>재밌는 부분은 객체를 생성하는 부분이다. 이 역시 class_t 자체에는 type 정보가 없으므로(<code>field_t</code>와 동일한 이유) 구체 class에게 생성을 맡긴다. 하지만 구체 class가 뭘 생성할지 모르므로 <code>void*</code>로 일단 받고 casting해서 반환하는 대범함을 보인다. (<code>field_t</code> 때와 마찬가지로 <code>new_instance()</code> 함수에 type 인자를 잘못 주면 안드로메다를 보게 된다.)</p>

<p>구체 class는 <code>field_impl_t</code>보다 훨씬 간단하다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_ObjTy</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">class_impl_t</span> <span class="o">:</span> <span class="k">public</span> <span class="kt">class_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">class_impl_t</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">);</span>

<span class="nl">private:</span>
    <span class="k">virtual</span> <span class="kt">void</span><span class="o">*</span> <span class="n">new_instance_impl</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">_ObjTy</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>구체 class는 어차피 자기가 어떤 class에 대한 것인지 type 정보를 template으로 받고 있으므로 그에 대해 new 해서 돌려주면 그만이다. 물론 기본 생성자가 없다면 컴파일 에러가 난다.</p>

<p>이는 <a href="/2012/05/31/xml-mapping-using-java-annotation-and-reflection/">java annotation과 reflection을 사용한 xml mapping</a>에서 <code>Class#newInstance()</code>와 기본생성자에 관해 이야기했던 것과 동일한 이유라고 보면 된다.<br>
기본 생성자가 아닌 생성자에 대해서도 고려해주려면 method에 대한 reflection도 만들어주어야 하는데 variadic template을 지원하지 않는 MSVC10에서는 별로 구현하고 싶지 않다-_-;</p>

<p>이제 class의 이름과 <code>class_t</code>를 관리해줄 관리자 class를 만들어야 한다. class의 이름은 <code>std::type_info.name()</code>을 쓰면 좋겠지만 이 이름이 그닥 적절하지 못하다.</p>

<p>예를 들어 <code>struct user_t {}</code>라는 구조체가 있다면 <code>typeid(user_t).name()</code>은 MSVC 기준으로 <code>&quot;struct user_t&quot;</code>가 된다. 이 경우 이름을 통해 <code>class_t</code>를 찾아올 때 영 좋지 못할 수가 있으니 직접 이름을 등록할 수 있도록 할 것이다.</p>

<p>이 때 문제가 될 수 있는 것은, 어떤 객체에 대한 <code>class_t</code>를 가져올 때, 그 객체의 class의 이름을 뭐라고 등록했는지 찾아야 한다는 것이다. 때문에 관리자 class는 사용자 지정 이름과 <code>class_t</code>만을 관리하는 것이 아니라, 그 객체의 <code>std::type_info*</code>와 사용자 지정 이름도 관리해야 각 객체들은 자신의 <code>class_t</code>를 적절히 찾아올 수 있게 될 것이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">reflection_base</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">static</span> <span class="n">reflection_base</span><span class="o">&amp;</span> <span class="n">instance</span><span class="p">();</span>
    <span class="k">const</span> <span class="kt">class_t</span><span class="o">*</span> <span class="n">get_class</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">field_t</span><span class="o">*</span> <span class="n">get_field</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">class_name</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">field_name</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="nl">public:</span>
    <span class="kt">void</span> <span class="nf">add_class</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">class_t</span><span class="o">*</span> <span class="n">class_impl</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">add_field</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">class_name</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">field_name</span><span class="p">,</span> <span class="kt">field_t</span><span class="o">*</span> <span class="n">field_impl</span><span class="p">);</span>

    <span class="kt">void</span> <span class="nf">add_class_name</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">type_info</span><span class="o">*</span> <span class="n">typeinfo</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">class_name</span><span class="p">);</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">class_name_from_typeinfo</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">type_info</span><span class="o">*</span> <span class="n">typeinfo</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="nl">private:</span>
    <span class="n">reflection_base</span><span class="p">()</span> <span class="p">{}</span>
    <span class="n">reflection_base</span><span class="p">(</span><span class="k">const</span> <span class="n">reflection_base</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="n">reflection_base</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">reflection_base</span><span class="o">&amp;</span><span class="p">);</span>

<span class="nl">private:</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">type_info</span><span class="o">*</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="kt">class_name_map_t</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">class_t</span><span class="o">*&gt;</span> <span class="kt">class_map_t</span><span class="p">;</span>

    <span class="kt">class_name_map_t</span> <span class="n">class_name_map</span><span class="p">;</span>
    <span class="kt">class_map_t</span> <span class="n">class_map</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>singleton pattern의 <code>reflection_base</code> class는 <code>type_info</code>와 사용자 지정 이름, 사용자 지정 이름과 <code>class_t</code>에 대한 map을 갖는다. 그리고 이를 등록하고 찾아서 반환할 수 있도록 한다. (어차피 내부 구현 코드는 map에 대한 insert, find이니 자세한 코드는 생략한다.)</p>

<p>이제 <code>class_t</code>를 관리하고 찾을 수 있는 방법이 생겼으니, 특정 객체에 대해 다른 class들이 <code>class_t</code>를 얻을 수 있도록 helper격의 class를 하나 만들어보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">reflection_class_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="kt">reflection_class_t</span><span class="p">()</span> <span class="p">{}</span>

    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">type_name</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">typeid</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">).</span><span class="n">name</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">class_name</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">reflection_base</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span>
            <span class="p">.</span><span class="n">class_name_from_typeinfo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">typeid</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">const</span> <span class="kt">class_t</span><span class="o">*</span> <span class="n">get_class</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span>
        <span class="k">return</span> <span class="kt">class_t</span><span class="o">::</span><span class="n">from_name</span><span class="p">(</span><span class="n">class_name</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>이제 <code>reflection_class_t</code>를 상속받는 class들은 <code>get_class()</code> 함수를 통해 자신의 <code>class_t*</code>를 가져올 수 있게 된다.</p>

<p>마지막으로 <code>reflection_base</code>에 <code>class_t</code>와 <code>field_t</code>를 등록하는 함수를 만들어보자. 이는 지난 번 글에서 사용했던 매크로와 유사한 코드이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_ObjTy</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">register_class</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">class_name</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">reflection_base</span><span class="o">::</span><span class="n">instance</span><span class="p">().</span><span class="n">add_class_name</span><span class="p">(</span><span class="o">&amp;</span><span class="k">typeid</span><span class="p">(</span><span class="n">_ObjTy</span><span class="p">),</span> <span class="n">class_name</span><span class="p">);</span>
    <span class="n">reflection_base</span><span class="o">::</span><span class="n">instance</span><span class="p">().</span><span class="n">add_class</span><span class="p">(</span><span class="n">class_name</span><span class="p">,</span> 
        <span class="k">new</span> <span class="kt">class_impl_t</span><span class="o">&lt;</span><span class="n">_ObjTy</span><span class="o">&gt;</span><span class="p">(</span><span class="n">class_name</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_ObjTy</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_FieldTy</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_FieldTy</span> <span class="p">(</span><span class="n">_ObjTy</span><span class="o">::*</span><span class="n">Field</span><span class="p">)</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">register_field</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">field_name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">class_name</span> <span class="o">=</span> <span class="n">reflection_base</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span>
        <span class="p">.</span><span class="n">class_name_from_typeinfo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">typeid</span><span class="p">(</span><span class="n">_ObjTy</span><span class="p">));</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">class_name</span><span class="p">);</span>

    <span class="n">reflection_base</span><span class="o">::</span><span class="n">instance</span><span class="p">().</span><span class="n">add_field</span><span class="p">(</span><span class="n">class_name</span><span class="p">,</span> <span class="n">field_name</span><span class="p">,</span> 
        <span class="k">new</span> <span class="kt">field_impl_t</span><span class="o">&lt;</span><span class="n">_ObjTy</span><span class="p">,</span> <span class="n">_FieldTy</span><span class="p">,</span> <span class="n">Field</span><span class="o">&gt;</span><span class="p">(</span><span class="n">field_name</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>
<p><code>register_class()</code> 함수는 특정 class type에 대해 지정한 이름으로 <code>class_impl_t</code> 객체를 만들어서 등록한다. 이 때 해당 class의 type과 사용자 지정 이름을 <code>class_name_map</code>에 같이 등록해준다.</p>

<p><code>register_field()</code> 함수는 특정 class를 찾아서, 그 <code>class_t</code>가 관리하는 <code>field_map</code>에 <code>field_impl_t</code> 객체를 만들어서 등록한다.</p>

<p>이제 위에서 작성한 코드는 다음과 같이 사용될 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">using</span> <span class="k">namespace</span> <span class="n">reflection</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">base_t</span> <span class="o">:</span> <span class="k">public</span> <span class="kt">reflection_class_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="kt">base_t</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="kt">user_t</span> <span class="o">:</span> <span class="k">public</span> <span class="kt">base_t</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">_tmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">_TCHAR</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">register_class</span><span class="o">&lt;</span><span class="kt">user_t</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;user_t&quot;</span><span class="p">);</span>
    <span class="n">register_field</span><span class="o">&lt;</span><span class="kt">user_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="o">&amp;</span><span class="kt">user_t</span><span class="o">::</span><span class="n">index</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;index&quot;</span><span class="p">);</span>
    <span class="n">register_field</span><span class="o">&lt;</span><span class="kt">user_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="o">&amp;</span><span class="kt">user_t</span><span class="o">::</span><span class="n">name</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">);</span>

    <span class="k">const</span> <span class="kt">class_t</span><span class="o">*</span> <span class="n">clazz</span> <span class="o">=</span> <span class="kt">class_t</span><span class="o">::</span><span class="n">from_name</span><span class="p">(</span><span class="s">&quot;user_t&quot;</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">clazz</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">clazz</span><span class="o">-&gt;</span><span class="n">enumerate_fields</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="kt">field_t</span><span class="o">*</span> <span class="n">field</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">});</span>

    <span class="kt">base_t</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">-&gt;</span><span class="n">new_instance</span><span class="o">&lt;</span><span class="kt">base_t</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">clazz</span> <span class="o">==</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">get_class</span><span class="p">());</span>
    <span class="k">delete</span> <span class="n">ptr</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><code>user_t</code>에 대해 reflection을 등록한다.<br>
(이 부분은 딱히 답이 없는데, 편하게 하려면 code generator를 사용한다던가 하는 수 밖에 없어보인다.
아니면 <a href="http://libsora.so/" title="libsora.so">if1live</a>님이 했던 것처럼 매크로로 구조체를 만들도록 하든가.)</p>

<p><code>class_t::from_name()</code> 함수를 사용해 이름으로 <code>class_t</code> 객체를 가져왔다. 그리고 <code>enumerate_fields()</code> 함수(본 문에서는 생략됨)를 사용하여 <code>class_t</code>가 가지고 있는 모든 field에 대한 이름을 출력해볼 수 있다.</p>

<p>그리고 <code>new_instance()</code> 함수로 객체를 생성할 수 있는데, 이 때 type을 부모의 type(<code>base_t</code>)으로 명시해준다. 하지만 실제 <code>class_t</code>는 <code>user_t</code>에 대한 <code>class_t</code>이므로, 이 때 생성되는 객체는 <code>user_t</code>에 대한 객체이다. 그렇기 때문에 <code>clazz</code> 변수와 <code>ptr-&gt;get_class()</code> 변수가 모두 <code>user_t</code>에 대한 <code>class_t</code>로 일치하는 것이다.</p>

<p>그냥 map 등록/참조이기 때문에 새로울 것이 없는 내용이다. 성능 문제야 당연히 있겠지만 map을 hash_map으로 바꾸는 것 이외에는 그닥 좋은 방법이 떠오르지 않는다. 오히려 register를 좀 자동으로 해줄 수 있는 방법이 없을까 하는 것이 더 고민이다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">c++에서 reflection 사용하기 3</h1>
				<p class="page-date">09 Jun 2012</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
					<code class="tag">reflection</code>
						
						
						
						
				</p>
				<div class="content"><p>지난 #2에서는 <code>class_t</code>, <code>field_t</code> 자체가 가상 함수를 갖고, <code>class_impl_t</code>와 <code>field_impl_t</code>가 이 class를 상속 받아서 구현하는 방식을 사용하였다. 사실 굳이 이 <code>impl_t</code> class 들은 노출될 필요가 없으므로 이를 감추도록 해보자.</p>

<p>그리고 다 완성된 type을 register함에 있어, 따로 <code>register_class</code>, <code>register_field</code> 함수를 직접 불러서 등록을 하였는데, 이것을 <a href="http://en.wikipedia.org/wiki/X_Macro">X-Macro pattern</a>을 사용하여 개선해보도록 하자.</p>

<p><strong>C++ Template Metaprogramming</strong>의 형식 삭제(type erasure) 부분을 읽다보니, 굳이 <code>impl_t</code> class를 <code>class_t</code>, <code>field_t</code> 외부로 노출할 필요가 없다는 것을 깨달았다.<br>
(물론 위 책에서 언급하는 예제는 복사 및 대입 가능한 대상이기 때문에 복사/대입/소멸 등도 고려되어 있지만, 본 글에서는 단지 <code>impl_t</code>를 숨기기 위한 용도 정도로만 사용한다.)</p>

<p>type erasure에 대한 개념을 간단히 적어보면 reflection을 만든다는 것은 결국 runtime까지 type 정보를 유지한다는 것이다. type 정보를 코드 하나하나에 다 열거하는 것은 쓸데없는 노동력을 요구하므로 적절히 template을 써서 type 정보를 capture한다.</p>

<p>문제는 이렇게 type capture를 한 template class는 일반 type으로 지칭할 수 없다는 귀찮은 점이 있다. 예를 들어서,</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Ty</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">class_t</span> <span class="p">{};</span>
</code></pre></div>
<p>위와 같은 <code>class_t</code>에 대해, <code>class_t&lt;int&gt;</code>와 같은 type 정보를 넣어 template class를 구체화했다면, 이 class는 <code>class_t</code>가 아니고 <code>class_t&lt;int&gt;</code>이다. 좀 더 엄밀히 말하면 구체화되지 않은 <code>class_t</code>라는 class는 없는 것이다.</p>

<p>때문에 지난 번에는 <code>class_t</code>와 그것을 상속받는 <code>class_impl_t</code>를 만들고, type 정보를 <code>class_impl_t</code>에만 국한시켜 실제 사용하는 <code>class_t</code>에서는 따로 type 정보 없이 사용할 수 있는 것이다.</p>

<p>하지만 외부 register 함수에서 <code>class_impl_t</code>, <code>field_impl_t</code> 객체를 직접 생성해서 <code>class_t</code>, <code>field_t</code>에 넣어주는 영 좋지 못한 구조를 보였다. 이를 함수 template을 사용하여 보다 나은 방법으로 개선해보자.</p>

<p>변경된 <code>class_t</code>는 다음과 같다. (<code>class_impl_t</code>는 삭제되었다, 그리고 지난 번과 중복되는 내용은 삭제한다.)</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">class_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Ty</span><span class="o">&gt;</span>
    <span class="kt">class_t</span><span class="p">(</span><span class="k">const</span> <span class="n">typeinfo</span><span class="o">&lt;</span><span class="n">_Ty</span><span class="o">&gt;&amp;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">inf</span><span class="p">(</span><span class="k">new</span> <span class="kt">impl_t</span><span class="o">&lt;</span><span class="n">_Ty</span><span class="o">&gt;</span><span class="p">),</span> <span class="n">class_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">{}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Class</span><span class="o">&gt;</span>
    <span class="n">_Class</span><span class="o">*</span> <span class="n">new_instance</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">_Class</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">inf</span><span class="o">-&gt;</span><span class="n">new_instance</span><span class="p">());</span>
    <span class="p">}</span>
<span class="nl">private:</span>
    <span class="k">struct</span> <span class="kt">interface_t</span> <span class="p">{</span>
        <span class="k">virtual</span> <span class="kt">void</span><span class="o">*</span> <span class="n">new_instance</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Ty</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="kt">impl_t</span> <span class="o">:</span> <span class="k">public</span> <span class="kt">interface_t</span> <span class="p">{</span>
        <span class="k">virtual</span> <span class="kt">void</span><span class="o">*</span> <span class="n">new_instance</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">_Ty</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">};</span>
<span class="nl">private:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">interface_t</span><span class="o">&gt;</span> <span class="n">inf</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>지난 번과 동일한 부분을 과감히 생략하고 변경된 부분만 모아보면 위와 같다.</p>

<ul>
<li><code>class_t</code> 내부에 <code>interface_t</code>와 <code>impl_t</code>가 들어갔다.</li>
<li><code>impl_t</code>는 template을 사용하여 실 type 정보를 capture할 class이고,</li>
<li><code>interface_t</code>는 <code>impl_t</code>를 일반적으로 접근하기 위한 interface class이다.</li>
</ul>

<p><code>class_t</code>의 생성자가 type 정보를 직접 받기 위해 template 함수로 작성되었다. 재밌는 점은 함수 template 생성자에 type 정보를 넘기기 위해 <code>&lt;&gt;</code>으로 명시해주는 것은 쓸 수가 없어 이를 적당히 회피하기 위해 type 정보를 컴파일러에게 알려주기 위해 class 하나를 추가한다는 것이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Ty</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">typeinfo</span> <span class="p">{};</span>
</code></pre></div>
<p>그래서 <code>class_t</code> 생성자는 <code>typeinfo&lt;_Ty&gt;</code> 객체를 인자로 받는 것이고, 이 인자를 통해 어떤 <code>_Ty</code>을 넘기려 하는 것인지 type 추론이 가능해진다. 그러면 해당 type으로 생성자가 구체화가 되고, 그 생성자에서는 <code>_Ty</code> 정보를 사용하여 <code>impl_t</code> 객체를 만들고, 이 객체를 <code>interface_t</code> 변수에 넣어두는 것이다. 그러면 기존 <code>class_t</code>의 virtual 함수를 non-virtual 함수로 만들고 수행에 대해서는 내부 <code>interface_t</code> 객체를 통해 적절히 delegate해주면 된다.</p>

<p><code>field_t</code> 역시 위와 동일한 방법으로 개선하였다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">field_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_ObjTy</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_FieldTy</span><span class="o">&gt;</span>
    <span class="kt">field_t</span><span class="p">(</span><span class="n">_FieldTy</span> <span class="p">(</span><span class="n">_ObjTy</span><span class="o">::*</span><span class="n">Field</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">inf</span><span class="p">(</span><span class="k">new</span> <span class="kt">impl_t</span><span class="o">&lt;</span><span class="n">_ObjTy</span><span class="p">,</span> <span class="n">_FieldTy</span><span class="o">&gt;</span><span class="p">(</span><span class="n">field</span><span class="p">)),</span> <span class="n">field_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">{}</span>
<span class="nl">private:</span>
    <span class="k">struct</span> <span class="kt">interface_t</span> <span class="p">{</span>
        <span class="k">virtual</span> <span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">obj_addr</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">type_info</span><span class="o">&amp;</span> <span class="n">type</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_ObjTy</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_FieldTy</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="kt">impl_t</span> <span class="o">:</span> <span class="k">public</span> <span class="kt">interface_t</span> <span class="p">{</span>
        <span class="kt">impl_t</span><span class="p">(</span><span class="n">_FieldTy</span> <span class="p">(</span><span class="n">_ObjTy</span><span class="o">::*</span><span class="n">Field</span><span class="p">))</span> <span class="o">:</span> <span class="n">field</span><span class="p">(</span><span class="n">Field</span><span class="p">)</span> <span class="p">{}</span>
        <span class="k">virtual</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">type_info</span><span class="o">&amp;</span> <span class="n">type</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">typeid</span><span class="p">(</span><span class="n">_FieldTy</span><span class="p">);</span> <span class="p">}</span>
        <span class="k">virtual</span> <span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">obj_addr</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

        <span class="n">_FieldTy</span> <span class="p">(</span><span class="n">_ObjTy</span><span class="o">::*</span><span class="n">field</span><span class="p">);</span>
    <span class="p">};</span>
<span class="nl">private:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">interface_t</span><span class="o">&gt;</span> <span class="n">inf</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>생성자를 template 함수로 만드는 방법은 <code>class_t</code>와 똑같은데, 아까 만든 <code>typeinfo</code>를 사용하여 type 정보를 넘기지는 않는다.<br>
기존의 <code>field_impl_t</code>에서 실제 field까지 template 인자로 받았던 것에 반해, 새로운 구조에서는 data member pointer를 생성 인자로 받기 때문에 <code>_FieldTy (_ObjTy::*Field)</code>이 인자를 통해서 충분한 type 유추가 가능하기 때문이다. (따라서 <code>impl_t</code>도 data member pointer를 인자로 갖도록 수정되었다.)</p>

<p>그 이외에 <code>impl_t</code> 객체를 만들어서 <code>interface_t</code>로 지칭하는 것이나, <code>field_t</code>의 작업 함수들이 수행을 <code>interface_t</code> 객체로 위임하는 것은 위 <code>class_t</code>에서 언급했던 내용과 동일하다.</p>

<p>이제 reflection 정보를 register하는 코드를 개선할 것이다. 기존에는 외부로 노출된 template 함수를 통해 직접 type 및 이름 정보를 입력하여 하나씩 정보를 등록하였다.</p>

<p>하지만 각 field를 정의할 때마다 어떤 class에 대한 field인지 매번 써주는 것은 비효율적이므로, 이를 개선하기 위해 다음과 같이 register를 도와주면서 어떤 class에 대한 register인지 type 정보를 갖고 있는 class를 설계해보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_ObjTy</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="kt">reflection_register_helper_t</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="n">_ObjTy</span> <span class="n">target_type</span><span class="p">;</span>

    <span class="k">static</span> <span class="kt">void</span> <span class="nf">register_class</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">class_name</span><span class="p">);</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_FieldTy</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">register_field</span><span class="p">(</span><span class="n">_FieldTy</span> <span class="p">(</span><span class="n">_ObjTy</span><span class="o">::*</span><span class="n">Field</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">field_name</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_ObjTy</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="kt">reflection_register_helper_t</span><span class="o">&lt;</span><span class="n">_ObjTy</span><span class="o">&gt;::</span><span class="n">register_class</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">class_name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">reflection_base</span><span class="o">::</span><span class="n">instance</span><span class="p">().</span><span class="n">add_class_name</span><span class="p">(</span><span class="o">&amp;</span><span class="k">typeid</span><span class="p">(</span><span class="n">_ObjTy</span><span class="p">),</span> <span class="n">class_name</span><span class="p">);</span>
    <span class="n">reflection_base</span><span class="o">::</span><span class="n">instance</span><span class="p">().</span><span class="n">add_class</span><span class="p">(</span><span class="n">class_name</span><span class="p">,</span> 
        <span class="k">new</span> <span class="kt">class_t</span><span class="p">(</span><span class="n">typeinfo</span><span class="o">&lt;</span><span class="n">_ObjTy</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">class_name</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_ObjTy</span><span class="o">&gt;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_FieldTy</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="kt">reflection_register_helper_t</span><span class="o">&lt;</span><span class="n">_ObjTy</span><span class="o">&gt;::</span><span class="n">register_field</span><span class="p">(</span>
    <span class="n">_FieldTy</span> <span class="p">(</span><span class="n">_ObjTy</span><span class="o">::*</span><span class="n">Field</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">field_name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">class_name</span> <span class="o">=</span> <span class="n">reflection_base</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span>
        <span class="p">.</span><span class="n">class_name_from_typeinfo</span><span class="p">(</span><span class="o">&amp;</span><span class="k">typeid</span><span class="p">(</span><span class="n">_ObjTy</span><span class="p">));</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">class_name</span><span class="p">);</span>

    <span class="n">reflection_base</span><span class="o">::</span><span class="n">instance</span><span class="p">().</span><span class="n">add_field</span><span class="p">(</span><span class="n">class_name</span><span class="p">,</span> <span class="n">field_name</span><span class="p">,</span>
        <span class="k">new</span> <span class="kt">field_t</span><span class="p">(</span><span class="n">Field</span><span class="p">,</span> <span class="n">field_name</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>
<p><code>reflection_register_helper_t</code> class는 template으로 type 정보를 받고 이를 유지한다. 따라서 <code>register_class()</code> 함수나 <code>register_field()</code> 함수는 따로 어떤 class에 대한 정보인지 type 정보를 받을 필요가 없다.</p>

<p>이제 매크로를 통해 다음과 같이 대신 등록해주는 코드를 만들어볼 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#define REFLECTION_REGISTER_BEGIN(class_name)  \</span>
<span class="cp">    static struct _register_##class_name :</span>
            <span class="k">public</span> <span class="n">reflection</span><span class="o">::</span><span class="kt">reflection_register_helper_t</span><span class="o">&lt;</span><span class="n">class_name</span><span class="o">&gt;</span> <span class="p">{</span> \
       <span class="n">_register_</span><span class="err">##</span><span class="n">class_name</span><span class="p">()</span> \
        <span class="p">{</span> \
            <span class="n">register_class</span><span class="p">(</span><span class="err">#</span><span class="n">class_name</span><span class="p">);</span>

<span class="cp">#define REFLECTION_REGISTER_FIELD(type, field_name) \</span>
<span class="cp">            register_field&lt;type&gt;(&amp;target_type::field_name, #field_name);</span>

<span class="cp">#define REFLECTION_REGISTER_END()  \</span>
<span class="cp">        } \</span>
<span class="cp">    } __AUTO_NAME;</span>
</code></pre></div>
<p>(<code>__AUTO_NAME</code>은 <code>__COUNTER__</code>를 사용하여 겹치지 않는 아무 이름이나 만들어주는 매크로이다. <a href="/2012/05/12/lambda-and-raii-2/">lambda 와 RAII #2</a>)</p>

<p><code>REFLECTION_REGISTER_BEGIN</code>, <code>FIELD</code>, <code>END</code> 매크로를 사용하면 등록하고자 하는 class의 정보를 template argument로 갖는 reflection_register_helper_t에 대한 상속 class를 만든다. 그리고 생성자에서 class, field 정보를 등록하는 코드를 차례대로 만들어둔 뒤, <code>END</code> 매크로에서 이 <code>register_class</code>에 대한 변수를 하나 만들게 된다.</p>

<p>만약 이 변수가 전역 변수로 선언된다면 프로그램이 실행될 때 해당 객체가 초기화되면서 생성자의 코드가 실행될 것이고, 그 때 해당 type에 대한 reflection 정보가 등록될 것이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">REFLECTION_REGISTER_BEGIN</span><span class="p">(</span><span class="kt">user_t</span><span class="p">)</span>
    <span class="n">REFLECTION_REGISTER_FIELD</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
    <span class="n">REFLECTION_REGISTER_FIELD</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
<span class="n">REFLECTION_REGISTER_END</span><span class="p">()</span>
</code></pre></div>
<p>(<code>reflection_register_helper_t</code> class가 <code>user_t</code>에 대한 type 정보를 <code>target_type</code>이라고 지칭할 수 있게 해주어서, <code>FIELD</code>를 등록할 때 다시 <code>user_t</code>를 언급할 필요가 없어졌다!)</p>

<p>이제 <a href="http://en.wikipedia.org/wiki/X_Macro">X-Macro pattern</a> 방법을 정의한 구조체에 대한 type 정보를 등록하는 것을 자동화해볼 것이다. 이 방법의 핵심은 구조체 선언을 매크로로 하고, 선언된 header 파일을 여러 번 incldue하고, 그 때마다 선언 매크로를 다른 것으로 치환(undef/define)하여 사용하는 것이다.</p>

<p>먼저 선언을 위한 매크로를 정의해보면 다음과 같다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#ifndef __DECLARE_TYPE_MACRO_DEFINED__</span>
<span class="cp">#define __DECLARE_TYPE_MACRO_DEFINED__</span>
<span class="cp">#define DECLARE_BEGIN(class_name) \</span>
<span class="cp">    struct class_name; \</span>
<span class="cp">    typedef std::shared_ptr&lt;class_name&gt; class_name##_ref; \</span>
<span class="cp">    struct class_name : public object_t {</span>

<span class="cp">#define DECLARE_FIELD(type, field_name) \</span>
<span class="cp">        type field_name;</span>

<span class="cp">#define DECLARE_END()   \</span>
<span class="cp">    };</span>
<span class="cp">#endif</span>

<span class="cp">#define STRUCT_BEGIN(class_name)        DECLARE_BEGIN(class_name)</span>
<span class="cp">#define STRUCT_FIELD(type, field_name)  DECLARE_FIELD(type, field_name)</span>
<span class="cp">#define STRUCT_END()                    DECLARE_END()</span>
</code></pre></div>
<p>(본 글에서는 생략했지만 <code>DECLARE</code>로 정의된 모든 class는 <code>object_t</code>를 상속받고, <code>object_t</code>는 <code>reflection_class_t</code>를 상속받기 때문에 reflection 정보를 가질 수 있다.)</p>

<p><code>STRUCT_BEGIN</code>, <code>FIELD</code>, <code>END</code> 매크로는 선언(declare) 단계에서는 <code>DECLARE_BEGIN</code>, <code>FIELD</code>, <code>END</code>를 사용하도록 작성이 되어있다.</p>

<p>이제 다음과 같이 <code>user_t</code>를 정의하면 (user.h)</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">STRUCT_BEGIN</span><span class="p">(</span><span class="kt">user_t</span><span class="p">)</span>
    <span class="n">STRUCT_FIELD</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
    <span class="n">STRUCT_FIELD</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
<span class="n">STRUCT_END</span><span class="p">()</span>
</code></pre></div>
<p>위 매크로에 의해 다음과 같이 번역될 것이다. (<code>STRUCT</code> -&gt; <code>DECLARE</code>)</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="kt">user_t</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>이제, <code>STRUCT_BEGIN</code>, <code>FIELD</code>, <code>END</code>를 reflection을 등록하기 위한 매크로로 치환한다. (type_register_macro.h)</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#ifdef STRUCT_BEGIN</span>
<span class="cp">#undef STRUCT_BEGIN</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef STRUCT_END</span>
<span class="cp">#undef STRUCT_END</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef STRUCT_FIELD</span>
<span class="cp">#undef STRUCT_FIELD</span>
<span class="cp">#endif</span>

<span class="cp">#define STRUCT_BEGIN(class_name)        REFLECTION_REGISTER_BEGIN(class_name)</span>
<span class="cp">#define STRUCT_FIELD(type, field_name)  REFLECTION_REGISTER_FIELD(type, field_name)</span>
<span class="cp">#define STRUCT_END()                    REFLECTION_REGISTER_END()</span>
</code></pre></div>
<p>이제 다시 user.h 파일을 include하면, 이 때의 코드는 다음과 같이 번역될 것이다. (<code>STRUCT</code> -&gt; <code>REFLECTION_REGISTER</code>)</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">REFLECTION_REGISTER_BEGIN</span><span class="p">(</span><span class="kt">user_t</span><span class="p">)</span>
    <span class="n">REFLECTION_REGISTER_FIELD</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
    <span class="n">REFLECTION_REGISTER_FIELD</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
<span class="n">REFLECTION_REGISTER_END</span><span class="p">()</span>
</code></pre></div>
<p>이에 대한 전체적인 코드 구조는 다음과 같다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#include &quot;object.h&quot;</span>
<span class="cp">#include &quot;user.h&quot;</span>

<span class="cp">#include &quot;type_register_macro.h&quot;</span>
<span class="cp">#include &quot;user.h&quot;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">reflection</span><span class="o">::</span><span class="kt">class_t</span><span class="o">*</span> <span class="n">clazz</span> <span class="o">=</span> <span class="n">reflection</span><span class="o">::</span><span class="kt">class_t</span><span class="o">::</span><span class="n">from_name</span><span class="p">(</span><span class="s">&quot;user_t&quot;</span><span class="p">);</span>
</code></pre></div>
<p><code>DECLARE</code> 매크로 정의를 포함한 object.h를 먼저 include하면, 그 뒤에 오는 user.h를 include하는 시점에는 구조체 선언이 이루어진다. 그리고 <code>REFLECTION_REGISTER</code> 매크로로 치환하는 type_register_macro.h를 include한 이후에 오는 user.h에서는 reflection 정보를 자동으로 등록하는 코드가 생성될 것이다.</p>

<p>본 글에서는 <code>class_impl_t</code>, <code>field_impl_t</code>를 숨기는 작업과, 매크로 치환과 #include를 여러 번 하는 방법을 사용하여 type 정보를 자동으로 등록하는 방법에 대해 알아보았다.</p>

<p>하지만 #include를 여러 번 하는 방법은, #pragma once나 #ifndef, #define ~ #endif을 통한 중복 include 방지를 사용할 수 없기 때문에 (혹은 사용한다고 하면 번거롭게 구조체 정의할 때마다 앞 뒤로 매크로 선언을 따로 해주어야 하기 때문에) include가 복잡하게 꼬이는 구조가 발생하면 여러 번 include 되어 문제가 발생할 수 있다.</p>

<p>매크로 상태를 사용하여 이를 해결할 수는 있는데 이에 대해서는 다음 글에 알아보도록 하자.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">c++에서 reflection 사용하기 4</h1>
				<p class="page-date">09 Jun 2012</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
					<code class="tag">reflection</code>
						
						
						
						
				</p>
				<div class="content"><p>이전 글에서는 자료구조가 선언된 header파일을 여러 번 include하면 문제가 발생했었다. 하지만 이리저리 참조가 되다보면 각 번역 단위에서 include가 한 번만 되는 것은 굉장히 힘든 일일 것이다.</p>

<p>따라서 본 글에서는 매크로를 잘 정의해서 선언 header파일이 구조체 선언, reflection 등록 딱 2번만 include가 될 수 있도록 만들어볼 것이다. <a href="https://github.com/lacti/FieldInfo/tree/v0.3">이전 글(#3)의 소스 코드</a> 내의,</p>

<ul>
<li><a href="https://github.com/lacti/FieldInfo/blob/v0.3/reset_type_macro.h">reset_type_macro.h</a></li>
<li><a href="https://github.com/lacti/FieldInfo/blob/v0.3/type_declare_macro.h">type_declare_macro.h</a></li>
<li><a href="https://github.com/lacti/FieldInfo/blob/v0.3/type_register_macro.h">type_register_macro.h</a></li>
<li><a href="https://github.com/lacti/FieldInfo/blob/v0.3/user.h">user.h</a></li>
</ul>

<p>가 이번 글의 타겟이 될 것이다.</p>

<p><code>#include</code>를 하는 phase는 2단계로 나뉜다.</p>

<ul>
<li>첫 번째는 구조체를 선언하기 위한 단계로 <code>DECLARE_PHASE</code>라고 하겠다. 이 때 <code>STRUCT</code> 매크로들은 <code>DECLARE</code> 매크로가 사용되어야 하므로, 이 시점에서는 type_declare_macro.h가 include된 상태이어야 한다.</li>
<li>두 번째는 선언된 구조체의 reflection 정보를 등록하는 단계로 <code>REGISTER_PHASE</code>라고 하겠다. 이 때 STRUCT 매크로들은 REFLECTION_REGISTER 매크로가 사용되어야 하므로, 이 시점에서는 type_register_macro.h가 include된 상태이어야 한다.</li>
</ul>

<p>두 macro.h 파일이 처음 참조하게 되는 초기화 파일인 reset_type_macro.h 파일에서 각 상태를 먼저 초기화해줄 수 있도록 한다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#ifdef STRUCT_BEGIN</span>
<span class="cp">#undef STRUCT_BEGIN</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef STRUCT_END</span>
<span class="cp">#undef STRUCT_END</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef STRUCT_FIELD</span>
<span class="cp">#undef STRUCT_FIELD</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef __DECLARE_PHASE__</span>
<span class="cp">#undef __DECLARE_PHASE__</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef __REGISTER_PHASE__</span>
<span class="cp">#undef __REGISTER_PHASE__</span>
<span class="cp">#endif</span>
</code></pre></div>
<p>이제 어떤 macro.h가 include되냐에 따라서 <code>STRUCT</code>와 <code>PHASE</code>도 변경될 수 있도록 밑작업을 마쳤다.</p>

<p>구조체를 선언하기 위한 매크로가 정의된 type_declare_macro.h 파일을 보면 다음과 같다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#include &quot;reset_type_macro.h&quot;</span>

<span class="cp">#ifndef __DECLARE_TYPE_MACRO_DEFINED__</span>
<span class="cp">#define __DECLARE_TYPE_MACRO_DEFINED__</span>
<span class="cp">#define DECLARE_BEGIN(class_name) \</span>
<span class="cp">    struct class_name; \</span>
<span class="cp">    typedef std::shared_ptr&lt;class_name&gt; class_name##_ref; \</span>
<span class="cp">    struct class_name : public object_t {</span>

<span class="cp">#define DECLARE_FIELD(type, field_name) \</span>
<span class="cp">        type field_name;</span>

<span class="cp">#define DECLARE_END()   \</span>
<span class="cp">    };</span>
<span class="cp">#endif</span>

<span class="cp">#define STRUCT_BEGIN(class_name)        DECLARE_BEGIN(class_name)</span>
<span class="cp">#define STRUCT_FIELD(type, field_name)  DECLARE_FIELD(type, field_name)</span>
<span class="cp">#define STRUCT_END()                    DECLARE_END()</span>

<span class="cp">#define __DECLARE_PHASE__</span>
</code></pre></div>
<p><code>DECLARE</code> 계열 매크로의 중복 정의를 막고, <code>STRUCT</code>가 <code>DECLARE</code> 매크로를 가리키게 한 다음,
현재 상태를 <code>DECLARE_PHASE</code>로 만든다.</p>

<p>선언된 구조체의 reflection 정보를 등록하기 위한 매크로가 정의된 type_register_macro.h 파일을 보면 다음과 같다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#include &quot;reflection_macro.h&quot;</span>
<span class="cp">#include &quot;reset_type_macro.h&quot;</span>

<span class="cp">#define STRUCT_BEGIN(class_name)        REFLECTION_REGISTER_BEGIN(class_name)</span>
<span class="cp">#define STRUCT_FIELD(type, field_name)  REFLECTION_REGISTER_FIELD(type, field_name)</span>
<span class="cp">#define STRUCT_END()                    REFLECTION_REGISTER_END()</span>

<span class="cp">#define __REGISTER_PHASE__</span>
</code></pre></div>
<p><code>STRUCT</code>가 <code>REFLECTION_REGISTER</code> 매크로를 가리키게 한 다음, 현재 상태를 <code>REGISTER_PHASE</code>로 만든다.</p>

<p>이제 모든 준비가 완료되었으니, user.h 파일에서 각 상태 별로 한 번씩만 include가 되도록 만들어주자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#if (defined(__DECLARE_PHASE__) &amp;&amp; !defined(__USER_DECLARED__)) \</span>
<span class="cp">    || (defined(__REGISTER_PHASE__) &amp;&amp; !defined(__USER_REGISTERED__))</span>

<span class="cp">#if defined(__DECLARE_PHASE__) &amp;&amp; !defined(__USER_DECLARED__)</span>
<span class="cp">#define __USER_DECLARED__</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(__REGISTER_PHASE__) &amp;&amp; !defined(__USER_REGISTERED__)</span>
<span class="cp">#define __USER_REGISTERED__</span>
<span class="cp">#endif</span>

<span class="n">STRUCT_BEGIN</span><span class="p">(</span><span class="kt">user_t</span><span class="p">)</span>
    <span class="n">STRUCT_FIELD</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
    <span class="n">STRUCT_FIELD</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
<span class="n">STRUCT_END</span><span class="p">()</span>

<span class="cp">#endif</span>
</code></pre></div>
<p>기존에는 #ifndef, #define ~ #endif 와 같이 단순히 중복 include를 막아줄 수 있었지만, 이제는 <code>DECLARE_PHASE</code>, <code>REGISTER_PHASE</code> 각각 한 번씩 include를 허용해주어야 하므로 상태를 따로 관리해야 한다.</p>

<p>따라서 <code>USER DECLARED</code>, <code>REGISTERED</code> 상태 2개를 갖고,</p>

<ul>
<li><code>DECLARE_PHASE</code>에서는 DECLARED 상태가 아닐 때만 진입 가능하도록,</li>
<li><code>REGISTER_PHASE</code>에서는 REGISTERED 상태가 아닐 때만 진입 가능하도록 매크로를 작성한다.</li>
</ul>

<p>이제 처음 #if 조건문에 의해, 각 상태마다 단 한 번의 include만 허용하게 된다.</p>

<p>한가지 안타까운 점은, 실제 구조체를 선언하는 모든 header 파일에 위와 같은 안전자 지시 장치를 해주어야 한다는 것이다. 이는 생각보다 번거로운 작업이 될 수 있는데, file template을 잘 만들어서 쓰거나 하면 어느정도 해결할 수 있을 것 같다.</p>

<p>여기까지 구조체를 선언, reflection 정보를 등록했고, 다음에는 등록한 reflection 정보를 사용하여 xml과 어떻게 bind할 것인지에 대해 살펴보자. 추가로 각 구조체의 version을 관리하여 어떻게 convert를 작성할 수 있을지도 고민해보도록 하자.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">class와 memset</h1>
				<p class="page-date">24 Dec 2010</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
						
				</p>
				<div class="content"><p>c++의 class보다 java의 class를 훨씬 많이 쓰는 나는 사실 c의 struct라면 모를까 c++의 class는 아직도 생소하다. struct를 쓸 때, 가장 좋은 점 중 하나는 초기화라고 생각하는데,</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="n">MyData</span> <span class="p">{</span>
    <span class="n">TCHAR</span> <span class="n">szName</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
    <span class="n">UINT</span>   <span class="n">nValue</span><span class="p">;</span>
    <span class="n">BOOL</span>  <span class="n">bBolean</span><span class="p">;</span>
    <span class="n">LPVOID</span> <span class="n">lpBuffer</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">MyData</span> <span class="n">data</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">};</span>
</code></pre></div>
<p>와 같이 선언과 동시에 초기화를 할 수가 있어 만약 모든 값을 <code>NULL(or 0)</code>으로 채우려면 class의 생성자 초기화리스트 보다 간단하게 할 수 있다는 것이다.</p>

<p>여기에 더 나아가</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="n">MyData</span> <span class="p">{</span>
    <span class="c1">// some variables;</span>
    <span class="n">MyData</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="n">memset</span> <span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">));</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>와 같은 방법으로 생성과 동시에 해당 구조체를 초기화할 수도 있다.</p>

<p>하지만 이 방식은 적어도 c까지는 유효했으나 c++부터는 그렇지 못하다. 왜냐하면 c++은 눈에 보이는 variable 외에도 virtual 함수에 의한 다형성을 위한 vfptr(virtual function pointer table)이 있기 때문이다.</p>

<p>class를 설계할 때 상속을 고려한다면, 다른건 몰라도 꼭 virtual로 선언해야하는게 바로 소멸자(destructor)이다. 그런데 이렇게 하나라도 virtual function을 가지게 된다면 컴파일러는 class 내부에 vfptr을 집어넣어주게 되고, 이 class를 위와 같은 memset으로 sizeof 잡아서 일괄 0으로 초기화하면 vfptr도 전부 NULL이 들어간다.</p>

<p>뭐 virtual function 호출 안하면 상관없다만 그렇다고 소멸자 호출을 막으면 안 되니까 [...]</p>

<p>그렇다고 초기화리스트를 사용하는건 자존심이 허락하지 않는다. 멤버 변수 쓸데없이 많은 것도 짜증나는데 어째서 초기화리스트에서 한 번 더 써주는 수고를 해야하는가?</p>

<p>물론 이를 해결할 수 있는 방법?이랄게 있기는 하다. 방법은 다음과 같다.</p>

<ol>
<li>초기화하고 싶은 변수를 struct로 따로 묶고 struct 생성자에서 memset을 사용하여 초기화한다.</li>
<li>그리고 이걸 사용할 class가 본 struct를 protected로 상속받는다-_- </li>
<li>행여나 member를 private로 만들고 싶다면 private으로 상속받는다.</li>
</ol>

<p>자, 이제 memset으로 변수도 초기화했고 class의 vfptr도 안전하다. 이렇게 주구장창 생성되는 struct의 이름만 잘 관리하면 [...........]</p>

<p>이를 보여주는 간단한 예제 코드는 다음과 같다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="n">Context</span> <span class="p">{</span>
    <span class="n">TCHAR</span>   <span class="n">szData</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
    <span class="n">LPVOID</span>  <span class="n">lpBuffer1</span><span class="p">;</span>
    <span class="n">LPVOID</span>  <span class="n">lpBuffer2</span><span class="p">;</span>
    <span class="n">LPVOID</span>  <span class="n">lpBuffer3</span><span class="p">;</span>
    <span class="n">UINT</span>    <span class="n">nValue</span><span class="p">;</span>

    <span class="n">Context</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="n">memset</span> <span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">));</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">CParent</span><span class="o">:</span> <span class="k">protected</span> <span class="n">Context</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">CParent</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">CParent</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>

    <span class="k">virtual</span> <span class="n">UINT</span> <span class="n">GetValue</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">private:</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">CChild</span><span class="o">:</span> <span class="k">public</span> <span class="n">CParent</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">CChild</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">CChild</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>

    <span class="k">virtual</span> <span class="n">UINT</span> <span class="n">GetValue</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">nValue</span><span class="p">;</span> <span class="p">}</span>
<span class="nl">private:</span>
<span class="p">};</span>


<span class="kt">int</span> <span class="nf">_tmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">_TCHAR</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">CParent</span> <span class="o">*</span><span class="n">lpObject</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CChild</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">lpObject</span><span class="o">-&gt;</span><span class="n">GetValue</span> <span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">class의 public과 private</h1>
				<p class="page-date">20 Jul 2011</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
						
				</p>
				<div class="content"><p>예전에 동아리 선배님께서 어떤 코드를 수정하시면서 하셨던 말이 있다.</p>

<blockquote>
<p>&quot;왜 멤버가 다 public 으로 되어있는거야!&quot;</p>
</blockquote>

<p>요즘 읽고 있는 코드에서 몇 개의 class 들이 저런 문제점을 지니고 있다.<br>
다음 예제를 보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Worker</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">DoWork</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">Run</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">Append</span><span class="p">(</span><span class="n">Work</span><span class="o">*</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">Remove</span><span class="p">(</span><span class="n">Work</span><span class="o">*</span><span class="p">);</span>
    <span class="n">Work</span><span class="o">*</span> <span class="nf">GetWork</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="nl">public:</span>
    <span class="k">volatile</span> <span class="kt">long</span> <span class="n">workCount</span><span class="p">;</span>
    <span class="n">Work</span><span class="o">*</span> <span class="n">workArray</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p><em>(volatile keyword를 사용한 이유는 다음에 설명하겠다)</em></p>

<p>저런 class가 있다고 할 때 저 interface만 보고 class가 무슨 일을 하는지 알 수 있을까?</p>

<ul>
<li>이름도 적절히 <code>Worker</code>이고,</li>
<li><code>DoWork</code>와 <code>Run</code>함수를 보니 <code>Work</code>를 실행해주는 것 같고,</li>
<li><code>Append</code>와 <code>Remove</code>가 있으니 뭔가 <code>Work</code>를 넣었다 뺐다도 할 수 있나보다.</li>
<li>그리고 <code>GetWork</code> 라는게 있으니까 뭔가 <code>Work</code> 객체를 가져올 수도 있나보다.</li>
<li>그리고 <code>WorkCount</code>, <code>WorkArray</code>가 있으니 내부에서 Work 객체를 저장하나보네?</li>
</ul>

<p><strong>그런데 public?</strong> </p>

<p>그리고 로직 코드를 읽고 나서야 <code>DoWork</code>, <code>Remove</code>, <code>GetWork</code> 함수는 오로지 <code>Worker</code> 내부에서만 사용되고, 외부에서는 <code>Run</code>과 <code>Append</code> 함수만 사용한다는 것을 알게 되었다.<br>
그런데 심지어 <code>workCount</code>를 직접 접근하는 곳을 발견하였다 [...]</p>

<p>여기까지 읽은 사람이라면 수도 없이 많은 문제를 떠올리겠지만, 다 생략하고 몇 개만 보겠다.</p>

<ul>
<li>class의 역할을 파악하고 동작을 이해함에 있어 private의 역할은 꽤나 중요하다. public method는 외부에서 호출한다는 것이니까, 결국 이 class가 어떤 동작을 외부로 제공해 줄지를 결정하는 것이기 때문이다. 위의 class를 제대로 적어보면 아래와 같이 되어야하지 않을까. 개인적으로 private나 protected 구간도 여러 개로 설정해서 member, variable, static 을 또 나누어서 표현한다. 혹자는 아예 public method의 가장 아래 부분에 생성자, 소멸자를 적음으로써 이 밑으로는 볼 필요가 없다는 convention을 제시하기도 했다.</li>
</ul>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Worker</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">Run</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">Append</span><span class="p">(</span><span class="n">Work</span><span class="o">*</span><span class="p">);</span>
    <span class="kt">long</span> <span class="nf">GetWorkdCount</span><span class="p">();</span>
<span class="nl">private:</span>
    <span class="kt">void</span> <span class="nf">DoWork</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">Remove</span><span class="p">(</span><span class="n">Work</span><span class="o">*</span><span class="p">);</span>
    <span class="n">Work</span><span class="o">*</span> <span class="nf">GetWork</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="nl">private:</span>
    <span class="k">volatile</span> <span class="kt">long</span> <span class="n">workCount</span><span class="p">;</span>
    <span class="n">Work</span><span class="o">*</span> <span class="n">workArray</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<ul>
<li>refactoring 등을 할 때 coverage 를 설정하기 위해서라도 private은 중요하다. 여기저기에서 호출하고 있는 method를 refactoring을 하는건 고난의 행군이 될 것이다. 최대한 외부로 노출되는 method 를 줄이고 private로 꽁꽁 묶어놔야 기능이나 설계를 개선할 때 수정으로 인해 영향을 받는 외부 부분이 줄어들면서 그나마 좀 나아지지 않을까 싶다.</li>
</ul>

<p>이 이야기는 결국 귀에 못이 박히도록 들어온 encapsulation 이야기인데, 이런 저런걸 고려해볼 때 friend 의 등장은 저걸 저해하는 것 같으면서도 잘 구성할 수 있게 해준다.</p>

<p>private member variable이야 getter로 빼준다 할지라도, method의 경우는 접근할 방법이 없으니까.
<del>(뭐 미친 척 하고 member function pointer 를 넘기면 되지 않을까 싶지만)</del></p>

<p>그런데 결국 friend를 해주면 coverage에 구멍이 생기니까 별로 좋은 일은 아니다.<br>
java의 package나 c#의 internal 같은 나름 우아한 방법으로 묶어주는 것도 좋을텐데 일단 C++은 그런게 없으니 namespace로 수작이라도 부려봐야지</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">const overloading</h1>
				<p class="page-date">12 Oct 2008</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
						
				</p>
				<div class="content"><p>c++의 overloading은 c에서 어떤 함수를 단순히 함수의 이름으로만 식별했던 것에 비해 함수의 인자의 type, 개수, 혹은 const/volatile 여부까지 고려해서 식별한다는 것이다.</p>

<p>즉 linking 시점에서 호출하는 지점과 호출 당하는 지점을 연결해줄 때 호출하는 지점에서 요구하는 함수의 정보(함수 이름, 인자 type, 개수, const/volatile 여부)를 기반으로 함수 table에서 찾아서 그 함수의 주소를 호출할 수 있도록 주소로 변환시켜 주면서 엮어준다는 것이다.</p>

<p>이 글에서는 const와 reference를 엮어, 그렇지 않은 함수와 함께 overloading을 하여 사용하는 것에 대한 글을 서술하도록 하겠다.</p>

<p>간단한 예를 들기 위해 1차원 array를 wrapping하는 class를 다음과 같이 작성한다고 해보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#include &lt;iostream&gt;</span>

<span class="k">class</span> <span class="nc">odarray</span> <span class="p">{</span> <span class="c1">// one dimension</span>
<span class="nl">public:</span>
    <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">odarray</span><span class="o">&amp;</span> <span class="n">array</span><span class="p">);</span>

    <span class="kt">int</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="p">[]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">mArray</span><span class="p">[</span><span class="n">index</span><span class="p">];</span> <span class="p">}</span>
    <span class="kt">int</span> <span class="k">operator</span> <span class="p">[]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">mArray</span><span class="p">[</span><span class="n">index</span><span class="p">];</span> <span class="p">}</span>
    <span class="kt">int</span> <span class="n">size</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">mSize</span><span class="p">;</span> <span class="p">}</span>

    <span class="n">odarray</span> <span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">mSize</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">mArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">mArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">odarray</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">delete</span><span class="p">[]</span> <span class="n">mArray</span><span class="p">;</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">mSize</span><span class="p">;</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">mArray</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">odarray</span><span class="o">&amp;</span> <span class="n">array</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">array</span><span class="p">.</span><span class="n">mSize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">odarray</span> <span class="n">oa1</span> <span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">oa1</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">oa1</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><code>operator []</code>가 const인 것과 그렇지 않은 것 2개를 작성하였다. 둘의 함수 내용은 같지만 해당 함수가 호출되는 시점의 constness에 따라 다른 함수가 호출될 수 있다는 것이다.</p>

<ul>
<li>const가 붙어있는 함수는 int 값을 복사해서 반환하고,</li>
<li>const가 붙어있지 않은 함수는 int&amp; 자체를 반환하여 해당 값을 수정할 수 있게 해준다.</li>
</ul>

<p>간단히 말해서 예를 들어보면,</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">odarray</span> <span class="nf">oa1</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="n">oa1</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">oa1</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;[</span><span class="o">/</span><span class="n">code</span><span class="p">]</span>
</code></pre></div>
<p><code>oa1[4] = 10;</code> 구문에서는 값의 변경이 필요하기 때문에 당연히 int&amp;를 반환하는 non-constness 함수를 호출할 것이다.</p>

<p>하지만 <code>std::cout &lt;&lt; oa1 &lt;&lt; std::endl;</code> 구문에서는 <code>oa1</code>을 <code>ostream</code>으로 출력하는 함수의 원형을 봐야한다. <code>std::ostream&amp; operator &lt;&lt; (std::ostream&amp; out, const odarray&amp; array)</code><br>
즉 이 함수는 인자로 <code>const odarray</code>를 받기 때문에 <code>odarray</code> 객체의 const를 보장하기 위해서 이 함수 내에서 호출되는 <code>odarray</code>의 멤버 함수는 모두 const 함수가 되는 것이다. 따라서 위 구문에서는 int를 반환하는 const 함수가 호출된다.</p>

<h3>결론</h3>

<p>c++ compiler는 const를 보장해주기 위해서 const 객체의 멤버 함수를 호출할 때는 const 멤버 함수를 호출한다.</p>

<h3>추가</h3>

<p>그래서 const overloading과 operator overloading을 결합하면 쉽게 getter/setter를 만들 수 있고, 이게 발전되어서 vb나 c#의 property가 된게 아닐까 싶다. 아 반환값 때문에 안되나-_-;</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">object</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="p">[]</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">propertyname</span><span class="p">);</span>
<span class="n">object</span> <span class="k">operator</span> <span class="p">[]</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">propertyname</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</code></pre></div></div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">dumpable 고찰</h1>
				<p class="page-date">30 Jun 2014</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
					<code class="tag">template</code>
						
						
						
						
				</p>
				<div class="content"><p>하재승님께서 <a href="http://lacti.me/2014/05/29/ndc14-dungeon-and-fighter-loader-optimization/">던전 앤 파이터 클라이언트 로딩 속도 최적화</a>에서 언급하신 <a href="https://github.com/ipkn/dumpable">dumpable</a> 라이브러리에 대한 이야기를 해보자. 이 라이브러리는 serializable memory가 가능한 dynamic container와 <code>operator =</code>를 사용하여 dumpable한 struct를 만들어준다.</p>

<p>다만 몇 가지 아쉬운 점이 있었다. </p>

<ul>
<li><code>dptr::alloc()</code> 함수가 thread safe하지 않다는 점</li>
<li>dstring, dvector가 custom allocator를 지원하지 않는다는 점</li>
<li>container의 type이 많지 않다는 점</li>
</ul>

<p>때문에 <a href="https://github.com/lacti/dumpable">dumpable을 fork해서</a> 문제를 고쳐보기로 했다.</p>

<ul>
<li>일단 <code>dptr:alloc()</code> 내의 static 변수를 thread_local로 변경해서 local_pool이 겹치지는 않도록 했다. 하나의 thread가 dumping을 하는 도중에는 다른 copy가 불가능하기 때문에 대충은 thread safe해졌다.</li>
<li>custom allocator를 넣어보려고 이리저리 뜯어보니 상당히 고쳐줘야 한다. 일단 type부터 다시 재정의를 해야 할 것 같다.</li>
</ul>

<p>고민을 좀 해보다보니 뭔가 기존 stl container에 allocator만을 가지고 tmp를 잘 해보면 되지 않을까라는 생각이 들었다. 뭔가 복사할 때에만 serialize를 위한 allocator로 교체해서 그 쪽의 메모리를 할당해주면 되지 않을까!</p>

<ol>
<li>data type을 정의한다. 이 data type은 serializable할 것인지 말 것인지 template param으로 bool 값을 갖는다.</li>
<li>data type에서 사용하는 stl container는 위 bool 값에 의해 <code>std::allocator</code>를 쓸지 <code>serializble_allocator</code>를 쓸지 <code>std::conditional</code>로 결정한다.</li>
<li>data type은 자신의 bool 값을 rebind하여 serializable 가능한 type을 갖는다.</li>
<li><code>write</code> 함수에서는 rebind된 type의 객체를 만든 후, 원본 객체로부터 복사를 유도하여 dumpable처럼 <code>operator =</code>에 의한 복사를 유도해보도록 하자.</li>
</ol>

<p>결론부터 이야기하자면 성공할 수 없는 삽질이다. 좀 더 자세한 설명을 위해 코드를 보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">namespace</span> <span class="n">ser</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">do_serialize</span> <span class="o">=</span> <span class="nb">false</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="n">vector</span> <span class="p">{</span>
        <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">conditional</span><span class="o">&lt;</span><span class="n">do_serialize</span><span class="p">,</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">allocator_type</span><span class="p">;</span>
        <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">allocator_type</span><span class="o">&gt;</span> <span class="n">type</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Base</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="n">make_serializable</span> <span class="p">{</span>
        <span class="k">typedef</span> <span class="n">Base</span><span class="o">&lt;</span><span class="nb">true</span><span class="o">&gt;</span> <span class="n">serializable_type</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>간단히 vector만 다시 정의해봤다. <code>do_serialize</code> 값에 따라 allocator만 바꿔주는 녀석이다.</li>
<li><code>make_serializable</code> 역시 별거 없고 그냥 Base type에 대해 serializable 값만 바꿔준다.(rebind)</li>
</ul>

<p>그리고 다음과 같이 data를 쓰려고 했다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#define SERIALIZABLE(name) \</span>
<span class="cp">    template &lt;bool do_serialize = false&gt; \</span>
<span class="cp">    struct name : ser::make_serializable&lt;name&gt;</span>

<span class="n">SERIALIZABLE</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ser</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">do_serialize</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>위와 같이 정의하고,</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">test</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">serializable_type</span> <span class="n">serializable_type</span><span class="p">;</span>
    <span class="n">serializable_type</span> <span class="n">ser_obj</span><span class="p">;</span>
    <span class="n">ser_obj</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>이런 식으로 테스트를 진행하려고 했다. 당연하지만 <code>data&lt;true&gt;</code>와 <code>data&lt;false&gt;</code>는 다른 type이기 때문에 <code>operator =</code>를 바로 호출할 수가 없다. <code>operator =</code> trick을 못 쓴다면 각 멤버에 대한 serialize 코드를 작성해주어야 한다는 것이므로 당초 목적을 달성할 수가 없다.</p>

<p>뿐만 아니라 allocator를 사용하는 방법 자체는 잘못되었다.</p>

<ul>
<li>container 내에는 pointer type이 많이 있는데 이는 allocator를 통해 할당 공간만 어떻게 하나로 합친다고 해서 될 수 있는 내용이 아니다.</li>
<li>프로그램 구동 시 처음 한 번 loading된 이후 변경이 없는 데이터의 경우 loading memory address를 강제로 고정해서 위 문제를 해결할 수 있을지는 모르겠지만, 그렇게 되면 범용적으로 사용할 수가 없다.</li>
</ul>

<p>따라서 dumpable처럼 container도 따로 구현해야만 한다. 많은 container가 없다는 점이 조금 아쉽기는 하지만 일단 custom allocator를 사용할 수 있는 수준까지 고쳐보고 다시 고민을 더 해봐야겠다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">function adapter와 type inference</h1>
				<p class="page-date">10 Nov 2013</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
					<code class="tag">template</code>
						
						
						
					<code class="tag">study</code>
						
						
						
						
				</p>
				<div class="content"><p>과제는 다음의 Adapter를 만들어보자는 것이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Adapter</span><span class="o">&lt;</span><span class="kt">int</span> <span class="cm">/* return-type */</span><span class="p">,</span> <span class="kt">int</span> <span class="cm">/* 1st-arg-type */</span><span class="p">,</span> <span class="kt">int</span> <span class="cm">/* 2nd-arg-type */</span><span class="o">&gt;</span>
        <span class="n">functor1</span><span class="p">(</span><span class="n">sum</span><span class="p">,</span> <span class="mi">100</span> <span class="cm">/* 1st-arg */</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">functor1</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span> <span class="c1">// 120</span>
    <span class="kt">int</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">functor1</span><span class="p">(</span><span class="mi">80</span><span class="p">);</span> <span class="c1">// 180</span>
<span class="p">}</span>
</code></pre></div>
<p>많은 친구들이 이미 문제를 잘 풀었기 때문에 자세한 설명은 생략한다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Adapter</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="n">R</span> <span class="p">(</span><span class="o">*</span><span class="n">F</span><span class="p">)(</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">);</span>
    <span class="n">Adapter</span><span class="p">(</span><span class="n">F</span> <span class="n">func</span><span class="p">,</span> <span class="n">T1</span> <span class="n">arg1</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">_function</span><span class="p">(</span><span class="n">func</span><span class="p">),</span> <span class="n">_arg1</span><span class="p">(</span><span class="n">arg1</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">R</span> <span class="k">operator</span> <span class="p">()</span> <span class="p">(</span><span class="n">T2</span> <span class="n">arg2</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">_function</span><span class="p">(</span><span class="n">_arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">F</span> <span class="n">_function</span><span class="p">;</span>
    <span class="n">T1</span> <span class="n">_arg1</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>이름 잘 지어주는 것도 물론 중요하지만 이정도 코드에서는 저정도 글자만 써줘도 이해할 것 같으니 과감히 생략.</p>

<p>개인적으로 풀이 중 가장 마음에 드는 것은 <a href="https://twitter.com/Omniavinco" title="Omniavinco on Twitter">Omniavinco</a>가 <a href="http://libsora.so/" title="libsora.so">if1live</a> 글에 댓글로 단 binder1st 상속을 통한 구현. (있는 것 가져다가 쓰는게 제일)</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#include &lt;functional&gt;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T3</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Adapter</span><span class="o">:</span><span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">binder1st</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pointer_to_binary_function</span><span class="o">&lt;</span> <span class="n">T2</span><span class="p">,</span> <span class="n">T3</span><span class="p">,</span> <span class="n">T1</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Adapter</span><span class="p">(</span><span class="n">T1</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="n">T2</span><span class="p">,</span> <span class="n">T3</span><span class="p">),</span> <span class="n">T3</span> <span class="n">v</span><span class="p">)</span><span class="o">:</span><span class="n">std</span><span class="o">::</span><span class="n">binder1st</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pointer_to_binary_function</span><span class="o">&lt;</span> <span class="n">T2</span><span class="p">,</span> <span class="n">T3</span><span class="p">,</span> <span class="n">T1</span> <span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ptr_fun</span><span class="p">(</span><span class="n">func</span><span class="p">),</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<h3>type infererence</h3>

<p>자, 과제가 끝났습니다-_-; 라고 하면 섭섭하실 것 같아 준비했습니다!</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">Adapter</span><span class="o">&lt;</span><span class="kt">int</span> <span class="cm">/* return-type */</span><span class="p">,</span> <span class="kt">int</span> <span class="cm">/* 1st-arg-type */</span><span class="p">,</span> <span class="kt">int</span> <span class="cm">/* 2nd-arg-type */</span><span class="o">&gt;</span>
</code></pre></div>
<p>변수 선언하기 위해서 Adapter type을 길게 써야하는게 굳이 그럴 필요가 있을까? <code>std::make_pair</code>과 같은 type inference를 이용한 helper function을 구현하여 그 귀찮음을 해소해보자.</p>

<p>일단 function의 <code>return_type</code>, <code>arg1_type</code>, <code>arg2_type</code>을 가져오기 위해서 간단한 template 부분 특수화(partial specialization)를 사용한 <code>type_trait</code> class를 만들어보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Function</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">function_traits</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">function_traits</span><span class="o">&lt;</span><span class="n">R</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="n">R</span> <span class="n">R</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">T1</span> <span class="n">T1</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">T2</span> <span class="n">T2</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>위 코드는 <a href="http://www.boost.org/doc/libs/release/libs/type_traits/doc/html/boost_typetraits/reference/function_traits.html">boost::function_traits</a>에서 필요한 부분만 발췌한 코드이다. 설명을 위해서 가져온 코드이고, 그냥 <a href="http://www.boost.org/doc/libs/release/libs/type_traits/doc/html/index.html">boost type_traits library</a>를 가져다 쓰는게 더 좋다.</p>

<p>함수 type으로부터 반환 type, 인자 type들을 얻어낼 수 있게 되었으니 이제 Adapter에 넣어주기만 하면 된다. 그 부분에 대해서도 helper class를 만들어보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">adapter_type</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="n">Adapter</span><span class="o">&lt;</span>
        <span class="k">typename</span> <span class="n">function_traits</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">R</span><span class="p">,</span>
        <span class="k">typename</span> <span class="n">function_traits</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">T1</span><span class="p">,</span>
        <span class="k">typename</span> <span class="n">function_traits</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">T2</span><span class="o">&gt;</span> <span class="n">type</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>이제 다음과 같은 방법으로 Adapter type을 간단하게 부를 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="n">adapter_type</span><span class="o">&lt;</span><span class="n">decltype</span><span class="p">(</span><span class="n">my_function</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">my_adapter</span><span class="p">;</span>
</code></pre></div>
<p>이제 모든 준비가 끝났으니 Adapter 객체를 만들어주는 적절한 helper function만 만들면 된다. 이 함수의 인자로 우리가 원하는 함수 포인터를 넣으면 해당 함수에 대한 type을 template이 잘 알아서 inference 해줄 것이고, 그에 따라 적절한 Adapter class에 대한 객체가 만들어질 것이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
<span class="k">typename</span> <span class="n">adapter_type</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">make_adapter</span><span class="p">(</span>
    <span class="n">F</span> <span class="n">func</span><span class="p">,</span> <span class="k">typename</span> <span class="n">function_traits</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">T1</span> <span class="n">arg1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">typename</span> <span class="n">adapter_type</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">arg1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p><code>F</code> type으로 받은 함수에 대해 <code>adapter_type</code>의 객체를 만들어 적절히 반환해준다.</p>

<p>이제 다음과 같이 main 함수 내의 코드를 정리할 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="c1">// Adapter&lt;int, int, int&gt; adapter(sum, 100);</span>
<span class="k">auto</span> <span class="n">adapter</span> <span class="o">=</span> <span class="n">make_adapter</span><span class="p">(</span><span class="n">sum</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">adapter1</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">adapter1</span><span class="p">(</span><span class="mi">80</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div>
<h3>정리</h3>

<p>간단한 레벨에서 c++스럽게 프로그래밍을 한다면 stl만 어느정도 써도 된다. 하지만 조금만 더 프로그래밍을 하다보면 쓸데없는 중복 코드를 제거하기 위한 일반적인 프로그래밍을 하게 되고, c++에서 그걸 표현하려면 template은 필요한 요소이기 때문에 익숙해지는게 좋다.</p>

<p>이번 과제로 나온 adapter는 어떤 함수의 interface를 다른 interface로 변환하기 위한 adapter pattern을 구현한 것이다. adapter pattern은 어떤 interface를 연결해주냐에 따라 장황한 구현의 세계가 펼쳐질 수 있는데 여기서는 간단히 함수와 함수를 연결해주는 것으로 template과 <code>operator ()</code> 만으로 구현을 한 것이다.</p>

<p>하지만 template을 사용하게 될 경우 그 구현체를 사용하는 쪽에서 type 노가다를 해주어야할 일이 생기는데 이걸 해결하기 위해서 auto keyword와 helper function을 통한 compiler의 type inference와 <code>type_traits</code>을 사용하는 것이다. (이번 스터디에서 type_traits는 주제를 벗어나기 때문에 다루지 않을 예정이다)</p>

<p><code>type_traits</code>을 언급했으니 말인데, 위에서 만든 Adapter의 효율은 생각보다 좋지 않다.
왜냐하면 binding되는 인자와 <code>operator ()</code>의 인자로 받는 객체의 크기가 매우 클 경우 해당 객체가 복사되어 넘어가기 때문이다. 이 문제를 해결하기 위해 인자의 const-reference를 쓰는 것이 좋을지, 아니면 move semantics을 쓰는 것이 좋을지, 아니면 <code>shared_ptr</code>, 혹은 <code>unique_ptr</code>을 쓰는게 좋을지 고민해보고 그에 대한 구현을 해보는 것도 좋은 연습이 되겠다.</p>

<p>template의 부분 특수화와 단위 전략(unit policy)을 공부하면 충분히 일반적인 interface를 가지면서도 각 경우에 대해 효율적으로 동작할 수 있는(심지어 compile time에 모든 것이 결정되어 runtime에 추가적인 부담을 지지 않는) 구현을 할 수 있다. <del>MC++D, TMP 스터디 절찬리 예매 중..은 아니고</del></p>

<p>사실 오늘 구현한 내용들은 어느 정도 표준에 포함되었거나 boost에 있는 내역들이다. 따라서 다음의 구현체를 찾아보며 공부하는 것을 적극 추천한다.</p>

<ul>
<li><a href="http://en.cppreference.com/w/cpp/utility/functional/bind">Cppref: std::bind</a></li>
<li><a href="http://en.cppreference.com/w/cpp/header/type_traits">Cppref: type_traits</a></li>
<li><a href="http://www.boost.org/doc/libs/1_54_0/libs/type_traits/doc/html/index.html%22">boost: type_traits library</a></li>
</ul>

<p>지금까지의 내용은 compiler time에서 일어나는 generic programming 이야기였다. 이를 runtime에서 하나의 type으로 모아서 작업하기 위한 type erasure을 오늘 다룰 것이다.</p>

<p>그렇다면 다음 과제는 dispatcher가 될 것 같다-_-;</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
						
				<h1 class="page-title">generic한 c++ rpc 구현</h1>
				<p class="page-date">20 Aug 2013</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
					<code class="tag">rpc</code>
						
						
						
						
				</p>
				<div class="content"><p>generic한 rpc를 간단히 구현해보자.</p>

<p>원래 의도는 asio를 사용하여 가벼운 덧셈 rpc 정도를 구현해보자는 것이었는데 왠지 모르게 스터디 친구들이 spec을 안드로메다로 보내버려서 <a href="http://c2.com/cgi/wiki?EmbeddedDomainSpecificLanguage">DSEL</a>을 통한 rpc stub, skeleton 생성 코드를 구현해보도록 하겠다.</p>

<p>양이 좀 많기 때문에 개요부터 설명하겠다.</p>

<ul>
<li>rpc 메시지을 주고 받기 위한 <strong>buffer</strong>를 먼저 설계하고, 메시지을 처리할 <strong>handler</strong>를 선언한다.</li>
<li>이를 기반으로 하나의 연결(connection)을 처리할 <strong>session</strong>을 구현하고, 이 위에 <code>rpc_server</code>와 <code>rpc_client</code>을 구현할 것이다.</li>
<li>마지막으로 구현된 기반 라이브러리를 바탕으로 <strong>DSEL</strong>을 만들어서 실제 사용할 rpc를 구현해볼 것이다.</li>
</ul>

<h3>buffer</h3>

<p>네트워크로 byte를 주고 받기 위한 buffer는 다음과 같이 쉽게 구현할 수 있다. 다만 매번 복사되는 것을 막기 위해 shared_ptr 형태도로 사용할 것이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="kt">buffer_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">buffer_t</span><span class="o">&gt;</span> <span class="n">buffer_ref</span><span class="p">;</span>
</code></pre></div>
<p>buffer로부터 데이터를 읽고 쓰는 class를 구현해보자. template만 있으면 primitive type에 대해서는 쉽게 구현할 수가 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">buffer_reader_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">buffer_reader_t</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">buffer</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">_buffer</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Ty</span><span class="o">&gt;</span>
    <span class="k">friend</span> <span class="kt">buffer_reader_t</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="kt">buffer_reader_t</span><span class="o">&amp;</span> <span class="n">reader</span><span class="p">,</span> <span class="n">_Ty</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">value</span> <span class="o">=</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">_Ty</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">reader</span><span class="p">.</span><span class="n">_buffer</span><span class="p">);</span>
        <span class="n">reader</span><span class="p">.</span><span class="n">_buffer</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">_Ty</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">reader</span><span class="p">;</span>
    <span class="p">}</span>
<span class="nl">private:</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">_buffer</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">buffer_writer_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">buffer_writer_t</span><span class="p">()</span>
        <span class="o">:</span> <span class="n">_buffer</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">buffer_t</span><span class="o">&gt;</span><span class="p">())</span> <span class="p">{}</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Ty</span><span class="o">&gt;</span>
    <span class="k">friend</span> <span class="kt">buffer_writer_t</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="kt">buffer_writer_t</span><span class="o">&amp;</span> <span class="n">writer</span><span class="p">,</span> <span class="k">const</span> <span class="n">_Ty</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">byte_begin</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
        <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">byte_end</span> <span class="o">=</span> <span class="n">byte_begin</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">byte_begin</span><span class="p">,</span> <span class="n">byte_end</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="o">*</span><span class="n">writer</span><span class="p">.</span><span class="n">_buffer</span><span class="p">.</span><span class="n">get</span><span class="p">()));</span>
        <span class="k">return</span> <span class="n">writer</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">buffer_ref</span> <span class="n">buffer</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_buffer</span><span class="p">;</span> <span class="p">}</span>
<span class="nl">private:</span>
    <span class="n">buffer_ref</span> <span class="n">_buffer</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p><code>buffer_writer_t</code> 객체는 여기저기 복사되어 전달될 수 있다. 그 때마다 buffer가 복사되면 자원이 아까우니 <code>shared_ptr</code> 형태인 buffer_ref를 사용하도록 하였다.</p>

<h3>handler</h3>

<p><code>buffer_reader_t</code>와 <code>buffer_writer_t</code>가 정의되었으니 handler는 다음과 같이 정의할 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span> <span class="p">(</span><span class="kt">buffer_reader_t</span><span class="p">,</span> <span class="kt">buffer_writer_t</span><span class="p">)</span><span class="o">&gt;</span> <span class="kt">handler_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">handler_t</span><span class="p">,</span> <span class="mi">128</span><span class="o">&gt;</span> <span class="kt">handler_array_t</span><span class="p">;</span>
</code></pre></div>
<p>rpc 함수는 필요한 인자(argument)를 buffer로부터 읽어서(<code>buffer_reader_t</code>) 그 결과를 다시 buffer로 써야한다(<code>buffer_writer_t</code>). 따라서 함수 signature가 reader와 writer를 인자로 받도록 구성된 것이다. 이 때 <code>buffer_writer_t</code> 객체가 reference가 아닌 이유는 writer가 갖고 있는 buffer 자체가 이미 <code>buffer_ref</code>이기 때문이다. 반환 값이 bool인 이유는 handler가 false를 반환할 경우 writer에 의해 작성된 buffer를 network로 전달하지 않기 위함이다.</p>

<p><code>rpc_client_t</code>와 <code>rpc_server_t</code>는 각기 다른 <code>handler_array_t</code>를 갖는다. 이 때 가질 수 있는 handler는 128개로 제한하였다. (원래 <code>UINT16_MAX</code>를 썼는데 이만큼 쓸 경우 <code>rpc_server_t</code>나 <code>rpc_client_t</code> 객체를 local variable로 만들면 stackoverflow가 발생한다-_-)</p>

<h3>session</h3>

<p>필요한 자료구조를 다 만들었으니 session도 쉽게 만들 수 있다. <code>session_t</code> class는 하나의 socket을 갖고, 그에 대해서 async-read/write 요청/완료 처리를 하는 class이다. peer로부터 message를 받으면 해당 message를 dispatch하여 적절한 handler를 호출해준다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">session_t</span> <span class="o">:</span> <span class="k">public</span> <span class="n">boost</span><span class="o">::</span><span class="n">enable_shared_from_this</span><span class="o">&lt;</span><span class="kt">session_t</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">session_t</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">io_service</span><span class="o">&amp;</span> <span class="n">io_service</span><span class="p">,</span> <span class="kt">handler_array_t</span><span class="o">&amp;</span> <span class="n">handler_array</span><span class="p">);</span>

    <span class="kt">void</span> <span class="nf">request_connect</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">ip</span><span class="o">::</span><span class="n">tcp</span><span class="o">::</span><span class="n">endpoint</span> <span class="n">endpoint</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">request_read_msg_size</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">request_read_msg</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">request_write</span><span class="p">(</span><span class="n">buffer_ref</span> <span class="n">buffer</span><span class="p">);</span>

    <span class="kt">bool</span> <span class="n">is_connected</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_connected</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">friend</span> <span class="k">class</span> <span class="nc">rpc_server_t</span><span class="p">;</span>
<span class="nl">private:</span>
    <span class="kt">void</span> <span class="nf">handle_connect</span><span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">error</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">handle_read_msg_size</span><span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">error</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">handle_read_msg</span><span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">error</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">handle_write</span><span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">error</span><span class="p">);</span>

<span class="nl">private:</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">io_service</span><span class="o">&amp;</span> <span class="n">_io_service</span><span class="p">;</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">ip</span><span class="o">::</span><span class="n">tcp</span><span class="o">::</span><span class="n">socket</span> <span class="n">_socket</span><span class="p">;</span>

    <span class="kt">size_t</span> <span class="n">_msg_size</span><span class="p">;</span>
    <span class="kt">buffer_t</span> <span class="n">_msg_buffer</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">atomic_bool</span> <span class="n">_connected</span><span class="p">;</span>
    <span class="kt">handler_array_t</span><span class="o">&amp;</span> <span class="n">_handler_array</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">session_t</span><span class="o">&gt;</span> <span class="n">session_ref</span><span class="p">;</span>
</code></pre></div>
<p><a href="http://www.boost.org/doc/libs/1_54_0/doc/html/boost_asio.html">boost asio</a>에 대해 자세한 설명은 하지 않겠다. 어쨌든 중요한건 요청을 수행하는 request 함수와 완료를 처리하는 handle 함수가 분리되어있다는 것이다.</p>

<p>전체 코드를 다 올리면 너무 기니까 간단하게 message를 읽는 코드만 옮겨보았다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="kt">session_t</span><span class="o">::</span><span class="n">request_read_msg_size</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">async_read</span><span class="p">(</span><span class="n">_socket</span><span class="p">,</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">buffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_msg_size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">_msg_size</span><span class="p">)),</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">transfer_exactly</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">_msg_size</span><span class="p">)),</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="kt">session_t</span><span class="o">::</span><span class="n">handle_read_msg_size</span><span class="p">,</span> <span class="n">shared_from_this</span><span class="p">(),</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">error</span><span class="p">));</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="kt">session_t</span><span class="o">::</span><span class="n">request_read_msg</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_msg_buffer</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">_msg_size</span><span class="p">)</span>
        <span class="n">_msg_buffer</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">_msg_size</span><span class="p">);</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">async_read</span><span class="p">(</span><span class="n">_socket</span><span class="p">,</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">buffer</span><span class="p">(</span><span class="n">_msg_buffer</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">_msg_size</span><span class="p">),</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">transfer_exactly</span><span class="p">(</span><span class="n">_msg_size</span><span class="p">),</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="kt">session_t</span><span class="o">::</span><span class="n">handle_read_msg</span><span class="p">,</span> <span class="n">shared_from_this</span><span class="p">(),</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">error</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>
<p>먼저 msg_size를 먼저 받아온 후 그 크기만큼 msg를 읽는다. <code>_msg_size</code> 변수는 <code>size_t</code> type인데 <code>asio::buffer()</code>는 type을 가리지 않기 때문에 <code>size_t</code> 변수에 바로 크기를 받아올 수 있다. 그 후 필요한 크기만큼 buffer를 적절하게 늘려서 <code>transfer_exactly</code>로 <code>async_read()</code>를 요청하면 boost asio가 알아서 잘 채워준다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="kt">session_t</span><span class="o">::</span><span class="n">handle_read_msg_size</span><span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">request_read_msg</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="n">_connected</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="kt">session_t</span><span class="o">::</span><span class="n">handle_read_msg</span><span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">buffer_reader_t</span> <span class="n">reader</span><span class="p">(</span><span class="n">_msg_buffer</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
        <span class="kt">uint16_t</span> <span class="n">msg_type</span><span class="p">;</span>
        <span class="n">reader</span> <span class="o">&gt;&gt;</span> <span class="n">msg_type</span><span class="p">;</span>

        <span class="kt">handler_t</span> <span class="n">handler</span> <span class="o">=</span> <span class="n">_handler_array</span><span class="p">[</span><span class="n">msg_type</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">handler</span> <span class="o">!=</span> <span class="n">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">buffer_writer_t</span> <span class="n">writer</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">handler</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="n">writer</span><span class="p">))</span>
                <span class="n">request_write</span><span class="p">(</span><span class="n">writer</span><span class="p">.</span><span class="n">buffer</span><span class="p">());</span>
        <span class="p">}</span>
        <span class="n">request_read_msg_size</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="n">_connected</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><code>msg_size</code> 요청 후 <code>msg_size</code>에 대한 완료 처리를 하고 그 다음에 msg 요청 후 msg에 대한 완료 처리를 한다. 그리고 다시 <code>msg_size</code> 요청하여 다음 msg를 받을 수 있도록 한다. 이렇게 하는 이유는 한 시점에 <strong>반드시 하나의 msg만 읽는 순서가 보장</strong>되도록 하기 위함이다.</p>

<p>어쨌든 msg를 읽었으면 <code>msg_type</code> 확인해서 <code>handler_array</code>에서 찾아 handler를 호출해준다. 그리고 원할 경후 handler에 의해 작성된 buffer_writer_t 내의 buffer를 peer에게 보내준다. (추후 코드가 나오겠지만 <code>handler_array</code>의 index 값과 message의 type 값은 일치하도록 구현하였다)</p>

<h3>rpc_server</h3>

<p><code>rpc_server_t</code> class는 boost asio acceptor를 사용하여 socket을 받고, <code>session_t</code> 객체를 만들어서 <code>request_msg_size()</code> 함수를 불러주는 class이다. protected로 노출되는 <code>handler_array</code>를 갖는데, 그 이유는 이를 상속받아 구현할 <code>rpc_server_t</code> class가 각 message를 받아 어떻게 처리할지 handler를 구현할 수 있도록 하기 위함이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">rpc_server_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">rpc_server_t</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">io_service</span><span class="o">&amp;</span> <span class="n">io_service</span><span class="p">,</span> <span class="kt">int</span> <span class="n">server_port</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="kt">rpc_server_t</span><span class="p">()</span> <span class="p">{}</span>
    <span class="kt">void</span> <span class="n">request_accept</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">handle_accept</span><span class="p">(</span><span class="n">session_ref</span> <span class="n">session</span><span class="p">,</span> <span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">error</span><span class="p">);</span>
<span class="nl">protected:</span>
    <span class="kt">handler_array_t</span> <span class="n">_handler_array</span><span class="p">;</span>
<span class="nl">private:</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">io_service</span><span class="o">&amp;</span> <span class="n">_io_service</span><span class="p">;</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">ip</span><span class="o">::</span><span class="n">tcp</span><span class="o">::</span><span class="n">acceptor</span> <span class="n">_acceptor</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="kt">rpc_server_t</span><span class="o">::</span><span class="n">request_accept</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">session_ref</span> <span class="n">session</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">session_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_io_service</span><span class="p">,</span> <span class="n">_handler_array</span><span class="p">);</span>
    <span class="n">_acceptor</span><span class="p">.</span><span class="n">async_accept</span><span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">_socket</span><span class="p">,</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="kt">rpc_server_t</span><span class="o">::</span><span class="n">handle_accept</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">session</span><span class="p">,</span>
            <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">error</span><span class="p">));</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="kt">rpc_server_t</span><span class="o">::</span><span class="n">handle_accept</span><span class="p">(</span><span class="n">session_ref</span> <span class="n">session</span><span class="p">,</span> <span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">session</span><span class="o">-&gt;</span><span class="n">request_read_msg_size</span><span class="p">();</span>
    <span class="n">request_accept</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>역시 accept의 순서 보장을 위해서 하나 accept 요청하고, 그 완료를 처리 후에 다음 accept를 요청하도록 되어있다. 사실 처음에 동시 접속이 많을 경우 위 같은 방법은 별로 좋지 않을 수 있다. 이를 위해 프로그램 처음 구동 시 <code>request_accept()</code>를 미리 많이 불러놓는 경우도 있다.</p>

<p><code>rpc_server</code> 측에 구현되는 message handler는 각 <code>message_type</code>에 따라 구현이 달라야 한다. 두 int의 덧셈을 요청하는 message라면 <code>int+int</code>을 구현해야 하고, 만약 두 double의 곱셈을 요청하는 message라면 <code>dobule*double</code>을 구현해야 하기 때문이다. 이 handler들은 추후 <code>rpc_server_t</code> class를 상속 받아 구현하는 rpc class에서 정의될 것이다.</p>

<h3>rpc_client</h3>

<p><code>rpc_client_t</code> class는 <code>rpc_server_t</code> class에 비해 다소 복잡하다.</p>

<ul>
<li>rpc 수행 결과를 비동기로 받아야 하니 rpc 요청 시 결과를 처리할 callback을 받아야 한다.</li>
<li>그리고 해당 rpc에 대한 수행 결과가 언제 올지 모르니, 요청할 때 id를 발급해서 id와 callback을 map같은 곳에다가 저장을 해두어야 한다.</li>
<li>그런데 rpc 함수의 return type은 제각각이니 이 callback을 일관된 type으로 통일을 해주어야 한다.</li>
</ul>

<p>그렇기 때문에 코드가 좀 복잡해진다. 일단 전체 코드를 보면 다음과 같다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">rpc_client_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">rpc_client_t</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">io_service</span><span class="o">&amp;</span> <span class="n">io_service</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="kt">rpc_client_t</span><span class="p">()</span> <span class="p">{}</span>
    <span class="kt">void</span> <span class="n">connect</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port</span><span class="p">);</span>
<span class="nl">protected:</span>
    <span class="k">struct</span> <span class="kt">general_callback_t</span> <span class="p">{</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="kt">general_callback_t</span><span class="p">()</span> <span class="p">{}</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="k">operator</span> <span class="p">()</span> <span class="p">(</span><span class="kt">buffer_reader_t</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">general_callback_t</span><span class="o">&gt;</span> <span class="n">general_callback_ptr</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">general_callback_ptr</span><span class="o">&gt;</span> <span class="kt">callback_map_t</span><span class="p">;</span>
    <span class="kt">int</span> <span class="nf">register_callback</span><span class="p">(</span><span class="n">general_callback_ptr</span> <span class="n">callback</span><span class="p">);</span>
    <span class="n">general_callback_ptr</span> <span class="nf">get_callback</span><span class="p">(</span><span class="kt">int</span> <span class="n">req_num</span><span class="p">);</span>
<span class="nl">protected:</span>
    <span class="n">session_ref</span> <span class="n">_session</span><span class="p">;</span>
<span class="nl">private:</span>
    <span class="kt">void</span> <span class="nf">initialize_handlers</span><span class="p">();</span>
    <span class="kt">bool</span> <span class="nf">default_handler</span><span class="p">(</span><span class="kt">buffer_reader_t</span> <span class="n">reader</span><span class="p">,</span> <span class="kt">buffer_writer_t</span> <span class="n">writer</span><span class="p">);</span>
<span class="nl">private:</span>
    <span class="kt">handler_array_t</span> <span class="n">_handler_array</span><span class="p">;</span>
    <span class="kt">callback_map_t</span> <span class="n">_callback_map</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">_callback_map_mutex</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">atomic_int</span> <span class="n">_req_num_gen</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>callback을 단일 type을 취급하기 위해 <code>general_callback_t</code> struct를 작성하였다. 단순히 <code>buffer_reader_t</code> 객체를 받아서 뭔가 처리하는 functor이고, 여기에 필요한 코드는 추후 rpc client 구현 시 macro로 찍어내게 될 것이다. 어쨌든 <code>general_callback_t</code>를 만들었으니 이 소유권을 보장해주기 위한 <code>unique_ptr</code>을 하나 선언하고, 이에 대한 map을 구성할 수 있다.</p>

<p>이제 <code>atomic_int</code>에 의해 thread-safe하게 증가되는 <code>request_number</code>와 함께 callback을 map에다가 register할 수 있는 것이다. 그리고 추후 해당 <code>request_number</code>에 대한 결과가 오면 <code>callback</code>을 꺼내서 호출해주면 된다.</p>

<p><code>rpc_server_t</code> class와는 다르게 <code>rpc_client_t</code> class는 <code>handler_array</code>를 갖지만 <code>default_handler</code>로 모든 것을 처리한다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="kt">rpc_client_t</span><span class="o">::</span><span class="n">initialize_handlers</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">handler</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="kt">rpc_client_t</span><span class="o">::</span><span class="n">default_handler</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">_1</span><span class="p">,</span> <span class="n">_2</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">each</span> <span class="o">:</span> <span class="n">_handler_array</span><span class="p">)</span>
        <span class="n">each</span> <span class="o">=</span> <span class="n">handler</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">bool</span> <span class="kt">rpc_client_t</span><span class="o">::</span><span class="n">default_handler</span><span class="p">(</span><span class="kt">buffer_reader_t</span> <span class="n">reader</span><span class="p">,</span> <span class="kt">buffer_writer_t</span> <span class="n">writer</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">req_num</span><span class="p">;</span>
    <span class="n">reader</span> <span class="o">&gt;&gt;</span> <span class="n">req_num</span><span class="p">;</span>
    <span class="n">general_callback_ptr</span> <span class="n">callback</span> <span class="o">=</span> <span class="n">get_callback</span><span class="p">(</span><span class="n">req_num</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">callback</span> <span class="o">!=</span> <span class="n">nullptr</span><span class="p">)</span>
        <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="n">reader</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>왜냐하면 <code>rpc_client</code> 입장에서는 도착하는 모든 message가 <code>request_number + result</code> 일 것인데, <code>request_number</code> 가져와서 <code>callback</code>을 얻었으면 실제 result를 얻는 것은 callback 내부에서 처리하기 때문에 handler에서는 따로 더 해줄 일이 없기 때문이다. (return false를 하는 이유는 rpc_client가 다시 rpc_server에게 뭔가 보낼 필요가 없기 때문이다)</p>

<p>callback 내에서는 reader 객체에서 result 값을 읽어서 사용자가 넘긴 진짜 callback을 불러줄 것이다. 그리고 이러한 코드는 macro에 의해서 자동 생성될 것이다.</p>

<h3>code generating</h3>

<p>이제 기반 class 구현이 끝났으니 기반 class를 상속받아 우리가 원하는 rpc class를 작성하면 되겠다. 하지만 우리의 관심사는 <strong>rpc 함수의 interface가 어떻게 선언되고, 그것에 대한 코드가 어떻게 정의되는가</strong>이다. 나머지 byte serializer나 rpc type enum 선언 등의 <a href="http://en.wikipedia.org/wiki/Boilerplate_code">boilerplate code</a>를 매번 작성해주는 것은 매우 귀찮은 일이니 직접하지 말고 컴파일러를 시키는 것이 여러모로 좋겠다.</p>

<p>일단 원하는 최종 형태의 코드는 다음과 같다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">RPC_BEGIN</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>
    <span class="n">RPC_METHOD2</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">RPC_METHOD2</span><span class="p">(</span><span class="kt">double</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">RPC_METHOD3</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="n">RPC_END</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>

<span class="kt">int</span> <span class="n">example</span><span class="o">::</span><span class="n">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">double</span> <span class="n">example</span><span class="o">::</span><span class="n">add</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="n">example</span><span class="o">::</span><span class="n">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div>
<p>rpc interface에 대한 선언을 하고, 그에 대한 구현을 한다. 그러면 필요한 나머지 코드가 모두 만들어지는 것이다.</p>

<p>type_enum, server 측의 rpc 수행 함수의 prototype, rpc_server, rpc_client 총 4개의 코드를 찍어내야 한다. 여기에는 <a href="http://en.wikipedia.org/wiki/X_Macro">X Macro pattern</a>이 사용될 것이다.</p>

<p>일단 본 예제에서는 총 3개의 인자까지 받을 수 있는 <code>RPC_METHOD3</code> macro까지 구현하였다. 결국 인자 개수만큼 macro를 다 만들어주어야 한다는 것인데 이러한 반복 코드는 <a href="http://www.boost.org/doc/libs/release/libs/preprocessor/doc/index.html">boost pp</a>를 사용해서 줄일 수 있다. 그렇지만 이 글에서 해당 내용까지 다루면 너무 길어지므로 일단 그냥 중복된 코드를 포함한 채로 macro를 선언하였다.</p>

<p>설명의 편의를 위해 <code>RPC_METHOD2()</code>를 기준으로 설명할 것이다.</p>

<p>type enum이 필요한 이유는 rpc client와 server가 어떤 rpc를 요청했는지를 구분하기 위한 식별자로 사용하기 위함이다. 그냥 enum 내에 rpc 함수 이름을 열거하면 되는데, 동일한 이름의 다른 argument type의 rpc가 존재할 수 있으니 rpc 이름에 type을 붙여서 type enum을 구성하도록 하자.</p>

<p>type enum 이름은 앞으로도 자주 사용되므로 이를 위한 helper macro를 선언한다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#define RPC_TYPE2(name, type1, type2) type_##name##_##type1##_##type2</span>
</code></pre></div>
<p>그리고 helper macro를 사용하여 enum을 생성하는 코드를 만들 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#define RPC_BEGIN(name) namespace name { enum type_enum {</span>
<span class="cp">#define RPC_METHOD2(rtype, name, type1, var1, type2, var2) RPC_TYPE2(name, type1, type2),</span>
<span class="cp">#define RPC_END(name) }; </span><span class="cm">/* enum */</span><span class="cp"> } </span><span class="cm">/* namespace */</span><span class="cp"></span>
</code></pre></div>
<p>코드 생성의 편의를 위해 namespace 내에 코드를 만들도록 하였다.</p>

<p>rpc server 측의 코드를 생성할 때에는, 실제 구현할 rpc 함수에 대한 prototype 선언, 그리고 message를 통해 실제 rpc 함수를 불러주는 entry function 2개의 코드를 만들어주어야 한다.</p>

<p>prototype을 생성해주는 코드는 간단한 편이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#define RPC_BEGIN(name) namespace name {</span>
<span class="cp">#define RPC_METHOD2(rtype, name, type1, var1, type2, var2) rtype name(type1 var1, type2 var2);</span>
<span class="cp">#define RPC_END(name) };</span>
</code></pre></div>
<p>그냥 해당 namespace 안에 rpc 함수 이름을 갖고, 지정된 type의 인자를 받는 함수를 선언하였다.</p>

<p>rpc server class를 만들어주는 macro는 약간 복잡하다. 아까 만든 rpc_server_t class를 상속받는 class를 하나 만든 후, <code>handler_array</code>에 각 rpc message를 받아서 실제 rpc 함수를 불러주는 과정의 코드를 만든다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#define RPC_BEGIN(name) \</span>
<span class="cp">    namespace name { \</span>
<span class="cp">    class name##_rpc_server_t : public rpc_server_t { \</span>
<span class="cp">    public: \</span>
<span class="cp">        name##_rpc_server_t(boost::asio::io_service&amp; io_service, int server_port) \</span>
<span class="cp">            : rpc_server_t(io_service, server_port) { \</span>
<span class="cp">            initialize_handlers(); \</span>
<span class="cp">        } \</span>
<span class="cp">    private: \</span>
<span class="cp">        void initialize_handlers() {</span>
<span class="cp">#define RPC_METHOD2(rtype, name, type1, var1, type2, var2) \</span>
<span class="cp">            _handler_array[RPC_TYPE2(name, type1, type2)] = [] \</span>
<span class="cp">                    (buffer_reader_t reader, buffer_writer_t writer) -&gt; bool { \</span>
<span class="cp">                int req_num; \</span>
<span class="cp">                type1 var1; \</span>
<span class="cp">                type2 var2; \</span>
<span class="cp">                reader &gt;&gt; req_num &gt;&gt; var1 &gt;&gt; var2; \</span>
<span class="cp">                rtype result = name(var1, var2); \</span>
<span class="cp">                writer &lt;&lt; sizeof(uint16_t) + sizeof(int) + sizeof(rtype); \</span>
<span class="cp">                writer &lt;&lt; static_cast&lt;uint16_t&gt;(RPC_TYPE2(name, type1, type2)); \</span>
<span class="cp">                writer &lt;&lt; req_num; \</span>
<span class="cp">                writer &lt;&lt; result; \</span>
<span class="cp">                return true; \</span>
<span class="cp">            };</span>
<span class="cp">#define RPC_END(name) \</span>
<span class="cp">        } </span><span class="cm">/* initialize_handlers */</span><span class="cp"> \</span>
<span class="cp">    }; </span><span class="cm">/* class */</span><span class="cp"> \</span>
<span class="cp">    }  </span><span class="cm">/* namespace */</span><span class="cp"></span>
</code></pre></div>
<p>그냥 <code>rpc_server_t</code> class 상속받고, <code>initialize_handlers()</code> 함수를 만든다. 그리고 그 함수 내에서 각 rpc message를 어떻게 처리할지에 대한 코드를 만드는데, 필요한 인자 정보를 <code>buffer_reader_t</code> 객체를 통해 읽고, 아까 prototype을 선언한 실제 함수를 불러 결과(result)를 얻은 뒤, 다시 그 결과를 <code>buffer_writer_t</code> 객체에 남아서 peer(client)에게 전달해주는 것이다.</p>

<p>rpc client 쪽은 callback 때문에 약간 복잡해보일 수 있지만 server와 난이도는 동일하다. 인자로 받은 내용을 buffer에 담아 peer(server)에게 보내고, 그 결과가 오면 callback을 불러주면 된다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#define RPC_BEGIN(name) \</span>
<span class="cp">    namespace name { \</span>
<span class="cp">    class name##_rpc_client_t : public rpc_client_t { \</span>
<span class="cp">    public: \</span>
<span class="cp">        name##_rpc_client_t(boost::asio::io_service&amp; io_service) \</span>
<span class="cp">            : rpc_client_t(io_service) { \</span>
<span class="cp">        }</span>
<span class="cp">#define RPC_METHOD2(rtype, name, type1, var1, type2, var2) \</span>
<span class="cp">        void name(type1 var1, type2 var2, boost::function&lt;void (rtype)&gt; callback) { \</span>
<span class="cp">            buffer_writer_t writer; \</span>
<span class="cp">            writer &lt;&lt; sizeof(uint16_t) + sizeof(int) + sizeof(type1) + sizeof(type2); \</span>
<span class="cp">            writer &lt;&lt; static_cast&lt;uint16_t&gt;(RPC_TYPE2(name, type1, type2)); \</span>
<span class="cp">            struct __callback_t : public general_callback_t { \</span>
<span class="cp">                virtual void operator () (buffer_reader_t reader) { \</span>
<span class="cp">                    rtype result; \</span>
<span class="cp">                    reader &gt;&gt; result; \</span>
<span class="cp">                    _callback(result); \</span>
<span class="cp">                } \</span>
<span class="cp">                __callback_t(boost::function&lt;void (rtype)&gt; callback) \</span>
<span class="cp">                    : _callback(callback) {} \</span>
<span class="cp">                boost::function&lt;void (rtype)&gt; _callback; \</span>
<span class="cp">            }; \</span>
<span class="cp">            int req_num = register_callback(general_callback_ptr( \</span>
<span class="cp">                                new __callback_t(callback))); \</span>
<span class="cp">            writer &lt;&lt; req_num &lt;&lt; var1 &lt;&lt; var2; \</span>
<span class="cp">            _session-&gt;request_write(writer.buffer()); \</span>
<span class="cp">        }</span>
<span class="cp">#define RPC_END(name)   \</span>
<span class="cp">    }; </span><span class="cm">/* class */</span><span class="cp">  \</span>
<span class="cp">    }  </span><span class="cm">/* namespace */</span><span class="cp"></span>
</code></pre></div>
<p><code>size</code>, <code>msg_type</code>, <code>req_num</code>, <code>args</code> 순으로 데이터를 writer에 써서 peer(server)에게 보낸다. 이 때 user-callback은 rtype(return type)을 인자로 받는 void function인데, 이를 callback map에 등록하기 위해 <code>general_callback_t</code> 객체로 감싼다. 이 <code>__callback_t</code> 객체의 <code>operator ()</code>가 불렸다는 것은 server의 수행 결과가 <code>buffer_reader_t</code> 객체에 담겼다는 것이므로 여기서 result를 읽어서<code>_callback</code>(user-callback)을 불러주기만 하면 된다.</p>

<p>이제 X-Macro pattern을 사용하기 위한 macro function 선언은 끝났다. 이제 약간의 전처리기 기술을 사용하면 코드가 완성된다. 개념을 익히기 위해 다음 코드르 보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#ifdef _OPTION_</span>
<span class="cm">/* define macro functions */</span>
<span class="cp">#include _TARGET_</span>
<span class="cm">/* undef macro functions */</span>
<span class="cp">#endif</span>
</code></pre></div>
<p>위 코드는 <code>_OPTION_</code> macro가 정의되어 있을 때만 수행되는 코드로, macro function을 그 구간 내에서만 사용하도록 정의(define) 후 해제(undef)하고 있다. 재밌는 것은 #include 부분인데 특정 파일을 지칭한 것이 아니라 <code>_TARGET_</code>라는 macro value를 지칭하고 있다. 즉, 위 내용이 들어있는 파일을 include하기 전에 <code>_TARGET_</code> macro에 적절한 파일명을 넣어주면 알아서 해당 파일을 include해준다는 것이다.</p>

<p>본 소스의 <code>rpc_gen_spec.h</code> 파일을 보면 <code>_RPC_GEN_TYPE_</code>,  <code>_RPC_GEN_SERVER_</code>, <code>_RPC_GEN_CLIENT_</code> 3개의 option에 대해서 각각 macro function을 교체한 후 <code>_RPC_GEN_TARGET_</code> macro value로 정의한 파일을 include하도록 되어있다.
이제 실제로 코드를 찍어내기 위한 <code>rpc_gen.h</code>에서는 다음과 같이 한 번에 여러 코드를 만들어낼 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#define _RPC_GENERATING_ 1</span>
<span class="cp">#   define _RPC_GEN_TYPE_</span>
<span class="cp">#     include &quot;rpc_gen_spec.h&quot;</span>
<span class="cp">#   undef _RPC_GEN_TYPE_</span>

<span class="cp">#   ifdef _RPC_SERVER_</span>
<span class="cp">#     define _RPC_GEN_SERVER_</span>
<span class="cp">#        include &quot;rpc_gen_spec.h&quot;</span>
<span class="cp">#       undef _RPC_GEN_SERVER_</span>
<span class="cp">#   endif</span>

<span class="cp">#   ifdef _RPC_CLIENT_</span>
<span class="cp">#      define _RPC_GEN_CLIENT_</span>
<span class="cp">#       include &quot;rpc_gen_spec.h&quot;</span>
<span class="cp">#     undef _RPC_GEN_CLIENT_</span>
<span class="cp">#   endif</span>
<span class="cp">#undef _RPC_GENERATING_</span>
</code></pre></div>
<p>일단 <code>_RPC_GEN_TYPE_</code> macro를 선언하고 <code>rpc_gen_spec.h</code> 파일을 include해서 <code>type_enum</code> 코드를 먼저 만들어낸다.  그리고 <code>_RPC_SERVER_</code>라는 option이 있으면 다시 <code>_RPC_GEN_SERVER_</code> macro 선언 후 <code>rpc_gen_spec.h</code> 파일을 include해서 서버 측 코드를 만들어낸다. 같은 방법으로 <code>_RPC_CLIENT_</code> option이 있으면 클라이언트 코드도 만들어낸다.</p>

<p>위 코드가 수행되는 동안 <code>_RPC_GENERATING_</code> 이라는 macro를 선언하고 있는데 그 이유는 이 파일을 include하는 쪽에서 초기 값을 선언할지, 아니면 코드 template을 선언할지에 대한 phase를 결정하도록 하기 위함이다.</p>

<p><code>example_rpc.h</code> 파일을 보면 이해하기가 쉽다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#ifndef _RPC_GENERATING_</span>
<span class="cp">#   define _RPC_SERVER_</span>
<span class="cp">#   define _RPC_CLIENT_</span>
<span class="cp">#   define _RPC_GEN_TARGET_ &quot;example_rpc.h&quot;</span>
<span class="cp">#   include &quot;rpc_gen.h&quot;</span>
<span class="cp">#else</span>
<span class="n">RPC_BEGIN</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>
    <span class="n">RPC_METHOD2</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">RPC_METHOD2</span><span class="p">(</span><span class="kt">double</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">RPC_METHOD3</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="n">RPC_END</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>
<span class="cp">#endif</span>
</code></pre></div>
<p><code>_RPC_GENERATING_</code> macro가 선언되어 있지 않다면 <code>_RPC_SERVER_</code>, <code>_RPC_CLIENT_</code> option을 주고, <code>_RPC_GEN_TARGET_</code>으로 이 파일 이름을 준다. 즉, 처음 이 파일이 include될 때 코드를 생성하기 위한 초기 값을 지정하는 것이다.</p>

<p>그리고 <code>rpc_gen.h</code> 파일이 include가 되면 <code>_RPC_GENERATING_</code> macro가 설정되고 <code>rpc_gen_spec.h</code> 파일이 include되면서 <code>_RPC_GEN_TARGET_</code>으로 지정된 <code>example_rpc.h</code> 파일이 <strong>다시</strong> include가 될 것이다. 이 때 <code>_RPC_GENERATING_</code> macro가 정의되었으므로 <code>RPC_BEGIN(...)</code> 코드가 사용될 것이고 이 macro function들이 적절히 치환되어 원하는 코드가 적절하게 생성될 것이다.</p>

<h3>example</h3>

<p>이제 모든 작업이 끝났으니 다음과 같이 코드를 실행해볼 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#include &quot;example_rpc.h&quot;</span>

<span class="kt">int</span> <span class="n">example</span><span class="o">::</span><span class="n">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">double</span> <span class="n">example</span><span class="o">::</span><span class="n">add</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="n">example</span><span class="o">::</span><span class="n">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span> <span class="p">}</span>

<span class="kt">int</span> <span class="n">_tmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">_TCHAR</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">io_service</span> <span class="n">io_service</span><span class="p">;</span>
    <span class="n">example</span><span class="o">::</span><span class="kt">example_rpc_server_t</span> <span class="n">server</span><span class="p">(</span><span class="n">io_service</span><span class="p">,</span> <span class="mi">12345</span><span class="p">);</span>
    <span class="n">server</span><span class="p">.</span><span class="n">request_accept</span><span class="p">();</span>

    <span class="n">example</span><span class="o">::</span><span class="kt">example_rpc_client_t</span> <span class="n">client</span><span class="p">(</span><span class="n">io_service</span><span class="p">);</span>
    <span class="n">client</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="s">&quot;127.0.0.1&quot;</span><span class="p">,</span> <span class="mi">12345</span><span class="p">);</span>

    <span class="n">client</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="p">[]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">});</span>
    <span class="n">client</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="mf">11.5</span><span class="p">,</span> <span class="mf">23.7</span><span class="p">,</span> <span class="p">[]</span> <span class="p">(</span><span class="kt">double</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">});</span>
    <span class="n">client</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="p">[]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">});</span>
    <span class="n">io_service</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>client 객체를 통해 rpc argument가 적절히 rpc server에게 전달되어 실 구현 함수가 수행된 후, 그 결과가 적절히 client의 callback으로 돌아와 console에 출력되는 것을 볼 수 있다.</p>

<h3>정리</h3>

<ul>
<li>macro 코드가 좀 더러운데 이 부분은 boost pp로 정리하면 어느 정도 괜찮아진다.</li>
<li>thread-safe하지 않은 코드가 좀 보이는데 적절하게 고쳐 쓰면 multi-thread에서도 안전하게 사용할 수 있다.</li>
<li>handler 개수가 128개로 제한되는 것이 아까우면 handler_array가 heap에 할당되도록 수정하면 된다.</li>
<li>rpc 결과를 callback으로 받아오는 것이 마음에 들지 않는다면 boost coroutine을 써서 실행 흐름을 제어하면 된다.</li>
</ul>

<p>어쨌든 할만큼 한 것 같다. reflection이 익숙한 스터디 친구들은 저정도로 만족하지 못할 것 같지만 c++에서 code generator 도움이 없이 코드를 정리하면 저게 한계다. 정말이다!</p>

<h3>소스 코드</h3>

<ul>
<li><a href="https://github.com/lacti/cpp-rpc">Github: cpp-rpc</a></li>
<li>첨부된 프로젝트를 실행하기 위해서는 BOOST_INCLUDE, BOOST_LIB64 macro에 각 경로를 지정해야 한다. Visual Studio의 Property Manager window를 켜서, Microsoft.Cpp.x64.user를 열어 User Macros에 BOOST_INCLUDE와 BOOST_LIB64를 추가해주면 된다.</li>
</ul>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">lambda와 RAII 1</h1>
				<p class="page-date">01 Apr 2012</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
						
				</p>
				<div class="content"><p>C++11 에서 도입된 lambda expression을 통한 RAII 구현 방식의 한 예와, 단위 전략을 통한 RAII 구현을 통해 장단점을 비교해보자.</p>

<p><a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">Wiki: Resource Acquisition Is Initialization(RAII)</a>는 scope 내의 정적으로 할당되는 객체의 생존 주기로 생성자와 소멸자가 쌍으로 호출되는 것을 사용하는 자원 관리 기법이다. 보통</p>

<ul>
<li>IO (열었으면 닫아야하니까),</li>
<li>메모리 (할당했으면 해제해야하니까, shared_ptr도 AddReference 했으면 ReleaseReference)</li>
<li>Lock (Lock 걸었으면 Unlock 해줘야하니까)</li>
</ul>

<p>등에서 사용된다.</p>

<p>본 글에서는 Lock을 사용하여 예를 들어보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">lock_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">lock</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">unlock</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div>
<p>위와 같은 <code>lock_t</code> class가 정의되어 있다. 어떤 class에서 저 객체를 쓴다고 해보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">item_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kr">__int64</span> <span class="kt">item_id_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">item_t</span><span class="o">&gt;</span> <span class="n">item_ref</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">inventory_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">item_ref</span> <span class="n">find</span><span class="p">(</span><span class="kt">item_id_t</span> <span class="n">item_id</span><span class="p">);</span>
<span class="nl">private:</span>
    <span class="kt">lock_t</span> <span class="n">lock</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">item_ref</span><span class="o">&gt;</span> <span class="n">items</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">item_ref</span> <span class="kt">inventory_t</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="kt">item_id_t</span> <span class="n">item_id</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
    <span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">items</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">items</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">find_item_by_id</span><span class="p">(</span><span class="n">item_id</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">!=</span> <span class="n">items</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">);</span>
    <span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="k">return</span> <span class="nf">item_ref</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>inventory가 가지고 있는 item에 대한 정보는 item의 <code>vector</code>로 관리하고 있다. 저 inventory 객체를 여러 Thread에서 접근한다고 하면, <code>std::find()</code>에 의해 <code>vector</code>를 순회하다가 접근 위반이 발생할 가능성이 있다. (한 thread 는 순회하고, 한 thread 는 vector 에 삽입/삭제할 경우)
따라서 lock을 사용하여 해당 container 를 보호해준다.</p>

<p>하지만 위 코드는 문제가 있다.<br>
<code>lock</code>을 사용하여 <code>items</code>로의 접근을 보호하지만, 실제 item을 찾은 다음 return 문을 수행하기 전에 <code>unlock</code>을 수행하지 않았기 때문이다. 이러한 문제는 <code>find</code> 함수가 좀만 길어지면, 혹은 조금만 신경을 쓰지 않게 되면 흔히 발생할 수 있는 문제이다.</p>

<p>따라서 이러한 문제를 해결하기 위해 정적 객체의 생존 주기를 활용한다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">scope_lock_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">scope_lock_t</span><span class="p">(</span><span class="kt">lock_t</span><span class="o">*</span> <span class="n">_lock</span><span class="p">)</span> <span class="o">:</span> <span class="n">lock</span><span class="p">(</span><span class="n">_lock</span><span class="p">)</span> <span class="p">{</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">();</span> <span class="p">}</span>
    <span class="o">~</span><span class="kt">scope_lock_t</span><span class="p">()</span> <span class="p">{</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">unlock</span><span class="p">();</span> <span class="p">}</span>
<span class="nl">private:</span>
    <span class="kt">lock_t</span><span class="o">*</span> <span class="n">lock</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>멤버로 <code>lock_t</code>에 대한 pointer를 갖고, 생성자에서 <code>lock()</code>을 부르고 소멸자에서 <code>unlock()</code>을 부르도록 하는 <code>scope_lock_t</code> class를 설계한다. 그러면 코드가 아래와 같이 바뀐다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">item_ref</span> <span class="kt">inventory_t</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="kt">item_id_t</span> <span class="n">item_id</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">scope_lock_t</span> <span class="n">scope_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">items</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">items</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">find_item_by_id</span><span class="p">(</span><span class="n">item_id</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">!=</span> <span class="n">items</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">);</span>
    <span class="k">return</span> <span class="nf">item_ref</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p><code>scope_lock_t</code> 객체가 멤버 변수인 <code>lock</code>을 가지고 생성된다. 생성될 때 <code>scope_lock_t</code>의 생성자에서 <code>lock()</code> 함수가 불린다. 그리고 실제 로직이 아래에서 수행되고 <code>inventory_t::find()</code> 함수가 종료되는 시점, 즉 <code>scope_lock_t</code> 객체가 소멸되는 시점에 <code>unlock()</code> 함수가 불린다.</p>

<p>생성자와 소멸자는 해당 객체의 생성/소멸 시점에 컴파일러가 알아서 불러주므로, 위와 같이 <code>scope_lock_t</code>를 만들어 쓰면 중간에 return을 해도, goto를 해도, 1년 뒤에 코드를 고쳐도! lock-unlock쌍이 잘 맞게 된다. 
<a href="/2011/07/20/object-ctor-dtor-with-goto/">(객체 생성/소멸자와 goto 에 대한 이야기)</a></p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">lambda와 RAII 2</h1>
				<p class="page-date">12 May 2012</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
						
				</p>
				<div class="content"><p>C++11은 lambda expression을 지원해주니 좀 다르게 생각해볼 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">lock_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">functor</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">scoped</span><span class="p">(</span><span class="n">functor</span><span class="o">&amp;</span> <span class="n">func</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">lock</span><span class="p">();</span>
        <span class="n">func</span><span class="p">();</span>
        <span class="n">unlock</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p><code>lock_t</code> class 자체에 위와 같이 functor를 받아 실행할 수 있는 함수를 만든다. 그리고 그 앞 뒤로 lock-unlock을 불러준다.</p>

<p>이렇게 하면 lambda를 사용하여 lock 사용 코드를 보다 깔끔하게 정리해볼 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">item_ref</span> <span class="kt">inventory_t</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="kt">item_id_t</span> <span class="n">item_id</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">item_ref</span> <span class="n">item</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="n">lock</span><span class="p">.</span><span class="n">scoped</span><span class="p">([</span><span class="o">&amp;</span><span class="n">item</span><span class="p">]</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">items</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">items</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">find_item_by_id</span><span class="p">(</span><span class="n">item_id</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">!=</span> <span class="n">items</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
            <span class="n">item</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">);</span>
    <span class="p">});</span>
    <span class="k">return</span> <span class="n">item</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>lambda를 통해 lock 구문을 수행하는 코드를 보다 깔끔하게 묶어낼 수 있다... 라고 이야기하고 싶지만, item이라는 값을 반환해야할 방법이 딱히 없어서 외부에서 변수를 선언하고 내부로 전달하는 영 좋지 못한 방법을 쓰고 있다.</p>

<p>약간 이야기가 다른 길로 가지만, 보다 깔끔한 해결책을 위해 아래와 같이 코드를 작성해볼 수 있다는 것을 이야기하고 싶다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">lock_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span> <span class="n">functor</span><span class="o">&gt;</span>
    <span class="n">R</span><span class="o">&amp;&amp;</span> <span class="n">scoped_return</span><span class="p">(</span><span class="n">functor</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">lock</span><span class="p">();</span>
        <span class="n">R</span><span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">func</span><span class="p">();</span>
        <span class="n">unlock</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>lock 범위 내에서 값을 반환할 수 있는 형태의 코드를 작성한 뒤 이를 사용하도록 한다는 것이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">item_ref</span> <span class="kt">inventory_t</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="kt">item_id_t</span> <span class="n">item_id</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lock</span><span class="p">.</span><span class="n">scoped_return</span><span class="o">&lt;</span><span class="n">item_ref</span><span class="o">&gt;</span><span class="p">([</span><span class="o">=</span><span class="p">]</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">items</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">items</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">find_item_by_id</span><span class="p">(</span><span class="n">item_id</span><span class="p">));</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">iter</span> <span class="o">!=</span> <span class="n">items</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="o">?</span> <span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">)</span><span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div>
<p>물론 값을 쓸데없이 복사하는 구간이 있는데, 저 부분은 다시 RAII를 사용하여 묶는 등 코드를 좀 더 정리해볼 수 있겠다. (그게 귀찮아서 위처럼 r-value를 썼는데, 어차피 move constructor가 구현되어있지 않다면 저 방법은 효윺이 영 좋지 않을 수 있다.)</p>

<p>lambda를 이용해 raii 영역을 하나의 scope로 묶어주는 방법에 대해서 정리해봤다. 하지만 이 방법을 써도 결국 최종 지점 (위 예제에서는 scoped 함수)에서는 결국 raii를 사용하여 자원을 관리할 필요가 있게 된다.</p>

<p>이러한 패턴은 생각보다 자주 등장하게 되므로, 이에 대한 일반적인 패턴을 만들어놓으면 좋을 것이다. 이를 만족시키는 적절한 template class 를 작성해보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Ty</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="n">_Ty</span><span class="o">::*</span><span class="n">begin</span><span class="p">)(),</span> <span class="kt">void</span> <span class="p">(</span><span class="n">_Ty</span><span class="o">::*</span><span class="n">end</span><span class="p">)()</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">raii_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">raii_t</span><span class="p">(</span><span class="n">_Ty</span><span class="o">*</span> <span class="n">_obj</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">obj</span><span class="p">(</span><span class="n">_obj</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;*</span><span class="n">begin</span><span class="p">)();</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="kt">raii_t</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;*</span><span class="n">end</span><span class="p">)();</span>
    <span class="p">}</span>
<span class="nl">private:</span>
    <span class="n">_Ty</span><span class="o">*</span> <span class="n">obj</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p><code>raii_t</code>라는 class는 특정 type과, 그 type에 대해 시작 시 수행할 함수와 끝날 때 수행될 함수를 template 인자로 받는다. 이제 <code>lock_t</code>에 대한 <code>lock_raii_t</code> class는 다음과 같은 typedef로 정의할 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="kt">raii_t</span><span class="o">&lt;</span><span class="kt">lock_t</span><span class="p">,</span> <span class="o">&amp;</span><span class="kt">lock_t</span><span class="o">::</span><span class="n">lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="kt">lock_t</span><span class="o">::</span><span class="n">unlock</span><span class="o">&gt;</span> <span class="kt">lock_raii_t</span><span class="p">;</span>
</code></pre></div>
<p><code>lock_raii_t</code>는 <code>lock_t</code>에 대해 동작하면서, 해당 변수가 생성 시 <code>lock_t::lock()</code> 함수를 부르고, 소멸될 때 <code>lock_t::unlock()</code> 함수를 부르게 된다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">lock_t</span> <span class="n">lock</span><span class="p">;</span>
<span class="kt">lock_raii_t</span> <span class="nf">raii</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
</code></pre></div>
<p>저 <code>raii_t</code>는 꽤 일반적이어서, 생성과 소멸 시 특정 함수를 통해 자원 관리가 되어야 하는 class에 대해 모두 적용될 수 있다. 예를 들면 <code>shared_ptr</code> (add_ref/release_ref) 등이 될 수 있다.</p>

<p><a href="https://twitter.com/summerlight00" title="summerlight00">summerlight</a>님께서 예제로 달았던 finalizer를 raii의 예로 들어보자. 특정 scope가 끝나는 시점에 수행되어야할 작업들을 명시해주는 객체가 된다. 즉, 익명의 객체를 하나 만들고, 그 소멸자에서 수행될 함수를 인자로 받도록 한다.</p>

<p>먼저 소멸자에서 무언가를 수행해줄 수 있는 class를 만들어보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Func</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">finalizer</span> <span class="p">{</span>
    <span class="n">finalizer</span><span class="p">(</span><span class="n">_Func</span><span class="o">&amp;&amp;</span> <span class="n">_func</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">func</span><span class="p">(</span><span class="n">_func</span><span class="p">)</span> <span class="p">{}</span>
    <span class="o">~</span><span class="n">finalizer</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">func</span><span class="p">();</span>
    <span class="p">}</span>
<span class="nl">private:</span>
    <span class="n">_Func</span> <span class="n">func</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>보다 일반적인 함수 수행을 원한다면 (일반 함수, 함수자, 멤버 함수 등) <code>std::function</code> 등을 적절히 사용하는 것도 좋겠지만 본 예제에서는 간단히 위처럼 설계했다. 위 <code>finalizer</code> class는 생성자로 받은 함수를 소멸자에서 수행하므로, 해당 객체가 소멸될 때까지 인자로 받은 함수의 수행을 미루게 된다.</p>

<p>이제 template argument 유추를 컴파일러에게 맡기기 위해 이 객체를 만들어주는 함수를 만들자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Func</span><span class="o">&gt;</span>
<span class="n">finalizer</span><span class="o">&lt;</span><span class="n">_Func</span><span class="o">&gt;</span> <span class="n">do_exit_scope</span><span class="p">(</span><span class="n">_Func</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">finalizer</span><span class="o">&lt;</span><span class="n">_Func</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">func</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>
<p>그러면 다음과 같이 사용이 가능해진다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">do_exit_scope</span><span class="p">([</span><span class="o">=</span><span class="p">]</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// implements here!</span>
<span class="p">});</span>
</code></pre></div>
<p>생성된 객체가 소멸될 때 불려야한다는 것은, 불편하게도 <code>auto f</code>와 같이 명시적으로 변수를 코드로 적어줘야 한다는 이야기다. 이왕이면 이런 것 정도는 자동으로 컴파일러가 해줬으면 좋겠다, 싶으니 약간의 장난을 쳐보자.</p>

<p>g++은 어떻게 해야 좋을지 모르겠고, <code>__COUNTER__</code> macro가 있는 msvc기준으로 설명하겠다. <code>__COUNTER__</code>는 해당 매크로가 해석될 때마다 1씩 증가하는 predefined macro이다. 따라서 임시 변수 명을 지어주기에는 적합한 녀석이다. (대체품으로 <code>__LINE__</code>를 쓰기도 한데, 이러면 한 줄에 여러 코드를 작성할 수 없다.)</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#define __concat(a, b)      a##b</span>
<span class="cp">#define __auto_var          __concat(_auto_var, __COUNTER__)</span>
<span class="cp">#define __do_exit_scope(f)  auto __auto_var = do_exit_scope(f)</span>
</code></pre></div>
<p><code>__auto_var</code> 매크로는 자동으로 변수의 이름을 대충 지어주는 매크로다. _auto_var라는 prefix를 붙이고, 뒤에 <code>__COUNTER__</code>를 붙여서 _auto_var1, _auto_var2 등으로 해당 매크로를 사용할 때마다 이름이 알아서 지어지도록 한다.</p>

<p><code>__COUNTER__</code>와 _auto_var를 붙이기 위해서 <code>##</code> 연산자를 썼다. 다만 이게 <code>_auto_var##__COUNTER__</code>처럼 사용하면 <code>__COUNTER__</code>이 문자열로 해석되므로 <code>__concat</code>와 같은 다른 macro를 만들어서 사용해야 한다.</p>

<p>마지막으로 <code>__do_exit_scope</code>라는 매크로 함수를 만들어서, 인자로 받은 함수에 대해 자동 변수 이름을 부여하도록 한다. 이러면 <code>auto f</code>와 같이 명시적으로 이름을 지정해주지 않아도 자동으로 변수를 할당하므로 조금이나마 더 나은 코드를 작성할 수 있다 (라는 기분이 든다-_-)</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">__do_exit_scope</span><span class="p">([</span><span class="o">=</span><span class="p">]</span> <span class="p">()</span> <span class="p">{</span> <span class="n">_tprintf_s</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">&quot;third</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span> <span class="p">});</span>
<span class="n">__do_exit_scope</span><span class="p">([</span><span class="o">=</span><span class="p">]</span> <span class="p">()</span> <span class="p">{</span> <span class="n">_tprintf_s</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">&quot;second</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span> <span class="p">});</span>
<span class="n">__do_exit_scope</span><span class="p">([</span><span class="o">=</span><span class="p">]</span> <span class="p">()</span> <span class="p">{</span> <span class="n">_tprintf_s</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">&quot;first</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span> <span class="p">});</span>
</code></pre></div>
<p>(변수의 소멸 순서는 생성 순서의 역순이므로, 출력 순서는 first - second - third 가 된다.)</p>

<p>raii 기법은 단순히 생성자/소멸자 쌍에서 관리 대상 객체의 특정 함수 호출 쌍을 맞춰줌으로써 자원 관리에 문제가 없도록 해주는 기법이라 정리해볼 수 있겠다.</p>

<p>이를 위해 자원이 사용되는 구간을 scope로 한정 짓기 위해 lambda를 사용하는 방법, 그리고 generic한 <code>raii_t</code> template class를 구현하여 사용하는 방법에 대해 간단히 알아보았다.</p>

<p>여기서 그치지 않고 더 나아가본다면 <strong>raii class 를 단위 전략 기법</strong>을 사용하여 설계하는 것이다. 간단히 설명하면,</p>

<ul>
<li>raii 객체가 생성자로 관리할 객체의 주소를 인자로 받는데, 그냥 자신의 멤버 변수로 가지고 있으면 안되나?</li>
<li>raii 객체가 생성자, 소멸자에서 호출될 함수를 모두 template 인자로 받는데, 위의 finalizer 예제 처럼 한 쪽에 대해 아무 동작을 수행하지 않도록 할 수 있는 다른 장치를 구현할 수 없을까?</li>
<li>raii 객체의 복사/대입 가능성은 전혀 고려하지 않고 있는데, 이것에 대해서는 어떻게 다루는 것이 좋을까?</li>
<li>raii 객체에 대해 multi-thread에서 접근한다고 할 필요가 있을 수 있는데, 위 raii class는 그런 관점에서는 일반적이라고 하기에는 무리가 있지 않을까?</li>
</ul>

<p>등등, storage, default template argument, ownership, thread-safety 등 몇 가지 세부 구현 전략에 대해서 더 raii class를 더 고민해볼 수 있는데, 이러한 것들을 <strong>단위 전략(policy)</strong> 이라고 불렀던 것이다(MC++D)</p>

<p>이 내용은 굉장히 흥미롭겠지만, 여백이 부족하여 더 이상 적지 않는다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">LockWindowUpdate</h1>
				<p class="page-date">18 Dec 2010</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
						
				</p>
				<div class="content"><p>Win32 혹은 MFC를 하다보면<br>
어떤 창 내에 여러 Child Window가 존재하고, 또, 해당 DC를 얻어서 그림을 그려야하는 경우가 생긴다.</p>

<p>이들이 모두 변경되는 경우, 즉 그림도 변경되고 Child Window도 <code>SetWindowPos</code> 등의 함수를 통해 변경될 경우에
그림은 <code>InvalidateRect()</code> 등의 함수에 의해 다시 그려질 것이나<br>
Child Window는 <code>SetWindowPos</code>나 <code>ShowWindow</code>함수가 호출되는 즉시 변경이 되기 때문에 UI가 <strong>한번에 갱신되지 않고 지역별로 갱신되는 문제</strong>가 발생한다.</p>

<p>이를 동기화하려면 부모 Window의 <code>WM_PAINT</code> 메시지와 Child Window의 <code>WM_PAINT</code>가 동기적으로 일어나야 한다.
하지만 어차피 부모 Window <code>WM_PAINT</code> 수행될 때 InvalidateRect 영역 내에 있는 Child의 Window에 대해서도 <code>WM_PAINT</code>가 다 수행되므로 개별 UI만 갱신되지 않도록 막아주면 된다.</p>

<p>따라서,</p>

<ul>
<li><code>LockWindowUpdate</code> 함수를 통해 부모 Window에 Lock을 걸어 Child Window가 수정되어도 <code>WM_PAINT</code> 가 수행되는 것을 막고 </li>
<li>모든 작업이 끝난 후에 <code>LockWindowUpdate(NULL)</code>을 호출하여 <code>UpdateWindow</code>를 수행해 줌으로써 화면을 갱신해주면 되겠다.</li>
</ul>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">member-data-pointer와 pointer의 차이</h1>
				<p class="page-date">13 Oct 2012</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
						
				</p>
				<div class="content"><p>pointer는 메모리의 특정 공간의 주소를 지칭하기 위해 사용된다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">float</span> <span class="n">some_var</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
<span class="kt">float</span><span class="o">*</span> <span class="n">float_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">some_var</span><span class="p">;</span>
</code></pre></div>
<p>member data pointer는 구조체나 클래스의 특정 멤버 변수의 위치를 상대적으로 지칭하기 위해 쓰인다. 따라서 메모리 주소 값을 가지는 것이 아니라, 구조체나 클래스 객체에서 어디에 접근을 해야하는지의 정보를 담고 있다고 생각하면 된다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="kt">tuple_t</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">first</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="kt">float</span> <span class="kt">tuple_t</span><span class="o">::*</span><span class="kt">member_t</span><span class="p">;</span>
</code></pre></div>
<p>때문에 실제 메모리에 접근하기 위해서는 구조체나 클래스 객체가 있어야 하고, 접근할 때에도 dereference operator를 써주어야 한다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">member_t</span> <span class="n">member</span> <span class="o">=</span> <span class="o">&amp;</span><span class="kt">tuple_t</span><span class="o">::</span><span class="n">first</span><span class="p">;</span>
<span class="kt">tuple_t</span> <span class="n">tuple</span><span class="p">;</span>
<span class="n">tuple</span><span class="p">.</span><span class="o">*</span><span class="n">member</span> <span class="o">=</span> <span class="mf">100.0f</span><span class="p">;</span>
</code></pre></div>
<p>위와 같이 <code>tuple.*member</code>를 통해 <code>member</code>가 가리키는 <code>first</code> 변수에 접근할 수 있었다. 이것은 <code>tuple</code> 객체 내에서 <code>member</code>가 가리키는 위치이고, <code>tuple</code>이라는 메모리 공간의 특정 지점에 접근을 하였으니 이제 float 값을 대입할 수 있는 것이다.</p>

<p>이제 float*로 저것을 가리킬 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">float</span><span class="o">*</span> <span class="n">float_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">tuple</span><span class="p">.</span><span class="o">*</span><span class="n">member</span><span class="p">);</span>
</code></pre></div>
<p>요약하면,</p>

<ul>
<li>메모리 주소 값을 갖는 <code>float*</code>와는 다르게 member-data-pointer는 객체 내의 상대적 위치 정보를 갖기 때문에 바로 <code>float*</code>로 casting할 수는 없고,</li>
<li>객체를 두고 객체 내의 멤버를 접근한 다음(<code>.*</code> 혹은 <code>-&gt;*</code>)에야 메모리 주소인 <code>float*</code>로 가리킬 수 있게 된다는 것이다.</li>
</ul>

<p>member-data-pointer가 member의 위치를 어떻게 가리킬 수 있는지에 대한 세부 내용은 접어두더라도, 객체 내의 member 위치(<code>offset_of</code>)의 방법을 이해하면 굳이 member-data-pointer를 쓰지 않아도 비슷한 효과를 흉내낼 수 있다(c-style)</p>

<p>이에 대해서는 다음 글에서 알아보자.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">MSVC call stacktrace 구현</h1>
				<p class="page-date">20 Jul 2011</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
						
				</p>
				<div class="content"><p>이전에 Macro와 inline을 사용하여 log를 찍는 이야기를 했었다. 좀 더 나아가면 여러가지 재밌는 일을 할 수 있어 소개해보고자 한다.<br>
다룰 내용은 <code>__FUNCSIG__</code>와 <code>__if_exists</code>이다. Visual Studio 전용일거다. gcc 유저는 저리가라</p>

<p>지인의 이야기를 들어보니 x64에서 디버깅을 할 경우 Call Stack이 알 수 없게 쌓인다고 한다. 따라서 x64 용 디버깅을 위해 Call Stack Trace 를 만들어본다는 마음으로 글을 읽어보자</p>

<p><code>__FUNCSIG__</code>는 Visual C++ compiler가 제공하는 <a href="http://msdn.microsoft.com/en-us/library/b0084kay.aspx">Predefined Macro</a>중 하나이다.
말 그대로 Function Signature를 <code>const char *</code> 형태로 넣어주는 것이다. 컴파일러가 해당 함수를 parsing 하다가 <code>__FUNCSIG__</code>를 만나면, code generation을 할 때 그걸 그 Function Signature로 static한 <code>const char</code> 배열을 만들고 그 주소값을 넣어주는게 아닐까. 요즘은 신통하게 <code>_T()</code> 매크로랑 같이 쓰면 <code>wchar_t</code> 형태로도 준다. 만세!</p>

<p><a href="http://msdn.microsoft.com/en-us/library/x7wy9xh3.aspx"><code>__if_exists</code></a>는 해당 지점에서 그 symbol이 존재하는지를 확인하기 위한 것이다. 당연히 컴파일러가 컴파일 단계에서 확인하는 것이고, 런타임 용은 아니다. <code>else</code> 를 쓸 수는 없고 <code>__if_not_exists</code>를 써야 한다.<br>
이 문서에서는 this symbol 여부를 확인하기 위해 쓸거다.</p>

<p>Call Stack 을 쌓기 위해 먼저 <code>StackElement</code>부터 만들어야한다. 가볍게, 파일명, 줄 수, this 주소 정도를 받아보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="n">StackElement</span>
<span class="p">{</span>
    <span class="n">LPCTSTR</span> <span class="n">FileName</span><span class="p">;</span>
    <span class="n">UINT</span>    <span class="n">Line</span><span class="p">;</span>
    <span class="n">LPCTSTR</span> <span class="n">FunctionSignature</span><span class="p">;</span>
    <span class="n">PVOID</span>    <span class="n">This</span><span class="p">;</span>

    <span class="n">StackElement</span><span class="p">(</span><span class="n">LPCTSTR</span> <span class="n">fileName</span><span class="p">,</span> <span class="n">UINT</span> <span class="n">line</span><span class="p">,</span> <span class="n">LPCTSTR</span> <span class="n">functionSignature</span><span class="p">,</span> <span class="n">PVOID</span> <span class="n">_this</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">FileName</span><span class="p">(</span><span class="n">fileName</span><span class="p">),</span> <span class="n">Line</span><span class="p">(</span><span class="n">line</span><span class="p">),</span> <span class="n">FunctionSignature</span><span class="p">(</span><span class="n">functionSignature</span><span class="p">),</span> <span class="n">This</span><span class="p">(</span><span class="n">_this</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>
</code></pre></div>
<p>그리고 Stack을 구현해야하지만 귀찮으니까 <code>std::deque</code>를 쓰자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="n">StackElement</span><span class="o">&gt;</span> <span class="n">CallStackType</span><span class="p">;</span>
<span class="n">CallStackType</span> <span class="n">CallStack</span><span class="p">;</span>
</code></pre></div>
<p>만약 Multi-Thread환경에서 작업한다면 전역 변수로 Call Stack을 관리한다는건 미친 짓이다. 적절히 Thread 별로 자료구조를 구현하거나(index 를 발급한다던지), Tls를 써주는게 좋겠다. 이 내용은 다음에 다루자.</p>

<p>그러면 이제 해당 logging을 위한 매크로를 작성하는 일만 남았다.<br>
왜 매크로를 작성해야하냐 하면은, <code>__FILE__</code>, <code>__LINE__</code>, <code>__FUNCSIG__</code>와 <code>__if_exits</code>를 문맥이 변경되지 않게 사용해야 하기 때문이다. <code>inline function</code>을 쓰면 해당 function이 호출되어버리니까 함수 문맥이 바뀌어버려서 안된다.</p>

<p>고로 매크로를 써야한다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#define START_TRACE() \</span>
<span class="cp">    do { \</span>
<span class="cp">        PVOID __this = NULL; \</span>
<span class="cp">        __if_exists (this) { \</span>
<span class="cp">            __this = this; \</span>
<span class="cp">        } \</span>
<span class="cp">        CallStack.push_front(StackElement(_T(__FILE__), __LINE__, _T(__FUNCSIG__), __this)); \</span>
<span class="cp">    } while (false)</span>

<span class="cp">#define END_TRACE() \</span>
<span class="cp">    CallStack.pop_front()</span>
</code></pre></div>
<p>약간 길어서 마음에 안 들기는 하다. 먼저 this symbol이 있는지 <code>__if_exists</code>로 검사한다. 있다면 그 주소를 <code>__this</code>변수에 넣고, 아니면 <code>NULL</code>로 유지한다. 그리고 <code>__FILE__</code>, <code>__LINE__</code>, <code>__FUNCSIG__</code>와 <code>__this</code> 정보를 <code>StackElement</code>에 담아서 CallStack 변수의 가장 위(push_front)에 넣는다.</p>

<p>그리고 함수 호출이 끝나서 빼는 경우에는 앞에서 뺀다(pop_front).</p>

<p>여기까지 읽다보면 실망하는 사람이 있을 것이다.
신통하게 뭔가 매크로만 하나 맨 위에 선언해두면 알아서 CallStack이 쌓이는 줄 알았는데, 이거 매크로를 각 함수마다 덕지덕지 발라야할 조짐을 느꼈기 때문일 것이다. 맞는 이야기이다.</p>

<p>간단한 예제를 보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Pot</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Pot</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="o">:</span> <span class="n">size</span><span class="p">(</span><span class="n">rand</span><span class="p">())</span> 
    <span class="p">{</span>
        <span class="n">START_TRACE</span><span class="p">();</span>
        <span class="n">END_TRACE</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">Size</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">START_TRACE</span><span class="p">();</span>
        <span class="n">END_TRACE</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">size</span><span class="p">;</span>
    <span class="p">}</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">_tmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">_TCHAR</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">START_TRACE</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Pot</span> <span class="n">pot</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pot</span><span class="p">.</span><span class="n">Size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">)</span>
            <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;over 100!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">END_TRACE</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>각 함수의 맨 위에 <code>START_TRACE()</code> 매크로를 사용하고, 함수가 끝날 때 <code>END_TRACE()</code> 를 사용한다. 그러면 Stack Trace 정보가 CallStack 변수에 쌓이는 것을 볼 수 있다.</p>

<p>하지만 위의 구조는 문제점이 있다. 알아챘는가? 아직이라면 한 5초 정도 생각해보자 -_-
답은 바로 밑에 이어진다.</p>

<p>위의 경우에서는 <code>END_TRACE()</code>를 안 불러준 채 함수를 탈출(return)해버리면 CallStack이 난장판이 된다. 즉, 위 방법은 결국 모든 return 구문 앞에다가 <code>END_TRACE()</code>를 붙여주어야 한다는 것.   <code>START_TRACE()</code>와 <code>END_TRACE()</code>를 붙여주는 것만으로도 엄청난 스트레스인데 이건 너무하다!</p>

<p>그런고로 이전 글에서 이야기한 생성자, 소멸자의 가호를 받아 위 문제를 RAII 방식으로 접근해서 풀어보도록 하자.<br>
<code>StackElement</code>의 생존을 관리하는, 즉 CallStack 변수에 생성할 때 <code>push_front</code>를 했다가 소멸할 때 <code>pop_front</code>를 하는 Functor 를 하나 만들자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="n">StackElementPushFunctor</span>
<span class="p">{</span>
    <span class="n">StackElementPushFunctor</span><span class="p">(</span><span class="k">const</span> <span class="n">StackElement</span><span class="o">&amp;</span> <span class="n">element</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">CallStack</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="n">element</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">StackElementPushFunctor</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">CallStack</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>이 Functor는 생성시 <code>StackElement</code>를 받아서 CallStack에 <code>push_front</code>로 앞에 넣어주고, 소멸될 때 <code>pop_front</code>로 빼준다. 그러면 함수가 시작할 때 이 객체를 만들었다가, 함수가 끝날 때 소멸시키면 되겠구나!</p>

<p>그래서 매크로가 다음과 같이 수정되어야 한다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#define TRACE() \</span>
<span class="cp">    PVOID __this = NULL; \</span>
<span class="cp">    __if_exists (this) { \</span>
<span class="cp">        __this = this; \</span>
<span class="cp">    } \</span>
<span class="cp">    StackElementPushFunctor __push__ (StackElement(_T(__FILE__), __LINE__, _T(__FUNCSIG__), __this));</span>
</code></pre></div>
<p>직접 CallStack 변수에다가 <code>StackElement</code>를 넣었던 것과 달리 <code>StackElementPushFunctor</code>에 대한 객체를 하나 만든다. 이 때 Functor 객체가 함수 내에서 지역 변수로 존재하기 때문에 함수가 끝나면 알아서 소멸자가 호출되어 CallStack에서 현재 함수에 대한 <code>StackElement</code>가 빠져나간다.</p>

<p>덕분에 위의 <code>Object::size</code> 함수나 <code>_tmain</code> 함수에서 <code>END_TRACE</code>가 있었어야만 했던 것에 반해, 여기서는 아예 안 넣어도 되기 때문에 코드 작성하기도 한결 간단하다</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">_tmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">_TCHAR</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">TRACE</span><span class="p">();</span>
    <span class="c1">// 로직 코드</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>매크로 함수 형태로 들어가있으니까 상당히 어색한데, 그냥 함수 취급 안하고 () 를 빼버리도록 매크로를 만드는 것도 하나의 방법이겠다. 아무튼 위의 코드는 전처리기에 의해 다음처럼 변한다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">_tmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">_TCHAR</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="c1">// this 얻기</span>
    <span class="n">StackElementPushFunctor</span> <span class="n">__push__</span> <span class="p">(</span><span class="cm">/* 생략 */</span><span class="p">);</span>

    <span class="c1">// 로직 코드</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// 함수 scope 가 끝나므로 __push__::~StackElementPushFunctor() 호출됨</span>
<span class="p">}</span>
</code></pre></div>
<p>이렇게 CallStack 구축할 수 있고, DEBUG가 아닐 경우에는 그냥 TRACE 매크로를 빈 걸로 교체해두면 성능적 문제도 전혀 없겠다. 어차피 디버깅 용이니까.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">stl operator 실수</h1>
				<p class="page-date">24 Dec 2010</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
						
				</p>
				<div class="content"><p>어제 나를 1시간동안 고민하게 한 코드는 다음과 같다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">CMyData</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">GetKey</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_nKey</span><span class="p">;</span> <span class="p">}</span>

    <span class="n">CMyData</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>
    <span class="o">~</span><span class="n">CMyData</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>

<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">m_nKey</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">CMyData</span><span class="o">&gt;</span> <span class="n">gCache</span><span class="p">;</span>
<span class="n">BOOL</span> <span class="nf">Find</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">CMyData</span><span class="o">&gt;&amp;</span> <span class="n">list</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">CMyData</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">gCache</span><span class="p">.</span><span class="n">begin</span> <span class="p">();</span>
        <span class="n">iterator</span> <span class="o">&lt;</span> <span class="n">gCache</span><span class="p">.</span><span class="n">end</span> <span class="p">();</span> <span class="o">++</span><span class="n">iterator</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">iterator</span><span class="o">-&gt;</span><span class="n">GetKey</span> <span class="p">()</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span> <span class="n">list</span><span class="p">.</span><span class="n">push_back</span> <span class="p">(</span><span class="n">list</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">list</span><span class="p">.</span><span class="n">size</span> <span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>어제 정신이 없었다고 변명을 해도 너무 어이없는 실수를 저질렀는데 더 큰 문제는 컴파일에서 뱉어주는 에러를 보고도 해당 문제를 파악하지 못했다는 것이다.</p>

<p>위 코드의 문제는</p>

<ul>
<li>나는 OOP 수업의 영향으로 class declaration에서 public - protected - private 순으로 선언을 하고, public method를 선언할 때 가장 마지막 부분에 생성자 소멸자를 선언한다. <strong>그런데 class 선언할 때 맨 앞에 public을 빼먹었다.</strong></li>
</ul>

<p><code>GetKey()</code> 접근 위반 에러를 먼저 봤다면 괜찮았을텐데, <code>std::list</code> 쪽에서 <code>CMyData</code>의 소멸자를 호출하지 못한다는 에러만 보고 <em>소멸자 제대로 선언했는데!</em>를 외쳤으나 <code>public:</code>이 빠진건 보지 못했다.</p>

<ul>
<li>stl container의 iterator를 사용할 때는 <code>begin</code>으로부터 시작해서 <code>end</code>가 아닐 때까지 반복하는거다. 그래서 당연히 <code>iterator != list.end();</code>으로 써야하는데 대체 무슨 정신으로 저기에다가 <code>operator &lt;</code>를 써놨는지 모르겠다.</li>
</ul>

<p>결론은 술먹고 코딩하는 것보다 졸면서 코딩하는게 100만배는 더 해롭다는 사실.<br>
저거 잡는데 1시간 반정도가 걸렸는데, 사실 잠 깨는데 1시간 걸리고 30분 동안 내가 졸면서 뭘 짜고 있었는지 파악하는게 걸린것 같다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">template 인자를 상속 받기</h1>
				<p class="page-date">09 Jan 2012</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
					<code class="tag">template</code>
						
						
						
						
				</p>
				<div class="content"><div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Base</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MyClass</span> <span class="o">:</span> <span class="k">public</span> <span class="n">_Base</span> <span class="p">{};</span>
</code></pre></div>
<p>위와 같은 형태가 어떤 의미를 지니고, 어느 곳에서 사용될 수 있는지 살펴보자</p>

<p>일단 자신의 부모 class를 generic하게 취할 수 있다는 것은 부모의 class 와 자식의 class 간의 결합성을 어느 정도 느슨하게 준다는 의미가 있다. (인자로 무엇을 주냐에 따라 상속 구조가 바뀌니까.)</p>

<p>또한 부모 class의 종류에 상관없이 동일한 기능을 추가해줄 수 있다거나, 아니면 부모 class들이 동일한 interface를 가지고 있다면, 그것을 통한 기능 확장도 가능하겠다.</p>

<h3>singleton</h3>

<p>부모 class의 종류에 상관없이 동일한 기능을 추가하는 가장 간단한 예제는 singleton이다. 아래와 같은 <code>MyClass</code>가 있다고 해보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">GetValue</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">100</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>이 Class를 Singleton으로 만드려면 가장 간단한 방법은 직접 해당 method를 <code>MyClass</code>에 추가하는 것이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">GetValue</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">100</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">static</span> <span class="n">MyClass</span><span class="o">&amp;</span> <span class="n">Instance</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_ptr</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">)</span>
            <span class="n">_ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyClass</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="n">_ptr</span><span class="p">;</span>
    <span class="p">}</span>
<span class="nl">private:</span>
    <span class="n">MyClass</span><span class="p">()</span> <span class="p">{}</span>
<span class="nl">private:</span>
    <span class="k">static</span> <span class="n">MyClass</span><span class="o">*</span> <span class="n">_ptr</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">MyClass</span><span class="o">*</span> <span class="n">MyClass</span><span class="o">::</span><span class="n">_ptr</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
</code></pre></div>
<p>물론 좋은 설계는 아니겠지만 만약 <code>Singleton</code> 객체가 많아진다고 해보자. 그러면 매번 저런 식의 static 함수와 변수를 각 class마다 추가해주어야 할 것이다.</p>

<p>이를 해결해주기 위한 여러 방법이 있겠지만 본 글에서 소개하고자 하는 방법은 다음과 같은 template singleton class를 만드는 것이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Target</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Singleton</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">static</span> <span class="n">_Target</span><span class="o">&amp;</span> <span class="n">Instance</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_ptr</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">)</span> <span class="n">_ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">_Target</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="n">_ptr</span><span class="p">;</span>
    <span class="p">}</span>
<span class="nl">private:</span>
    <span class="k">static</span> <span class="n">_Target</span><span class="o">*</span> <span class="n">_ptr</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Target</span><span class="o">&gt;</span>
<span class="n">_Target</span><span class="o">*</span> <span class="n">Singleton</span><span class="o">&lt;</span><span class="n">_Target</span><span class="o">&gt;::</span><span class="n">_ptr</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
</code></pre></div>
<p>위와 같은 <code>Singleton</code>을 설계하고 모든 문제가 해결되었다! 라고 생각하면 안된다. <code>MyClass</code>는 여러 instance가 생기면 안되기 때문에 생성자가 private으로 작성되어 있다.</p>

<p>하지만 위 <code>Singleton</code> class는 <code>new _Target</code>를 통해서 직접 해당 객체를 생성하므로, <code>Singleton&lt;MyClass&gt;::Instance()</code> 구문은  컴파일 에러를 발생시킬 것이다.</p>

<p>이를 해결하기 위해 다음과 같이 코드를 수정한다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Class</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Singleton</span> <span class="o">:</span> <span class="k">private</span> <span class="n">_Class</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">static</span> <span class="n">_Class</span><span class="o">&amp;</span> <span class="n">Instance</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_ptr</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">)</span>
            <span class="n">_ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="o">&lt;</span><span class="n">_Class</span><span class="o">&gt;</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="n">_ptr</span><span class="p">;</span>
    <span class="p">}</span>
<span class="nl">private:</span>
    <span class="n">Singleton</span><span class="p">()</span> <span class="p">{}</span>
<span class="nl">private:</span>
    <span class="k">static</span> <span class="n">Singleton</span><span class="o">*</span> <span class="n">_ptr</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Class</span><span class="o">&gt;</span>
<span class="n">Singleton</span><span class="o">&lt;</span><span class="n">_Class</span><span class="o">&gt;*</span> <span class="n">Singleton</span><span class="o">&lt;</span><span class="n">_Class</span><span class="o">&gt;::</span><span class="n">_ptr</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">GetValue</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">100</span><span class="p">;</span> <span class="p">}</span>

<span class="nl">protected:</span>
    <span class="n">MyClass</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>
</code></pre></div>
<p><code>MyClass</code>의 생성자를 살짝 protected로 바꾸었다. 이제 <code>MyClass</code>를 상속받는 녀석이 아니면 저 객체를 생성하지 못할 것이다. 그리고 <code>Singleton</code> class가 이를 상속받는다.</p>

<p>단순히 생성하기 위한 상속을 받는 것이고, 기능 상속을 받을 필요는 없으므로 private 상속을 받는다. 그리고 <code>Singleton</code> 객체를 static 변수로 포함하고 있다가 이것을 <code>Instance()</code> 함수에서 <code>_Class&amp;</code>로 변환해서 반환한다.</p>

<ul>
<li>그 이유는 static 함수에서 <code>new _Class</code>를 수행할 때 여전히 <code>MyClass</code>의 생성자가 protected이므로 접근이 불가능하기 때문이다. 따라서 접근 가능한 자신의 생성자 <code>private Singleton()</code>를 부른다. <code>Singleton</code>의 생성자에서는 부모의 생성자인 <code>MyClass</code> 함수가 protected이므로 접근이 가능하다.</li>
</ul>

<p>따라서 위와 같이 class를 설계하면, <code>Singleton&lt;MyClass&gt;::Instance()</code>와 같이 유일 객체에 접근이 가능하며, 그 객체 이외의 다른 객체의 생성도 막을 수 있다.</p>

<p><strong>하지만 이것으로도 완벽하지 않고, 여러 문제가 발생할 여지가 있다. 이에 대해서는 MC++D 의 6장 Singleton 구현을 보자</strong></p>

<h3>extension</h3>

<p>부모 class들이 동일한 interface를 가지고 있다고 할 때, 이들에게 공통적으로 적용될 수 있는 기능을 추가한 class를 확장해보자.</p>

<p>약간 억지 예제이지만, STL container의 iterator를 확장해 보겠다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_FwdIter</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">for_each_iter</span> <span class="o">:</span> <span class="k">public</span> <span class="n">_FwdIter</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_FuncTy</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">for_each</span><span class="p">(</span><span class="n">_FwdIter</span> <span class="n">end</span><span class="p">,</span> <span class="n">_FuncTy</span> <span class="n">funct</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">_FwdIter</span> <span class="n">it</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
            <span class="n">funct</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">for_each_iter</span><span class="p">(</span><span class="n">_FwdIter</span> <span class="n">_begin</span><span class="p">)</span> <span class="o">:</span> <span class="n">begin</span><span class="p">(</span><span class="n">_begin</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">_FwdIter</span> <span class="n">begin</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p><code>for_each_iter</code>는 forward iterator 기능을 모두 가지면서 <code>for_each</code>라는 함수를 하나 더 갖는 iterator이다. 이를 만족하기 위해 <code>_FwdIter</code>에 대해 public 상속을 하였으며, <code>for_each</code> 함수를 추가로 갖는다.</p>

<p>단, 저렇게 만들어놓으면 매번 <code>for_each_iter&lt;std::vector&lt;int&gt;::iterator&gt;</code> 등 type을 길게 써주어야 한다. 이 문제를 해결하기 위해 간단하게 type을 추론하여 객체를 생성해주는 생성 함수를 만들자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_FwdIter</span><span class="o">&gt;</span>
<span class="n">for_each_iter</span><span class="o">&lt;</span><span class="n">_FwdIter</span><span class="o">&gt;</span> <span class="n">make_for_each_iter</span><span class="p">(</span><span class="n">_FwdIter</span> <span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">for_each_iter</span><span class="o">&lt;</span><span class="n">_FwdIter</span><span class="o">&gt;</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>그러면 아래와 같이 사용할 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ints</span><span class="p">;</span>
<span class="n">ints</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">ints</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="n">ints</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="n">ints</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

<span class="k">auto</span> <span class="n">ea1</span> <span class="o">=</span> <span class="n">make_for_each_iter</span><span class="p">(</span><span class="n">ints</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
<span class="n">ea1</span><span class="p">.</span><span class="n">for_each</span><span class="p">(</span><span class="n">ints</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_tprintf</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">),</span> <span class="n">v</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div>
<p>부모 class들이 동일한 interface를 가지고 있고 그에 대한 동일한 작업을 수행하거나 결과를 제공하는 함수가 멤버 함수 형태로 제공되어 그것이 하나의 객체를 이루면 좋을 경우에 위와 같이 쓰면 될 것 같다.</p>

<p>하지만 보통은 algorithm에 있는 함수들처럼 그냥 함수를 만들어 쓴다. 만약 위와 같이 객체 형태로 표현할 때 장점이 있는 구조에서는 도움이 되지 않을까 싶다. (적절한 예제가 더 안 떠오른다-_-;)</p>

<h3>마무리</h3>

<p>template 인자로 받게되는 것은 암시적 interface가 요구되기 때문에 컴파일 타임에서의 느슨한 결합이 요구될 때 쓰면 좋다. 그리고 상속이라는 것을 통해 기능 확장, 혹은 접근 제한 등을 적절히 혼합하여 사용하면 재미난 많은 것을 할 수 있다.</p>

<p>더 나아가서 <a href="http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">CRTP</a>라는 재귀 상속의 개념도 있는데, 이건 다음 글에서 알아보도록 하자.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">template 프로그래밍과 type erasure</h1>
				<p class="page-date">10 Nov 2013</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
					<code class="tag">template</code>
						
						
						
					<code class="tag">study</code>
						
						
						
						
				</p>
				<div class="content"><div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Iter</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_FuncTy</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">for_each</span><span class="p">(</span><span class="n">_Iter</span> <span class="n">begin</span><span class="p">,</span> <span class="n">_Iter</span> <span class="n">end</span><span class="p">,</span> <span class="n">_FuncTy</span> <span class="n">functor</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">begin</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">begin</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">functor</span><span class="p">(</span><span class="o">*</span><span class="n">begin</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">ForEach</span><span class="p">(</span><span class="n">Iterator</span><span class="o">*</span> <span class="n">iter</span><span class="p">,</span> <span class="k">const</span> <span class="n">Functor</span><span class="o">&amp;</span> <span class="n">functor</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">MoveNext</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">functor</span><span class="p">.</span><span class="n">DoIt</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">Current</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>첫 번째 코드(<code>for_each</code>)는 <code>_Iter</code>, <code>_FuncTy</code>에 들어가는 각 type에 맞게 compile time에 모든 code가 생성(template instantiation)되어 어떤 함수가 호출될지 compile time에 결정되는 구조이고,</li>
<li>두 번째 코드(<code>ForEach</code>)는 <code>Iterator</code>와 <code>Functor</code> interface를 구현한 객체가 runtime에 <code>ForEach()</code> 함수로 넘어간 다음 virtual function call이 불려서 runtime에 어떤 함수가 호출될지 결정되는 구조이다.</li>
</ul>

<p>즉, <code>ForEach</code> 함수는 1개이지만 <code>for_each</code> 함수는 부르는 type에 따라서 여러 개가 될 수 있다는 것이다. <code>ForEach</code> 함수는 내부에서 vfptr에 의한 함수 호출 부담이 야기되지만, <code>for_each</code> 함수는 그런 것 없다. (즉, 늦어도 linking time에 실제 호출될 함수의 주소가 binding된다)</p>

<p>template으로 일반화된 프로그래밍을 하는 것은 좋은데 문제는 결과물이 복잡한 template type으로 표현된다는 것이다. 그 부분을 모두 손으로 작성하는 type 노가다를 막기 위해 helper function에 의한 type inference를 사용한다고 해도 결국 애매한 상황이 발생한다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">my_func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">adapter</span> <span class="o">=</span> <span class="n">make_adapter</span><span class="p">(</span><span class="n">my_func</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
    <span class="n">process</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">process</span><span class="p">(</span><span class="o">???</span> <span class="n">adapter</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></div>
<p>위 코드에서 process는 adapter를 인자로 받아서 무언가 작업을 수행해야 하는데 이 시점에서 결국 adapter의 full-name이 다시 한 번 등장해야 한다.</p>

<p>위 문제를 좀 더 일반화시켜서, <strong>int 1개를 인자로 받고 int를 반환하는 함수</strong>를 <code>process()</code> 함수가 받아서 처리한다고 생각해보자. 간단히 <code>int (*)(int)</code>의 function pointer만 생각할 수도 있겠지만 위 예제 코드에서 나온 adapter도 <code>int (int)</code>의 signature를 가지고 있기 때문에 이 역시 저 함수의 인자로 넘어갈 수 있어야 한다.</p>

<p>가장 간단한 방법은 <code>process()</code> 함수 역시 template으로 만드는 것이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_FuncTy</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">process</span><span class="p">(</span><span class="n">_FuncTy</span> <span class="n">func</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>그러면 function pointer가 들어가든, adapter 객체가 들어가든, lambda가 들어가든 아니면 뭐 다른 뭔가가 들어가든 그에 맞게 알아서 <code>process()</code>의 함수가 만들어질 것이고 코드는 문제 없이 실행될 것이다.</p>

<p>template에 의해서 코드가 모두 header에 붙어있어 컴파일된 코드 결과물이 크고 아름다워지기 때문에 위 함수를 cpp로 내리기 위해서 template을 안 쓰고 문제를 해결하고 싶을 수 있다. 물론 그렇지 않다고 하더라도 <code>process()</code> 함수에서 바로 functor를 받아서 처리하는 구조가 아니라, map 같은 곳에 저장해놨다가 추후에 호출하는 경우라면 해당 객체의 호출 시점에 runtime으로 미루어지니 compile time에 코드가 만들어지는 template으로는 답이 없다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">register_all</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">table</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">function_1</span><span class="p">;</span> <span class="c1">// register function pointer</span>
    <span class="n">table</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_adapter</span><span class="p">;</span> <span class="c1">// register adapter object</span>
    <span class="n">table</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">};</span> <span class="c1">// register lambda</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">process</span><span class="p">(</span><span class="kt">int</span> <span class="n">optype</span><span class="p">,</span> <span class="kt">int</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">optype</span><span class="p">](</span><span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>위와 같은 경우에는 table이라는 자료 구조에 int key과 뭔가 <code>int (int)</code> 형태의 호출 signature를 갖는 대상을 저장해두어야, 추후 <code>process()</code> 함수가 호출될 때 table에서 적절한 호출 객체를 꺼내서 부를 수 있게 될 것이다.</p>

<p>즉, <strong>요약하면 모든 일반화된 <code>int (int)</code> 호출자에 대해서 동일하게 지칭할 수 있는 객체를 만들어야 하는 것</strong>이다.</p>

<h3>generic functor: int (int)</h3>

<p>runtime에 호출될 대상이 결정되기 위해서 virtual function call을 사용한다고 하였다. 그렇다면 먼저 <code>int (int)</code>에 대한 interface를 정의하여 virtual function call을 사용할 수 있도록 해보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="n">functor_ii_inf</span> <span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="k">operator</span> <span class="p">()</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span>  <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>이제 호출할 대상들이 저 interface를 구현하기만 하면 된다. 이는 template으로 간단히 표현할 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">functor_ii_impl</span> <span class="o">:</span> <span class="k">public</span> <span class="n">functor_ii_inf</span> <span class="p">{</span>
    <span class="n">functor_ii_impl</span><span class="p">(</span><span class="n">F</span> <span class="n">func</span><span class="p">)</span> <span class="o">:</span> <span class="n">_func</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="k">operator</span> <span class="p">()</span> <span class="p">(</span><span class="kt">int</span> <span class="n">arg1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">_func</span><span class="p">(</span><span class="n">arg1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">F</span> <span class="n">_func</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p><code>functor_ii_inf</code> interface를 구현하여 operator가 virtual이 된 것을 빼면 지난 번 Adapter class와 다를 것이 별로 없다.</p>

<p>지난 2차 과제 풀이에서 썼듯이 위와 같이 <code>functor_ii_impl</code>를 그대로 사용하려면 각 호출자를 집어넣어 생성할 때마다 그에 대한 type을 매번 명시해주어야 한다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">functor_ii_inf</span><span class="o">*</span> <span class="n">inf1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">functor_ii_impl</span><span class="o">&lt;</span><span class="n">Adapter</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">my_adapter</span><span class="p">);</span>
</code></pre></div>
<p>이는 매우 불편한 작업이므로 helper function을 사용하여 생성 부분을 좀 단순화해보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
<span class="n">functor_ii_inf</span><span class="o">*</span> <span class="n">make_functor_ii</span><span class="p">(</span><span class="n">F</span> <span class="n">func</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">functor_ii_impl</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>이제 다음과 같이 사용할 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">functor_ii_inf</span><span class="o">*&gt;</span> <span class="n">table</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">register_all</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">table</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">make_functor_ii</span><span class="p">(</span><span class="n">function_1</span><span class="p">);</span>
    <span class="n">table</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">make_functor_ii</span><span class="p">(</span><span class="n">my_adapter</span><span class="p">);</span>
    <span class="n">table</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">make_functor_ii</span><span class="p">([]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">});</span>
<span class="p">}</span>
</code></pre></div>
<p>template으로 인해 생성된 여러 type을 interface 상속을 통해 제거하고, <code>functor_ii_inf</code>라는 하나의  추상화된 type으로 지칭하게 되었다. 이것을 <strong>type erasure</strong>라고 한다.</p>

<p>위와 같은 방법으로 구현하게 되어도 큰 문제가 없을 수 있지만 <code>functor_ii_inf*</code> 객체에 대한 메모리 해제를 해줄 주체에 대한 귀찮음이 있다.
이를 <code>std::shared_ptr</code>을 써서 간단히 해결하는 것도 좋은 방법이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">functor_ii_inf</span><span class="o">&gt;</span> <span class="n">functor_ii</span><span class="p">;</span>
</code></pre></div>
<p>여기까지 구현한 내용을 하나로 묶어서 관리해주면 이번 과제를 하기 위해 template을 붙일 때 아주 좋을 것 같다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="n">functor_ii</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="k">struct</span> <span class="n">inf</span> <span class="p">{</span>
        <span class="k">virtual</span> <span class="kt">int</span> <span class="k">operator</span> <span class="p">()</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="n">impl</span> <span class="o">:</span> <span class="k">public</span> <span class="n">inf</span> <span class="p">{</span>
        <span class="n">impl</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">)</span>
            <span class="o">:</span> <span class="n">_f</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">}</span>
        <span class="k">virtual</span> <span class="kt">int</span> <span class="k">operator</span> <span class="p">()</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">_f</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">F</span> <span class="n">_f</span><span class="p">;</span>
    <span class="p">};</span>
<span class="nl">public:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
    <span class="n">functor_ii</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">_inf</span><span class="p">(</span><span class="k">new</span> <span class="n">impl</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">))</span> <span class="p">{</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="k">operator</span> <span class="p">()</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">_inf</span><span class="p">)(</span><span class="n">a</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">inf</span><span class="o">&gt;</span> <span class="n">_inf</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<ul>
<li><code>functor_ii</code> class는 template이 안 붙어있는 일반 class이다. 즉 1개의 type이다. 대신 생성자가 template function이며 멤버 변수인 <code>_inf</code>에 적절한 <code>impl</code> 객체를 넣어준다.</li>
<li><code>inf</code> class는 필요한 interface를 정의하고 있고, <code>impl</code>에서는 호출가능한 <code>int (int)</code> 형태를 인자로 받아 멤버 변수에 갖고, <code>operator ()</code> 함수에서 그것을 불러주는 template class이다.</li>
</ul>

<p>즉, <code>functor_ii</code>는 모든 <code>int (int)</code>에 대응할 수 있는 실제 template class인 <code>impl</code>을 <code>inf</code> interface로 가리키고 있는 객체인 것이다. 그리고 <code>inf</code> 객체를 <code>shared_ptr</code>로 가지고 있기 때문에 메모리도 잘 관리가 된다.</p>

<p>한가지 재밌는 것은 아까 만들었던 <code>make_functor_ii()</code> helper function과 다르게 <code>functor_ii</code> class는 implicit한 생성자를 가지고 있기 때문에 register를 수행할 때 단순 대입만 해도 된다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">functor_ii</span><span class="o">&gt;</span> <span class="n">table</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">register_all</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">table</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">function_1</span><span class="p">;</span> <span class="c1">// functor_ii(function_1); 과 같다.</span>
    <span class="c1">// 생략</span>
<span class="p">}</span>
</code></pre></div>
<p>이렇듯 template으로 최대한 일반화된 프로그래밍을 하고, 이 수행 흐름을 runtime까지 끌어올 일이 있다면 적절히 type erasure 기법을 써서 프로그래밍을 해주면 되겠다. 사실 위 구현체는 <a href="http://en.cppreference.com/w/cpp/utility/functional/function">std::function</a>에 구현되어 있으니 이를 가져다 쓰는 것이 제일 좋다.</p>

<h3>과제 1: dispatcher</h3>

<p>간단한 dispatching 시스템을 구현해보자. message-id에 대응되는 message-handler가 호출되면 된다. 단 message-handler는 단순 function pointer일수도 있고, lambda function일 수도 있고, functor일 수도 있다. 대충 호출 가능한 대상을 다 받자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="kt">message_t</span> <span class="p">{};</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span> <span class="cm">/* op-code */</span><span class="p">,</span> <span class="n">handler</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">,</span> <span class="k">const</span> <span class="kt">message_t</span><span class="o">&amp;&gt;&gt;</span> <span class="n">table</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">dispatch</span><span class="p">(</span><span class="kt">int</span> <span class="n">op_code</span><span class="p">,</span> <span class="k">const</span> <span class="kt">message_t</span><span class="o">&amp;</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">table</span><span class="p">[</span><span class="n">op_code</span><span class="p">](</span><span class="n">message</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p><code>handler</code> class는 적절히 위 예제(<code>functor_ii</code>)를 고쳐서 만들어보자. 다만 반환 type과 인자 type을 template 인자로 받도록 한다. 테스트 message와 handler는 대충 작성해도 된다.</p>

<p>물론 <code>std::function</code>을 쓰면 간단히 해결되지만 연습 차원에서 위 진행 과정을 이해하면서 직접 프로그래밍 해보자.</p>

<h3>과제 2: class factory</h3>

<p>과제가 하나면 섭섭하니 시간이 남는다면 다음의 것도 구현해보자. string으로 class의 객체를 생성할 수 있는 reflection의 class factory를 구현해보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">interface_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">execute</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">test_class_1</span> <span class="o">:</span> <span class="k">public</span> <span class="kt">interface_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">execute</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class_1&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">test_class_2</span> <span class="o">:</span> <span class="k">public</span> <span class="kt">interface_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">execute</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;class_2&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span><span class="o">*</span> <span class="n">obj</span> <span class="o">=</span> <span class="p">(</span><span class="kt">interface_t</span><span class="o">*</span><span class="p">)</span><span class="n">new_instance</span><span class="p">(</span><span class="s">&quot;test_class_2);</span>
    <span class="n">obj</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">template에 의한 generic interface 정의</h1>
				<p class="page-date">13 Jul 2011</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
					<code class="tag">template</code>
						
						
						
						
				</p>
				<div class="content"><p>알고리즘 등의 일반화나 의존성 제거를 위해서 class 사이를 interface 로 쪼개는 경우가 있다.
나는 C++ 보다는 Java가 더 익숙해서 template보다는 interface나 generics를 사용하는게 더 익숙한 편이다.</p>

<p>그래서 저번 자료구조 숙제를 할 때도 당황했던 것이, <code>Iterator</code>나 <code>List</code> 에 대해 <code>Vector</code>나 <code>LinkedList</code>를 구현할 때, 먼저 Interface를 정의하고 그것에 대해 구현하려 했던 것이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Iterator</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="n">Iterator</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">++</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>물론 더 많은 method가 필요하겠지만 이정도로 하자.</p>

<p>++ 연산자에 대해 overloading을 하면서 그걸 virtual로 만들고 있다. 그러면 Iterator를 상속받는 녀석은 다음과 같다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">VectorIterator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="n">Iterator</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">++</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* pointing to next */</span> <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="cm">/* some value */</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p><code>VectorIterator</code> 객체이지만 부모 type인 <code>Iterator&amp; type</code>으로 가리킬 수 있다. reference type이니까 가능하다.</p>

<p>이제 <code>List</code>를 정의한다. 이 Interface는 Iterator를 반환하는 함수가 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">List</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="n">Iterator</span> <span class="n">ListIterator</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>이 때 Iterator 객체에 대한 주소를 넘겨주게 되면 메모리 관리를 해줘야하는 번거로움이 있고, 상태를 갖는 객체라서 공유되면 안된다. (각각 다른 지점을 pointing 할 수 있다) 따라서 그냥 값 객체처럼 잘 캡슐화해서 Iterator 객체로 반환하는게 제일 바람직하다.</p>

<p>그런데 망조가 보인다. Iterator type으로 반환해야하는데 <code>VectorIterator</code>를 어떻게 반환하지?</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Vector</span> <span class="o">:</span> <span class="k">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="n">Iterator</span> <span class="n">ListIterator</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">VectorIterator</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="cm">/* ERROR */</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p><code>VectorIterator</code> class가 <code>Iterator</code> class를 상속받았어도 단순 객체일 때는 대입이 불가능하기 때문에 저 구문은 실행이 되지 않는다. 당초에 virtual을 쓰는 것 자체가 객체의 포인터에 의해 vfptr로 다형성을 사용해서 자식이 override한 함수를 쓸 수 있도록 <code>subtype polymorphism</code>을 일으키는건데, 메모리 관리 귀찮다고 그냥 객체를 쓴다고 될 일이 아니다.</p>

<p>그렇다면 해당 문제를 해결하려면 어떻게 해야할까? <code>smart pointer</code> 같은거라도 끼얹나?</p>

<p>당초에 접근이 잘못됬다.<br>
동일한 interface를 만드는 이유는 해당 interface를 통해 실질적인 구현을 알 필요 없이, 실제 객체의 타입과 상관없이 그 객체를 사용하겠다는 것, 즉 의존성을 분리하겠다는 것이다.</p>

<p><code>List</code>, <code>Iterator</code>를 만드는 것 자체가 순회하고자 하는 아래의 함수가 있을 때 <code>Vector</code>, <code>LinkedList</code>, <code>ArrayList</code>, <code>Queue</code>, <code>Deque</code> 중 뭐라도 그것이 동작할 수 있게 동일한 Interface를 만들어주기 위함이었던 것이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">for_each</span> <span class="p">(</span><span class="k">const</span> <span class="n">Iterator</span><span class="o">&amp;</span> <span class="n">begin</span><span class="p">,</span> <span class="k">const</span> <span class="n">Iterator</span><span class="o">&amp;</span> <span class="n">end</span><span class="p">,</span> <span class="n">Functor</span> <span class="n">functor</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">Iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
        <span class="n">functor</span> <span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>명시적인 <code>Iterator</code>라는 Interface가 있으면 컴파일러가 위의 코드를 명확히 검사해줄 것이고, 의존성도 줄어들 것이고, 저 함수는 가히 Generic하다고 부를 수 있을 것이고, 왠지 코딩 잘하는 것 같고, 다 좋은건가?</p>

<p>하지만 위에서 언급한 Iterator에 대한 문제가 여전히 해결되지 않았다. (Java는 어차피 gc가 object를 수집하니까 다 reference 형태로 돌아다녀서 상관없고, 무엇보다 원래 느려서 다형성 부담따위 고민도 안한다)</p>

<p>명시적으로 interface를 정의하지 않아도 template에 의해서 위 문제가 해결 가능하다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Iterator</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">for_each</span> <span class="p">(</span><span class="k">const</span> <span class="n">Iterator</span><span class="o">&amp;</span> <span class="n">begin</span><span class="p">,</span> <span class="k">const</span> <span class="n">Iterator</span><span class="o">&amp;</span> <span class="n">end</span><span class="p">,</span> <span class="n">Functor</span> <span class="n">functor</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">Iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
        <span class="n">functor</span> <span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>맨 위에 template 구문이 추가된 것 빼고는 위의 <code>for_each</code> 문과 동일하다.
이와 같이 코드를 작성할 경우 <code>List</code>, <code>Iterator</code>와 같은 명시적인 interface는 필요하지가 않다.
단지 저 <code>for_each</code>에 들어가는 type 이 ++ 연산과 * 연산만 구현되면 되는 것이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Vector</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">class</span> <span class="nc">Iterator</span> <span class="p">{</span>
    <span class="nl">public:</span>
        <span class="n">Iterator</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">++</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
        <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">*</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
    <span class="p">};</span>
<span class="p">};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">LinkedList</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">class</span> <span class="nc">Iterator</span> <span class="p">{</span>
    <span class="nl">public:</span>
        <span class="n">Iterator</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">++</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
        <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">*</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
    <span class="p">};</span>
<span class="p">};</span>
</code></pre></div>
<p>위에서 보면 <code>Vector::Iterator</code>나 <code>LinkedList::Iterator</code> 둘 다 <code>operator ++</code> 과 <code>operator *</code> 을 갖고 있다. 비록 Java 에서처럼 두 객체가 명시적으로 동일한 interface를 포함하고 있다는 명시적 코드는 없지만, 위의 <code>for_each</code> template 함수에 들어가게 되면 컴파일러가 각각의 type에 대한 <code>for_each</code>를 만들어내면서, ++ 과 * 연산자가 정의되어있는가를 검사해준다.</p>

<p>즉, 명시적인 Interface가 없다면 Java 의 Generics에서는 불가능할 일이 C++에서는 어차피 컴파일러가 해당 코드를 만들어내면서 그 코드에 대해 다시 컴파일을 수행하니 가능하다는 것.<br>
따라서 굳이 명시적인 interface class (pure abstract class)를 만들지 않아도 template을 통해 generic이 보장될 수 있다는 것. 다만 어떤 interface 가 필요한지에 대한 명확한 문서 or 주석 or 설명이 없다면 template 컴파일 에러를 해석해서 해당 함수를 구현해야하는 지옥을 맛보겠지만 [....]</p>

<hr>

<p>template이나 define에 대해서는 가끔 script 언어같이 느껴지는 것이,<br>
script 언어가 실행 중에 코드를 동적으로 해석하여 실행하는 것과 template이나 define macro가 컴파일 타임에 코드를 찍어내서 그걸 컴파일하여 코드를 다시 만들어내는 것이 비슷하게 느껴지기 때문이 아닐까 한다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">template을 사용한 generic 프로그래밍</h1>
				<p class="page-date">04 Nov 2013</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
					<code class="tag">template</code>
						
						
						
					<code class="tag">study</code>
						
						
						
						
				</p>
				<div class="content"><p><em>(한 번에 1~2시간 정도로 짧게(?) 하고 있다. 대충 accelerated c++ 책이랑 EC++ 책을 보고 있다.)</em></p>

<p>C++ 언어를 가지고 C++스럽게 프로그래밍을 해보자! 는 어떤 의미일까?<br>
다양한 의견이 있겠지만, 프로그래밍 언어는 <strong>표현력이 증가</strong>하는 쪽으로 발전한다는 관점에서 프로그래머가 C에 비해서 보다 자신의 의도를 C++ 문법으로 잘 표현할 수 있는 방법으로 프로그래밍을 하는 의미가 아닐까라고 생각한다.</p>

<p>예를 들면 define 대신에 inline, const, typedef 등을 쓰는 것처럼.</p>

<p>프로그래머가 의도를 보다 명확히 표현해야 협업하는 사람이나 미래의 나와 오해가 덜 생기고 가독성도 좋고 버그도 적고 추후 유지보수하기도 좋다.</p>

<p>패턴을 사용하여 설계하는 것도 같은 맥락에 있다고 볼 수 있는데 문제는 그녀석들이 smalltalk나 java같이 enterprise한 언어에서 탄생한 녀석들이라, C++로 구현할 때 코드가 안드로메다로 가는 경우도 있다. 따라서 같은 설계를 C++스럽게 표현하기 위해 C++ 문법에도 익숙해지고, C++ 코드도 많이 읽어봐야한다.</p>

<p>즉, C++ 문법적 기능들을 사용해서 <strong>코드는 최대한 간결하게! 의미는 명확하게!</strong> 작성하는 것을 목표로 진행하고 있다.</p>

<h3>명확한 의도</h3>

<p>명확한 의도를 전달하기 위해 기본적으로 지켜야할 규칙은 당연히 <strong>이름 잘 짓기</strong>다. 예를 들어 <code>operator ++</code> overloading 해서 빼기 연산을 수행하면 안 된다는 이야기다. 뭐 이런건 이야기할 필요도 없고.</p>

<p>모든 method를 public으로 가지는 class나 의미없는 getter/setter, 지역 함수인데 전역으로 공개된 함수 등, 해당 코드의 coverage가 비정상적으로 넓어서 그 의도를 파악하지 못하는 경우가 있을 수 있겠다. (함수 내에서 사용되는 모든 변수가 전역 변수라고 생각해보자!)</p>

<p>그러므로 객체지향이랍시고 학교에서 우리에게 주입한 <em>닥치고 class, 닥치고 getter/setter</em>의 세뇌에서 풀려나 의도에 맞는 함수와 class의 사용, 적절한 visibility를 고민해야 할 것이다.</p>

<p>그러기 위한 시작점이 static storage class이다.</p>

<h3>static storage class</h3>

<p>이야기를 이어가기 위해 <strong><a href="http://en.wikipedia.org/wiki/Translation_unit_%28programming%29">번역 단위</a></strong>에 대한 개념을 대충 알 필요가 있다. 번역단위는 컴파일러가 하나의 obj 파일을 만들어내기 위한 단위라고 보면 된다. c/c++의 경우 include한 header 파일들을 cpp에 다 복사해서 넣어놓고, 전처리기가 macro expand해주고, template engine이 template instantiation한 결과라고 보면 되겠다.</p>

<p>자, 그러면 이제 코드를 보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="c1">// 전역공간</span>
<span class="k">static</span> <span class="n">MyClass</span> <span class="n">svar1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sfunc</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">MyClass</span> <span class="n">svar2</span><span class="p">;</span>
</code></pre></div>
<p><code>svar1</code>과 <code>svar2</code>가 메모리에 할당되는 시점은 언제일까? 그리고 생성자가 불리는 시점은 언제일까? 둘 다 프로그램이 시작할 때 메모리에 할당되며, 생성자는 <code>svar1</code>일 경우 프로그램 시작 시, <code>svar2</code>일 경우 해당 함수가 처음 호출될 경우에 불리게 된다. <code>svar1</code>과 <code>sfunc</code>를 보면 static을 안 붙인 것과 차이가 없다고 생각할 수 있지만, static을 붙이게 되면 다른 번역 단위에서 extern keyword로 접근할 수 없게 된다.</p>

<p>요컨데 전역 변수 대신 함수 내 static 변수, 전역 함수 대신 static 함수를 써서 해당 변수/함수의 접근 범위를 줄일 수 있고, 이는 coverage를 줄일 수 있게 해주기 때문에 코드 유지보수하기 좋아진다는 소리.</p>

<h3>visibility</h3>

<p>같은 맥락으로 public, protected, private 잘 지정하고, const 잘 붙이고, const reference 잘 쓰고, typedef 잘 걸어주는걸 습관들이자. 개인적으로 필요하다면 IN, OUT directive를 넣어주는 것도 괜찮다고는 생각함. 근데 move semantics가 있으니까 reference parameter보다는 반환으로 처리해도 괜찮을 것 같다. 그리고 메모리 관리할 대상이 아니면 const reference로 반환하고, 관리할 대상이라면 <code>shared_ptr</code>로 반환하고.</p>

<p>아무튼 등등 많이 짜고 많이 읽고 익숙해져서 의도를 명확히 표현하면 되겠다.</p>

<h3>binary_search</h3>

<p>c++스러운 프로그래밍을 하기 위한 연습 첫 번째: <code>binary search</code>를 c++스럽게 작성해보자.</p>

<p>(과정 생략 결과 공개)</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Iter</span><span class="o">&gt;</span>
<span class="n">_Iter</span> <span class="n">midpoint</span><span class="p">(</span><span class="n">_Iter</span> <span class="n">left</span><span class="p">,</span> <span class="n">_Iter</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_Iter</span> <span class="n">prevLeft</span> <span class="o">=</span> <span class="n">left</span><span class="o">++</span><span class="p">;</span>
        <span class="n">_Iter</span> <span class="n">prevRight</span> <span class="o">=</span> <span class="n">right</span><span class="o">--</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">==</span> <span class="n">right</span><span class="p">)</span> <span class="k">return</span> <span class="n">left</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prevLeft</span> <span class="o">==</span> <span class="n">right</span><span class="p">)</span> <span class="k">return</span> <span class="n">prevLeft</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Iter</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_Ty</span><span class="o">&gt;</span>
<span class="n">_Iter</span> <span class="n">bsearch</span><span class="p">(</span><span class="n">_Iter</span> <span class="n">begin</span><span class="p">,</span> <span class="n">_Iter</span> <span class="n">end</span><span class="p">,</span> <span class="n">_Ty</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_Iter</span> <span class="n">left</span> <span class="o">=</span> <span class="n">begin</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">left</span> <span class="o">==</span> <span class="n">right</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">_Iter</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">midpoint</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
        <span class="n">_Ty</span> <span class="n">midValue</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">mid</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">midValue</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span> <span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">midValue</span><span class="p">)</span> <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
        <span class="k">else</span> <span class="n">left</span> <span class="o">=</span> <span class="o">++</span><span class="n">mid</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">right</span> <span class="o">==</span> <span class="n">end</span> <span class="o">||</span> <span class="o">*</span><span class="n">left</span> <span class="o">!=</span> <span class="n">key</span> <span class="o">?</span> <span class="n">end</span> <span class="o">:</span> <span class="n">left</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>c++스럽게 작성해야 한다면 일단 class를 만들고 보는 경향이 있는데 이게 다 객체지향 수업에서 c++을 잘못 가르쳐서 그렇다. 뿐만 아니라 GoF design pattern같은 코드의 구현체가 워낙 enterprise하게 구현된걸 많이 봐서 일반화된 프로그래밍을 할 때 크고 아름다운 class와 interface의 조합을 구성하는 경우가 많다.</p>

<p>하지만 c++에는 template이라는 좋은 물건이 있으니 저걸로도 충분히 binary_search를 잘 구현할 수 있다.</p>

<ul>
<li>최대한 일반화하여 작성하기 위해, container가 아닌 iterator 수준으로 받을 수 있도록 구현했다. 그리고 interface는 최대한 stl algorithm을 따라했다. (그래야 프로그래머가 외울게 줄어든다!)</li>
<li>c++에는 operator overloading이 있으므로 다른 언어처럼 less_comparator 같은 추상화된 객체를 도입할 필요가 없다. 그냥 <code>&lt; 연산자</code>를 쓰자.</li>
<li>random access iterator를 쓰면 편하겠지만 일단 사용하는 연산자를 최소화하기 위해 <code>++</code>, <code>--</code>, <code>==</code>, <code>* 연산자</code>만 사용했다. 따라서 저 함수에 들어가는 iterator는 위 4개의 연산자만 있으면 된다.

<ul>
<li>key로 지정된 _Ty의 경우 &lt;, == 연산자만 있으면 된다.</li>
</ul></li>
</ul>

<p>결국 하고 싶은 이야기는, <del>c++스럽게 프로그래밍을 하기 위해서는 template을 쓰자!가 아니라</del> c++의 문법을 잘 익혀놔서 가장 적합한 문법으로 구현하자는 이야기이다. 즉, 저걸 굳이 class로 프로그래밍할 필요도 없고, 그냥 일반 함수를 써서 활용도를 축소시킬 필요도 없다는 것이다.</p>

<p>물론 더 나아가서 random access iterator에 대해서도 효율적으로 동작할 수 있도록 위 코드를 수정할 수도 있다. iterator_tag와 template의 부분 특수화를 사용하거나 함수 overloading을 사용하면 간단하게 할 수 있다. 이 부분은 EC++ 책에도 잘 나와있으니 이 글에서는 생략하도록 하겠다.</p>

<p>당연한 이야기이지만 algorithm의 <a href="http://www.cplusplus.com/reference/algorithm/binary_search/">binary_search</a>를 쓰는게 더 낫다. 이미 구현되어있는 것을 또 구현하지 않는 것이 제일 좋다! 그러므로 표준 라이브러리에 대해서는 틈틈이 알아두는게 좋다.</p>

<h3>정리</h3>

<p>코드를 간결하게, 그리고 명확하게 작성하기 위해 가작 적합한 c++ 기능을 사용하는 것은 너무나 당연한 이야기다. 앞으로 남은 한 번 혹은 두 번의 기회 동안 그 이야기를 더 진행하면서 스터디를 진행하는 친구를 세뇌시킬 생각이다.</p>

<p><a href="http://libsora.so/" title="libsora.so">if1live</a>님 방식으로 이야기하면 많이 짜고 많이 읽으면 된다. 그런데 <a href="https://twitter.com/summerlight00" title="summerlight00">summerlight</a>님처럼 표준 문서를 읽으라고는 못하겠다(나도 귀찮아서 안 읽으니까!)</p>

<h3>과제</h3>

<p>다음 이야기는 type erasure를 중심으로 진행할 예정이다.<br>
과제는 아래와 같다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Adapter</span><span class="o">&lt;</span><span class="kt">int</span> <span class="cm">/* return-type */</span><span class="p">,</span> <span class="kt">int</span> <span class="cm">/* 1st-arg-type */</span><span class="p">,</span> <span class="kt">int</span> <span class="cm">/* 2nd-arg-type */</span><span class="o">&gt;</span>
        <span class="n">functor1</span><span class="p">(</span><span class="n">sum</span><span class="p">,</span> <span class="mi">100</span> <span class="cm">/* 1st-arg */</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">functor1</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span> <span class="c1">// 120</span>
    <span class="kt">int</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">functor1</span><span class="p">(</span><span class="mi">80</span><span class="p">);</span> <span class="c1">// 180</span>
<span class="p">}</span>
</code></pre></div>
<p>위와 같은 동작을 수행할 수 있는 Adapter class (혹은 struct)을 구현해보자.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">template을 사용한 type간 동등성, 대입가능성</h1>
				<p class="page-date">19 Jul 2011</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
					<code class="tag">template</code>
						
						
						
						
				</p>
				<div class="content"><ul>
<li>runtime에 <code>typeid</code>를 써서 객체 type의 동등성(Same)을 확인하고,</li>
<li><code>dynamic_cast</code>를 써서 객체간의 대입가능성(Assignable)을 확인할 수 있다.</li>
</ul>

<p>하지만 이런 것을 확인하기 위해 runtime을 소모하는 것은 너무 아까운 일이다. 고로 template을 써보자.<br>
아래의 예제는 두 class, C1과 C2를 통해 진행된다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">C1</span> <span class="p">{};</span>
<span class="k">class</span> <span class="nc">C2</span> <span class="o">:</span> <span class="k">public</span> <span class="n">C1</span> <span class="p">{};</span>
</code></pre></div>
<h3>동등성 확인</h3>

<p>type 간의 동등성을 확인하는 것은 매우 간단하다. template의 specialization을 쓰면 된다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Type1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Type2</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">IsSame</span>
<span class="p">{</span>
    <span class="k">enum</span>
    <span class="p">{</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">false</span>
    <span class="p">};</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Type1</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">IsSame</span><span class="o">&lt;</span><span class="n">_Type1</span><span class="p">,</span> <span class="n">_Type1</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">enum</span> 
    <span class="p">{</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">true</span>
    <span class="p">};</span>
<span class="p">};</span>
</code></pre></div>
<p><code>IsSame</code>을 사용할 때, 비교하는 두 class의 type이 다르다면 위 template이 사용될 것이다. 여기의 value 값은 false다.<br>
만약 두 type이 같다면, type이 같은 경우로 specialization 된 아래의 template이 사용된다. 따라서 value는 true이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %d %d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">IsSame</span><span class="o">&lt;</span><span class="n">C1</span><span class="p">,</span> <span class="n">C1</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="n">IsSame</span><span class="o">&lt;</span><span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
                        <span class="n">IsSame</span><span class="o">&lt;</span><span class="n">C2</span><span class="p">,</span> <span class="n">C2</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="n">IsSame</span><span class="o">&lt;</span><span class="n">C2</span><span class="p">,</span> <span class="n">C1</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">);</span>
<span class="c1">// 수행 결과: 1 0 1 0</span>
</code></pre></div>
<p>이 모든 것이 compile time에 compiler가 판단해주므로 runtime 부담이 없다.</p>

<h3>대입 가능성 확인</h3>

<p>대입 가능성(assignable)을 판단할 때는, 두 type을 from과 to로 나누어 생각하는게 편하다.<br>
FROM is assignable TO 라는 개념으로 생각해볼 때, TO가 base class, FROM이 derive class가 되는 것이다.</p>

<p>이걸 compiler가 판단해주려면 함수의 overloading 판정을 사용하면 된다.
compiler는 최대한 근접한 type의 인자를 갖는 함수를 호출해준다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_From</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_To</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">IsAssignable</span>
<span class="p">{</span>
<span class="nl">private:</span>
    <span class="k">typedef</span> <span class="kt">char</span> <span class="n">IncorrectSize</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="kt">int</span>  <span class="n">CorrectSize</span><span class="p">;</span>

    <span class="k">static</span> <span class="n">_From</span>         <span class="nf">Instantiate</span><span class="p">();</span>
    <span class="k">static</span> <span class="n">CorrectSize</span>   <span class="nf">Check</span><span class="p">(</span><span class="k">const</span> <span class="n">_To</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="k">static</span> <span class="n">IncorrectSize</span> <span class="nf">Check</span><span class="p">(...);</span>

<span class="nl">public:</span>
    <span class="k">enum</span>
    <span class="p">{</span>
        <span class="n">value</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">CorrectSize</span><span class="p">)</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Check</span><span class="p">(</span><span class="n">Instantiate</span><span class="p">()))</span>
    <span class="p">};</span>
<span class="p">};</span>
</code></pre></div>
<p>compiler가 compile time에 비교를 해야하므로 가장 만만한건 <code>sizeof</code> 연산자이다.<br>
크기가 다른 두 type을 반환하도록 적절히 typedef를 걸어두고, From type이 <code>const To&amp;</code> 를 인자로 받는 Check와 그게 아닌 경우 <code>...</code> 중 어느 것이 호출되어 반환 값이 결정되는가를 보는 것이다. 그 반환 값의 type, 그리고 그 type에 대한 <code>sizeof</code> 는 모두 compile time에 결정될 수 있기 때문에 대입 가능한 경우에는 적절히 value가 설정될 것이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %d %d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">IsAssignable</span><span class="o">&lt;</span><span class="n">C1</span><span class="p">,</span> <span class="n">C1</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="n">IsAssignable</span><span class="o">&lt;</span><span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
                        <span class="n">IsAssignable</span><span class="o">&lt;</span><span class="n">C2</span><span class="p">,</span> <span class="n">C2</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="n">IsAssignable</span><span class="o">&lt;</span><span class="n">C2</span><span class="p">,</span> <span class="n">C1</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">);</span>
<span class="c1">// 수행 결과: 1 0 1 1</span>
</code></pre></div>
<p>재밌는 것은 위 방법으로 Assignable을 판단할 경우 만능 <code>void*</code> 에 대해서는 모든 pointer type이 다 통과해버린다는 것인데, 그런 것은 위에서 구현한 <code>IsSame</code>과 적절히 섞어서 가려낼 수 있다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">template의 암시적 interface 요구</h1>
				<p class="page-date">10 Jan 2012</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
					<code class="tag">template</code>
						
						
						
						
				</p>
				<div class="content"><p>상속을 통한 동적 다형성을 이용하려면, 명시적인 interface가 형성되어야 한다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">game_object</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="kt">float</span> <span class="n">dt</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">character</span> <span class="o">:</span> <span class="k">public</span> <span class="n">game_object</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="kt">float</span> <span class="n">dt</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">item</span> <span class="o">:</span> <span class="k">public</span> <span class="n">game_object</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="kt">float</span> <span class="n">dt</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>와 같이 interface와 이를 구현(implements)하는 구체 class를 작성하고</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">game_object</span><span class="o">*&gt;</span> <span class="n">objects</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">objects</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">objects</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">(</span><span class="n">game_object</span><span class="o">*</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">obj</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="n">dt</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div>
<p>이처럼 동일한 interface로 취급할 수 있도록 하나의 container에 각 구체 class들의 객체를 담고
iterating하면서 <code>update</code> 함수를 불러준다. 이 때 type은 <code>game_object *</code>이므로 <code>update</code>라는 함수가 있다는 것을 명시적으로 보장해 줄 수 있다.</p>

<p>template을 쓰면 좀 더 유연해지는데, 굳이 <code>game_object</code>라는 interface를 명시적으로 두지 않아도 <code>update</code>라는 함수만 있으면 된다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">character</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="kt">float</span> <span class="n">dt</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">item</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="kt">float</span> <span class="n">dt</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p><code>character</code>와 <code>item</code> 자체는 어쨌든 <code>update</code>라는 함수를 갖는다. 하지만 그 둘이 같은 interface를 갖는다는 명시적인 보장은 없다. (적어도 코드를 작성하는 사람이 눈으로 보고는 알 수 있겠다)</p>

<p>이에 하지만 만약 둘을 처리하는 로직이 공통될 경우 (둘 다 <code>update</code>을 불러줘야할 경우)가 있을 것이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">character</span><span class="o">&gt;</span> <span class="n">characters</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">item</span><span class="o">&gt;</span> <span class="n">items</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">characters</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">characters</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">(</span><span class="n">character</span><span class="o">&amp;</span> <span class="n">ch</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ch</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">dt</span><span class="p">);</span>
<span class="p">});</span>
<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">items</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">items</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">(</span><span class="n">item</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">it</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">dt</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div>
<p>그럼 위처럼 코드가 중복된다. 하지만 하는 동작이 동일하다면, (코드 형태가 유사하다면) 명시적인 interface 규약이 없어도 암시적으로 코드의 틀이 비슷하다는 것이니까 이 때 template을 쓴다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_contTy</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">update_all</span><span class="p">(</span><span class="n">_contTy</span><span class="o">&amp;</span> <span class="n">cont</span><span class="p">,</span> <span class="kt">float</span> <span class="n">dt</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">cont</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">cont</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">(</span><span class="k">typename</span> <span class="n">_contTy</span><span class="o">::</span><span class="n">value_type</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">val</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">dt</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div>
<p>위 template 함수는 어떤 container를 인자로 받아서, 그 내부를 순회하며 각 element들의 <code>update</code> method를 불러준다.</p>

<p>이 때 위 함수는</p>

<ul>
<li>container가 <code>begin</code>, <code>end</code> method를 갖고 있고,</li>
<li>그 반환 값이 forward iterator 이고,</li>
<li>container의 type이 <code>value_type</code>이라는 typename을 갖고,</li>
<li>그 <code>value_type</code>은 <code>update</code>라는 method를 갖는다는</li>
</ul>

<p>암시적인 규약을 내포한다.</p>

<p>이걸 왜 암시적이라고 부르냐하면, <code>update_all</code> 함수는 실제 사용되기 전까지 컴파일 대상이 아니며 사용되었을 때 해당 type으로 코드가 instantiate되면서 올바른 코드인지 검사하기 때문이다.</p>

<p>즉 <code>std::vector&lt;character&gt;</code>라는 type으로 위 함수를 부르게 되면,</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">update_all</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">character</span><span class="o">&gt;&amp;</span> <span class="n">cont</span><span class="p">,</span> <span class="kt">float</span> <span class="n">dt</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">cont</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">cont</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">character</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">val</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">dt</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div>
<p>와 같은 적법한 코드가 생성되어, 이 때 <code>std::vector</code>가 <code>begin</code>, <code>end</code>, <code>value_type</code>을 가지고 있고, <code>value_type</code>인 <code>character</code>가 <code>update</code> 함수를 가지고 있으니 문제 없이 컴파일 되는 것이다.</p>

<p>즉 사용되는 시점에 코드를 찍어내는 것이고 실행 중(runtime) 에 모종의 작업이 필요한 것이 아니므로 interface나 abstract class같은 vfptr을 생성하는 명시적인 interface가 필요없다는 것이다. (이렇게 생각해보면 명시적/암시적 interface 라고 이름 붙이는 것도 웃긴 일이다)</p>

<p>template 함수의 또 하나의 장점은, 무시무시한 type inference와 코드 찍어내기로 인해 template 함수 내에서 요구하는 명세를 지키는 대상에 대해서는 모두 사용할 수 있게 해준다는 것이다.</p>

<p>예를 들어,
위 <code>update_all</code> 함수는 <code>vector</code>, <code>list</code>, <code>deque</code>, <code>set</code> 등 여러 stl container에 대해 사용 가능하기 때문에 굉장히 일반적인 함수라 할 수 있다. (generic 하다)</p>

<p>생각해보니 단순히 프로그래밍 측면에서 위의 두 내용을 비교하는 것은 바람직하지 못한 것 같다. 다음 글에서는 vfptr과 template instantiate의 세부적 내용을 통해 둘이 어떻게 다르고 어떤 장단점이 있는지 자세히 보도록 하자.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
						
				<h1 class="page-title">thread local storage 초기화</h1>
				<p class="page-date">13 Jul 2011</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
						
				</p>
				<div class="content"><p>Tls는 <code>Thread Local Storage</code>로 Thread 내 전역변수라고 생각하면 간단하다(Local 인데 왠 전역!)<br>
즉, 그냥 global 영역에 선언하는 변수는 프로그램 내에 여러 Thread 가 공유하는 자원이 되지만, Tls 로 선언한 자원들은 해당 Thread 별로 따로 갖는다고 보면 된다.<br>
(이 때문에 strtok 같은 함수도 내부에서 static 변수를 써도 Tls 로 선언하면 Multithread 에서도 문제가 없다는 것)</p>

<p>그런데, Tls 는 생성자/소멸자가 정의된 객체에 대해 사용할 수가 없다. 따라서 primitive type, pointer, 그냥 구조체만 선언해서 쓸 수 있게 된다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kr">__declspec</span><span class="p">(</span><span class="kr">thread</span><span class="p">)</span> <span class="kt">int</span> <span class="n">tlsValue</span><span class="p">;</span>
<span class="n">__descspec</span><span class="p">(</span><span class="kr">thread</span><span class="p">)</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">header</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">body</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">tail</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="p">}</span> <span class="n">tlsChunk</span><span class="p">;</span>
</code></pre></div>
<p>그 외의 객체를 쓰고 싶으면 객체의 포인터를 Tls 선언해서 각 Thread 마다 객체를 동적할당(new)하여 사용해야하는 것이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">Strings</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Strings</span><span class="o">*</span> <span class="n">StringsPtr</span><span class="p">;</span>
<span class="kr">__declspec</span><span class="p">(</span><span class="kr">thread</span><span class="p">)</span> <span class="n">StringsPtr</span> <span class="n">tlsStrings</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">InitializeTls</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tlsStrings</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Strings</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>만약 각기 다른 기능(모듈)의 여러 class가 존재하고, 그것들이 모두 Tls로 존재해야한다면 그 class에 대한 포인터 타입을 Tls로 선언한 다음에 그 객체들을 생성하기 위한 코드를 작성해야 할 것이다. Thread 모듈은 다른 각 모듈과 독립적이다. 즉, 뭐가 Tls 에 추가되든 말든 자신이 알면 안된다는 것이다.</p>

<p>예를 들어 Timer라는 모듈을 Tls로 갖는다고 하자. 그러면 Timer가 Tls구현을 위해 Thread를 아는 것은 당연한 이야기이지만, Thread 모듈 입장에서는 어떤 모듈이 Tls 를 하는지 알 수 없으므로 Thread가 Timer 혹은 다른 모듈을 알 수 없고, 알 필요도 없고, 의존성을 낮추기 위해서 알아서도 안 된다는 것이다.</p>

<p>왜 이런 장황한 이야기를 하냐면, 내가 본 코드가 아래와 유사한 구조이기 때문이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#define __declspec(thread) TLS</span>
<span class="n">TLS</span> <span class="kt">int</span> <span class="n">tlsTimerIndex</span><span class="p">;</span>
<span class="n">TLS</span> <span class="n">TimerPtr</span> <span class="n">tlsTimer</span><span class="p">;</span>
<span class="n">TLS</span> <span class="n">QueuePtr</span> <span class="n">tlsQueue</span><span class="p">;</span>
<span class="n">TLS</span> <span class="n">TracerPtr</span> <span class="n">tlsTracer</span><span class="p">;</span>
</code></pre></div>
<p>이와 같이 한 파일에 Tls 관련 변수를 다 정의해놓고, 이것들에 대해 extern으로 해놓은 h 파일을 여기저기에서 include해서 쓰고 있다. 딱 보면 알 수 있지만 저 파일 선언하려면 Timer, Queue, Tracer를 모두 include해줘야 한다. 폭풍의존이 생긴다.</p>

<p>그리고 아래와 같이 Thread가 갖고 있는 static method인 <code>InitializeTls</code> 함수에서 Tls를 일괄 초기화해준다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Thread</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">InitializeTls</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tlsTimer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Timer</span><span class="p">;</span>
        <span class="n">tlsQueue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Queue</span><span class="p">;</span>
        <span class="n">tlsTracer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Tracer</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>요약해서 말하자면, 위 방법은 전역으로 사용할 변수를 한 파일에 다 모아놓은 것이다. 그게 더 관리하기 쉽다고 생각할 수도 있지만, 적어도 나는 유지 보수와 에러 커버리지 측면에서 위 방법이 옳지 않다고 이야기하고 싶다.</p>

<p>Tls로 사용하는 <code>Queue</code>가 뭔가 잘못되었다. 그래서 새로운 <code>EnhancedQueue</code>를 작성해서 대체하려고 하는데, 단지 <code>Queue</code>가 정의된 파일만을 고치는 것이 아니라 저 Tls가 선언된 파일과 저 파일을 참조하게 되는 거의 모든 파일들을 의존폭풍에 함께 휘날리며 찾아다니면서 수정을 해야한다.<br>
즉, 수정 범위가 의존된 파일이라면, 전체 프로젝트를 대상으로 수정을 해야한다는 것이다.</p>

<p>새로운 모듈을 작성해서 Tls에 추가할 때는?<br>
역시 Tls가 옹기종기 모여있는 header 파일과 cpp 파일에 해당 값을 추가하고 <code>InitializeTls</code> 함수에 초기화해주는 구문을 추가하면 되겠다. 그런데 내가 지금 만든 모듈을 추가하려하는데 기존의 코드까지 고쳐야한다는게 상당히 거부감이 드는건 단지 내 성격상의 문제일런지 모르겠다</p>

<p>그래서 위 코드를 적어도 나같으면 이렇게 하겠다. 먼저, Tls 변수를 절대 전역적으로 노출시키지 않는다. Timer를 예로 들자면,</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Timer</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">static</span> <span class="n">Timer</span><span class="o">&amp;</span> <span class="n">GetCurrentThreadTimer</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div>
<p>와 같이 static method로 interface를 노출시켜준다. 그리고 cpp 파일에서,</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kr">__declspec</span> <span class="n">Timer</span><span class="o">*</span> <span class="n">tlsTimer</span><span class="p">;</span>
<span class="n">Timer</span><span class="o">&amp;</span> <span class="n">Timer</span><span class="o">::</span><span class="n">GetCurrentThreadTimer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">tlsTimer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>와 같이 tls를 외부로 노출시키지 않은 채(즉 extern 을 쓰지 않고) 선언하고, 이를 static method를 통해 반환할 수 있게 해준다. 그러면 <code>Timer::GetCurrentThreadTimer()</code> 함수를 써서 얻는 객체는 Thread-safe하게 사용할 수 있는 Timer가 될 것이다.</p>

<p>그리고 Thread에서 Tls 초기화를 위해 약간 신경을 써준다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="c1">// thread.h</span>
<span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">TlsInitializer</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">class</span> <span class="nc">Thread</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TlsInitializer</span><span class="o">&gt;</span> <span class="n">TlsInitializers</span><span class="p">;</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="nf">RegisterTlsInitializer</span><span class="p">(</span><span class="n">TlsInitializer</span> <span class="n">initializer</span><span class="p">);</span>
<span class="nl">private:</span>
    <span class="k">static</span> <span class="n">TlsInitializers</span> <span class="n">sTlsInitializers</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// thread.cpp</span>
<span class="n">Thread</span><span class="o">::</span><span class="n">TlsInitializers</span> <span class="n">Thread</span><span class="o">::</span><span class="n">sTlsInitializers</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">Thread</span><span class="o">::</span><span class="n">RegisterTlsInitializer</span><span class="p">(</span><span class="n">TlsInitializer</span> <span class="n">initializer</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sTlsInitializers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">initializer</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Thread의 static method인 <code>RegisterTlsInitializer</code> 함수를 통해서 Tls를 초기화하는 함수 포인터를 등록할 수 있다. 등록된 함수 포인터는 Thread의 static variable인 <code>sTlsInitializers</code>에 저장이 되고, Thread 객체가 생성될 때 이 vector에 저장되어있는 각 모듈별로 등록된 Tls 초기화 함수들이 호출되어 Tls를 초기화할 것이다.</p>

<p>그런데 여기까지 해도 여전히 Tls 초기화 함수를 <code>RegisterTlsInitializer</code> 함수의 인자로 호출해주는 시점이 문제다. Thread 객체가 처음 만들어지기 전까지는 각 모듈의 Tls 초기화 함수들이 등록되어야하기 때문이다.
따라서 아래와 같이 생성자 기반의 Functor를 만든다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="n">TlsInitializerRegister</span> <span class="p">{</span>
    <span class="n">TlsInitializerRegister</span><span class="p">(</span><span class="n">TlsInitializer</span> <span class="n">initializer</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Thread</span><span class="o">::</span><span class="n">RegisterTlsInitializer</span><span class="p">(</span><span class="n">initializer</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>이제 Tls Initializer 함수를 만들고, 그 함수 포인터를 인자로 저 객체를 생성해주면 된다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Timer</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">InitializeTls</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div>
<p>당연한 이야기이지만 함수 포인터의 원형이 <code>void (*) (void)</code>이므로 member method가 아닌 static method이다.
그리고 Timer.cpp에서 아래와 같이 전역 변수를 만들어준다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">static</span> <span class="n">TlsInitializerRegister</span> <span class="nf">_TimerTlsInitializerRegister</span> <span class="p">(</span><span class="n">Timer</span><span class="o">::</span><span class="n">InitializeTls</span><span class="p">);</span>
</code></pre></div>
<p>그러면 해당 전역 변수가 생성되면서 <code>Timer::InitializeTls</code> 함수가 Thread의 Tls 목록에 등록되는 것이다. 행여나 다른 파일 등에서 저 변수를 접근해서 쓰지 못하도록 static 으로 전역 변수를 선언했다.</p>

<p>초기화 함수 이름이나 등록 방법이 애매하면, Macro를 사용하여 코드를 찍어낼 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#define DECLARE_TLS_INITIALIZER() static void _InitializeTls(void)</span>
<span class="cp">#define IMPLEMENT_TLS_INITIALIZER(_ClassName) \</span>
<span class="cp">    static TlsInitializerRegister _##_ClassName##TlsInitializerRegister (_ClassName::_InitializeTls); \</span>
<span class="cp">    void _ClassName::InitializeTls(void)</span>
</code></pre></div>
<p>그러면 아래와 같이 사용할 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="c1">// timer.h</span>
<span class="k">class</span> <span class="nc">Timer</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">DECLARE_TLS_INITIALIZER</span><span class="p">();</span>
<span class="p">};</span>

<span class="c1">// timer.cpp</span>
<span class="n">IMPLEMENT_TLS_INITIALIZER</span><span class="p">(</span><span class="n">Timer</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tlsTimer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Timer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>개인적으로 최대한 설계로 깔끔함을 추구하려고 노력하는 편이고, 그 뒤에 Macro 등으로 가독성을 올릴 수 있다고 믿는 편이라 굳이 쓰지 않아도 되는 Macro를 도입한게 아닐까 하는 생각도 들기도 한다.</p>

<p>어쨌든 처음에 지적한 <strong>한 파일에 몰아넣기</strong> 보다는 위 방법과 같이 <strong>모듈별 분리</strong> 방법이 설계적 측면에서 더 낫다고 생각한다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
						
				<h1 class="page-title">type_t class 도입을 통한 임시 객체 없는 type 분기</h1>
				<p class="page-date">15 Nov 2011</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
					<code class="tag">template</code>
						
						
						
						
				</p>
				<div class="content"><p>어떤 class 2개가 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">big_class</span> <span class="p">{};</span>
<span class="k">class</span> <span class="nc">huge_class</span> <span class="p">{};</span>
</code></pre></div>
<p>이 class들은 기본 생성자에서 굉장히 복잡한 작업을 하는 객체들 혹은 생성 자체가 복잡한 class들이다. 이러한 class에 대해 어떠한 작업을 수행하는 generic한 함수가 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Ty</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">operation</span><span class="p">()</span> <span class="p">{}</span>
</code></pre></div>
<p>이 함수는 객체의 type을 받아서 내부에서 모종의 작업을 수행하게 된다. 따라서 메인 함수에서는 다음과 같이 각 class에 대해 operation을 요청하게 된다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">_tmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">_TCHAR</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">operation</span><span class="o">&lt;</span><span class="n">big_class</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">operation</span><span class="o">&lt;</span><span class="n">huge_class</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>(굳이 객체를 넘기지 않은건 이 예제에서는 별로 그럴 필요가 없기 때문이다.)</p>

<p>operation 내에서는 각 type별로 type의 이름을 출력해주는 <code>print</code>라는 함수를 호출한다고 하자. 그러면 간단하게 template의 specialization을 사용하여, <code>print</code> 함수는 다음과 같다고 생각할 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Ty</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">Ty</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Ty</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">big_class</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf_s</span><span class="p">(</span><span class="s">&quot;big_class</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Ty</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">huge_class</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf_s</span><span class="p">(</span><span class="s">&quot;huge_class</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>specialization을 하기 위해 함수 interface에 인자로 받을 객체를 추가했다. 덕분에 각 type 별로 함수가 구분되기는 했지만, 저 함수를 부르려면 일단 객체를 만들어야하는 부담이 생긴다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Ty</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">operation</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="n">_Ty</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div>
<p><code>big_class</code>와 <code>huge_class</code>는 기본 생성자에서 굉장히 많은 일을 하는 무거운 class이다. 따라서 실제 객체를 쓰지도 않는 <code>print</code> 함수를 위해 임시 객체를 만드는 것은 굉장히 낭비스러운 일이다. 또한, 저 operation 함수가 generic 해야함을 고려해볼 때, 저 함수를 사용하는 모든 class 들이 <del>임시 객체를</del>기본 생성자를 갖는다고 가정하는 것은 전혀 generic하지 않은 생각이다.</p>

<p>이 문제를 해결하기 위해서는, <code>print</code> 함수에 객체를 넘기는 것이 아니라 객체의 type을 넘기는 방법을 사용하면 된다. c++ template meta programming 책에서는 이에 대해서, <strong>간접층을 도입하여 문제를 해결할 수 있다</strong> 라고 소개한다.</p>

<p>먼저 type 정보를 위한 template class를 도입한다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Ty</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">type_t</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="n">_Ty</span> <span class="n">type</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>단순히 저 class를 사용하는 것만으로 위 문제가 깔끔하게 해결된다. 이제 <code>print</code> 함수는 실제 객체의 type을 인자로 넣는 것이 아니라 <code>type_t</code>를 인자로 받는다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Ty</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="kt">type_t</span><span class="o">&lt;</span><span class="n">_Ty</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="p">{}</span>

<span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="kt">type_t</span><span class="o">&lt;</span><span class="n">big_class</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf_s</span><span class="p">(</span><span class="s">&quot;big_class</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="kt">type_t</span><span class="o">&lt;</span><span class="n">huge_class</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf_s</span><span class="p">(</span><span class="s">&quot;huge_class</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p><code>print</code> 함수의 인자는 이제 <code>type_t</code>의 객체이지 실제 <code>big_class</code>와 <code>huge_class</code>의 객체가 아니다. 그리고 <code>type_t</code> class 는 아무런 멤버 변수도 갖지 않는 매우 가벼운 임시 객체를 생성할 수 있다. (typedef 정보만 갖기 때문에 컴파일러가 최적화하여 아무런 임시 객체를 만들지 않고 바로 함수를 호출하도록 linking을 할 것이다)</p>

<p>이제 operation 함수는 무거운 <code>big_class</code>와 <code>huge_class</code>에 대한 임시 객체를 만드는 대신, 각 type 에 대한 <code>type_t</code> 객체를 만들어서 <code>print</code> 함수에게 넘겨주면 된다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Ty</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">operation</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="kt">type_t</span><span class="o">&lt;</span><span class="n">_Ty</span><span class="o">&gt;</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div>
<p>다음은 코드 전문이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">big_class</span> <span class="p">{};</span>
<span class="k">class</span> <span class="nc">huge_class</span> <span class="p">{};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Ty</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">type_t</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="n">_Ty</span> <span class="n">type</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Ty</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="kt">type_t</span><span class="o">&lt;</span><span class="n">_Ty</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="p">{}</span>

<span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="kt">type_t</span><span class="o">&lt;</span><span class="n">big_class</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf_s</span><span class="p">(</span><span class="s">&quot;big_class</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="kt">type_t</span><span class="o">&lt;</span><span class="n">huge_class</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf_s</span><span class="p">(</span><span class="s">&quot;huge_class</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Ty</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">operation</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="kt">type_t</span><span class="o">&lt;</span><span class="n">_Ty</span><span class="o">&gt;</span><span class="p">());</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">_tmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">_TCHAR</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">operation</span><span class="o">&lt;</span><span class="n">big_class</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">operation</span><span class="o">&lt;</span><span class="n">huge_class</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>template의 specialization이 들어가면 컴파일 순서에 따라 문제가 발생할 여지가 있다. 예를 들어 위 예제에서 operation 함수가 실제 구현되는 부분은 main 함수가 컴파일 될 때이다.</p>

<p><code>operation&lt;big_class&gt;</code>가 컴파일 될 때 <code>big_class</code> type에 대한 operation 함수의 코드가 만들어진다고 보면 되고, 이 때 <code>print(type_t&lt;big_class&gt;());</code> 구문을 생성하게 된다. 이 시점에서</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="kt">type_t</span><span class="o">&lt;</span><span class="n">big_class</span><span class="o">&gt;&amp;</span><span class="p">)</span>
</code></pre></div>
<p>함수를 컴파일러가 알지 못한다면, 컴파일러는</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Ty</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="kt">type_t</span><span class="o">&lt;</span><span class="n">_Ty</span><span class="o">&gt;&amp;</span><span class="p">)</span>
</code></pre></div>
<p>의 코드만 보고 직접 <code>big_class</code>에 대한 <code>print</code> 함수 또한 만들어버릴 것이다.</p>

<p>즉, 컴파일러가 특수화된 template 함수를 미처 보지 못하면 그 template 함수의 원형을 통해 필요한 type 의 함수를 만들어버리게 되므로 의도치 않은 동작을 할 수 있다. 즉, 위와 같은 코드를 작성할 때에는 컴파일러가 읽게되는 순서를 주의해야 한다는 것이다. (이에 대한 설명은 추후에 다시 하도록 하겠다)</p>

<p>함수의 overload처럼 template 함수도 동일한 interface로 generic한 일관성을 지키며, 필요한 각 부분에 대해 specialization을 통해 최적화된 함수를 구현할 수 있다. overload 된 함수는 모두 컴파일 대상이지만, template 함수는 실제 사용되기 전까지는 컴파일조차 되지 않는다. 이러한 장점을 이용하여 무슨 짓을 할 수 있는지 차차 알아보도록 하자.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
						
				<h1 class="page-title">variadic template을 사용한 typelist 구현</h1>
				<p class="page-date">29 Jun 2014</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
					<code class="tag">template</code>
						
						
						
						
				</p>
				<div class="content"><p>Modern C++ Design 책에서 소개한 typelist를 c++11 문법인 variadic template으로 구현해보자.</p>

<p>typelist는 type들의 list형태로 compile time에 여러 type에 대한 동일한 작업을 할 때 사용된다. 예를 들면,</p>

<ul>
<li>conversion table을 만들어서 부담이 적은 dynamic_cast를 구현한다던가,</li>
<li>hierarchical inheritance를 통한 tuple class 구현이라던가,</li>
<li>여러 type에 대해 작성되어야 할 boilerplate 코드를 template으로 구현한다던가 할 때 사용된다.</li>
</ul>

<p>여러 type을 list 형태로 묶기 위해서는 <strong>개수를 알 수 없는</strong> type 인자를 template으로 받아야 한다는 것인데, c++11 이전에는 그러한 방법이 없었기 때문에 template overloading (boost mpl)이나 typenode에 의한 linked list + macro (loki) 형태로 구현했었다.</p>

<p>c++11에서는 variadic template이 지원되니 이 부분을 개선해보도록 하자.</p>

<h4>typenode를 사용한 구현</h4>

<p>MC++D에서 소개된 loki 라이브러리의 Typelist는 <code>Typelist</code> template class와 <code>TYPELIST</code> macro를 사용하여 구현된다. 본 글에서는 macro가 필요없기 때문에 이름 혼동을 막기 위해 <code>typenode</code> template class와 그를 사용하는 <code>typelist</code> template class로 구현하도록 하겠다.</p>

<p>일단 <code>typenode</code>를 보면 다음과 같다. <code>typenode</code>는 loki 라이브러리에서 <code>Typelist</code>로 소개된 <code>Head</code>와 <code>Tail</code>을 가지고 있는 struct와 동일하다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Head</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Tail</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">typenode</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="n">Head</span> <span class="n">head_type</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">Tail</span> <span class="n">tail_type</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>loki에서는 저 <code>typenode</code>를 사용할 경우, 인자 4개를 받는 typelist 구현을 위해서는 <code>TYPELIST_4</code>와 같은 macro를 만들어서 typenode의 linked list 형태가 만들어지도록 하였다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#define TYPELIST_1(T1) typenode&lt;T1, null_type&gt;</span>
<span class="cp">#define TYPELIST_2(T1, T2) typenode&lt;T2, TYPELIST_1(T1)&gt;</span>
<span class="cp">#define TYPELIST_3(T1, T2, T3) typenode&lt;T3, TYPELIST_2(T1, T2)&gt;</span>
<span class="cp">#define TYPELIST_4(T1, T2, T3, T4) typenode&lt;T4, TYPELIST_3(T1, T2, T3)&gt;</span>
</code></pre></div>
<p>하지만 variadic template이 지원되는 c++11에서는 template 인자를 여러 개 받기 위해 저렇게 할 필요는 없다. 그냥 variadic template param을 받아서 재귀적으로 풀어주기만 하면 된다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">typelist</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="k">struct</span> <span class="n">typelist</span><span class="o">&lt;&gt;</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="n">null_type</span> <span class="n">type</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Head</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Rest</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">typelist</span><span class="o">&lt;</span><span class="n">Head</span><span class="p">,</span> <span class="n">Rest</span><span class="p">...</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="n">typenode</span><span class="o">&lt;</span><span class="n">Head</span><span class="p">,</span> <span class="k">typename</span> <span class="n">typelist</span><span class="o">&lt;</span><span class="n">Rest</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span> <span class="n">type</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>기존 template meta programming과 동일하게,</p>

<ul>
<li>기본 템플릿(primary template)을 먼저 선언해주고,</li>
<li>종료 조건에 대한 specialization을 해주고,</li>
<li>재귀적으로 푸는 일반 항에 대해 만들어주면 된다.</li>
</ul>

<p>그냥 수식 정의하는 것, 혹은 함수형 프로그래밍하는 것과 똑같다고 보면 된다.</p>

<p>그러면 일반 항에 의해 <code>Head</code>와 나머지로 type이 분리되고, 이 때마다 <code>typenode</code>에 대한 link를 재귀적으로 만들어주니 loki와 같이 번거롭게 <code>TYPENODE_n</code> macro를 정의하지 않아도 typelist를 구현할 수 있는 것이다. 이렇게 만들어진 typelist는 loki에서 구현된 typenode의 linked list 형태이므로, loki의 typelist libs를 그대로 사용할 수 있다.</p>

<p>다음으로 넘어가기 전에 비교를 위해 <code>length</code>, <code>type_at</code>, <code>visitor</code> 3가지 libs에 대해 살펴보자.<br>
먼저 <code>length</code>를 보자. length는 typelist에 들어있는 type의 개수를 세는 meta function이다. (tmp에서 사용되는 template function을 meta function이라고 한다.)</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TL</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">length</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">length</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">TL</span><span class="o">::</span><span class="n">tail_type</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="k">struct</span> <span class="n">length</span><span class="o">&lt;</span><span class="n">null_type</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>구현 방식은 typelist와 동일하다. 다만 primary template 형태에서 일반 항을 구현할 수 있기 때문에 일반 항과 종료 조건만 구현해주면 된다. 즉, <code>Tail</code>이 <code>null_type</code>이 될 때까지 1씩 더해가는 재귀적 구조라고 생각하면 되겠다.</p>

<p>특정 위치에 있는 type을 가져오는 <code>type_at</code> meta function도 동일한 방법으로 구현할 수 있겠다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TL</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">type_at</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">type_at</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">TL</span><span class="o">::</span><span class="n">tail_type</span><span class="p">,</span> <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">type</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Head</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Tail</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">type_at</span><span class="o">&lt;</span><span class="n">typenode</span><span class="o">&lt;</span><span class="n">Head</span><span class="p">,</span> <span class="n">Tail</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="n">Head</span> <span class="n">type</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>index를 받아야 하므로 template argument가 2개(typelist와 index)이다. 두 번째 인자는 integer 값으로 이를 non-type template parameter 혹은 value-type template parameter라고 한다. 별다른 차이는 없고, 그냥 index 값이 0일 때를 종료 조건으로 그 때의 Head를 반환하도록 구현해주면 된다.</p>

<p>마지막으로 <code>visitor</code>를 보자. visitor는 typelist에 있는 type들을 모두 한 번씩 방문하면서 인자로 넘긴 <code>Delegator</code> meta function을 호출해주는 meta function이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TL</span><span class="p">,</span> <span class="k">template</span> <span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Delegator</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">visitor</span> <span class="p">{</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">execute</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Delegator</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">TL</span><span class="o">::</span><span class="n">head_type</span><span class="o">&gt;::</span><span class="n">execute</span><span class="p">();</span>
        <span class="n">visitor</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">TL</span><span class="o">::</span><span class="n">tail_type</span><span class="p">,</span> <span class="n">Delegator</span><span class="o">&gt;::</span><span class="n">execute</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Delegator</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">visitor</span><span class="o">&lt;</span><span class="n">null_type</span><span class="p">,</span> <span class="n">Delegator</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">execute</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>
</code></pre></div>
<p>역시 구현 방법은 동일하다. <code>Delegator</code>는 type을 template 인자로 받아야 하기 때문에 template class가 되어야 하고, 이 때문에 visitor의 template 인자가 template template class가 된다는 점만 좀 다르다.<br>
<code>visitor::execute()</code>에서는 typelist를 풀어서 Head를 <code>Delegator::execute()</code>로 넘겨서 호출해주고, 남은 대상들을 재귀적으로 호출해주도록 구현되어 있다. 이 때 재귀적으로 구성될 것 같은 함수 구조는 template engine이 다 풀어서 실제로는 그냥 <code>Delegator::execute()</code> 함수가 연속적으로 불리는 코드가 생성된다. (즉 runtime 부담이 최소화된다)</p>

<h4>typenode 없는 typelist 구현</h4>

<p>typenode가 없다는 것은 재귀적으로 구성된 node에 의한 list가 아닌 variadic template param을 보존하고 있는 list 형태로 구현한다는 것이다. 예를 들어 <code>typelist&lt;short, int&gt;</code>를 구현한다고 하면,</p>

<ul>
<li>typenode 기반일 경우 <code>typenode&lt;short, typenode&lt;int, null_type&gt;&gt;</code>와 같이 구성된다면,</li>
<li>이번에는 <code>typelist&lt;short, int&gt;</code>와 같이 구성되는 것을 말하는 것이다.</li>
</ul>

<p>이렇게 구현할 경우 list를 어떻게 유지할 것이며, 각 지점의 type을 어떻게 접근할 수 있을지 고민해야 한다. 왜냐하면 tmp는 재귀적으로 알고리즘을 작성해야 하기 때문이다.</p>

<p>일단 이는 간단히 다음과 같이 구현해볼 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Types</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">typelist</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">First</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">typelist</span><span class="o">&lt;</span><span class="n">First</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="n">typelist</span><span class="o">&lt;</span><span class="n">First</span><span class="o">&gt;</span> <span class="n">type</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">null_type</span> <span class="n">next</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">First</span> <span class="n">current</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">First</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Rest</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">typelist</span><span class="o">&lt;</span><span class="n">First</span><span class="p">,</span> <span class="n">Rest</span><span class="p">...</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="n">typelist</span><span class="o">&lt;</span><span class="n">First</span><span class="p">,</span> <span class="n">Rest</span><span class="p">...</span><span class="o">&gt;</span> <span class="n">type</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">typelist</span><span class="o">&lt;</span><span class="n">Rest</span><span class="p">...</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">First</span> <span class="n">current</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>구현하는 방식은 위에서 언급했던 것과 크게 다르지 않다. primary template을 만들고, 종료 조건에 대해 구현하고, 일반 항을 구현한다.</p>

<ul>
<li>처음 typelist와 interface를 맞추기 위해 type으로 자기 자신을 가리키도록 했다.</li>
<li>지금 인자를 제외한 남은 template 인자들로 다음 list를 가리키기 위한 next를 만들었다.</li>
<li>지금 인자를 가져오기 위한 current를 만들었다.</li>
</ul>

<p>그럼 이제 meta function들은 <code>next</code>를 타고 이동하고 <code>current</code>를 선택하면서 구현하면 되겠다.
<code>length</code>를 보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">List</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">length</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">length</span><span class="o">&lt;</span><span class="n">List</span><span class="o">::</span><span class="n">next</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="k">struct</span> <span class="n">length</span><span class="o">&lt;</span><span class="n">null_type</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>typenode 때와 동일하다. <code>tail_type</code> 대신 <code>next</code>로 재귀한다고 생각하면 된다.</p>

<p><code>type_at</code>과 <code>visitor</code>도 동일하다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">List</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">type_at</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">type_at</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">List</span><span class="o">::</span><span class="n">next</span><span class="p">,</span> <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">type</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">List</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">type_at</span><span class="o">&lt;</span><span class="n">List</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">List</span><span class="o">::</span><span class="n">current</span> <span class="n">type</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">List</span><span class="p">,</span> <span class="k">template</span> <span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Delegator</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">visitor</span> <span class="p">{</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">execute</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Delegator</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">List</span><span class="o">::</span><span class="n">current</span><span class="o">&gt;::</span><span class="n">execute</span><span class="p">();</span>
        <span class="n">visitor</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">List</span><span class="o">::</span><span class="n">next</span><span class="p">,</span> <span class="n">Delegator</span><span class="o">&gt;::</span><span class="n">execute</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Delegator</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">visitor</span><span class="o">&lt;</span><span class="n">null_type</span><span class="p">,</span> <span class="n">Delegator</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">execute</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>
</code></pre></div>
<p>이상으로 간단히 typenode 없는 typelist를 구현해 보았다.</p>

<h4>정리</h4>

<p>전자와 후자의 가장 큰 차이점은 typenode에 의한 재귀적 list냐 아니면 variadic template 인자에 의한 선형적 list냐의 차이라고 생각된다. 이를 기반으로 수행하는 meta function들은 어차피 재귀적으로 수행되므로, 아마도 둘의 차이는 compile 시 소모되는 메모리 양이 되지 않을까 한다. 아마도 후자의 메모리 소모량이 더 적지 않을까 한다.<br>
또한 debugging을 위해 typelist의 typename을 출력해보면 후자가 보기 좋기 때문에 후자가 더 좋아보이기도 한다.</p>

<p>그러면 이제 typelist를 수정하는 meta function들을 구현해야 하는데 그건 다음에 해보도록 하겠다.</p>

<ul>
<li><a href="http://stackoverflow.com/questions/9662632/variadic-variadic-template-templates">Stackoverflow: Variadic variadic template templates</a></li>
<li><a href="http://stackoverflow.com/questions/16648144/merge-two-variadic-templates-in-one">Stackoverflow: Merge two variadic templates in one</a></li>
</ul>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">객체의 생성, 소멸과 goto 이야기</h1>
				<p class="page-date">20 Jul 2011</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
						
				</p>
				<div class="content"><h3>생성자 소멸자 이야기</h3>

<p>어떤 class의 생성자와 소멸자를 구현했다. 거기에서는 엄청나게 복잡한 작업을 수행한다. 예를 들면,</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Object</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Object</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* 엄청 복잡한 작업 */</span> <span class="p">}</span>
    <span class="o">~</span><span class="n">Object</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* 진짜 복잡한 작업 */</span> <span class="p">}</span>
    <span class="n">Object</span> <span class="p">(</span><span class="k">const</span> <span class="n">Object</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* 적절한 복사 생성자 */</span> <span class="p">}</span>
    <span class="n">Object</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Object</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* 신통한 대입 연산자 */</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>그리고 저 객체를 다음과 같이 사용한다고 해보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">objects</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">objects</span><span class="p">.</span><span class="n">push_back</span> <span class="p">(</span><span class="n">objectFactory</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
</code></pre></div>
<p>무엇이 문제일까?<br>
복사 생성자와 대입 연산자가 적절하게 잘 구현되어있다고 하자. 그러면 sallow copy 문제는 당연히 아니다.</p>

<p>문제는 <code>vector</code> 자체가 <code>Object</code>로 구현되어 있기 때문에 내부에 <code>Object</code>에 대한 배열을 갖고 있을 것이며, <code>push_back</code>을 수행할 때마다 내부의 배열 공간이 할당되면서 <code>Object</code>의 생성자에서 무시무시한 작업을 수행할 것이며, 수행된 이후에 대입 연산자를 통해 Object 객체가 복사될 것이다.
(물론 <code>vector</code>의 <code>push_back</code>은 넣을 때마다 늘어나지는 않고, 2배인가 √2배인가로 늘어났던 것 같다)</p>

<p>또한 저 <code>vector</code>가 소멸될 때 내부 <code>Object</code>배열의 소멸자가 단체로 호출된다면 ㅎㄷㄷ</p>

<p>가끔 이런 코드를 작성하는 사람도 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">while</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">objects</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">objectManager</span><span class="p">.</span><span class="n">flush</span> <span class="p">(</span><span class="n">objects</span><span class="p">))</span>
        <span class="n">std</span><span class="o">::</span><span class="n">for_each</span> <span class="p">(</span><span class="n">objects</span><span class="p">.</span><span class="n">begin</span> <span class="p">(),</span> <span class="n">objects</span><span class="p">.</span><span class="n">end</span> <span class="p">(),</span> <span class="n">ObjectFunctor</span> <span class="p">());</span>
<span class="p">}</span>
</code></pre></div>
<p>심지어 이 구문에서는 <code>std::vector</code> 객체를, 그것도 <code>Object</code>라는 무시무시한 객체에 대한 <code>vector</code> 객체를 매 { } 마다 생성, 소멸을 반복한다. 즉 while 의 { 에서 vector 의 생성자가 호출되고, } 에서 <code>vector</code> 의 소멸자가 호출되는 것이다.</p>

<p>즉, 위의 코드를 다시 대충 표현해보면,</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">while</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">objects</span><span class="p">;</span>
    <span class="c1">// objects::vector&lt;Object&gt;();  생성자 호출</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">objectManager</span><span class="p">.</span><span class="n">flush</span> <span class="p">(</span><span class="n">objects</span><span class="p">))</span>
        <span class="n">std</span><span class="o">::</span><span class="n">for_each</span> <span class="p">(</span><span class="n">objects</span><span class="p">.</span><span class="n">begin</span> <span class="p">(),</span> <span class="n">objects</span><span class="p">.</span><span class="n">end</span> <span class="p">(),</span> <span class="n">ObjectFunctor</span> <span class="p">());</span>
    <span class="c1">// objects::~vector&lt;Object&gt;();  소멸자 호출</span>
<span class="p">}</span> <span class="c1">// while loop</span>
</code></pre></div>
<p>이게 얼마나 프로그램에 부담이 될지는 자명한 일.<br>
<em>(추후 수정하면 위 내용에는 좀 오해가 있었고, 실제 vector의 생성 시에는 별로 하는 일이 없으므로 <code>vector</code> 생성마다 부담이 되는 건 없다)</em></p>

<h3>goto 이야기</h3>

<p>옛날에는 error 처리를 위해 goto가 추천되던 시절이 있었다. 오해 말자. C 언어 시절이다.<br>
그 이유는 function 내에 탈출 흐름 구문(return)이 너무 많아지면 에러 처리 등이 힘들기 때문에 에러를 처리하기 위해 goto 를 쓴다는 것이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">socket_accept</span> <span class="p">(</span><span class="kt">socket_t</span><span class="o">**</span> <span class="n">server</span><span class="p">,</span> <span class="kt">socket_t</span><span class="o">**</span> <span class="n">client</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="p">(</span><span class="o">*</span><span class="n">server</span> <span class="o">=</span> <span class="n">serversocket_create</span> <span class="p">()))</span> <span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="p">(</span><span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="n">clientsocket_create</span> <span class="p">()))</span> <span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">socket_listen</span> <span class="p">(</span><span class="o">*</span><span class="n">server</span><span class="p">))</span> <span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">socket_accpet</span> <span class="p">(</span><span class="o">*</span><span class="n">server</span><span class="p">,</span> <span class="n">client</span><span class="p">))</span> <span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">socket_handshake</span> <span class="p">(</span><span class="o">*</span><span class="n">client</span><span class="p">))</span> <span class="k">goto</span> <span class="n">error_out</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">error_out:</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="o">*</span><span class="n">client</span><span class="p">)</span> <span class="n">socket_close</span> <span class="p">(</span><span class="o">*</span><span class="n">client</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="o">*</span><span class="n">server</span><span class="p">)</span> <span class="n">socket_close</span> <span class="p">(</span><span class="o">*</span><span class="n">server</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>만약 위의 코드를 에러 확인 후 자원 해제 및 에러를 반환하게 했다면, 꽤나 많은 검사와 해제 중복 코드가 생겼을 것이다. 그렇기 때문에 에러 발생 시 할당한 자원을 모두 해제하고 에러 코드를 반환하기 위한 구문을 하단에 모아놓고, 에러 발생 시 그 쪽으로 goto를 시킨다는게 주 발상이었던 것이다.</p>

<p>C++에 와서 저런 문제가 없어졌을까?<br>
없어지지는 않았지만 설계적 접근으로 해결할 수 있다. java 같은 경우는 <del>(많이 욕먹은 이유 중 하나이지만)</del> checked exception을 사용해서 logic 과 exception 을 깔끔하게 분리할 수 있게 해주기도 하였다. <del>(물론 쓰기에 따라 안 깔끔할 수도 있지만)</del></p>

<p>재밌는건, 저러한 코드를 C++에서 작성했다면, 옛날 컴파일러에서 문제가 발생할 여지가 있다는 것이다.
Object 예제로 확인해보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">objects</span><span class="p">;</span>
    <span class="c1">// objects::vector&lt;Object&gt;(); 생성자 호출</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">objectManager</span><span class="p">.</span><span class="n">flush</span> <span class="p">(</span><span class="n">objects</span><span class="p">))</span>
        <span class="n">std</span><span class="o">::</span><span class="n">for_each</span> <span class="p">(</span><span class="n">objects</span><span class="p">.</span><span class="n">begin</span> <span class="p">(),</span> <span class="n">objects</span><span class="p">.</span><span class="n">end</span> <span class="p">(),</span> <span class="n">ObjectFunctor</span> <span class="p">());</span>
    <span class="k">else</span> <span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span> <span class="c1">// flush 에 실패했다면 error out!</span>
    <span class="c1">// objects::~vector&lt;Object&gt;(); 소멸자 호출</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="nl">error_out:</span>
    <span class="c1">// 모종의 에러 처리 작업</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</code></pre></div>
<p>한 눈에 알 수 있다. goto에 의해 객체의 소멸자 호출 구문을 멋지게 뛰어넘어버린다. 만약 Object 생성자에서 동적으로 할당한 메모리를 소멸자에서 해제하는 코드가 있다면, goto에 의해 메모리가 줄줄 새게 된다는 것이다.</p>

<p>이러한 문제가 가장 심하게 발생했던 곳은 SEH (structured exception handler) 이다. 객체를 가지고 어떤 일을 수행하다가 예외가 발생하면? try catch 구문을 만날 때까지 stack 이 주욱 감겨(rewinding) 올라가는데 이 과정에서 객체의 소멸자를 안 불렀다는 &quot;이야기&quot;가 있다. 물론 나는 당해본 적이 없어서 모르겠지만 -_-</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="p">{</span>
    <span class="n">Object</span> <span class="n">object</span><span class="p">;</span>
    <span class="c1">// object::Object(); Object의 생성자는 호출이 된다.</span>
    <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;memory leak!&quot;</span><span class="p">);</span> <span class="c1">// Stack은 감아주지만 소멸자는 호출이 안된다.</span>
    <span class="c1">// object::~Object(); 소멸자는 누가 불러주나?</span>
<span class="p">}</span>
</code></pre></div>
<p>그렇다면 이걸 해결하기 위한 방법으로는 어떤 것이 있을까? 재미있게도, <code>do, while(0)</code> 문으로 해결이 된다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">do</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">objects</span><span class="p">;</span>
    <span class="c1">// objects::vector&lt;Object&gt;(); 생성자 호출</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">objectManager</span><span class="p">.</span><span class="n">flush</span> <span class="p">(</span><span class="n">objects</span><span class="p">))</span>
        <span class="n">std</span><span class="o">::</span><span class="n">for_each</span> <span class="p">(</span><span class="n">objects</span><span class="p">.</span><span class="n">begin</span> <span class="p">(),</span> <span class="n">objects</span><span class="p">.</span><span class="n">end</span> <span class="p">(),</span> <span class="n">ObjectFunctor</span> <span class="p">());</span>
    <span class="k">else</span> <span class="k">break</span><span class="p">;</span> <span class="c1">// flush 에 실패했다면 에러 처리를 하자</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="c1">// objects::~vector&lt;Object&gt;(); 소멸자 호출</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">// 모종의 에러 처리 작업</span>
<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</code></pre></div>
<p><code>do while(0)</code> 는 어차피 한 번 실행되고 종료되는 구문이다. 다만 scope 만 하나 만들어 줄 수 있으며, 그냥 { } 보다 좋은건 <code>while (0)</code> 뒤에 ; 이 붙을 수 있기 때문에 과거 C에서 매크로 함수로 많이 썼던 방법이었다.</p>

<p>하지만 더 좋은 것은 <code>break</code> 구문이 먹는다는 것이고, <code>break</code> 구문은 <code>do while</code>의 scope를 벗어나는 지점으로 이동하기 때문에 objects 의 소멸자가 호출될 수 있다는 것이다.</p>

<p>위의 코드를 보면 정상 경로에서 } 가 닫히기 직전인 objects의 소멸자 호출이 return보다 나중에 되어서 해제가 안되는 것 아니냐고 할 수 있겠지만, 옛날 컴파일러는 다행히 그정도로 멍청하지 않아서 소멸자를 불러주고 return을 수행해준다. 고로 모두 행복하다.</p>

<p>재미있는 것은, <em>visual studio 2010으로 goto로 탈출 했을 경우 객체의 소멸자가 불리지 않는가!</em> 에 대해 실험을 해봤는데, 이 신통한 컴파일러가 goto 구문 앞에다가 소멸자를 부르는 코드를 추가해놨다-_-</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp">    <span class="p">{</span>
        <span class="n">Object</span> <span class="n">object</span> <span class="p">(</span><span class="n">rand</span><span class="p">());</span>
        <span class="n">object</span><span class="p">.</span><span class="n">PrintStatus</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">object</span><span class="p">.</span><span class="n">GetStatus</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// object::~object();</span>
            <span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">object</span><span class="p">.</span><span class="n">OnComplete</span><span class="p">();</span>
        <span class="c1">// object::~object();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">error_out:</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</code></pre></div>
<p>뭐, 어쨌든 코드의 흐름이 이리 뛰고 저리 뛰고를 자주 하면 짜기도, 읽기도, 고치기도 힘들어진다. 그럼 결국 오묘한 버그가 탄생하고 야근을 하게 되겠지!</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">메시지 enum에 따른 message 콜백 함수 자동생성</h1>
				<p class="page-date">19 Nov 2013</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
					<code class="tag">message</code>
						
						
						
						
				</p>
				<div class="content"><p>일단 message에 대한 기본 type과 각 message을 구분하기 위한 enum이 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="kt">message_base_t</span> <span class="p">{};</span>

<span class="k">enum</span> <span class="n">message_enum</span> <span class="p">{</span>
    <span class="n">message1</span><span class="p">,</span>
    <span class="n">message2</span><span class="p">,</span>
    <span class="n">message3</span><span class="p">,</span>
    <span class="n">message_count</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div>
<p>message과 enum 값을 쉽게 연결하기 위해 중간 층을 도입한다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">code</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="kt">message_enum_t</span> <span class="o">:</span> <span class="k">public</span> <span class="kt">message_base_t</span> <span class="p">{</span>
    <span class="k">enum</span> <span class="p">{</span>
        <span class="n">enum_value</span> <span class="o">=</span> <span class="n">code</span>
    <span class="p">};</span>
<span class="p">};</span>
</code></pre></div>
<p>이제 message을 만든다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="n">message_struct_1</span> <span class="o">:</span> <span class="k">public</span> <span class="kt">message_enum_t</span><span class="o">&lt;</span><span class="n">message1</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="n">message_struct_2</span> <span class="o">:</span> <span class="k">public</span> <span class="kt">message_enum_t</span><span class="o">&lt;</span><span class="n">message2</span><span class="o">&gt;</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="n">message_struct_3</span> <span class="o">:</span> <span class="k">public</span> <span class="kt">message_enum_t</span><span class="o">&lt;</span><span class="n">message3</span><span class="o">&gt;</span> <span class="p">{};</span>
</code></pre></div>
<p>기본적인 handler는 다음과 같이 단순하게 정의할 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="kt">base_handler_t</span><span class="p">)(</span><span class="k">const</span> <span class="kt">message_base_t</span><span class="o">&amp;</span><span class="p">);</span>
</code></pre></div>
<p>dispatch를 위해 handler에 대한 table을 하나 만들어둔다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">base_handler_t</span><span class="p">,</span> <span class="n">message_count</span><span class="o">&gt;</span> <span class="kt">handler_table_t</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">handler_table_t</span> <span class="kt">_handler_table_t</span><span class="p">;</span>
</code></pre></div>
<p>일단 등록된 handler가 없어도 서버 동작에 문제가 없도록 하기 위해 빈 handler로 초기화를 해준다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">static</span> <span class="kt">void</span> <span class="nf">empty_handler</span><span class="p">(</span><span class="k">const</span> <span class="kt">message_base_t</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="k">struct</span> <span class="kt">handler_init_t</span> <span class="p">{</span>
    <span class="kt">handler_init_t</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">message_count</span><span class="p">;</span> <span class="o">++</span><span class="n">index</span><span class="p">)</span>
            <span class="kt">_handler_table_t</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">empty_handler</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="n">_init</span><span class="p">;</span>
</code></pre></div>
<p>각 handler를 쉽게 등록하기 위한 register를 만든다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="kt">handler_register_t</span> <span class="p">{</span>
    <span class="kt">handler_register_t</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">base_handler_t</span> <span class="n">handler</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">_handler_table_t</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">handler</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>handler의 귀찮은 함수 선언, casting, register 등록 부분의 코드를 생성해줄 macro를 정의한다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#define HANDLER(messageName) \</span>
<span class="cp">    static void handler_##messageName(const messageName&amp; msg); \</span>
<span class="cp">    static void _base_##messageName##_handler(const message_base_t&amp; msg) { \</span>
<span class="cp">        handler_##messageName(static_cast&lt;const messageName&amp;&gt;(msg)); \</span>
<span class="cp">    } \</span>
<span class="cp">    static handler_register_t _register_##messageName( \</span>
<span class="cp">        messageName::enum_value, _base_##messageName##_handler); \</span>
<span class="cp">    static void handler_##messageName(const messageName&amp; msg)</span>
</code></pre></div>
<p>위 macro를 사용해서 handler를 구현한다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">HANDLER</span><span class="p">(</span><span class="n">message_struct_1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="n">msg</span><span class="p">).</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>dispatch를 구현한다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_msgTy</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">dispatch_message</span><span class="p">(</span><span class="k">const</span> <span class="n">_msgTy</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">_handler_table_t</span><span class="p">[</span><span class="n">_msgTy</span><span class="o">::</span><span class="n">enum_value</span><span class="p">](</span><span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>모든 구현이 끝났으니 사용하면 된다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">dispatch_message</span><span class="p">(</span><span class="n">message_struct_1</span><span class="p">());</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">멤버 데이터 포인터를 사용하여 연산식 묶어내기 1</h1>
				<p class="page-date">01 Oct 2012</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
					<code class="tag">refactor</code>
						
						
						
						
				</p>
				<div class="content"><p>게임 내 스탯 시스템을 구현한다고 해보자. 그 스탯들은 여러 상황에서 버프에 의해 값이 변경될 수 있기 때문에</p>

<ul>
<li><strong>스탯을 저장하는 자료구조</strong>와</li>
<li>그 <strong>스탯을 변경하기 위한 버프 종류 enum</strong>과,</li>
<li>각 버프 종류 enum에 따라 스탯을 어떻게 변경할지에 대한 <strong>연산식</strong>에 대해서</li>
</ul>

<p>코딩을 해주어야 한다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">enum</span> <span class="n">BuffType</span> <span class="p">{</span>
    <span class="n">BUFF_HP</span><span class="p">,</span>
    <span class="n">BUFF_MP</span><span class="p">,</span>
    <span class="n">BUFF_ATTACK</span><span class="p">,</span>
    <span class="n">BUFF_DEFENCE</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">Stat</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">hp</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">mp</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">attack</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">defence</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>일단 각 스탯에 어떤 값을 어떻게 계산하면 되는지에 대해서는 다음의 3가지로 추상화를 했다고 치자. <strong>SET, ADD, RATE</strong> 즉, 지정, 더하기, 곱하기이다.</p>

<p>그럼 대충 다음과 같은 코드가 나온다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">switch</span> <span class="p">(</span><span class="n">buffType</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="n">BUFF_HP</span>:
    <span class="k">switch</span> <span class="p">(</span><span class="n">buffMethod</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">SET</span>: <span class="n">stat</span><span class="p">.</span><span class="n">hp</span> <span class="o">=</span> <span class="n">buffValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">ADD</span>: <span class="n">stat</span><span class="p">.</span><span class="n">hp</span> <span class="o">+=</span> <span class="n">buffValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">RATE</span>: <span class="n">stat</span><span class="p">.</span><span class="n">hp</span> <span class="o">*=</span> <span class="n">buffValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">break</span><span class="p">;</span>
</code></pre></div>
<p><code>BUFF_MP</code>, <code>BUFF_ATTACK</code>, <code>BUFF_DEFENCE</code> 등 버프 종류가 바뀌어도 연산하는 식은 똑같다. 다만 stat 구조체 내의 어떤 변수를 접근하는지만 바뀌는 것이다.</p>

<p>버프의 종류가 한 100가지 된다고 치자. 그러면 100개의 동일한 case pattern을 다 코딩해주어야 하나? 그리고 SET, ADD, RATE 말고 <strong>EXPONENT</strong>라는 방법이 추가되었다고 해보자. <strong>맙소사!</strong></p>

<p>위 상황을 해결할 수 있는 가장 간단한 방법은 <code>BuffType</code> enum에 대응되는 <code>Stat</code> 자료구조의 멤버 데이터 포인터를 묶어주는 것이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="kt">float</span> <span class="n">Stat</span><span class="o">::*</span><span class="n">StatDataPtr</span><span class="p">;</span>
<span class="n">StatDataPtr</span> <span class="n">statDataPtr</span><span class="p">[</span><span class="n">BUFF_MAX</span><span class="p">];</span>

<span class="n">statDataPtr</span><span class="p">[</span><span class="n">BUFF_HP</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Stat</span><span class="o">::</span><span class="n">hp</span><span class="p">;</span>
<span class="n">statDataPtr</span><span class="p">[</span><span class="n">BUFF_MP</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Stat</span><span class="o">::</span><span class="n">mp</span><span class="p">;</span>
</code></pre></div>
<p>각 Buff의 종류별로 어떤 멤버를 접근할지 정보를 구성했으니, 아까의 코드가 한결 간편해진다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">StatDataPtr</span> <span class="n">dataPtr</span> <span class="o">=</span> <span class="n">statDataPtr</span><span class="p">[</span><span class="n">buffType</span><span class="p">];</span>
<span class="k">switch</span> <span class="p">(</span><span class="n">buffMethod</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="n">SET</span>: <span class="n">stat</span><span class="p">.</span><span class="o">*</span><span class="n">dataPtr</span> <span class="o">=</span> <span class="n">buffValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
<span class="k">case</span> <span class="n">ADD</span>: <span class="n">stat</span><span class="p">.</span><span class="o">*</span><span class="n">dataPtr</span> <span class="o">+=</span> <span class="n">buffValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
<span class="k">case</span> <span class="n">RATE</span>: <span class="n">stat</span><span class="p">.</span><span class="o">*</span><span class="n">dataPtr</span> <span class="o">*=</span> <span class="n">buffValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</code></pre></div>
<p>이제 <code>BuffType</code>이 추가될 때마다 해당 <code>BuffType</code>에 대응되는 <code>Stat</code>의 데이터 포인터를 배열에 추가해주기만 하면 된다. 그리고 Method가 추가되어도, 그러한 연산을 수행하는 코드가 한 곳에만 존재하기 때문에 Method를 확장하기도 좋다.</p>

<p>하지만 아무래도 enum을 정의하고 나서 데이터 포인터와의 연결을 위해 다시 한 번 enum을 언급하는 것은 귀찮다. 이를 해결하기 위해서 X-Macro pattern를 써보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="c1">// buff_type.inl</span>
<span class="n">BUFF_ENUM</span><span class="p">(</span><span class="n">BUFF_HP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Stat</span><span class="o">::</span><span class="n">hp</span><span class="p">);</span>
<span class="n">BUFF_ENUM</span><span class="p">(</span><span class="n">BUFF_MP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Stat</span><span class="o">::</span><span class="n">mp</span><span class="p">);</span>
</code></pre></div>
<p>위와 같이 <code>BUFF_ENUM</code>이라는 매크로를 사용하여 enum 정의와 데이터 포인터 연결을 같이 할 수 있도록 묶어주고,</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="c1">// buff_type.h</span>
<span class="cp">#define BUFF_ENUM(name, ptr) name,</span>
<span class="k">enum</span> <span class="n">BuffType</span> <span class="p">{</span>
<span class="cp">#include &quot;buff_type.inl&quot;</span>
<span class="p">};</span>
<span class="cp">#undef BUFF_ENUM</span>
</code></pre></div>
<p>header 파일과 cpp 파일에 각기 다른 macro 함수를 적용하여 적절한 코드를 생성하도록 한다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="c1">// buff_bind.cpp</span>
<span class="cp">#define BUFF_ENUM(name, ptr) statDataPtr[buff] = ptr;</span>
<span class="cp">#include &quot;buff_type.inl&quot;</span>
<span class="cp">#undef BUFF_ENUM</span>
</code></pre></div>
<p>이제 새로운 버프가 추가되면, buff_type.inl 파일 하나에만 <code>BUFF_ENUM</code>으로 추가해두면, buff_type.h와 buff_bind.cpp 양 쪽에 코드가 적절히 치환되어 적절하게 추가될 것이다.</p>

<p>물론 코드가 모두 이렇게 깔끔하게 묶어낼 수 있는 것은 아니지만 만약 대부분의 코드를 이렇게 묶어낼 수 있다면, 이는 충분히 시도할만한 가치가 있는 방법이라고 생각된다.</p>

<p>편의상 <code>Stat</code> 구조체의 모든 변수가 float임을 가정했는데, 만약 그렇지 않다면 type erasure를 써야 하는데 이건 본 글에서 다루는 내용보다 더 큰 내용이니 다음에 다루도록 하겠다.</p>

<p>다음 글에서는 어제 <a href="https://twitter.com/summerlight00" title="summerlight00">summerlight</a>님께 배운 정보를 바탕으로 <code>Stat</code> 구조체 내부에 배열이 있을 경우에 어떻게 처리할 수 있을지에 대해서 알아보겠다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">멤버 데이터 포인터를 사용하여 연산식 묶어내기 2</h1>
				<p class="page-date">03 Oct 2012</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
					<code class="tag">refactor</code>
						
						
						
						
				</p>
				<div class="content"><p>이번 글에서는 <code>Stat</code> 자료구조 내에 배열이 있을 때 이를 어떻게 처리할지에 대해서 알아보도록 하자.</p>

<p><code>Stat</code> 코드를 작성하다보니, 이동 속도에 관해서는 각각의 변수를 따로 두는 것 보다, 배열 하나로 처리하는 것이 더 낫다는 것을 깨닫게 되었다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">enum</span> <span class="n">MovingStatType</span> <span class="p">{</span>
    <span class="n">MST_WALK</span><span class="p">,</span>
    <span class="n">MST_RUN</span><span class="p">,</span>
    <span class="n">MST_RIDE</span><span class="p">,</span>
    <span class="n">MST_MAX</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">Stat</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">hp</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">movingSpeed</span><span class="p">[</span><span class="n">MST_MAX</span><span class="p">];</span>
</code></pre></div>
<p>배열로 묶어서 <code>movingSpeed</code> 관련 코드가 개선된 것까지는 좋았는데 <code>hp</code>와 <code>movingSpeed</code>는 type이 다르기 때문에 이전 글에서의 방법을 더 이상 사용할 수 없게 되었다. 둘의 type을 비교해보면 아래와 같다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="kt">float</span> <span class="n">Stat</span><span class="o">::*</span><span class="n">DataPtr</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">float</span> <span class="p">(</span><span class="n">Stat</span><span class="o">::*</span><span class="n">ArrayPtr</span><span class="p">)[</span><span class="mi">3</span><span class="p">];</span>
</code></pre></div>
<p>어쨌든 두 타입이 완전히 달라졌기 때문에, 이를 일치시키지 못한다면 또 다시 switch-case의 지옥을 맛보게 될 것이다. 멤버 데이터 포인터 수준에서는 이를 해결할 수 없기 때문에 <strong>멤버 함수 포인터</strong>를 사용하여 문제를 해결 할 것이다.</p>

<p>목표는 그냥 멤버 변수와 배열 멤버 변수의 <strong>접근 interface를 통일시키는 것</strong>이다. 멤버 함수 포인터를 사용할 것이니 함수의 signature는 같아야 한다는 것이다.</p>

<p>위 <code>Stat</code> 구조체에서는 다음과 같이 생각해볼 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="n">Stat</span> <span class="p">{</span>
    <span class="kt">float</span><span class="o">&amp;</span> <span class="n">Hp</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">hp</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">float</span><span class="o">&amp;</span> <span class="n">WalkSpeed</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">movingSpeed</span><span class="p">[</span><span class="n">MST_WALK</span><span class="p">];</span> <span class="p">}</span>
    <span class="kt">float</span><span class="o">&amp;</span> <span class="n">RunSpeed</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">movingSpeed</span><span class="p">[</span><span class="n">MST_RUN</span><span class="p">];</span> <span class="p">}</span>
    <span class="kt">float</span><span class="o">&amp;</span> <span class="n">RideSpeed</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">movingSpeed</span><span class="p">[</span><span class="n">MST_RIDE</span><span class="p">];</span> <span class="p">}</span>
</code></pre></div>
<p>이제 위 함수들은 다음의 멤버 함수 포인터로 지칭이 가능하다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="p">(</span><span class="n">Stat</span><span class="o">::*</span><span class="n">Accessor</span><span class="p">)();</span>
</code></pre></div>
<p>하지만 모든 멤버 변수에 대해서 저렇게 함수를 만들어주는 것은 여간 고역이 아니다. 이런 일을 사람이 하는 것은 도의에 어긋나니, 컴파일러가 이 일을 대신하도록 해보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="n">Stat</span> <span class="p">{</span>
    <span class="kt">float</span><span class="o">&amp;</span> <span class="n">Hp</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">hp</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">_Index</span><span class="o">&gt;</span>
    <span class="kt">float</span><span class="o">&amp;</span> <span class="n">MovingSpeed</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">movingSpeed</span><span class="p">[</span><span class="n">_Index</span><span class="p">];</span> <span class="p">}</span>
</code></pre></div>
<p>template 함수를 사용해서 배열의 인자를 template으로 넘겼다. 저 <code>_Index</code> 값으로 <code>MST_WALK</code> 등의 값을 넘기면 그에 해당하는 <code>MovingSpeed&lt;&gt;</code> 함수를 컴파일러가 알아서 생성해줄 것이다.</p>

<p><strong>이렇게 생성된 template 함수들의 interface도 위에서 정의한 Accessor에 부합된다. 이것이 핵심 아이디어이다.</strong></p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">Accessor</span> <span class="n">acc1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Stat</span><span class="o">::</span><span class="n">MovingSpeed</span><span class="o">&lt;</span><span class="n">MST_WALK</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">Accessor</span> <span class="n">acc2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Stat</span><span class="o">::</span><span class="n">MovingSpeed</span><span class="o">&lt;</span><span class="n">MST_RUN</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>
<p>Stat의 각 멤버에 대해 노출 함수를 만들어주는 것은 지겨운 일이다. 이 함수들 역시 template으로 묶어보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="n">Stat</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="kt">float</span> <span class="n">Stat</span><span class="o">::*</span><span class="n">_DataPtr</span><span class="o">&gt;</span>
    <span class="kt">float</span><span class="o">&amp;</span> <span class="n">Access</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;*</span><span class="n">_DataPtr</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div>
<p>Access 함수는 멤버 데이터 포인터를 template 인자로 받는다. 이 역시 위에서 정의한 Accessor 타입에 부합된다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">Accessor</span> <span class="n">acc3</span> <span class="o">=</span> <span class="n">Stat</span><span class="o">::</span><span class="n">Access</span><span class="o">&lt;&amp;</span><span class="n">Stat</span><span class="o">::</span><span class="n">hp</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>
<p>배열의 멤버 데이터 포인터를 template 인자로 받으려면 약간 까다로운데, 그 이유는 배열의 멤버 데이터 포인터의 타입을 명시할 때에는 그 배열의 크기가 필요하기 때문이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="n">Stat</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">_Size</span><span class="p">,</span> <span class="kt">float</span> <span class="p">(</span><span class="n">Stat</span><span class="o">::*</span><span class="n">_ArrayPtr</span><span class="p">)[</span><span class="n">_Size</span><span class="p">],</span> <span class="kt">int</span> <span class="n">_Index</span><span class="o">&gt;</span>
    <span class="kt">float</span><span class="o">&amp;</span> <span class="n">Access</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;*</span><span class="n">_ArrayPtr</span><span class="p">)[</span><span class="n">_Index</span><span class="p">];</span> <span class="p">}</span>
</code></pre></div>
<p>배열 타입 명시를 위한 배열의 크기, 멤버 데이터 포인터 값, 그리고 배열 내의 index. 이렇게 3개의 template 인자를 받는다. 이 함수를 사용하여 acc1, acc2를 다시 정의해 본다면 다음과 같다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">Accessor</span> <span class="n">acc1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Stat</span><span class="o">::</span><span class="n">Access</span><span class="o">&lt;</span><span class="n">MST_MAX</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Stat</span><span class="o">::</span><span class="n">movingSpeed</span><span class="p">,</span> <span class="n">MST_WALK</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">Accessor</span> <span class="n">acc2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Stat</span><span class="o">::</span><span class="n">Access</span><span class="o">&lt;</span><span class="n">MST_MAX</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Stat</span><span class="o">::</span><span class="n">movingSpeed</span><span class="p">,</span> <span class="n">MST_RUN</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>
<p>이제 일반적인 <strong>Access</strong>라는 멤버 함수를 사용하여 모든 멤버를 접근할 수 있게 되었다. 하지만 이미 선언할 때 명시해준 배열의 크기를 또 적어주어야 하는 것은 마음에 들지 않는다. 이를 고쳐보자.</p>

<p>배열의 크기를 구하기 위해 간단한 메타 템플릿 함수를 작성해보자. 일단 일반적인 interface를 선언하고,</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">countof</span><span class="p">;</span>
</code></pre></div>
<p>그리고 배열의 크기를 알아내기 위한 특수화된 <em>specialization</em> 메타 템플릿 함수를 작성한다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Ty</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_Class</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">_Size</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">countof</span><span class="o">&lt;</span><span class="n">_Ty</span> <span class="p">(</span><span class="n">_Class</span><span class="o">::*</span><span class="p">)[</span><span class="n">_Size</span><span class="p">]</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">enum</span> <span class="p">{</span> <span class="n">value</span> <span class="o">=</span> <span class="n">_Size</span> <span class="p">};</span>
<span class="p">};</span>
</code></pre></div>
<p><code>countof</code>의 타입 argument가 <code>_Ty (_Class::*)[_Size]</code> 형태이면 그 <code>_Size</code>를 value로 갖는 메타 템플릿 함수이다. <code>decltype</code> 키워드를 사용하여 멤버 데이터 포인터의 타입을 얻을 수 있으므로, 다음과 같이 멤버 데이터 포인터가 가리키는 배열의 크기를 얻을 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">countof</span><span class="o">&lt;</span><span class="n">decltype</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Stat</span><span class="o">::</span><span class="n">movingSpeed</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">value</span>
</code></pre></div>
<p>이제 위 배열 멤버에 대한 접근을 다음과 같이 표현할 수 있게 되었다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">Accessor</span> <span class="n">acc1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Stat</span><span class="o">::</span><span class="n">Access</span><span class="o">&lt;</span><span class="n">countof</span><span class="o">&lt;</span><span class="n">decltype</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Stat</span><span class="o">::</span><span class="n">movingSpeed</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">Stat</span><span class="o">::</span><span class="n">movingSpeed</span><span class="p">,</span> <span class="n">MST_WALK</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>
<p>모든 준비가 갖추어졌다. 멤버의 데이터 타입이 배열이든, 그렇지 않든 <code>float&amp; (Stat::*)()</code> signature를 사용하여 값을 얻을 수 있게 되었다.</p>

<p>이제 이전 글에서 했던 방법처럼 코드를 정리하면 된다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="p">(</span><span class="n">Stat</span><span class="o">::*</span><span class="n">StatAccessor</span><span class="p">)();</span>
<span class="n">StatAccessor</span> <span class="n">statAccessorTable</span><span class="p">[</span><span class="n">BUFF_MAX</span><span class="p">];</span>

<span class="n">statAccessorTable</span><span class="p">[</span><span class="n">BUFF_HP</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Stat</span><span class="o">::</span><span class="n">Access</span><span class="o">&lt;&amp;</span><span class="n">Stat</span><span class="o">::</span><span class="n">hp</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">statAccessorTable</span><span class="p">[</span><span class="n">BUFF_WALK_SPEED</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Stat</span><span class="o">::</span><span class="n">Access</span><span class="o">&lt;</span><span class="n">countof</span><span class="o">&lt;</span><span class="n">decltype</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Stat</span><span class="o">::</span><span class="n">movingSpeed</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">Stat</span><span class="o">::</span><span class="n">movingSpeed</span><span class="p">,</span> <span class="n">MST_WALK</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>
<p><code>statAccessorTable</code>을 사용하여 switch-case 구문도 깔끔하게 정리할 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">StatAccessor</span> <span class="n">accessor</span> <span class="o">=</span> <span class="n">statAccessorTable</span><span class="p">[</span><span class="n">buffType</span><span class="p">];</span>
<span class="k">switch</span> <span class="p">(</span><span class="n">buffMethod</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="n">SET</span>: <span class="p">(</span><span class="n">stat</span><span class="p">.</span><span class="o">*</span><span class="n">accessor</span><span class="p">)()</span> <span class="o">=</span> <span class="n">buffValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
<span class="k">case</span> <span class="n">ADD</span>: <span class="p">(</span><span class="n">stat</span><span class="p">.</span><span class="o">*</span><span class="n">accessor</span><span class="p">)()</span> <span class="o">+=</span> <span class="n">buffValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
<span class="k">case</span> <span class="n">RATE</span>: <span class="p">(</span><span class="n">stat</span><span class="p">.</span><span class="o">*</span><span class="n">accessor</span><span class="p">)()</span> <span class="o">*=</span> <span class="n">buffValue</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</code></pre></div>
<p><code>AccessorTable</code>을 등록할 때, 아무래도 배열 타입을 등록하는데 코드가 쓸데없이 길어진다. 이는 매크로를 사용하여 깔끔하게 정리할 수 있겠다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="c1">// buff_type.inl</span>
<span class="n">BUFF_ENUM</span><span class="p">(</span><span class="n">BUFF_HP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Stat</span><span class="o">::</span><span class="n">hp</span><span class="p">)</span>
<span class="n">BUFF_ENUM_A</span><span class="p">(</span><span class="n">BUFF_WALK_SPEED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Stat</span><span class="o">::</span><span class="n">movingSpeed</span><span class="p">,</span> <span class="n">MST_WALK</span><span class="p">)</span>
</code></pre></div>
<p>역시 적절한 macro 함수 교체를 통해 적절한 코드가 생성되도록 한다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="c1">// buff_bind.cpp</span>
<span class="cp">#define BUFF_ENUM(name, ptr) statAccessorTable[name] = &amp;Stat::Access&lt;ptr&gt;;</span>
<span class="cp">#define BUFF_ENUM_A(name, ptr, idx) \</span>
<span class="cp">    statAccessorTable[name] = &amp;Stat::Access&lt;countof&lt;decltype(ptr)&gt;::value, ptr, idx&gt;;</span>
<span class="cp">#include &quot;buff_type.inl&quot;</span>
<span class="cp">#undef BUFF_ENUM_A</span>
<span class="cp">#undef BUFF_ENUM</span>
</code></pre></div>
<p>본 글에서는 완전히 일치하지는 않지만 어느 정도 타입이 비슷할 때, 멤버 데이터 포인터가 아닌 <strong>template 인자를 활용한 멤버 함수로 signature를 맞추어 반복되는 코드의 양을 줄이는 방법</strong>에 대해 알아보았다.</p>

<p>지난 번 글에서도 언급했지만, 이것이 가능했던 이유는 각 멤버들이 모두 float이었기 때문이다. 다음 글에서는 type erasure를 사용하여 좀 더 일반적인 (하지만 성능에서는 손해를 보는) 방법에 대해 알아보도록 하겠다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">멤버 데이터 포인터를 사용하여 연산식 묶어내기 3</h1>
				<p class="page-date">07 Oct 2012</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
					<code class="tag">refactor</code>
						
						
						
						
				</p>
				<div class="content"><p>지난 두 글에서 사용한 전략은, 멤버에 접근하기 위한 방법을 동일한 인터페이스로 맞춰서 (첫 번째 글에서는 멤버 데이터 포인터, 두 번째 글에서는 멤버 함수 포인터) <code>BuffType</code>과 그 인터페이스를 대응시키는 방법을 사용하였다.</p>

<p>동일한 인터페이스를 사용하기 위해서 그들을 하나의 동일한 타입으로 지칭하는 방법을 사용하였고, 그렇기 때문에 서로 다른 type, int 변수와 float 변수, 그리고 그에 대한 배열 변수가 있을 때에는 사용할 수 없는 방법이었다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="n">Stat</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">hp</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">attack</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="kt">float</span> <span class="n">Stat</span><span class="o">::*</span><span class="n">DataPtr</span><span class="p">;</span>
<span class="n">DataPtr</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Stat</span><span class="o">::</span><span class="n">hp</span><span class="p">;</span> <span class="c1">// Error!</span>
</code></pre></div>
<p>이번 글에서는 형식 삭제(<a href="http://en.wikipedia.org/wiki/Type_erasure">type erasure</a>)를 사용하여 보다 다양한 type을 지원하면서, 확장 가능한 방법에 대해 알아보도록 하겠다.</p>

<p>형식 삭제라고 하면 뭔가 어려워 보이지만, 그 결과물을 보면 굉장히 친숙하다. C++에서 형식 삭제를 하는 방법은 가상 함수를 통한 다형성을 사용하는 것인데, 예를 들면 다음과 같다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="n">ValueHolder</span> <span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">float</span> <span class="n">GetValue</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">SetValue</span><span class="p">(</span><span class="kt">float</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">struct</span> <span class="n">IntValueHolder</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ValueHolder</span> <span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">float</span> <span class="n">GetValue</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">);</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">SetValue</span><span class="p">(</span><span class="kt">float</span> <span class="n">_value</span><span class="p">)</span> <span class="p">{</span> <span class="n">value</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_value</span><span class="p">);</span> <span class="p">}</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
</code></pre></div>
<p><code>ValueHolder</code>는 concrete class가 어떤 값을 들고 있던, <code>GetValue()</code> 함수를 통해 float type의 변수를 반환하도록 하거나, <code>SetValue()</code> 함수를 통해 float 값을 받아서 자신의 값을 변경하도록 할 수 있는 interface이다.</p>

<p>이전 글과 이어서 생각해 볼때, 위와 같은 방법을 사용하여 int, float, 혹은 그에 대한 배열 멤버 변수들을 Get, Set 할 수 있도록 구조를 잡으면 이 문제를 해결할 수 있다는 이야기이다.</p>

<p>그런데 왜 형식 삭제라는 골치 아픈 용어를 사용할까?<br>
char, short, int, long, float, double에 대한 모든 type에 대해 ValueHolder concrete class를 작성하는 것은 매우 귀찮은 일이다. 그렇다면 template을 사용하여 그 귀찮음을 해결해보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Ty</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">ValueHolderImpl</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ValueHolder</span> <span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">float</span> <span class="n">GetValue</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">);</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">SetValue</span><span class="p">(</span><span class="kt">float</span> <span class="n">_value</span><span class="p">)</span> <span class="p">{</span> <span class="n">value</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">_Ty</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_value</span><span class="p">);</span> <span class="p">}</span>
    <span class="n">_Ty</span> <span class="n">value</span><span class="p">;</span>
</code></pre></div>
<p>이제 <code>ValueHolderImpl&lt;&gt;</code> class를 사용하면 float type과 <code>static_cast</code> 호환이 되는 모든 형식에 대해 <code>ValueHolder</code>를 만들 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">ValueHolder</span><span class="o">*</span> <span class="n">intHolder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ValueHolderImpl</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">ValueHolder</span><span class="o">*</span> <span class="n">floatHolder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ValueHolderImpl</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>
<p>concrete class들은 <code>ValueHolderImpl&lt;int&gt;</code>와 같이 type 정보를 가진 채로 명시되지만 <code>ValueHolder</code> interface으로 지칭이 가능하다. 즉, runtime에는 concrete class의 type 정보 없이 그것들을 사용할 수 있게 되는 것이다.</p>

<p>덕분에 서로 다른 type인 <code>ValueHolderImpl&lt;int&gt;</code>, <code>ValueHolderImpl&lt;float&gt;</code>에 대해 <code>ValueHolder</code>라는 공통된 접근을 할 수 있고, compile-time에 존재하던 형식 정보(type information)가 runtime에서 제거되었으므로 이를 형식 삭제라고 하는 것이다.</p>

<p>이제 필요한 이론을 모두 습득하였으니 즐거운 코딩을 해보자. 형식 삭제를 위한 interface를 먼저 설계해보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Class</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">IAccessor</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">float</span> <span class="n">GetValue</span><span class="p">(</span><span class="k">const</span> <span class="n">_Class</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">SetValue</span><span class="p">(</span><span class="n">_Class</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">float</span> <span class="n">value</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>위 <code>ValueHolder</code>처럼 값을 넣고, 빼는 함수를 갖는다. 차이가 있다면, 이 Accessor 들은 구체적인 값을 가지는 것(Holding)이 아니라 멤버 데이터 포인터를 갖고, 특정 class의 instance를 인자로 받아 그 값을 넣고 빼는 구조라는 것이다. 일반적인 설계를 위해, 어떤 class에 대한 Accessor를 만들 것인지를 template parameter로 남겨두었다.</p>

<p>배열이 아닌 type에 대한 Accessor를 보면 이해하기가 쉽겠다. 다음 코드를 보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Class</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_Ty</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">SingleAccessor</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IAccessor</span><span class="o">&lt;</span><span class="n">_Class</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">float</span> <span class="n">GetValue</span><span class="p">(</span><span class="k">const</span> <span class="n">_Class</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="o">*</span><span class="n">dataPtr</span><span class="p">);</span> 
    <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">SetValue</span><span class="p">(</span><span class="n">_Class</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">,</span> <span class="kt">float</span> <span class="n">value</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">obj</span><span class="p">.</span><span class="o">*</span><span class="n">dataPtr</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">_Ty</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">SingleAccessor</span><span class="p">(</span><span class="n">_Ty</span> <span class="n">_Class</span><span class="o">::*</span><span class="n">_dataPtr</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">dataPtr</span><span class="p">(</span><span class="n">_dataPtr</span><span class="p">)</span> <span class="p">{}</span>
<span class="nl">private:</span>
    <span class="n">_Ty</span> <span class="n">_Class</span><span class="o">::*</span><span class="n">dataPtr</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>생성자로 멤버 데이터 포인터를 받는다. 그리고 그 멤버 데이터 포인터가 어떤 type일지는 template parameter로 남겨둔다. 그리고 Get/SetValue 함수에서 object를 받아 자신이 가지고 있는 멤버 데이터 포인터를 사용하여 값을 가져오거나, 지정하는 작업을 수행한다.</p>

<p>이제 이 <code>SingleAccessor</code>를 사용하여 int 변수이든, float 변수이든 멤버 변수의 type에 상관없이 접근할 수 있는 <code>IAccessor</code>를 만들 수 있는 것이다.</p>

<p>멤버 변수의 타입이 배열인 것은 배열에 대한 크기와, 몇 번째 element에 접근할지에 대한 index 값이 같이 필요하다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Class</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_Ty</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">_Size</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">ArrayAccessor</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IAccessor</span><span class="o">&lt;</span><span class="n">_Class</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">float</span> <span class="n">GetValue</span><span class="p">(</span><span class="k">const</span> <span class="n">_Class</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">((</span><span class="n">obj</span><span class="p">.</span><span class="o">*</span><span class="n">arrayPtr</span><span class="p">)[</span><span class="n">index</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">SetValue</span><span class="p">(</span><span class="n">_Class</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">,</span> <span class="kt">float</span> <span class="n">value</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="o">*</span><span class="n">arrayPtr</span><span class="p">)[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">_Ty</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">_Ty</span><span class="p">,</span> <span class="n">_Size</span><span class="o">&gt;</span> <span class="n">_Class</span><span class="o">::*</span><span class="n">ArrayPtrType</span><span class="p">;</span>
    <span class="n">ArrayAccessor</span><span class="p">(</span><span class="n">ArrayPtrType</span> <span class="n">_arrayPtr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_index</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">arrayPtr</span><span class="p">(</span><span class="n">_arrayPtr</span><span class="p">),</span> <span class="n">index</span><span class="p">(</span><span class="n">_index</span><span class="p">)</span> <span class="p">{}</span>
<span class="nl">private:</span>
    <span class="n">ArrayPtrType</span> <span class="n">arrayPtr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p><code>GetValue</code>/<code>SetValue</code> 함수의 구조는 <code>SingleAccessor</code>와 크게 차이가 없다. 배열 타입의 멤버 데이터 포인터 변수와 index를 생성자로 받아서 가지고 있고, <code>GetValue</code>/<code>SetValue</code> 함수가 불리는 시점에 해당 배열의 위치에 접근하여 값을 가져오거나 넣는다.</p>

<p>이제 Accessor들과 enum 값을 연관지어 관리할 관리자를 만들어보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Class</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">AccessorManager</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">IAccessor</span><span class="o">&lt;</span><span class="n">_Class</span><span class="o">&gt;&gt;</span> <span class="n">AccessorImpl</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">AccessorImpl</span><span class="o">&gt;</span> <span class="n">AccessorImplMap</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Class</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_Ty</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">Register</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="n">_Ty</span> <span class="n">_Class</span><span class="o">::*</span><span class="n">dataPtr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">implMap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="k">new</span> <span class="n">SingleAccessor</span><span class="o">&lt;</span><span class="n">_Class</span><span class="p">,</span> <span class="n">_Ty</span><span class="o">&gt;</span><span class="p">(</span><span class="n">dataPtr</span><span class="p">)));</span>
    <span class="p">}</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Class</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_Ty</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">_Size</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">Register</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">_Ty</span><span class="p">,</span> <span class="n">_Size</span><span class="o">&gt;</span> <span class="n">_Class</span><span class="o">::*</span><span class="n">arrayPtr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">implMap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">type</span><span class="p">,</span>
            <span class="k">new</span> <span class="n">ArrayAccessor</span><span class="o">&lt;</span><span class="n">_Class</span><span class="p">,</span> <span class="n">_Ty</span><span class="p">,</span> <span class="n">_Size</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arrayPtr</span><span class="p">,</span> <span class="n">index</span><span class="p">)));</span>
    <span class="p">}</span>
    <span class="n">AccessorImpl</span> <span class="k">operator</span> <span class="p">[]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">implMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="o">!=</span> <span class="n">implMap</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
        <span class="k">return</span> <span class="n">implMap</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>
    <span class="p">}</span>
<span class="nl">private:</span>
    <span class="n">AccessorImplMap</span> <span class="n">implMap</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p><code>AccessorManager</code>는 int(BuffType)와 <code>shared_ptr&lt;IAccessor&gt;</code>의 map을 갖고 이들을 <code>Register</code> 해주거나 enum 값으로 <code>IAccessor</code>를 찾아주는 작업을 한다.</p>

<p>재미있는 것은 <code>Register()</code> 함수들이다. <code>Register()</code> 함수는 인자로 들어오는 값을 통해 template parameter들이 deduce하고, 이렇게 deduce된 template parameter들을 <code>SingleAccessor</code>나 <code>ArrayAccessor</code>의 template parameter로 넘겨준다.</p>

<p>이제 다음과 같이 쓸 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">AccessorManager</span><span class="o">&lt;</span><span class="n">Stat</span><span class="o">&gt;</span> <span class="n">manager</span><span class="p">;</span>
<span class="n">manager</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">BUFF_HP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Stat</span><span class="o">::</span><span class="n">hp</span><span class="p">);</span>
<span class="n">manager</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">BUFF_RUN_SPEED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Stat</span><span class="o">::</span><span class="n">movingSpeed</span><span class="p">,</span> <span class="n">MST_RUN</span><span class="p">);</span>
</code></pre></div>
<p>첫 번째 <code>Register</code> 호출은 <code>SingleAccessor</code>를 생성하는 <code>Register</code> 함수가 호출된다. 그리고 <code>hp</code> 멤버의 type이 적절히 deduce되어 <code>SingleAccessor</code>가 만들어진다.</p>

<p>두 번째 <code>Register</code> 호출은 <code>ArrayAccessor</code>를 생성하는 <code>Register</code> 함수가 호출된다. 그리고 <code>movingSpeed</code> 멤버 type과 배열의 크기가 적절히 deduce되어 <code>ArrayAccessor</code>가 만들어진다. 이 때 index인 <code>MST_RUN</code>이 같이 <code>ArrayAccessor</code>로 전달되어, <code>BUFF_RUN_SPEED</code> 의해서 <code>movingSpeed[MST_RUN]</code>의 값을 제어할 수 있게 되는 것이다.</p>

<p>생각해보니, 이러한 Manager class는 전역으로 하나만 있으면 좋겠다. 따라서 다음과 같이 간단한 singleton을 만들어서 써보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Class</span><span class="o">&gt;</span>
<span class="n">AccessorManager</span><span class="o">&lt;</span><span class="n">_Class</span><span class="o">&gt;&amp;</span> <span class="n">Accessor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">AccessorManager</span><span class="o">&lt;</span><span class="n">_Class</span><span class="o">&gt;</span> <span class="n">instance</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">instance</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>이는 thread-safe하지 않을 수 있는데, <code>AccessorManager</code>에 <code>Register</code> 하는 과정은 처음 프로그램이 초기화될 때 딱 한 번만 수행하면 되는 작업이고, 그 이후에는 전부 <code>operator []</code>로 access만 하면 되므로 thread-safe를 걱정할 필요는 없어 보인다.</p>

<p>이제 지난 글에서 정의한 <code>BUFF_ENUM</code>과 <code>BUFF_ENUM_A</code>를 다음과 같이 정의하여 마무리를 지어보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#define BUFF_ENUM(type, member) Accessor&lt;Stat&gt;().Register(type, member);</span>
<span class="cp">#define BUFF_ENUM_A(type, member, index) Accessor&lt;Stat&gt;().Register(type, member, index);</span>
<span class="cp">#include &quot;BuffType.inl&quot;</span>
<span class="cp">#undef BUFF_ENUM</span>
<span class="cp">#undef BUFF_ENUM_A</span>
</code></pre></div>
<p>BuffType.inl의 내용은 지난 글과 동일하다. 이제 위와 같은 코드가 프로그램이 시작될 때 수행될 수 있도록 전역 구조체 변수의 생성자로 넣어놓는 방법 등을 사용하여 잘 배치해두면, Stat 구조체 내의 변수와 BuffType을 엮을 수 있다는 것이다.</p>

<p>매번 <code>AccessorManager</code>에게 enum 값을 넘겨서 <code>IAccessor</code>를 받은 후, 그 <code>IAccessor</code>와 <code>Stat</code> 구조체 변수를 엮어서 값을 주고 받는 코딩을 하는 것은 너무 더럽고 귀찮다. 따라서 간단히 이 둘을 연결해줄 수 있는 <code>Accessible</code>을 만들어보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Class</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Accessible</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Accessible</span><span class="p">(</span><span class="n">_Class</span><span class="o">&amp;</span> <span class="n">_object</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">object</span><span class="p">(</span><span class="n">_object</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">float</span> <span class="n">GetValue</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Accessor</span><span class="o">&lt;</span><span class="n">_Class</span><span class="o">&gt;</span><span class="p">()[</span><span class="n">type</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">GetValue</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">SetValue</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">float</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Accessor</span><span class="o">&lt;</span><span class="n">_Class</span><span class="o">&gt;</span><span class="p">()[</span><span class="n">type</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">SetValue</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Accessible</span><span class="p">(</span><span class="k">const</span> <span class="n">Accessible</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">object</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">object</span><span class="p">)</span> <span class="p">{}</span>
<span class="nl">private:</span>
    <span class="n">Accessible</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Accessible</span><span class="o">&amp;</span><span class="p">);</span>
<span class="nl">private:</span>
    <span class="n">_Class</span><span class="o">&amp;</span> <span class="n">object</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p><code>Accessible</code>은 class를 template parameter로 받고, <code>IAccessor</code>를 통해 접근할 object를 멤버로 갖는 class이다. 그리고 <code>Accessor&lt;&gt;</code>를 통해 <code>IAccessor</code>를 불러와서 멤버로 가지고 있는 object와 연결하여 <code>GetValue</code>/<code>SetValue</code>를 할 수 있게 만들어준다. </p>

<p>이제 다음과 같이 사용할 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">Accessible</span><span class="o">&lt;</span><span class="n">Stat</span><span class="o">&gt;</span> <span class="n">accessible</span><span class="p">(</span><span class="n">stat</span><span class="p">);</span>
<span class="k">switch</span> <span class="p">(</span><span class="n">buffMethod</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="n">METHOD_SET</span>: <span class="n">accessible</span><span class="p">.</span><span class="n">SetValue</span><span class="p">(</span><span class="n">buffType</span><span class="p">,</span> <span class="n">buffValue</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
<span class="k">case</span> <span class="n">METHOD_ADD</span>: <span class="n">accessible</span><span class="p">.</span><span class="n">SetValue</span><span class="p">(</span><span class="n">buffType</span><span class="p">,</span> <span class="n">accessible</span><span class="p">.</span><span class="n">GetValue</span><span class="p">(</span><span class="n">buffType</span><span class="p">)</span> <span class="o">+</span> <span class="n">buffValue</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
<span class="k">case</span> <span class="n">METHOD_RATE</span>: <span class="n">accessible</span><span class="p">.</span><span class="n">SetValue</span><span class="p">(</span><span class="n">buffType</span><span class="p">,</span> <span class="n">accessible</span><span class="p">.</span><span class="n">GetValue</span><span class="p">(</span><span class="n">buffType</span><span class="p">)</span> <span class="o">*</span> <span class="n">buffValue</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>그렇다면 이것이 지난 번 방법에 비해 왜 더 느릴까?
지난 글에서 서술한 방법들은 멤버 데이터 포인터나 멤버 함수 포인터를 사용하여 객체의 지정된 값을 가져오거나 지정하는 방법이었다. 만약 <code>Stat</code> 구조체가 POD 형태라면, 이들은 offset에 의한 데이터 접근을 하게 되거나 function-call 1번 수행(그나마도 inline 화 될 수 있는)하면 끝나는 형태이다.</p>

<p>그렇지만 이번 글에 소개된 방법은 <code>IAccessor</code>라는 interface를 통해 concrete의 동작을 위해 vfptr을 사용하는 방식으로 가상 함수 호출을 위한 부담을 추가로 가지게 되는 것이다. 이 호출 부담 때문에 더 느릴 수 밖에 없는 것이다.</p>

<p>다 쓰고 보니 <code>AccessorManager</code>가 굳이 map을 사용하지 않고, <code>BUFF_MAX</code>를 받아 배열로 <code>IAccessor</code>를 관리하는 것이 더 낫겠다 싶다. 하지만 굳이 위와 같이 냅둔 이유는 <a href="/2012/06/09/using-reflection-at-cpp-3/">c++에서 reflection 사용하기 3</a>와 형식이 유사해지기 때문에 코드 읽기가 좀 더 나을지도 모르겠다는 생각과, <code>AccessorManager</code>에서 배열의 크기를 template parameter로 받아서 배열을 생성해주기 약간 귀찮았기 때문이다-_-a</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">멤버 데이터 포인터의 casting과 안정성 1</h1>
				<p class="page-date">31 Oct 2012</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
						
				</p>
				<div class="content"><p>어제 동아리 친구와 이야기를 나누다 run-time에서는 float array를 float pointer로 casting하여 사용할 수 있는데 compile time에서는 왜 그럴 수 없냐는 이야기가 나왔다.</p>

<p>질문이 좀 미묘한데, 좀 더 정확히 정의하자면 <em>float array type의 member data pointer를 float pointer type의 member data pointer로 casting하여 사용할 수 없냐</em>는 이야기이다.</p>

<p><strong>일단 결론부터 이야기하자면, casting은 가능하지만 정의되지 않은 동작을 한다.</strong></p>

<p>예제 코드를 간단히 꾸려보면 다음과 같다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">enum</span> <span class="n">stat_speed</span> <span class="p">{</span> <span class="n">ss_walk</span><span class="p">,</span> <span class="n">ss_run</span><span class="p">,</span> <span class="n">ss_max</span> <span class="p">};</span>

<span class="k">struct</span> <span class="kt">stat_t</span> <span class="p">{</span>
    <span class="kt">stat_t</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">fill</span><span class="p">(</span><span class="n">speed</span><span class="p">,</span> <span class="n">speed</span> <span class="o">+</span> <span class="n">ss_max</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">float</span> <span class="n">speed</span><span class="p">[</span><span class="n">ss_max</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="kt">float</span><span class="o">*</span> <span class="kt">stat_t</span><span class="o">::*</span><span class="n">dataptr</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">accessor</span> <span class="p">{</span>
    <span class="k">static</span> <span class="kt">float</span> <span class="n">get</span><span class="p">(</span><span class="kt">stat_t</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="o">*</span><span class="n">dataptr</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">_tmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">_TCHAR</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="kt">float</span><span class="o">*</span> <span class="kt">stat_t</span><span class="o">::*</span><span class="n">fpointer_ptr</span><span class="p">;</span>
    <span class="c1">// fpointer_ptr aptr = static_cast&lt;fpointer_ptr&gt;(&amp;stat_t::speed); // cannot convert</span>
    <span class="n">fpointer_ptr</span> <span class="n">aptr</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">fpointer_ptr</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="kt">stat_t</span><span class="o">::</span><span class="n">speed</span><span class="p">);</span>

    <span class="kt">stat_t</span> <span class="n">stat</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">accessor</span><span class="o">&lt;</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">*</span> <span class="kt">stat_t</span><span class="o">::*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="kt">stat_t</span><span class="o">::</span><span class="n">speed</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">accessor</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">accessor</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">stat</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><code>stat_t</code>의 <code>speed</code>는 <code>float (stat_t::*)[ss_max]</code> type이다. 이것을 <code>float* stat_t::*</code> type으로 바꿔볼 것이다. 당연한 이야기이지만 이 두 개의 type은 완전히 다르기 때문에 <code>static_cast</code>로는 형 변환이 안된다. 때문에 <code>reinterpret_cast</code>를 사용해서 강제 형 변환을 유도해야 한다.</p>

<p>(run-time에서 메모리에 존재하는 배열과 그곳을 접근하기 위한 주소 값의 의미인 포인터로 둘이 동일하게 동작하는 것으로 생각할 수는 있지만, compiler가 생각하는 type 입장에서는 완전 다른 type이다.)</p>

<p>template parameter로 넘겨줄 때에도 <code>reinterpret_cast</code>를 사용해서 넘겨주면 형식 안정성을 다 무시하고 그냥 넘겨줄 수 있다. 때문에 위 <code>accessor::get()</code> 함수가 호출되는 위 코드 전체에는 아무런 compile error가 없다.</p>

<p>template programming을 하는 이유가 compile time에 검사해주는 type check를 사용하여 형식 안정성을 보장해주기 위함인데, <code>reinterpret_cast</code>가 들어간 시점에서 위 코드는 그냥 망했다.</p>

<p>뭐 일단 casting해서 template parameter를 넘길 수 있냐 없냐를 보여주기 위한 억지 예제이기는 하다. 이제 compile 성공 여부를 떠나서 위 코드가 제대로 실행되는지 보자.</p>

<p>일단 member data pointer가 어떤 구조를 가졌는지를 설명해야 하는데, 자세한 내용은 대충 이 pdf의 chapter 3에서 확인하고 요점만 이야기해보자.</p>

<ul>
<li><a href="http://www.dsi.fceia.unr.edu.ar/downloads/informatica/info_II/c++../inside.the.c++.object.model.pdf">PDF: Inside the C++ object model</a></li>
</ul>

<p>member function pointer를 보면, 단순히 어떤 클래스의 함수의 주소 값만 가지고 있으면 될 것 같지만 이게 vfptr를 참조해야 하는지, 그리고 그 상속 구조가 다중 상속 혹은 virtual 상속 구조인지에 따라서 내부 구성이 좀 달라진다. 그런데 이게 c++ 표준에 명세만 있고 구현이 없어서 컴파일러마다 구현체가 제각각이다. (즉 무슨 짓을 해놓는지 모름)</p>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Thunk#Object-oriented_programming">Wiki: Thunk (object-oriented programming)</a></li>
</ul>

<p>위와 동일한 개념이 member data pointer에도 적용된다고 보면 된다. 때문에 member data pointer가 단순 offset_of의 개념이라고 생각하면 안된다. (사실 고백하자면, 이 예제를 이해하는데 위 내용을 다 알아야 할 필요는 없지만 그냥 기회가 되었으니 공부하는 셈 치고 보면 좋다)</p>

<p>즉, 위 예제에서 <code>float (stat_t::*)[ss_max]</code>를 <code>float* stat_t::*</code>으로 casting하고, 그것을 dereferencing한 <code>float*</code> 값을 다시 dereferencing했을 때 <code>speed[ss_walk]</code>가 나오지 않는다는 이야기다. (즉 run-time에서 우리가 해왔던 것과는 조금 다르게 동작한다)</p>

<p>심지어 예제를 돌려보면 잘못된 메모리 접근으로 프로그램이 계속 죽는다!</p>

<p>시간이 부족한 관계로 위 예제가 실제로 어떻게 동작하는지 disassemble해서 살펴 보는 것과 그러면 어떻게 이해를 해야 하고 어떻게 코드를 고치면 위 문제를 풀어볼 수 있을지에 대해서는 다음 글에서 알아보자.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">반복자 i++과 ++i에 대한 헛소리</h1>
				<p class="page-date">01 Jul 2011</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
						
				</p>
				<div class="content"><p>반복문에서 반복자를 증가시킬 때, <code>for ( ; ; i++)</code>과 <code>for ( ; ; ++i)</code>를 이야기할 때, 뭐가 빠르네 느리네 이야기가 왜 나왔을까?<br>
간단히 생각해보면, <code>i++</code>과 <code>++i</code>는 동작이 약간 다르다. 연산자 우선순위는 <code>i++</code>이 좀 더 빠르지만, 실행 측면에서 본다면</p>

<p><code>i++</code>은</p>

<ol>
<li>자신의 상태를 저장한다</li>
<li>자신의 상태를 변화한다</li>
<li>저장한 예전 상태를 반환한다</li>
</ol>

<p><code>++i</code>는</p>

<ol>
<li>자신의 상태를 변화한다</li>
<li>자신 자체를 반환한다.</li>
</ol>

<p><code>i++</code>의 3)과 <code>++i</code>의 2)를 보면 <code>i++</code>의 경우 복사해둔 것을 반환하지만, <code>++i</code>의 경우는 자기 자체(reference)를 반환한다. <code>i++++</code>은 안되지만 <code>++++i</code>는 되는 이유가 그것이다.<br>
함수 prototype으로 치자면</p>

<ul>
<li>전항연산의 <code>int &amp; operator ++ (void)</code>와 </li>
<li>후항연산의 <code>int operator ++ (int dummy)</code>의</li>
</ul>

<p>차이랄까. 반환 값의 type이 다르다.</p>

<p>이게 단순 primitive type이면서 value type일 때는, <code>i++</code>의 3)과 <code>++i</code>의 2) 가 결국 복사된 값이므로 저기서 발생하는 부담은 같지만, 이를 수행하기 위한 instruction 차이가 난다.</p>

<p>하지만 이게 wrapper class에 의한 object이면 좀 달라진다.<br>
<code>i++</code>의 경우 반환하기 위한 임시 객체를 복사해서 준비해야하고, 자신을 변화시킨 후, 복사해둔 객체를 반환해야한다. 하지만 <code>++i</code>는? 그냥 자기 자신 (*this) 을 반환하면 된다.</p>

<p>객체의 복사라는게 객체의 크기에 따라 안드로메다급으로 걸릴 수 있는 일인데다가 <code>obj next = current++;</code>와 같이 작성할 경우</p>

<ol>
<li>++ 함수 내부에서 임시 객체 생성 위한 복사 1번</li>
<li>++ 함수 반환 값에서 next 로 대입되기 위한 복사 1번</li>
<li>재수없다면 next 객체 생성 따로 ++ 함수 반환 값 대입 연산 따로 까지 칠 경우 1번</li>
</ol>

<p>총 2번 (컴파일러가 바보면 3번) 복사 짓을 해야한다는 것이다. 메모리도 그렇고 명령어도 그렇고 낭비가 심하다.</p>

<p>STL의 iterator 같은 걸 쓸 때 iterator는 object이다. 따라서 전항 ++ 이 후항 ++ 보다 성능이 빠르다는 이야기가 위 근거에 의해 성립되는 것이다.</p>

<p>자 그럼 이게 왜 헛소리인지 보자. 일단 <strong>컴파일러가 그렇게 멍청하지 않다.</strong><br>
for 문에서 int 변수를 <code>i++</code> 하나 <code>++i</code> 하나 컴파일러가 바보가 아닌 이상에야 <code>INC instruction</code> 넣어주면 된다.</p>

<p>저게 iterator 같은 class라면?</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#include &lt;iostream&gt;</span>
<span class="k">class</span> <span class="nc">serial</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">serial</span> <span class="o">&amp;</span> <span class="k">operator</span> <span class="o">++</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;prefix&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">serial</span> <span class="o">&amp;</span> <span class="k">operator</span> <span class="o">++</span> <span class="p">(</span><span class="kt">int</span> <span class="n">dummy</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;postfix&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">serial</span> <span class="n">s</span><span class="p">;</span>
    <span class="o">++++</span><span class="n">s</span><span class="p">;</span>
    <span class="n">s</span><span class="o">++++</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>재밌게도 후항(postfix) ++ 연산을 overloading할 때 반환 값에 대해서 신경을 쓰지 않아도 된다. 그런고로 전항(prefix) ++ 연산과 동일한 동작을 수행하게 하면 성능상 문제가 없다 할 수 있겠다.</p>

<p>물론, </p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">serial</span> <span class="o">&amp;</span> <span class="k">operator</span> <span class="o">++</span> <span class="p">(</span><span class="kt">int</span> <span class="n">dummy</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">++</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
</code></pre></div>
<p>와 같이 후항 연산에서 전항 연산을 호출해버려도 되고, (컴파일러가 함수 호출은 최적화시켜 줄거라 믿자)</p>

<p>Visual Studio 2010에서 해본 결과 아예 후항 ++ 연산 함수를 정의하지 않으면 알아서 전항 ++ 함수를 호출해버린다-_-
(g++ 4.5.2에서는 error: no &#39;operator++(int)&#39; declared for postfix &#39;++&#39; 와 같이 에러를 띄운다)</p>

<p>그런고로 값 타입이든 객체 타입이든 반복문 등에서 반복자를 증가시킬 때 ++을 앞에 쓰냐 뒤에 쓰냐는 성능에 영향이 없다는 소리. 물론 컴파일러에 따라 다를 수 있다는 말이 제일 정답일 것이다만-_-</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">빠른 메시지 만들기</h1>
				<p class="page-date">11 Feb 2014</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
					<code class="tag">message</code>
						
						
						
						
				</p>
				<div class="content"><p><a href="http://kentonv.github.io/capnproto/">Cap&#39;n Proto</a>와 같은 무한대(?)로 빠른 메시지를 설계한다고 생각해보자. 그렇다면 우리는 어떤 점을 고민해야 할까?</p>

<p>이를 위해 잠깐 네트워크로 정보를 전달하는 과정을 생각해보자.</p>

<ol>
<li>end-point #1은 정보를 패킷에 담아 네트워크로 전송한다. (serialize)</li>
<li>end-point #2는 네트워크에서 바이트를 읽어 메시지를 구성하고, 그 메시지로부터 정보를 읽는다. (deserialize)</li>
</ol>

<p>당연한 이야기지만 메시지 serialize/deserialize 비용을 최소화하는 것이 정답이란 소리다. 그러면 이것을 어떻게 최적화할 수 있을까? 이는 메시지에 어떠한 내용이 들어가냐를 고민해봄으로써 좀 더 자세히 생각해볼 수 있다.</p>

<p>다음과 같은 메시지가 있다고 해보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="kt">player_message_t</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">hp</span><span class="p">,</span> <span class="n">mp</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">atk</span><span class="p">,</span> <span class="n">def</span><span class="p">,</span> <span class="n">luck</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>위 경우 serialize, deserialize 과정이 필요가 없다. 왜냐하면,</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="c1">// send</span>
<span class="n">send</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">byte</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">player_stat</span><span class="p">));</span>

<span class="c1">// receive</span>
<span class="kt">player_message_t</span><span class="o">*</span> <span class="n">message</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">player_message_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
</code></pre></div>
<p>c/c++의 struct는 바로 byte로 mapping될 수 있기 때문데 send할 때 그냥 보내고, receive할 때 그냥 casting해서 읽으면 되기 때문이다. 이 경우 필요한 추가 정보라고 해봐야 message dispatch를 위한 id와, message의 경계를 확인하기 위한 message size 정도이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="kt">message_header_t</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">message_id</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">message_size</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>하지만 위와 같은 단순한 경우일 때 message_size는 단순히 sizeof(T) 같은 형태로 얻어낼 수 있으니 더욱 구조가 간단해질 수 있다.</p>

<p>좀 더 복잡한 메시지를 고려해보자. 소위 말하는 가변 길이 메시지인데 보통은 list 때문에 발생한다. (string의 경우 char의 list)</p>

<p>이 경우 가장 간단한 방법은 size를 기록하는 것이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="kt">player_message_t</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">hp</span><span class="p">,</span> <span class="n">mp</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">name_size</span><span class="p">;</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">name_bytes</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">atk</span><span class="p">,</span> <span class="n">def</span><span class="p">,</span> <span class="n">luck</span><span class="p">;</span> 
<span class="p">};</span>
</code></pre></div>
<p>하지만 이 경우 첫 번째 경우와 같은 serialize/deserialize 성능을 보이기가 어렵다. 그 이유는 <code>name_bytes</code> 때문인데, 이 때문에 쓸 때 따로 write하는 구문을 추가해야할 뿐만 아니라 읽을 때도 <code>name_size</code>만큼 메모리를 할당한 다음 메시지를 읽도록 구현해야 하기 때문이다.</p>

<p>하지만 위 문제를 해결할 수 있는 간단한 방법이 있다. 바로 offset과 null-terminated를 사용하는 것이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="kt">player_message_t</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">hp</span><span class="p">,</span> <span class="n">mp</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">name_offset</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">atk</span><span class="p">,</span> <span class="n">def</span><span class="p">,</span> <span class="n">luck</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="o">+</span> <span class="n">name_offset</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>이 경우 메시지의 bytes 구조는 다음과 같아진다.</p>

<ul>
<li><code>hp</code> <code>mp</code> <code>name_offset</code> <code>atk</code> <code>def</code> <code>luck</code> <code>name-bytes</code></li>
</ul>

<p>위와 같이 작성할 경우 serialize 입장에서는 큰 차이가 없다. hp, mp, atk, def, luck를 모두 write한 다음 <code>name_offset</code>의 위치를 기록하고, 마지막 부분에 <code>name-bytes</code>를 기록한다. 하지만 deserialize에서 큰 차이가 나타난다. 첫 번째 소개한대로 읽은 message buffer에 대해 단순히 <code>player_message_t</code>로 casting만 해서도 관련 정보를 모두 읽을 수 있는 구조이기 때문에, deserialize 비용이 필요 없어진다.</p>

<p>list도 위와 같은 방법으로 구현할 수 있다. 차이점이 있다면 string의 경우 char type에 대해 구현한 것이고, list의 경우 어떤 T type에 대해 구현한다는 것이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="kt">player_message_t</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">hp</span><span class="p">,</span> <span class="n">mp</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">name_offset</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">inven_offset</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">inven_count</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">atk</span><span class="p">,</span> <span class="n">def</span><span class="p">,</span> <span class="n">luck</span><span class="p">;</span>
    <span class="k">struct</span> <span class="kt">inven_t</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">item_id</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">item_data_id</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="o">+</span> <span class="n">name_offset</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">const</span> <span class="kt">inven_t</span><span class="o">*</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">inven_t</span><span class="o">*&gt;</span><span class="p">(</span>
                    <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="o">+</span> <span class="n">inven_offset</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">const</span> <span class="kt">inven_t</span><span class="o">*</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">inven_t</span><span class="o">*&gt;</span><span class="p">(</span>
                    <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="o">+</span> <span class="n">inven_offset</span><span class="p">)</span>
                        <span class="o">+</span> <span class="n">inven_count</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>이 경우 메시지의 구조는 다음처럼 된다.</p>

<ul>
<li><code>hp</code> <code>mp</code> <code>name_offset</code> <code>inven_offset</code> <code>inven_count</code> <code>atk</code> <code>def</code> <code>luck</code> <code>name-bytes</code> <code>inven_t-bytes</code></li>
</ul>

<p>그냥 string랑 똑같은데 <code>begin()</code>, <code>end()</code> method를 나누어 구현했다고 보면 된다. 다만, <code>end()</code> 함수에서 <code>inven_count</code>를 더하는 부분이 <code>inven_t</code> 크기가 고정일 경우를 가정하고 있는데, 이 부분은 null-terminated 등을 써서 가변에 대해서도 쉽게 적용할 수 있을 것이라 보기 때문에 더 이상의 자세한 설명은 생략한다. (iterator를 직접 구현하여 사용할 경우 간단히 해결할 수 있는데 그렇게까지 글을 쓰면 너무 무의미하게 길어진다.)</p>

<p><del>대체 왜 이런 글을 쓰는지 지금도 잘 모르겠지만 어쨌든 글을 마무리 짓자면,</del> 발상의 전환을 통해 어렵지 않은 방법으로 성능 개선을 할 수 있는 방법은 무궁무진하니 이미 알고 있는 내용일지라도 여러 방면으로 고민하여 기술을 갈고 닦았으면 좋겠다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">탈무드 이야기</h1>
				<p class="page-date">20 Sep 2011</p>
				<p class="page-tags">
						
						
					<code class="tag">c++</code>
						
						
						
						
				</p>
				<div class="content"><p>탈무드에는 다음과 같은 이야기가 있다.</p>

<blockquote>
<p>예루살렘에서 멀리 떨어진 곳에 어진 유태인이 살고 있었다. 그는 아들을 예루살렘에 있는 학교에 보냈다. 아들이 학교에서 공부하고 있는 사이에 아버지는 병이 들었다. 병세는 점점 깊어져 아무래도 아들을 만날 수 없으리라고 생각된 아버지는 유서를 썼다. 내용은 &#39;전 재산을 한 노예에게 줄 것, 다만 재산 중에서 하나만 아들이 원하는 것을 아들에게 주라&#39;는 내용이었다. 그 아버지가 죽자 노예는 그 아들에게 부친이 죽은 것을 알리고, 유서를 보여 주었다. </p>

<p>이렇게 시작해서 노예의 재산은 결국 주인의 재산이므로 아들은 재산으로 노예를 선택했고 아버지가 남긴 유산도 얻을수 있었다.</p>
</blockquote>

<p>프로그래밍적으로 접근해보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Person</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Container</span> <span class="p">{};</span>
<span class="k">class</span> <span class="nc">Wealth</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Container</span> <span class="p">{};</span>
<span class="k">class</span> <span class="nc">Owned</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Attribute</span> <span class="p">{};</span>
<span class="k">class</span> <span class="nc">Owner</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Attribute</span> <span class="p">{};</span>
</code></pre></div>
<p>사람과 재산은 여러 속성을 띌 수 있으므로 하나의 <code>Container</code>라 할 수 있다.
그리고 소유 관계를 표현하기 위한 <code>Owned</code>, <code>Owner</code>는 각각 속성이라 할 수 있다.</p>

<p>이 집에는 아버지, 아들, 노예가 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">PersonRef</span> <span class="n">father</span><span class="p">,</span> <span class="n">son</span><span class="p">,</span> <span class="n">slave</span><span class="p">;</span>
</code></pre></div>
<p>저 객체들은 어떻게든 태어나서, 여지껏 자신의 상태를 잘 관리하며 살아왔을 것이다. 각자는 자신의 삶을 독립적으로 살아가므로 하나의 Agent로 봐도 되겠다.</p>

<p>여기서 아들은 공부를 위해 먼 곳으로 떠났다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">GoStudy</span><span class="p">(</span><span class="n">son</span><span class="p">);</span>
</code></pre></div>
<p>그런데 저 함수는 굉장히 복잡하기 때문에, <code>son</code> 객체는 저 함수의 수행을 완료할 때까지 상당한 시간을 소모할 것이다.</p>

<p>아버지는 상당한 재산을 가지고 있었다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">WealthRef</span> <span class="n">wealth</span><span class="p">;</span>
<span class="n">wealth</span><span class="o">-&gt;</span><span class="n">GetAttribute</span><span class="o">&lt;</span><span class="n">Owner</span><span class="o">&gt;</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">SetOwner</span><span class="p">(</span><span class="n">father</span><span class="p">);</span>
</code></pre></div>
<p>하지만 아버지에게 위기가 찾아왔다. 아버지 객체의 생존 시간이 다 된 것이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">dieAndDestroy</span><span class="p">(</span><span class="n">father</span><span class="p">);</span>
</code></pre></div>
<p>아버지는 저 함수의 수행이 끝나면 자신이 완전히 소멸된다는 점을 잘 알고 있다.</p>

<p>자신이 걱정하는 바는, 아들 객체가 <code>GoStudy</code> 수행이 끝나기 전에 자신의 <code>dieAndDestroy</code> 함수 수행이 완료될 것이라는 점이다. 그렇게 되면, 자신 객체는 모든 참조를 잃게 되고, 자신이 소유한 재산들은 모두 소유권이 사라지게 될 것이다.</p>

<p>왜냐하면 dieAndDestroy 함수는 자신이 소유한 모든 재산들의 소유권을 NULL로 만들기 때문이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">OwnedList</span><span class="o">&amp;</span> <span class="n">ownedList</span> <span class="o">=</span> <span class="n">father</span><span class="o">-&gt;</span><span class="n">GetAttribute</span><span class="o">&lt;</span><span class="n">Owned</span><span class="o">&gt;</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">List</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">foreach</span><span class="p">(</span><span class="n">ownedList</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">ownedList</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">(</span><span class="n">Owned</span><span class="o">*</span> <span class="n">owned</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">owned</span><span class="o">-&gt;</span><span class="n">SetOwner</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div>
<p>그러면 자신의 소유물 중 하나인 노예가 모든 소유 권한이 없어진 틈을 타서, 아들이 돌아오기 전에 모든 소유권을 자신에게 돌리게 될 것이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">OwnedList</span><span class="o">&amp;</span> <span class="n">ownedList</span> <span class="o">=</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">GetAttribute</span><span class="o">&lt;</span><span class="n">Owner</span><span class="o">&gt;</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetAttribute</span><span class="o">&lt;</span><span class="n">Owned</span><span class="o">&gt;</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">List</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">foreach</span><span class="p">(</span><span class="n">ownedList</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">ownedList</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">slave</span><span class="p">]</span> <span class="p">(</span><span class="n">Owned</span><span class="o">*</span> <span class="n">owned</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">owned</span><span class="o">-&gt;</span><span class="n">SetOwner</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div>
<p>그래서 아버지는 현명하게도 자신의 정보를 유지할 방법으로 유서라는 객체를 만들었다. 유서라는 객체는 2개의 수행으로 나누어진다.</p>

<ul>
<li><strong>전 재산의 소유권을 노예에게 이전한다.</strong></li>
</ul>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">OwnedList</span><span class="o">&amp;</span> <span class="n">ownedList</span> <span class="o">=</span> <span class="n">father</span><span class="o">-&gt;</span><span class="n">GetAttribute</span><span class="o">&lt;</span><span class="n">Owned</span><span class="o">&gt;</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">List</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">foreach</span><span class="p">(</span><span class="n">wholeWealth</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">wholeWealth</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">slave</span><span class="p">]</span> <span class="p">(</span><span class="n">Owned</span><span class="o">*</span> <span class="n">owned</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">owned</span><span class="o">-&gt;</span><span class="n">SetOwner</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div>
<p>이렇게 되면 노예는 굳이 아버지가 남긴 유산을 자신의 것으로 등록하는 redundant한 작업을 수행하지 않는다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">GetAttribute</span><span class="o">&lt;</span><span class="n">Owner</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">==</span> <span class="n">slave</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>
</code></pre></div>
<ul>
<li><strong>아들이 원하는 재산 하나만 아들에게 소유권을 준다.</strong></li>
</ul>

<p>이것은 굉장한 술책이다. 왜냐하면 아들 Agent는 현재 <code>GoStudy</code> 함수 수행이 끝나지 않은 상태인데,
아들이 <strong>원하는</strong> 재산 한 가지를 주어야하므로, 아들에게 무엇을 원하는지 물어봐야한다는 것이다.</p>

<p>그리고 당시의 시대상을 고려해볼 때 아들은 통신 기기가 발달하지 않았기 때문에 이에 대한 응답을 비동기적(전화나 인터넷 메일 등)으로 공부하다가 중간에 잠깐 응답할 수가 없고, 동기적으로 집까지 와서 해당 재산을 선택해야한다는 것이다.</p>

<p>따라서 이 유서는, 굉장하게도, 2번째 단계에서 지연된 수행을 시도한다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="n">Will2Phase</span> <span class="o">:</span> <span class="k">public</span> <span class="n">DeferredJob</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="k">operator</span> <span class="p">()</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Owned</span><span class="o">*</span> <span class="n">oneOfWealth</span> <span class="o">=</span> <span class="n">son</span><span class="o">-&gt;</span><span class="n">choose</span><span class="p">(</span><span class="n">mWholeWealth</span><span class="p">);</span>
        <span class="n">oneOfWealth</span><span class="o">-&gt;</span><span class="n">SetOwner</span><span class="p">(</span><span class="n">son</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Will2Phase</span><span class="p">(</span><span class="n">OwnedList</span><span class="o">&amp;</span> <span class="n">wholeWealth</span><span class="p">,</span> <span class="n">PersonRef</span> <span class="n">son</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">mWholeWealth</span><span class="p">(</span><span class="n">wholeWealth</span><span class="p">),</span> <span class="n">mSon</span><span class="p">(</span><span class="n">son</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">OwnedList</span><span class="o">&amp;</span> <span class="n">mWholeWealth</span><span class="p">;</span>
    <span class="n">PersonRef</span> <span class="n">mSon</span><span class="p">;</span>
<span class="p">}</span> <span class="n">will</span><span class="p">(</span><span class="n">wholeWealth</span><span class="p">,</span> <span class="n">son</span><span class="p">);</span>
<span class="n">son</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">(</span><span class="n">will</span><span class="p">);</span>
</code></pre></div>
<p>유서라는 이 Transaction은 완료가 되어야 정식 발효가 되는 그런 개념은 아니다.</p>

<p>하지만 일말의 양심이 있는 노예는, 재산 소유의 정당성을 얻기 위해, 유서 집행을 서두른다. 덕분에 아들은 비동기적으로 아버지 객체의 Destroy 소식을 들을 것이고, 자신이 수행하던 <code>GoStudy</code> 함수의 수행을 중단하고 그 다음 작업인 <code>Will2Phase::operator() (void)</code> 를 수행하게 될 것이다.</p>

<p>현명한 아버지의 아들답게, 아들은 <code>choose</code> 함수를 통해 <code>wholeWealth</code> 목록 중에서 노예를 선택한다. 그게 가능한 이유는 <code>wholeWealth</code> 라는 것이 capture된 시점 자체가 <strong>아버지의 유서를 작성한 시점이기 때문에</strong> 비록 그 내부 원소들의 소유권은 노예에게 돌아갔지만, 아직 <strong>그 목록에는 노예가 포함</strong> 되어있기 때문인 것이다.</p>

<ul>
<li>만약 아버지의 유서가, 그럴리는 없겠지만, &quot;전 재산을 한 노예에게 줄 것, <strong>그의 재산</strong> 중에서&quot; 라고 유서를 작성했으면 <code>wholeWealth</code> 목록을 갱신해야하므로 아들은 망했을 것이다.</li>
<li>하지만 프로그래밍을 하다보면 이런 실수는 꽤 있다</li>
</ul>

<p>그리고 소유권 이전 문제. 본 글을 처음 작성했던 동아리 친구가 언급한대로 <strong>x∈y and y∈z이지만 x∈z는 성립하지 않는다.</strong></p>

<p>유서가 모두 집행된 상태에서 breakpoint를 걸어 객체들의 상태를 보면, 아들은 단 하나의 객체, 즉 노예에 대한 Owner일 뿐이고 아직 남은 다른 재산들은 모두 노예에게 소유권이 있다. (갱신을 안 했으니까!)</p>

<p>그런고로, 아들이 진정 모든 재산의 소유권을 얻으려면 다음의 작업을 해야한다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">OwnedList</span><span class="o">&amp;</span> <span class="n">remains</span> <span class="o">=</span> <span class="n">oneOfWealth</span><span class="o">-&gt;</span><span class="n">GetAttribute</span><span class="o">&lt;</span><span class="n">Owned</span><span class="o">&gt;</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">List</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">foreach</span><span class="p">(</span><span class="n">remains</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">remains</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">son</span><span class="p">]</span> <span class="p">(</span><span class="n">Owned</span><span class="o">*</span> <span class="n">owned</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">owned</span><span class="o">-&gt;</span><span class="n">SetOwner</span><span class="p">(</span><span class="n">son</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div>
<p>하지만 이런 당연한 사실을 구구절절히 읊는 것은 탈무드의 격이 떨어지는 것.<br>
따라서 이 구절을 간단하게 <em>&quot;현명한 아들은, 아버지의 뜻을 깨닫고, 모든 재산을 얻을 수 있었다&quot;</em>과 같이 표현한 것이다. 요새 말로 하자면 <strong>더 이상의 자세한 설명은 생략한다</strong> 정도?</p>

<p>다 쓰고 보니 공유 자원에 대한 monitor 드립과 권한 문제 드립을 안 쳤네 [...]</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1><a id="concurrency" href="#concurrency">concurrency</a></h1>
				<hr />
				<div class="page-breaker"></div>
							
						
				<h1 class="page-title">concurrency 스터디</h1>
				<p class="page-date">03 Aug 2013</p>
				<p class="page-tags">
						
						
					<code class="tag">concurrency</code>
						
						
						
					<code class="tag">study</code>
						
						
						
						
				</p>
				<div class="content"><p>오늘 스터디에서 공부한 내용을 간략히 정리해보자.</p>

<ul>
<li><a href="http://en.wikipedia.org/wiki/ABA_problem">Wiki: ABA problem</a></li>
<li><a href="http://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf">Simple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue Algorithms</a></li>
<li><a href="/2011/08/02/context-switching-and-simultaneously/">context switching과 simultaneously 실행</a></li>
<li><a href="/2012/02/23/thread-unsafety-problem-in-circular-queue/">환형큐의 thread unsafety 문제</a></li>
</ul>

<h3>volatile/interlocked operation/memory barrier</h3>

<ul>
<li><a href="/2011/08/02/volatile-interlocked-operation/">volatile 과 interlocked operation</a></li>
<li><a href="http://summerlight-textcube.blogspot.kr/2009/11/volatile%EA%B3%BC-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%B0%B0%EB%A6%AC%EC%96%B4.html">summerlight: volatile과 메모리 배리어</a></li>
</ul>

<h3>intrusive/non-intrusive</h3>

<ul>
<li><a href="http://www.makelinux.net/ldd3/chp-11-sect-5">Linux kernel LinkedList</a></li>
<li><a href="http://www.boost.org/doc/libs/release/doc/html/intrusive.html">Boost: Boost.Intrusive</a></li>
<li><a href="http://www.boost.org/doc/libs/release/doc/html/intrusive/intrusive_vs_nontrusive.html">Boost: Intrusive and non-intrusive containers</a></li>
</ul>

<h3>InterlockedSList</h3>

<ul>
<li><a href="/2011/08/03/interlocked-singly-linked-lists/">Interlocked Singly Linked Lists</a></li>
</ul>

<h3>Actor model</h3>

<p>각 actor 객체에 접근하는 thread는 반드시 하나임을 보장함. context switching 비용을 줄이기 위해 thread 개수를 제한하지만 많은 actor를 다루기 위해 객체별 수행 동기화 기법을 사용한다.</p>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Actor_model">Wiki: Actor model</a></li>
<li><a href="/2011/08/11/synchronize-function-execution-in-each-object/">객체별 함수 수행 동기화</a></li>
</ul>

<h3>out of order execution</h3>

<ul>
<li>컴파일러의 명령어 재배치 수준이 아닌 cpu 내부의 비순차 실행</li>
<li>비순차 실행을 통해 최대 수행 시간의 절감 효과를 얻음</li>
<li>하드웨어적 한계로 비순차 실행 명령어 window를 유지 (reservation stations), 그 내부에서 각 operand 준비 완료가 되면 연산 수행</li>
<li>operand 준비 완료 통지 연산량 감소를 port grouping, 결과 순서를 보장해주기 위해 rob를 사용</li>
<li><a href="http://en.wikipedia.org/wiki/Reservation_stations">Wiki: Reservation stations</a></li>
</ul>

<h3>memory consistency model</h3>

<p>우리가 작성한 대로 수행을 보장해준다면(Sequentially-consistent ordering) 프로그램의 흐름을 이해하기가 쉽지만 최적화 가능성이 줄어듬. 이를 완화(relaxed)해주어서 최적화가 잘 되게 해보자. 그런데 intel x86-64는 그런 것 신경 안 써줘도 빠르게 돌아감*(<a href="https://twitter.com/summerlight00" title="summerlight00">summerlight</a>님 수정)*</p>

<ul>
<li><a href="http://www.hpl.hp.com/techreports/Compaq-DEC/WRL-95-7.pdf">WRL-RR: Shared Memory Consistency Models: A Tutorial</a></li>
</ul>

<p>c++11에 memory order로 추가됨.</p>

<ul>
<li><a href="http://en.cppreference.com/w/cpp/atomic/memory_order">Cppref: std::memory_order</a></li>
</ul>

<h3>c++ threading facilities</h3>

<ul>
<li><a href="http://en.wikipedia.org/wiki/C%2B%2B11#Threading_facilities">Wiki: c++ threading facilities</a></li>
</ul>

<p>표준에서 지원하기는 하지만 표준 라이브러리가 어떻게 구현되어있는지 보고 괜찮은지를 판단한 후 사용하자.</p>

<ul>
<li><a href="http://www.slideshare.net/lactrious/synchronizing-concurrent-threads">async, future, promise in c++</a></li>
</ul>

<h3>sync/async programming</h3>

<p>아무튼 async가 흐름 따라가기가 어렵다.</p>

<ul>
<li><a href="/2012/03/18/asynchronous-programming-and-async-await/">asynchronous programming 과 async, await</a></li>
</ul>

<h3>c++11의 lambda</h3>

<ul>
<li><a href="http://ogoons.tistory.com/69">Visual C++10과 C++0x</a></li>
</ul>

<h3>thread safe한 singleton</h3>

<ul>
<li><a href="http://board.poolc.org/generation03/512">PoolC: C++ 싱글턴 (summerlight)</a></li>
</ul>

<p>근데 intel x86-64에서는 memory barrier 안 쳐줘도 문제가 없다-_-; 하지만 c++11부터는 함수 내 static 변수를 반환하는 것만으로도 대충 thread-safe한 singleton이 구현 가능해졌다.</p>

<ul>
<li><a href="http://stackoverflow.com/questions/8102125/is-local-static-variable-initialization-thread-safe-in-c11">Stackoverflow: Is local static variable initialization thread-safe in C++11</a></li>
<li><a href="http://stackoverflow.com/questions/2280630/c-threadsafe-static-constructor">Stackoverflow: c++ threadsafe static constructor</a></li>
</ul>

<h3>기타 windows via c/c++ 내용</h3>

<p>CreateThread, SSDT, Kernel object, CriticalSection, ...</p>

<h3>lock</h3>

<ul>
<li>CAS (InterlockedCompareExchange 사용) 로 쉽게 구현할 수 있다.</li>
<li>reader/writer (shared/exclusive) lock을 사용할 수 있지만 fairness를 잘 고민해야한다.</li>
<li>그냥 lock/unlock 부르지 말고 raii 잘 써서 쓰자.</li>
</ul>

<h3>과제 해법</h3>

<ul>
<li>lock 사용</li>
<li>interlocked-operation 사용</li>
<li>counter(actor)에 대해 message passing 사용</li>
</ul>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">concurrency 알고리즘과 memory model</h1>
				<p class="page-date">10 Aug 2013</p>
				<p class="page-tags">
						
						
					<code class="tag">concurrency</code>
						
						
						
					<code class="tag">memory</code>
						
						
						
					<code class="tag">study</code>
						
						
						
						
				</p>
				<div class="content"><p>오늘 스터디에서 공부한 내용을 간략히 정리해보자.</p>

<p>원래 의도는,</p>

<ul>
<li>peterson&#39;s algorithm을 보고 여기서 비순차 실행이 일어날 때 발생하는 문제를 보고,</li>
<li>memory consistency model의 memory order를 통해 문제를 어떻게 해결할 수 있는지 본 후에,</li>
<li>lock free stack, lock free queue algorithm을 보고 문제를 파악한 후에 이를 해결하기 위해</li>
<li>hazard pointer를 보려고 했는데</li>
</ul>

<p>순서가 꼬였다-_-
아무튼 의도했던 순서로 정리하겠음</p>

<h3>peterson&#39;s algorithm</h3>

<p><a href="http://en.wikipedia.org/wiki/Peterson&#x27;s_algorithm">Wiki: Peterson&#39;s algorithm</a></p>

<p>그냥 눈에 보이는대로 코드가 수행되면 문제가 발생하지 않는데, 비순차 실행에 의해 <code>flag[my_index] = true; turn = other_index;</code> 대입의 순서가 뒤집히면 critical section에 두 thread가 진입할 수 있는 문제가 발생한다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="nl">P0:</span> <span class="n">turn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">true</span> <span class="o">&amp;&amp;</span> <span class="n">turn</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// busy wait</span>
    <span class="p">}</span>
    <span class="c1">// critical section</span>
    <span class="p">...</span>
    <span class="c1">// end of critical section</span>
    <span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="nl">P1:</span> <span class="n">turn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nb">true</span> <span class="o">&amp;&amp;</span> <span class="n">turn</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// busy wait</span>
    <span class="p">}</span>
    <span class="c1">// critical section</span>
    <span class="p">...</span>
    <span class="c1">// end of critical section</span>
    <span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</code></pre></div>
<p>위 코드에 대해 아래와 같은 수행 흐름이 나오면 critical section이 보호되지 않는다.</p>

<table><thead>
<tr>
<th>turn</th>
<th>flag_0</th>
<th>flag_1</th>
<th>진행</th>
</tr>
</thead><tbody>
<tr>
<td>0</td>
<td>false</td>
<td>false</td>
<td>초기상태</td>
</tr>
<tr>
<td>1</td>
<td>false</td>
<td>false</td>
<td>p0: turn = 1</td>
</tr>
<tr>
<td>0</td>
<td>false</td>
<td>false</td>
<td>p1: turn = 0</td>
</tr>
<tr>
<td>0</td>
<td>false</td>
<td>true</td>
<td>p1: flag_1 = true // p1 진입</td>
</tr>
<tr>
<td>0</td>
<td>true</td>
<td>true</td>
<td>p2: flag_0 = true // p0 진입</td>
</tr>
</tbody></table>

<h3>memory consistency model</h3>

<p>비순차 실행에 의해 의존성이 없다고 판단되는 연산의 순서가 뒤집히는 것을 방지하기 위해 memory consistency model을 고민해야 한다.</p>

<ul>
<li><a href="http://www.hpl.hp.com/techreports/Compaq-DEC/WRL-95-7.pdf">WRL RR: Shared MEmory Consistency Models: A Tutorial</a></li>
<li><a href="http://www.boost.org/doc/libs/release/doc/html/atomic/thread_coordination.html">Boost: Thread coordination using Boost.Atomic</a></li>
<li><a href="http://en.cppreference.com/w/cpp/atomic/memory_order">Cppref: std::memory_order</a></li>
</ul>

<p>메모리 가시성 개념도 포함되어 있음. fence를 경계로 비순차 수행 가능 범위의 경계가 생김.<br>
인텔 x86-64 core를 쓰면 알아서 해주기 때문에 프로그래머가 신경 쓸 필요가 없다.</p>

<p>표준에서 설명하는 <code>memory_order_consume</code>, <code>memory_order_acquire</code>의 차이를 잘 모르겠음.
그리고 boost thread_coordination 문서의 마지막 예제 내용을 잘 모르겠음.</p>

<p>위 질문에 대한 <a href="https://twitter.com/summerlight00" title="summerlight00">summerlight</a>님의 답변</p>

<blockquote>
<p>consume와 acquire 시멘틱에 대한 차이: DEC alpha에서 작업할거 아니면 그냥 acquire로 통일하면 됨.</p>
</blockquote>

<h3>lock free algorithm과 aba problem</h3>

<ul>
<li>lock free algorithm과 aba problem: <a href="https://sites.google.com/site/doc4code/Non-Blocking%20Algorithm.pdf">Non_Blocking_Algorithm.pdf</a></li>
<li>obstruction-free, lock-free, wait-free 개념 구분</li>
<li>CAS, CAS2(CASW), DCAS, TSX, RTM 대충</li>
<li>aba problem이 잘 설명되어 있다. CAS를 node pointer로만 하기 때문에 그 주소값만 같으면 해당 주소가 가리키는 객체의 상태가 어떻게 변했어도 작업이 진행될 수 있는 것이 문제.<br>
(즉 stack/queue를 나갔다가 다시 들어왔을 때, 해제되었다가 다시 할당되었는데 그 주소가 같을 때)</li>
</ul>

<p>즉, 객체의 pointer 비교만으로는 객체의 상태 비교가 안되므로 count를 넣어서 객체의 버전관리(?)를 한다. CAS할 때마다 count를 증가시켜 이전과는 다른 객체라고 기록해주는 것. 여기서 CAS2가 쓰인다.</p>

<p>근데 InterlockedSList는 가난한 시절이라 CAS2 못 쓰고 memory alignment해서 남는 하위 4bit를 count로 쓴 것으로 알고 있다.<br>
(어설픈 기억으로는 MPMC concurrency queue를 lock free algorithm으로 만들 때 CAS 뭔가 잘못써서 aba problem 발생하면 해당 node가 다른 queue로 들어간 시점에도 뭔가 오동작하여 해당 queue까지 파괴했던 시나리오가 있었는데-_-; 자세히 기억이 안 난다.)</p>

<h3><a href="http://www.drdobbs.com/lock-free-data-structures-with-hazard-po/184401890">hazard pointer</a></h3>

<p>오늘 출력해간 논문보다 위 링크가 더 읽기 좋다. 완전 오늘 헛소리한 듯-_- 나중에 다시 자세히 읽어보고 정리하겠음</p>

<p>어쨌든 위 lock free algorithm 설명할 때 node를 언제 해제할 지는 굉장히 골치아픈 문제이다. 아직 어떤 thread가 그 node를 접근하고 있을 수 있는데 마음대로 delete했다가는 access violation이 발생하기 때문. 따라서 이를 안전하게 지울 수 있도록(safe memory reclamation) 여러 방법이 고안되었는데 그 중 하나가 hazard pointer이다.</p>

<h3>환형큐의 concurrency 문제</h3>

<ul>
<li><a href="/2012/02/23/thread-unsafety-problem-in-circular-queue/">환형큐의 thread unsafety 문제</a></li>
</ul>

<h3><a href="/2011/08/11/synchronize-function-execution-in-each-object/">객체별 수행 동기화</a> 글 코드의 문제</h3>

<p><a href="http://blog.fegs.kr/" title="blog.fegs.kr">angdev</a>님의 문제 해결법</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">mJobQueue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">RequestJobPtr</span><span class="p">(</span><span class="k">new</span> <span class="n">_RequestJobImpl</span><span class="p">(</span><span class="n">functor</span><span class="p">)));</span>
<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">mJobQueue</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">InterlockedExchange</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mExclusiveFlag</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">RequestJobPtr</span> <span class="n">job</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span> <span class="n">mJobQueue</span><span class="p">.</span><span class="n">try_pop</span><span class="p">(</span><span class="n">job</span><span class="p">);</span> <span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="o">*</span><span class="n">job</span><span class="p">)();</span>
        <span class="k">delete</span> <span class="n">job</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">InterlockedExchange</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mExclusiveFlag</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h3>과제 풀이법</h3>

<ul>
<li>제빵사와 먹깨비 Actor가 주기적으로 공유자원 Basket을 감지하여 동작하는 방법</li>
<li>제빵사와 먹깨비와 바구니까지 모두 Actor이고 메시지를 잘 주고 받으면서 동기화</li>
<li>제빵사, 먹깨비 Actor가 모두 각자의 thread를 갖고 공유자원 Basket을 blocking-wait하면서 동작</li>
</ul>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">Concurrent Pool (Static Size)</h1>
				<p class="page-date">22 Aug 2011</p>
				<p class="page-tags">
						
						
					<code class="tag">concurrency</code>
						
						
						
					<code class="tag">c++</code>
						
						
						
						
				</p>
				<div class="content"><p>정적인 크기의 Thread-safe한 (Concurrent) Object Pool을 만들어보자.<br>
핵심은 배열을 사용한다는 것. 왜냐하면 여러 thread가 접근해도 자신만의 index 지점을 접근하면 한 지점에 동시에 thread가 접근하면서 발생하는 문제가 없기 때문.</p>

<p>이게 동적으로 크기가 확장되면 배열의 포인터가 무효화되면서 여러 문제가 생길 수 있어 복잡하다. 따라서 정적인 크기라고 고정짓고 이야기를 해보자.</p>

<p>Object Pool은 미리 Object들을 만들어놓고 필요할 때마다 하나씩 꺼내서 쓰겠다는 것이다. 그 이유는 객체 생성과 소멸, 메모리 할당과 해제의 비용이 아깝기 때문.<br>
(때에 따라서 객체의 초기화 비용은 중복될 수도 있다. 다시 사용하기 전에 초기화할 수도 있으니까)</p>

<p>따라서 미리 객체를 일정 개수만큼 만들어놓고, 필요할 때 꺼내서 쓰고, 다시 집어넣어서 <strong>재사용</strong> 가능하게 해주는 기법이 Object Pool 이라고 보면 된다.</p>

<h3>구현과 한계</h3>

<p>일정 크기만큼의 객체 배열을 생성한다. 이 때 여러 Thread가 객체를 하나씩 요구할 때, 공유되는 변수는 index 하나 뿐이다.<br>
즉, 여러 Thread가 객체를 동시에 요청해도, index 값만 원자적으로 증가시켜서 그 index에 위치한 객체만 해당 thread에게 반환한다. 그렇게 되면 index의 객체는 오로지 그 thread에서만 접근이 가능하므로 thread-safe하게 접근할 수 있을 것이다.</p>

<p>말로 설명하니 길고 지루한데, 요약하자면</p>

<ul>
<li>circular queue에서 index를 interlocked으로 증가시켜서 그 지점에 객체를 넣었다 뺐다 할 수 있게 해주면 thread-safe한 object pool이 만들어진다는 것이다.</li>
</ul>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">ObjectPool</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">Pop</span> <span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">element</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="nf">Push</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">element</span><span class="p">);</span>

    <span class="n">LONG</span> <span class="n">Count</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">mCount</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">LONG</span> <span class="n">Size</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">mSize</span><span class="p">;</span> <span class="p">}</span>

    <span class="n">ObjectPool</span> <span class="p">(</span><span class="n">LONG</span> <span class="n">size</span><span class="p">);</span>
    <span class="o">~</span><span class="n">ObjectPool</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="nl">private:</span>
    <span class="n">T</span><span class="o">*</span>   <span class="n">mArray</span><span class="p">;</span>
    <span class="n">LONG</span> <span class="n">mSize</span><span class="p">;</span>
    <span class="n">LONG</span> <span class="n">mCount</span><span class="p">;</span>

    <span class="n">LONG</span> <span class="n">mPushIndex</span><span class="p">;</span>
    <span class="n">LONG</span> <span class="n">mPopIndex</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>생성과 소멸은 객체의 배열의 할당과 해제를 해주면 된다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">ObjectPool</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">ObjectPool</span> <span class="p">(</span><span class="n">LONG</span> <span class="n">size</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">mSize</span> <span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="n">mCount</span> <span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">mPushIndex</span> <span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">mPopIndex</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">mArray</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>
<span class="p">}</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">ObjectPool</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::~</span><span class="n">ObjectPool</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">mArray</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><code>Push</code>와 <code>Pop</code>은 Circular Queue와 동일하다. 다만 index를 증가시키는 부분이 interlocked으로 작성되어있다는 것이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">ObjectPool</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Pop</span> <span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">element</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">InterlockedIncrement</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">mPopIndex</span><span class="p">)</span> <span class="o">%</span> <span class="n">mSize</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_null</span> <span class="p">(</span><span class="n">mArray</span><span class="p">[</span><span class="n">index</span><span class="p">]))</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">element</span> <span class="o">=</span> <span class="n">mArray</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="n">set_null</span> <span class="p">(</span><span class="n">mArray</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">ObjectPool</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Push</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">element</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">InterlockedIncrement</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">mPushIndex</span><span class="p">)</span> <span class="o">%</span> <span class="n">mSize</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_null</span> <span class="p">(</span><span class="n">mArray</span><span class="p">[</span><span class="n">index</span><span class="p">]))</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">mArray</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">element</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><code>Push</code>와 <code>Pop</code>함수가 <code>bool</code>을 반환하는 이유는 Pool의 크기가 정적인 이상 해당 요청이 실패할 수도 있기 때문이다.<br>
<code>T</code>라는 type 자체가 포인터일 경우에는 <code>Pop</code> 함수에서 <code>NULL</code>을 반환하게 한다거나, 아니면 예외를 던지게 하는 방법이 있을 수 있겠지만 별로 둘 다 좋은 방법 같지는 않다는 생각에 <code>bool</code>을 반환하게 했다.</p>

<p>또 하나의 문제는 <code>is_null</code>과 <code>set_null</code> 함수이다. 이 뜬금없는 함수에 대한 구현은 여기서 설명할 수 없는데, 그것은 이 기능이 각 type 마다 다르기 때문이다.<br>
만약 <code>T</code>가 포인터 type이라면 위 문제는 간단해진다. <code>is_null</code> 함수는 그 지점이 <code>NULL</code>인지만 비교하면 되고, <code>set_null</code> 함수는 그 지점에 <code>NULL</code>을 넣어주면 되니까.</p>

<p>하지만 그냥 객체이면 문제가 좀 복잡해지는데, 저걸 설정해줄 수 있도록 <code>T</code> 자체가 기능을 포함하는 건 어불성설이고, 아마도 <code>T</code>에 대한 proxy 객체를 쓰든지 해서 해당 지점이 유효한지, 유효하지 않은지를 관리하도록 하는게 좋을 것 같다.</p>

<p>아니면 bool array를 크기만큼 하나 더 만들어서 그 지점에 데이터가 이미 있는지 없는지를 검사하게 하는 것도 방법일 수도 있겠다.</p>

<p>위와 같은 2가지 방법은 완벽한 해결책이 될 수 없다. 왜냐하면 Thread 1이 <code>Push</code>를 해서 해당 지점에 객체를 반환하고, bool 값을 update하기 직전에, Thread 2가 <code>Pop</code>을 요청했는데 그 지점이라면 값을 가져갈 수가 없기 때문이다. (아직 bool 값이 갱신되지 않았으니까.)<br>
그런데 이 문제는 T가 포인터일 때 NULL을 대입하고 검사하는 과정에서도 <code>Push</code>와 <code>Pop</code>이 빈번하다면 발생할 수 있을 것 같다.</p>

<p>이를 해결하려면 더욱 첨예한 알고리즘을 사용해야하는데 이에 대해서는 고민을 좀 더 해봐야겠다.</p>

<h3>결론</h3>

<p>Circular Queue를 이용하여 Concurrent Object Pool을 간단하게 구성해보았다. 하지만 유효성 검사 한계 때문에 일반 객체에 대해서는 사용하지 못하고 포인터에 대해서만 사용 가능할 것 같다.</p>

<p>그나마도 Push와 Pop을 빈번하게 할 경우 문제가 발생할 수 있으니 좀 더 고민해서 좋은 구조를 만들어보자.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">context switching과 simultaneously 실행</h1>
				<p class="page-date">02 Aug 2011</p>
				<p class="page-tags">
						
						
					<code class="tag">concurrency</code>
						
						
						
						
				</p>
				<div class="content"><p>multi thread (or process) programming에서 가장 기초적인 개념으로 ABA Problem과 연결(되나?) 되는 기본적인 개념을 설명하고자 한다. <strong>한 개의 코어는 한 시점에 한 개의 명령을 수행한다!</strong> 라는 기본 전제를 깔고 이야기를 시작해보려 한다.</p>

<h3>context switching</h3>

<p>태초 단일 코어(core) 시대에는 한 개의 프로그램만 실행하면 됬다. 그게 OS든 그냥 프로그램이든. 여러 개의 프로그램을 동시에? 그런 사치 따위 없다. 그냥 하나라도 빨리 수행하면 그만.</p>

<p>그러다가 cpu가 발달하고 느린 작업, 빠른 작업, 사용자 반응성(interact)이 중요한 작업, 그렇지 않은 작업 들에 대해서 분리해서 한 번 같이 실행해볼까 하는 시도가 나왔다. (물론 처음에는 묶어서batch 작업을 처리했던가)<br>
그래서 출력하면서 문서 편집을 할 수 있다는, ABABABABABAB를 빨리해서 A와 B가 동시에 실행되는 것 처럼 보이는 좋은 구조가 나타났다.</p>

<p>그렇게 여러 개의 프로세스(프로그램이 실행되고 있는 것)가 짧은 간격으로 번갈아가며 수행하니 동시에 실행되는 것 같아 참으로 보기 좋았다. 그런데 문제는 메모리 공간이 모자르기 시작했다. 그래서 각 프로세스 별로 <a href="http://en.wikipedia.org/wiki/Virtual_memory">메모리 공간을 가상화</a>해주고, 그것들을 실제 메모리에 연결해주는 메모리 매핑을 운영체제가 지원해주었다.</p>

<p>이제 운영체제는 CPU를 제어하여 여러 프로세스들을 번갈아가며 빠르게 실행해주고, 메모리를 관리하여 부족한 공간은 디스크에 적당히 연결해서 사용(swap memory)할 수 있게 해주었다.</p>

<p>물론 각 프로세스는 자신의 수행이 중단되고 다른 프로세스가 작업을 재개(context switching) 하는지, 자신이 사용하는 메모리가 물리 메모리(physical memory)에 있는지 이게 아니면 swap out되어서 disk 에 있는지 몰라도 크게 상관이 없었다.</p>

<p>메모리 이야기는 다른 곳에서 또 하겠지만, 어쨌든 이 글의 주제인 CPU scheduling만 본다면, 하나의 core는 결국 한 순간에 하나의 명령만 수행할 수 있고 여러 프로세스를 돌아가면서 수행해봐야 엄밀히 따지면 그 프로세스들이 동시(simultaneously)에 실행된다고 볼 수는 없다는 것이다.</p>

<p><span style="color: #888;">간단히 말하자면, 내가 만든 프로그램을 CPU 가 실행 중인 바로 그 때는 운영체제 코드가 실행될 수 없다, 컴퓨터는 지금 실행하는 코드가 무슨 코드인지 관심 없고 그냥 program counter가 가리키는 기계어를 읽어서 처리할 뿐이다. 지금 수행하고 있는 프로세스를 제치고 운영체제 코드가 수행되려면 interrupt 가 일어나야한다(preempt). 물론 실행 가능한 명령과 그렇지 않은 명령에 대한 권한은 그 기계어가 있는 메모리 영역에 대한 segment의 특성attribute 으로 설정가능하다.</span></p>

<h3>multi thread programming</h3>

<p>각 프로세스들은 자신의 실행 흐름을 갖는다. multi thread라는 개념이 없을 때, 각 프로세스는 단 한 개의 주 실행흐름(main thread)를 가지고, 이것이 cpu에 의해서 실행되었다.</p>

<p>cpu에서 실행하기 위해 필요한 정보들, 즉 실행 문맥(state, context)은 register 등을 생각해보면 되겠다. 어차피 현재 CPU가 수행하고 있는 정보들은 PC(IR), EA...DX, ESI, EDI, EBP, ESP 등(x86) 다 register에 저장되어있으니까 이 값만 잘 저장했다가, 나중에 복구해주면 거기서 이어서 작업을 수행할 수 있을 것이다. 즉 여러 실행 흐름을 번갈아가면서 실행한다는 것은, 각 실행 흐름(thread)의 문맥(context)을 저장해놨다가, 그걸 번갈아가며 register에 덮어쓰고 그 지점(PC)의 코드를 이어서 실행시키게 한다는 것이다. <a href="http://en.wikipedia.org/wiki/Context_switch">context switch</a></p>

<p>그러면, 굳이 하나의 프로세스마다 하나의 실행 흐름만 있을 필요가 있나? 그래서 하나의 프로세스가 여러 실행 흐름(thread)을 갖는 multi thread programming이 나오게 됬다(억지다!)<br>
즉, 내부에서 메모리는 공유(static, heap 영역)하지만 cpu scheduling은 따로 되어서 실행 흐름은 서로 영향을 안 주는 것이라고 볼 수 있다.</p>

<p>억지 예제를 들자면, 테트리스를 짠다고 할 때, 키 입력을 blocking io 함수인 scanf 로 받는다고 하면, enter key를 눌러서 stream을 flush 하기 전까지 프로그램 수행은 멈춘다. 이를 위해서 키 입력을 받는 thread와 게임 logic을 돌리는 thread 를 분리할 수 있을 것이다.
(물론 테트리스를 만든다면 <code>GetAsyncKeyboardState</code> 같은 non blocking 함수를 쓰는게 나을 것 같다)</p>

<p>아무튼, 이렇게 하나의 프로세스에서 여러 스레드가 수행된다면, core는 그 thread들의 수행을 중간에 끊어서 다른 thread 로 전환(context switching) 할 수 있기 때문에 프로그램을 짤 때 각별히 주의해야한다.</p>

<p>왜냐하면 C++ 코드의 한 줄은 기계어가 한 번에 실행할 수 있는 하나의 명령, 즉 1:1 관계가 아니기 때문에 그 명령 내부에서 context switching이 발생하면 문제가 생길 수 있기 때문이다.</p>

<p>물론 lock을 사용하여 배타적 구간을 만드는 방식으로 프로그램을 작성한다고 해도 이러한 thread 간에서 서로 lock을 획득하다 발생할 수 있는 dead (or live) lock 문제가 발생할 수도 있다.<br>
따라서 multi thread programming 을 할 때는 이러한 문제까지 고려하여 더욱 세심하게 프로그래밍을 해야한다. <a href="http://en.wikipedia.org/wiki/ABA_problem">ABA Problem</a></p>

<h3>simultaneously</h3>

<p>위의 개념은 엄밀히 동시에 실행된다고 할 수 없다. 하나의 core가 context switching을 하면서 수행해주는 것이기 때문에 하나가 수행하고 있으면 다른 하나는 멈춰있는 상태라는 것이니까.</p>

<p>하지만 시간은 흐르고 multi-core 시대가 되었다. 이제 ABABABAB 시대는 막을 내리고 AAAA와 BBBB가 문자 그대로 동시(simultaneously)에 실행되는 시대가 온 것이다.</p>

<p>한 thread에서 context switching이 일어날 때와 여러 core에서 여러 thread가 동시에 수행될 때 발생하는 문제는 대동소이하다. 다만 차이가 있다면,</p>

<ul>
<li><p>lock을 사용할 때, 단일 core의 경우 어떤 프로세스가 lock을 획득하지 못할 경우 그냥 해당 lock의 wait queue에 들어가서 scheduling 대상에서 빠지는 것이 더 효율적일 수 있다. 왜냐하면 spin lock처럼 cpu를 소모하면서 기다려봤자 자신의 수행이 다른 thread로 switching되기 전에는 lock을 획득할 일이 없기 때문이다.  </p>

<p>multi core에서 동시에 실행된다면, spin lock으로 기다리는게 유리하다. 물론 lock 구간이 길지 않을 때이다. 한 core에서 실행 중인 thread가 lock을 획득하기 위해 spin하고 있으면, 다른 core에서 수행 중인 lock을 얻은 thread가 그 구간을 수행하고 unlock을 하면 spin하던 thread가 바로 그 구간을 실행할 수 있기 때문이다.<br>
번거롭게 커널의 lock wait queue에 들어가서 sleep했다가 다시 wake up해주는 무거운 방법(semaphore)을 쓸 필요가 없다</p></li>
<li><p>연산에 대한 lock operation을 수행할 때 단일 core의 수행만 보호해주는 것이 아니라 다른 core까지도 보호를 해주어야 한다. 예를 들어 다음의 명령이 있다.</p></li>
</ul>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">count</span><span class="p">]</span>
<span class="n">add</span> <span class="n">eax</span><span class="p">,</span> <span class="mi">1</span>
<span class="n">mov</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">count</span><span class="p">],</span> <span class="n">eax</span>
</code></pre></div>
<p>이 명령을 단일 core에서 수행한다면 저 명령 3줄을 실행하는 동안 context switching을 못하게 하면 그만이다. 하지만 여러 core에서 수행된다면 thread A가 <code>add eax, 1</code>을 수행하는 와중에 thread B가 mov <code>eax, dword ptr [count]</code>를 수행해버릴 수 있다.
뭐 spin lock 등을 걸어서 저 명령어 수행의 배타성을 보장해줘도 되지만 그건 너무 비싸다. 그래서 하드웨어 설계하시는 아저씨들이 열심히 고민을 해서 lock operation이라는걸 만들었다.</p>

<p>왜냐하면 cpu는 자신이 수행해야할 명령어를 instruction cache에 넣어두고 수행을 하게 되는데, thread A의 저 3줄이 다 끝나기 전에 thread B를 수행하는 core의 instruction cache에 저 명령이 들어가면 안된다. 하지만 그걸 cpu 가 알 수 있나? 그냥 thread A에서 저 명령을 수행할 때 lock operation이면 다른 cpu의 instruction cache를 비워버릴 수 밖에. 그래서 내부적으로 lock operation을 사용하는 interlocked operation 함수들이 비싸다는 거다.<br>
(하지만 뭐 다른 뾰족한 수가 없다, single core 에서는 context switching 을 유발하는 timer interrupt 를 강제로 막아버려서 thread-safe 하게 수행을 이어나가는 방법도 있지만-_-)</p>

<p>물론 multi core에서도 하나의 core가 여러 thread를 수행하게 되면 내부에서 context switching이 발생한다. 코드가 동시에 실행될 수도 있고, 실행 문맥이 전환될 수도 있는 것이다.</p>

<p>결론은 이러한 프로그래밍을 더 이상 피할 수 없는 시대에 왔으며-_- (그래서 과목도 생긴지 좀 되었다!)  이에 대해 잘 공부하여 이로 인해 발생할 수 있는 문제를 잘 회피하자는 것이다. 편하다고 single thread만 고려해서 작성하다 보면 나중에 나처럼 망한다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">Interlocked Singly Linked Lists</h1>
				<p class="page-date">03 Aug 2011</p>
				<p class="page-tags">
						
						
					<code class="tag">concurrency</code>
						
						
						
						
				</p>
				<div class="content"><p>Concurrent Data Structure는 Lock을 최소화하여 동작해야 multi thread에서 해당 자료구조에 접근할 때 발생하는 부담이 최소화되어 효율적인 프로그래밍이 가능하다.</p>

<p>여러가지 방법이 있겠지만, 가장 간단한(?) Windows API로 제공되는 <a href="http://msdn.microsoft.com/en-us/library/ms684121.aspx">Interlocked Singly Linked Lists</a>에 대해 보자. (이후 SLIST 라고 이야기하겠다)</p>

<p>SLIST는 단방향(singly) Linked List로 구성된 Stack이다. MSDN 을 보면 non blocking atomic 동기화 알고리즘으로 쓰면 성능 향상에 도움이 되고 multi thread에서 사용해도 문제가 없댄다. 아무튼 이래 저래 좋다고 한다.</p>

<p>일단 SLIST 의 사용법을 보기에 앞서 2가지만 짚고 넘어가자.</p>

<h3>왜 Stack 일까?</h3>

<p>정확한 이유는 모르겠는데, 다음의 이유로 무리한 추측을 해보자.</p>

<ol>
<li><p>Stack이면 가장 최근에 Push했던 것이 가장 먼저 Pop된다. 즉, 굳이 멀고 먼 Memory까지 안 가도 Cache에서 적중되어 가져올 수 있는 확률이 있다. 그런데 multi thread에서 안전하게 돌아가기 위한 lock operation을 쓴다는 것은 결국 메모리에 내용이 바로 반영되야한다니까 cache 이야기는 좀 아닌 것 같다.</p></li>
<li><p>Queue는 Concurrent Data Structure 알고리즘 구현이 Stack에 비해 복잡하다. Stack은 관리해줘야할 공유 변수가 하나(Stack Pointer)이지만 Queue 는 2개(Head, Tail)이다. 그런데 똑똑한 MS 양반들이 Queue가 더 복잡하다고 해서 안 해놨을 것 같지는 않다.</p></li>
<li><p>Stack으로도 충분했다. 굳이 Queue까지 API로 제공하지 않아도 Stack만으로도 Queue나 다른 자료구조를 구현해서 쓸 수는 있다. 그럼 왜 하필 Stack을 만들어놨을까? 누가 좀 알려주세요 [...]</p></li>
</ol>

<p>찾아보면 <a href="http://alexkr.com/memos/16/non-blocking-singly-linked-list/">SLIST 기반으로 Queue처럼 쓰는 예제</a> 도 있다.</p>

<h3>왜 Memory Alignment 이야기가 나올까?</h3>

<p>MSDN을 보면 모든 항목들은 <code>MEMORY_ALLOCATION_ALIGNMENT</code>로 정렬되어있어야 한다고 써있다.</p>

<blockquote>
<p>All list items must be aligned on a MEMORY_ALLOCATION_ALIGNMENT boundary</p>
</blockquote>

<p>그 이유는 아마도 CPU가 해당 메모리 값을 가져와서 lock operation을 수행할 때 이게 적절치 못하게 메모리에 걸쳐 있으면 한 번에 Fetch를 할 수가 없기 때문일 것이다.</p>

<p>SLIST에서는 SLIST_ENTRY라는 객체를 사용하는데 이걸 메모리에서 가져와서 CPU가 lock operation 걸고 원자적으로 변경을 수행하면서 thread safe하게 작업하는 것이다. CPU는 MEMORY_ALIGNMENT단위로 메모리로부터 값을 가져와서 처리할 수 있는데, 만약 그 값이 4라고 해보자.</p>

<p>즉, CPU가 메모리 주소 4 단위로 읽을 수가 있다. 그런데 저 SLIST_ENTRY 값이 오묘하게 메모리 주소 3부터 6까지 (3, 4, 5, 6) 4 Bytes 가 존재한다고 하면, CPU는 저걸 한 번에 가져와서 작업을 수행할 수가 없다. 적어도 0 ~ 3까지 1번(0, 1, 2, 3), 그리고 4 ~ 7까지 1번(4, 5, 6, 7) 총 2번 8Bytes를 가져온 다음에 3부터 6까지의 Bytes를 추려서 작업에 임해야 한다.</p>

<p>그래서 SLIST를 사용할 때는 각 항목들을, 즉 각 항목들의 메모리 주소를 정렬해야한다는 것이다.</p>

<p><em>(추후 추가하자면 위 내용은 좀 잘못되었다. 실제로 bus size만 놓고 생각한다면 <code>MEMORY_ALLOCATION_ALIGNMENT</code> 값처럼 큰 값으로 정렬을 요구할 필요가 없다. 오히려 DCAS 부재로 인한 ABA problem을 막기 위한 주소bit의 추가 공간 확보가 더 정확한 설명일 것이다.)</em></p>

<p>갑자기 항목에서 왜 항목의 주소로 넘어가는지는 SLIST_ENTRY 구조체 속을 들여다보면 알 수 있다.
WinNT.h 파일에 보면 SLIST_ENTRY type 은 아래와 같이 정의되어 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_SINGLE_LIST_ENTRY</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">_SINGLE_LIST_ENTRY</span> <span class="o">*</span><span class="n">Next</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SINGLE_LIST_ENTRY</span><span class="p">,</span> <span class="o">*</span><span class="n">PSINGLE_LIST_ENTRY</span><span class="p">;</span>
<span class="cp">#define SLIST_ENTRY SINGLE_LIST_ENTRY</span>
</code></pre></div>
<p>즉, 각 항목이라는 것은 결국 내부에서 다음 node를 가리키는 주소를 포함한다. 왜냐하면 singly linked list이니까.<br>
그러면 저 Next 변수는 CPU 가 lock operation 을 통해 한 번에 작업을 수행해야 하므로 MEMORY_ALIGNMENT되어 있어야 한다. 그런데 저기(Next)에 들어가는 값이 다음 항목의 메모리 주소이고, 또 그 다음 항목의 Next 변수를 가지고 CPU가 작업을 해야하니까 그 Next 변수를 갖는 SLIST_ENTRY도 메모리 정렬이 되어있어야 한다.</p>

<p>따라서 모든 항목의 주소가 메모리 정렬 되어있어야 하는 것이다.</p>

<p>역시 WinNT.h 파일에 보면,</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#if defined(_WIN64) || defined(_M_ALPHA)</span>
<span class="cp">#define MAX_NATURAL_ALIGNMENT sizeof(ULONGLONG)</span>
<span class="cp">#define MEMORY_ALLOCATION_ALIGNMENT 16</span>
<span class="cp">#else</span>
<span class="cp">#define MAX_NATURAL_ALIGNMENT sizeof(DWORD)</span>
<span class="cp">#define MEMORY_ALLOCATION_ALIGNMENT 8</span>
<span class="cp">#endif</span>
</code></pre></div>
<p>와 같이 <code>MEMORY_ALLOCATION_ALIGNMENT</code> 값이 정의되어 있음을 볼 수 있다.</p>

<h3>어떻게 사용하나?</h3>

<ul>
<li>먼저 Stack의 Head를 <code>InitializeSListHead</code> 함수로 초기화해야한다.</li>
<li>그리고 Push(<code>InterlockedPushEntrySList</code>)와 Pop(<code>InterlockedPopEntrySList</code>)을 수행한다.</li>
<li><code>InterlockedFlushSList</code> 함수가 있다. 이는 Stack 에 들어있는 모든 Node 를 반환하는 함수다. 이 함수를 수행하면 Head 는 초기화된다. 즉 빈 Stack 이 된다.</li>
<li>이 외에 개수를 세는 <code>QueryDepthSList</code>까지 있다.</li>
</ul>

<p>아무튼 다 MSDN 에 예제까지 친절히 나와있으므로 자세한 설명은 생략한다.</p>

<p><code>SLIST_ENTRY</code> 항목들의 메모리 주소는 정렬되어야 한다. 이를 일단 SLIST로 관리해야할 Node들이 <code>SLIST_ENTRY</code> 객체를 멤버로 가져야하고, SLIST_ENTRY 멤버 변수들의 주소는 <code>MEMORY_ALLOCATION_ALIGNMENT</code> 값으로 정렬 되어있어야 한다.</p>

<p>가장 간단한 방법은 다음과 같다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="n">MyItem</span>
<span class="p">{</span>
    <span class="n">SLIST_ENTRY</span> <span class="n">ListEntry</span><span class="p">;</span>
    <span class="c1">// Other Variables</span>
<span class="p">};</span>
</code></pre></div>
<p>첫 번째 멤버 변수로 넣어준다. 그리고 MyIem 을 할당할 때 내부에서 <a href="http://msdn.microsoft.com/en-us/library/8z34s9c6.aspx"><code>_aligned_malloc</code></a> 와 같은 함수로 할당해주면 MyItem 의 주소가 정렬되니까 첫 번째 멤버 변수인 ListEntry (SLIST_ENTRY) 의 주소도 정렬된다(같은 값이니까)</p>

<p>같은 방법인데, 저걸 상속으로 표현하자는 사람도 있다. 상속하면 Base Type 의 멤버들이 메모리의 가장 위 쪽으로 올라가니까. 하지만 그게 모든 컴파일러에서 보장되도록 표준화되어있는 내용은 아닌 것으로 알고 있으니까 글쎄, 좋을지는 모르겠다.</p>

<p>이와 같은 이유로, virtual function pointer table 을 갖는 class type 에서 SLIST_ENTRY 을 멤버로 넣어 사용할 경우, 과연 이 변수를 정렬하기 위해서는 어떻게 해야할까 고민이 좀 되는데, 그냥 그러지 말자고 하고 싶다-_-</p>

<p>아무튼 저렇게 만들어놓고 꺼내서 쓸 때는 단순히 casting 만 해서 쓰면 되니까 편하다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">MyItem</span><span class="o">*</span> <span class="n">item</span> <span class="o">=</span> <span class="p">(</span><span class="n">MyItem</span><span class="o">*</span><span class="p">)</span> <span class="n">InterlockedPopEntryList</span> <span class="p">(</span><span class="n">listHead</span><span class="p">);</span>
</code></pre></div>
<p>궁금할 것 같은 내용은 위에서 다 풀어 써놨으니까 간략한 예제를 보자. 예제는 <a href="http://msdn.microsoft.com/en-us/library/ms686962.aspx">MSDN: Using Singly Linked List</a>에 있다.</p>

<p>먼저 <code>LIST_HEADER</code>를 만들어줘야한다. 이는 사용할 SLIST의 Head 포인터이다. 당연한 이야기이지만 이것도 메모리 정렬이 되어야 한다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">pListHead</span> <span class="o">=</span> <span class="p">(</span><span class="n">PSLIST_HEADER</span><span class="p">)</span><span class="n">_aligned_malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">SLIST_HEADER</span><span class="p">),</span>
       <span class="n">MEMORY_ALLOCATION_ALIGNMENT</span><span class="p">);</span>
</code></pre></div>
<p><code>PROGRAM_ITEM</code>이라는 구조체가 첫 번째 멤버 변수로 <code>SLIST_ENTRY</code>를 갖는다. 따라서 <code>PROGRAM_ITEM</code> 객체의 메모리 주소만 정렬해주면 된다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">pProgramItem</span> <span class="o">=</span> <span class="p">(</span><span class="n">PPROGRAM_ITEM</span><span class="p">)</span><span class="n">_aligned_malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">PROGRAM_ITEM</span><span class="p">),</span>
            <span class="n">MEMORY_ALLOCATION_ALIGNMENT</span><span class="p">);</span>
</code></pre></div>
<p>꺼내서 쓸 때는 어차피 <code>SLIST_ENTRY</code>의 주소가 곧 <code>PROGRAM_ITEM</code>의 주소이므로 casting만 해서 쓰면 된다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">pListEntry</span> <span class="o">=</span> <span class="n">InterlockedPopEntrySList</span><span class="p">(</span><span class="n">pListHead</span><span class="p">);</span>
<span class="n">pProgramItem</span> <span class="o">=</span> <span class="p">(</span><span class="n">PPROGRAM_ITEM</span><span class="p">)</span><span class="n">pListEntry</span><span class="p">;</span>
</code></pre></div>
<h3>정리</h3>

<p>이러한 구조가 어디에서 쓰일까. multi thread 에서 접근해야하는 자료구조일 경우 쓰이겠다. 예를 들면,</p>

<ul>
<li>작업 queue</li>
<li>log queue</li>
<li>메모리 관리자</li>
</ul>

<p>queue 시리즈야 예제에서 이미 봤고, 메모리 관리자 이야기를 잠깐 해보자.</p>

<p>재활용이 가능한 메모리들이 있다. 이런 것들을 pool 형태로 관리하여 할당 부담을 줄이고 단편화를 줄이기 위한 관리자를 만든다고 하자. 자원 할당은 여러 thread에서 접근해야하니까 병목 지점이고, 이 때문에 lock은 최대한 적게 썼으면 좋겠다.<br>
그러니까 미리 지정된 크기만큼 메모리를 다 할당해서(보통 크게 할당해서 쪼개놓고) SLIST에 다 넣어둔다. 그리고 요청할 때마다 하나씩 Pop해서 쓰게 해준다.</p>

<p>뭐 어떤 이야기에 따르면, 다 쓰고 Push한걸 다음에 바로 Pop을 하면 이 메모리가 아직 cache에 남아있어서 바로 hit되어 빠르게 사용할 수 있다는 좋은 이야기가 있는데 이게 얼마나 효용이 좋은지도 모르겠고, 그리고 Windows Vista부터는 LFH(Low Fragmentation Heap)이 기본 Heap이라서 저 작업이 뻘짓이라는 이야기도 있다.</p>

<p>결론이 좀 이상해졌는데 아무튼 Windows API가 제공해주는 SLIST를 사용하여 multi thread 환경에서 보다 빠른 프로그램을 작성할 수 있다니까 믿고 써보자.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">producer/consumer model 구현</h1>
				<p class="page-date">12 Aug 2013</p>
				<p class="page-tags">
						
						
					<code class="tag">concurrency</code>
						
						
						
					<code class="tag">c++</code>
						
						
						
					<code class="tag">study</code>
						
						
						
						
				</p>
				<div class="content"><p>먹깨비 과제를 풀어보자. 여러 가지 구현법이 있을 것인데, 나는 간단하게</p>

<ul>
<li>바구니는 공유 자원이니 lock으로 보호하고,</li>
<li>제빵사와 먹깨비는 actor로 만들어서 매 tick마다 상황 판단 후 작업을 처리하도록 했다.</li>
</ul>

<p>따라서 공유 자원을 보호하기 위한 <code>spin_lock</code>과 actor 기반 코드를 만들었고 그 기반으로 바구니, 제빵사, 먹깨비를 만들었다.</p>

<p>먼저 <code>spin_lock</code>을 만들어보자. 이전 글에서 몇 번 설명한적 있으니 대충 보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">spin_lock_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">spin_lock_t</span><span class="p">()</span> <span class="p">{</span> <span class="n">_flag</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">acquire</span><span class="p">()</span> <span class="p">{</span> <span class="k">while</span> <span class="p">(</span><span class="n">_flag</span><span class="p">.</span><span class="n">test_and_set</span><span class="p">());</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">release</span><span class="p">()</span> <span class="p">{</span> <span class="n">_flag</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span> <span class="p">}</span>
<span class="nl">private:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">atomic_flag</span> <span class="n">_flag</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">spin_lock_raii_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">explicit</span> <span class="kt">spin_lock_raii_t</span><span class="p">(</span><span class="kt">spin_lock_t</span><span class="o">&amp;</span> <span class="n">lock</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_lock</span><span class="o">-&gt;</span><span class="n">acquire</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="kt">spin_lock_raii_t</span><span class="p">(</span><span class="kt">spin_lock_raii_t</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">_lock</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">_lock</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">other</span><span class="p">.</span><span class="n">_lock</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="kt">spin_lock_raii_t</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_lock</span> <span class="o">!=</span> <span class="n">nullptr</span><span class="p">)</span>
            <span class="n">_lock</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span>
    <span class="p">}</span>
<span class="nl">private:</span>
    <span class="kt">spin_lock_raii_t</span><span class="p">(</span><span class="k">const</span> <span class="kt">spin_lock_raii_t</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="kt">spin_lock_raii_t</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">spin_lock_raii_t</span><span class="o">&amp;</span><span class="p">);</span>
<span class="nl">private:</span>
    <span class="kt">spin_lock_t</span><span class="o">*</span> <span class="n">_lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">_lockCount</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">spin_lock_support_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">spin_lock_raii_t</span> <span class="n">lock</span><span class="p">(</span><span class="kt">int</span> <span class="n">lock_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">spin_lock_raii_t</span><span class="p">(</span><span class="n">_lock</span><span class="p">[</span><span class="n">lock_index</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="nl">private:</span>
    <span class="kt">spin_lock_t</span> <span class="n">_lock</span><span class="p">[</span><span class="n">_lockCount</span><span class="p">];</span>
<span class="p">};</span>
</code></pre></div>
<ul>
<li><code>spin_lock</code> 자체는 <code>atomic_flag</code>를 사용하여 간단히 만들었다.</li>
<li><code>spin_lock_raii</code>는 <code>spin_lock</code>을 가지고 생성자/소멸자에서 <code>acquire</code>, <code>release</code>해주는 raii class이다.</li>
<li>그리고 <code>spin_lock_support</code>를 만들어서 lock이 필요한 class에서 이를 상속받아 사용할 수 있도록 코드를 작성하였다. 상황에 따라 lock을 여러 개 사용할 수도 있으므로 lock 개수를 template 인자로 받도록 하였다.</li>
</ul>

<p>이를 사용하여 구현한 바구니(basket)은 다음과 같다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">basket_t</span> <span class="o">:</span> <span class="k">public</span> <span class="kt">spin_lock_support_t</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">basket_t</span><span class="p">()</span> <span class="o">:</span> <span class="n">_bread_count</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_bread_count</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">add</span><span class="p">()</span> <span class="p">{</span> <span class="o">++</span><span class="n">_bread_count</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">sub</span><span class="p">()</span> <span class="p">{</span> <span class="o">--</span><span class="n">_bread_count</span><span class="p">;</span> <span class="p">}</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">_bread_count</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>lock을 여러 개 사용할 필요가 없으니 <code>spin_lock_support</code>의 template 인자를 1로 지정하여 사용하였다. 이제 다른 actor에서 바구니를 접근할 때에는 다음과 같이 사용할 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="n">locker</span> <span class="o">=</span> <span class="n">basket</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="n">basket</span><span class="p">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">20</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
<span class="n">basket</span><span class="p">.</span><span class="n">add</span><span class="p">();</span>
</code></pre></div>
<p>이제 actor를 만들어보자. ppl의 <code>concurrent_queue</code>는 너무 느려서 actor model의 mpsc queue를 구현하는데 적합하지 않은 것 같다. 따라서 <code>InterlockedSList</code>를 사용하여 간단히 구현해 보았다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="kt">message_t</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">actor_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">actor_t</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">_job_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">InitializeSListHead</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_queue_head</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">post</span><span class="p">(</span><span class="kt">message_t</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="kt">job_entry_t</span> <span class="o">:</span> <span class="k">public</span> <span class="n">SLIST_ENTRY</span> <span class="p">{</span>
            <span class="kt">message_t</span> <span class="n">message</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="kt">void</span><span class="o">*</span> <span class="n">entry_memory</span> <span class="o">=</span> <span class="n">_aligned_malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">message_t</span><span class="p">),</span> 
            <span class="n">MEMORY_ALLOCATION_ALIGNMENT</span><span class="p">);</span>
        <span class="kt">job_entry_t</span><span class="o">*</span> <span class="n">entry</span> <span class="o">=</span> <span class="k">new</span> <span class="p">(</span><span class="n">entry_memory</span><span class="p">)</span> <span class="kt">job_entry_t</span><span class="p">;</span>
        <span class="n">entry</span><span class="o">-&gt;</span><span class="n">message</span> <span class="o">=</span> <span class="n">message</span><span class="p">;</span>

        <span class="kt">bool</span> <span class="n">victim</span> <span class="o">=</span> <span class="n">_job_count</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">InterlockedPushEntrySList</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_queue_head</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">victim</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

        <span class="kt">int</span> <span class="n">process_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">do</span> <span class="p">{</span>
            <span class="n">PSLIST_ENTRY</span> <span class="n">local_head</span> <span class="o">=</span> <span class="n">InterlockedFlushSList</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_queue_head</span><span class="p">);</span>
            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">message_t</span><span class="o">&gt;</span> <span class="n">messages</span><span class="p">;</span>
            <span class="n">messages</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span>

            <span class="n">PSLIST_ENTRY</span> <span class="n">it</span> <span class="o">=</span> <span class="n">local_head</span><span class="p">;</span>
            <span class="n">PSLIST_ENTRY</span> <span class="n">next</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">next</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>

                <span class="kt">job_entry_t</span><span class="o">*</span> <span class="n">each_entry</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">job_entry_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
                <span class="n">messages</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">each_entry</span><span class="o">-&gt;</span><span class="n">message</span><span class="p">);</span>

                <span class="n">each_entry</span><span class="o">-&gt;</span><span class="kt">job_entry_t</span><span class="o">::~</span><span class="kt">job_entry_t</span><span class="p">();</span>
                <span class="n">_aligned_free</span><span class="p">(</span><span class="n">each_entry</span><span class="p">);</span>
                <span class="n">it</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">messages</span><span class="p">.</span><span class="n">rbegin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">messages</span><span class="p">.</span><span class="n">rend</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
                <span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">)();</span>
            <span class="n">process_count</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">messages</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
        <span class="p">}</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">_job_count</span><span class="p">.</span><span class="n">fetch_sub</span><span class="p">(</span><span class="n">process_count</span><span class="p">)</span> <span class="o">!=</span> <span class="n">process_count</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_SubTy</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">post</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="n">_SubTy</span><span class="o">::*</span><span class="n">method</span><span class="p">)())</span> <span class="p">{</span>
        <span class="n">_SubTy</span><span class="o">*</span> <span class="n">sub_instance</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">_SubTy</span><span class="o">*&gt;</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
        <span class="n">post</span><span class="p">([</span><span class="n">sub_instance</span><span class="p">,</span> <span class="n">method</span><span class="p">]</span> <span class="p">()</span> <span class="p">{</span> <span class="p">(</span><span class="n">sub_instance</span><span class="o">-&gt;*</span><span class="n">method</span><span class="p">)();</span> <span class="p">});</span>
    <span class="p">}</span>
<span class="nl">private:</span>
    <span class="n">SLIST_HEADER</span> <span class="n">_queue_head</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">atomic_int</span> <span class="n">_job_count</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>원리는 간단하다.</p>

<ul>
<li>수행할 작업을 <code>void ()</code> 형태로 받아서 <code>InterlockedSList</code> 기반의 queue에 넣는다.</li>
<li>그리고 처음 queue에 넣는 thread를 victim으로 삼아서 queue 내에 들어있는 작업들을 계속 처리하도록 한다.</li>
<li>이 때 절묘한 타이밍으로 queue에 넣은 작업이 처리될 수 없는 문제를 해결하기 위해 <code>_job_count</code>로 처리 구간을 보장해준다.</li>
</ul>

<p>template 인자를 받는 <code>post()</code> 함수는 이 actor를 상속받은 하위 class들의 member function pointer를 받아서 this에 대해 <code>post()</code> 함수를 호출해주는 helper function이다. 이 helper function이 있으면 다음과 같이 간결하게 <code>post()</code>를 호출할 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">eater_t</span> <span class="n">eater</span><span class="p">;</span>
<span class="n">eater</span><span class="p">.</span><span class="n">post</span><span class="p">(</span><span class="o">&amp;</span><span class="kt">eater_t</span><span class="o">::</span><span class="n">act</span><span class="p">);</span>
</code></pre></div>
<p><code>post()</code>가 가능한 actor 기반을 만들었으니, 이를 기반으로 주기적인 작업을 수행하기 위한 interface를 정의해보자. 간단히 다음과 같이 <code>tick_actor_t</code>를 선언하였다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">tick_actor_t</span> <span class="o">:</span> <span class="k">public</span> <span class="kt">actor_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">act</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p><code>tick_actor_t</code> class는 주기적으로 <code>act()</code> 함수가 불려져서 뭔가 지속적인 작업을 처리할 수 있도록 하는 의미를 지닌 interface이다.</p>

<p>그러한 방식으로 구현이 되려면 다음의 개념이 필요하다.</p>

<ul>
<li>누가(어떤 thread가) 해당 actor를 도맡아서 주기적으로 <code>act()</code> 함수를 불러주는가?</li>
</ul>

<p>결국 thread를 관리하고, 각 thread에게 (대충) 공평하게 actor를 분배하고, 각 thread는 담당하는 actor를 처리하는 구조를 작성하여야 한다. 이에 대해서는 다음과 같은 개념으로 구현을 하였다.
* <em>시나리오</em>를 통해 어떤 actor가 등장할지 각 thread에게 전달된다.
* 각 <em>일꾼(worker-thread)</em>들은 시나리오를 보고 자기가 담당해야 할 역할(actor)을 기억한다.
* 각 <em>일꾼(worker-thread)</em>들은 자기가 연기할 대상(actor)을 주기적으로 연기(act)한다.</p>

<p>해서 <code>scenario</code>, <code>worker</code>, 그리고 worker를 관리하기 위한 <code>worker_pool</code> class가 등장하였다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">scenario_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">tick_actor_t</span><span class="o">*</span> <span class="p">()</span><span class="o">&gt;</span> <span class="kt">tick_actor_factory_t</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">concurrency</span><span class="o">::</span><span class="n">concurrent_queue</span><span class="o">&lt;</span><span class="kt">tick_actor_factory_t</span><span class="o">&gt;</span> <span class="kt">tick_actor_factory_queue_t</span><span class="p">;</span>

    <span class="kt">scenario_t</span><span class="p">(</span><span class="kt">int</span> <span class="n">worker_count</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">_worker_count</span><span class="p">(</span><span class="n">worker_count</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_worker_sched_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">_tick_actor_factory_queue_array</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">tick_actor_factory_queue_t</span><span class="p">[</span><span class="n">worker_count</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="kt">scenario_t</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">delete</span><span class="p">[]</span> <span class="n">_tick_actor_factory_queue_array</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">get_worker_count</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_worker_count</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">enter</span><span class="p">(</span><span class="kt">tick_actor_factory_t</span> <span class="n">factory</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">current_sched_index</span> <span class="o">=</span> <span class="n">_worker_sched_index</span><span class="o">++</span> <span class="o">%</span> <span class="n">_worker_count</span><span class="p">;</span>
        <span class="n">_tick_actor_factory_queue_array</span><span class="p">[</span><span class="n">current_sched_index</span><span class="p">].</span><span class="n">push</span><span class="p">(</span><span class="n">factory</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">tick_actor_factory_queue_t</span><span class="o">&amp;</span> <span class="n">get_factory_queue</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">_worker_count</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">_tick_actor_factory_queue_array</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="p">}</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">_worker_count</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">atomic_int</span> <span class="n">_worker_sched_index</span><span class="p">;</span>
    <span class="kt">tick_actor_factory_queue_t</span><span class="o">*</span> <span class="n">_tick_actor_factory_queue_array</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p><code>scenario</code> class는 일꾼(worker)의 총 수가 몇 명인지 가지고 있다가, 어떤 배역(actor)이 등장(enter)하게 될 경우 round-robin 방식으로 각 worker와 연결된 queue에 배역 생성기(actor)를 넣어준다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">worker_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">worker_t</span><span class="p">(</span><span class="kt">scenario_t</span><span class="o">&amp;</span> <span class="n">scenario</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">_scenario</span><span class="p">(</span><span class="n">scenario</span><span class="p">),</span> <span class="n">_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">void</span> <span class="n">work</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">tick_actor_t</span><span class="o">*&gt;</span> <span class="kt">tick_actors_t</span><span class="p">;</span>
        <span class="kt">tick_actors_t</span> <span class="n">tick_actors</span><span class="p">;</span>
        <span class="k">auto</span><span class="o">&amp;</span> <span class="n">factory_queue</span> <span class="o">=</span> <span class="n">_scenario</span><span class="p">.</span><span class="n">get_factory_queue</span><span class="p">(</span><span class="n">_index</span><span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">scenario_t</span><span class="o">::</span><span class="kt">tick_actor_factory_t</span> <span class="n">factory</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">factory_queue</span><span class="p">.</span><span class="n">try_pop</span><span class="p">(</span><span class="n">factory</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">auto</span><span class="o">*</span> <span class="n">new_actor</span> <span class="o">=</span> <span class="n">factory</span><span class="p">();</span>
                <span class="n">tick_actors</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">new_actor</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">tick_actors</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">tick_actors</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">auto</span><span class="o">&amp;</span> <span class="n">actor</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">);</span>
                <span class="n">actor</span><span class="p">.</span><span class="n">post</span><span class="p">(</span><span class="o">&amp;</span><span class="kt">tick_actor_t</span><span class="o">::</span><span class="n">act</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">_index</span><span class="p">;</span>
    <span class="kt">scenario_t</span><span class="o">&amp;</span> <span class="n">_scenario</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p><code>worker</code> class에서는 자신에게 할당된 (scenario에서 enter하면 추가되는) 배역 생성 queue를 확인하여 새로 부여받은 배역(actor)이 있나 확인하여 자신이 관리하는 vector에 넣는다.
그리고 자신이 관리하는 모든 배역(actor)에 대해 <code>act()</code> 함수를 호출함으로써 각자의 <code>act()</code> 함수가 호출될 수 있도록 한다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">worker_pool_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">worker_pool_t</span><span class="p">(</span><span class="kt">scenario_t</span><span class="o">&amp;</span> <span class="n">scenario</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">_scenario</span><span class="p">(</span><span class="n">scenario</span><span class="p">)</span> <span class="p">{</span> <span class="n">employ</span><span class="p">();</span> <span class="p">}</span>
    <span class="o">~</span><span class="kt">worker_pool_t</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">finalize</span><span class="p">();</span>
    <span class="p">}</span>
<span class="nl">private:</span>
    <span class="kt">void</span> <span class="n">employ</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">_scenario</span><span class="p">.</span><span class="n">get_worker_count</span><span class="p">();</span> <span class="o">++</span><span class="n">index</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">_workers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">([</span><span class="k">this</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span> <span class="p">()</span> <span class="p">{</span>
                <span class="kt">worker_t</span> <span class="n">worker</span><span class="p">(</span><span class="n">_scenario</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
                <span class="n">worker</span><span class="p">.</span><span class="n">work</span><span class="p">();</span>
            <span class="p">}));</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">finalize</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">each</span> <span class="o">:</span> <span class="n">_workers</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">each</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">_workers</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="p">}</span>
<span class="nl">private:</span>
    <span class="kt">scenario_t</span><span class="o">&amp;</span> <span class="n">_scenario</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">_workers</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>그리고 <code>worker_pool</code> class에서 각 worker에 thread를 부여하고 이것들을 관리할 수 있도록 간단히 코드를 작성하였다.</p>

<p>기반 코드 작성이 끝났으니 먹깨비와 제빵사를 구현해보자.
<code>tick_actor</code> class의 <code>act()</code> 함수만 채우면 되니 간단하다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">baker_t</span> <span class="o">:</span> <span class="k">public</span> <span class="kt">tick_actor_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">baker_t</span><span class="p">(</span><span class="kt">basket_t</span><span class="o">&amp;</span> <span class="n">basket</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">_basket</span><span class="p">(</span><span class="n">basket</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">act</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">locker</span> <span class="o">=</span> <span class="n">_basket</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_basket</span><span class="p">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">20</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">_basket</span><span class="p">.</span><span class="n">add</span><span class="p">();</span>
    <span class="p">}</span>
<span class="nl">private:</span>
    <span class="kt">basket_t</span><span class="o">&amp;</span> <span class="n">_basket</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">eater_t</span> <span class="o">:</span> <span class="k">public</span> <span class="kt">tick_actor_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">eater_t</span><span class="p">(</span><span class="kt">basket_t</span><span class="o">&amp;</span> <span class="n">basket</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">_basket</span><span class="p">(</span><span class="n">basket</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">act</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">locker</span> <span class="o">=</span> <span class="n">_basket</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_basket</span><span class="p">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">_basket</span><span class="p">.</span><span class="n">sub</span><span class="p">();</span>
    <span class="p">}</span>
<span class="nl">private:</span>
    <span class="kt">basket_t</span><span class="o">&amp;</span> <span class="n">_basket</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>각자는 <code>act()</code> 함수에서 자신이 참조하는 바구니에 <code>lock()</code>을 걸고, 문제의 제약조건에 따라 <code>count()</code>를 확인한 뒤 <code>add()</code> or <code>sub()</code>을 수행한다.</p>

<p>여기까지 만들고 보면 결국 공유 자원은 lock으로 보호되고, actor간의 message 통신이 없으므로 <code>post()</code> 함수가 무의미해졌다는 사실을 깨달을 수 있게 된다!</p>

<p>이제 main 함수에서 시나리오를 구성해보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">_tmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">_TCHAR</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">scenario_t</span> <span class="n">scenario</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">());</span>
    <span class="kt">worker_pool_t</span> <span class="n">pool</span><span class="p">(</span><span class="n">scenario</span><span class="p">);</span>

    <span class="kt">basket_t</span> <span class="n">basket</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">index</span><span class="p">)</span>
        <span class="n">scenario</span><span class="p">.</span><span class="n">enter</span><span class="p">([</span><span class="o">&amp;</span><span class="n">basket</span><span class="p">]</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">baker_t</span><span class="p">(</span><span class="n">basket</span><span class="p">);</span> <span class="p">});</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">index</span><span class="p">)</span>
        <span class="n">scenario</span><span class="p">.</span><span class="n">enter</span><span class="p">([</span><span class="o">&amp;</span><span class="n">basket</span><span class="p">]</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">eater_t</span><span class="p">(</span><span class="n">basket</span><span class="p">);</span> <span class="p">});</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><code>scenario</code>를 먼저 만든다. 일꾼(<code>worker</code>) 수는 하드웨어가 지원하는 thread 개수로 지정한다. 이제 만들어진 <code>scenario</code> 객체로 <code>worker_pool</code> 객체를 만들면 일꾼들이 고용(employ)되어 준비가 완료된다.</p>

<p>배역들을 등장시키기 위해 <code>scenario</code>의 <code>enter()</code> 함수를 불러준다. 생성하는 코드 자체를 template 등으로 감쌀수도 있겠지만 그러면 코드가 복잡해지니 간단히 lambda로 구현한 factory method를 전달하였다. 이제 제빵사와 먹깨비가 round-robin 방식으로 각 worker에게 배정되어 관리될 것이다.</p>

<p>간단한 내용을 무의미하게 길게 코딩하는 법을 소개해 보았다.
처음 과제 자체가 actor model에 익숙해지는 것을 위해 multi-thread 동기화 예제를 좀 무리하게 냈던 것인데, 스터디에 참여했단 다른 친구들이 나처럼 의미없는 actor model을 구현하지 않고 재미있는 model을 구현해 주어서 참 다행이었다-_-;</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">thread-safe한 counter 구현</h1>
				<p class="page-date">04 Aug 2013</p>
				<p class="page-tags">
						
						
					<code class="tag">concurrency</code>
						
						
						
					<code class="tag">c++</code>
						
						
						
					<code class="tag">study</code>
						
						
						
						
				</p>
				<div class="content"><p>먼저 간단한 counter example을 만들어보자.
문제를 확인하기 위해서 다음과 같은 코드를 작성해본다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">const</span> <span class="kt">int</span> <span class="n">thread_count</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">loop_count</span> <span class="o">=</span> <span class="mi">65536</span><span class="p">;</span>

<span class="k">volatile</span> <span class="kt">int</span> <span class="n">counter</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">add_entry</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">loop_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">loop_index</span> <span class="o">&lt;</span> <span class="n">loop_count</span><span class="p">;</span> <span class="o">++</span><span class="n">loop_index</span><span class="p">)</span>
        <span class="o">++</span><span class="n">counter</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">_tmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">_TCHAR</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">thread_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">thread_index</span> <span class="o">&lt;</span> <span class="n">thread_count</span><span class="p">;</span> <span class="o">++</span><span class="n">thread_index</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">threads</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">add_entry</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">each</span> <span class="o">:</span> <span class="n">threads</span><span class="p">)</span>
        <span class="n">each</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;expect: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">thread_count</span> <span class="o">*</span> <span class="n">loop_count</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;actual: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">counter</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>c++ code 한 줄이 원자적(atomic)으로 실행된다는 보장은 없다. assembly의 한 줄도 원자적으로 실행된다는 보장은 없다(smp, micro-operation)<br>
위 코드를 release로 빌드해보면 <code>++counter</code> 부분에 대한 코드가 assembly로 한 줄이 나오는데, 어쨌든 expect와 actual 값이 다르게 나온다는 것은 해당 연산이 원자적으로 수행되지 않는다는 것이다.</p>

<p>재밌는 것은 volatile keyword를 제거한 후 release로 build하면 제법 문제없는 결과가 나오는 것처럼 보인다는 것이다. 그 이유를 생성된 assembly code를 통해 확인하면 알 수 있는데, <code>for (loop_counter) ++counter</code> 부분이 <code>counter += loop_counter</code> 코드로 최적화되어 버리기 때문이다. <code>counter += loop_counter</code> 명령은 원자적이지 않지만, 다음 thread가 생성되어 간섭하기 전에 완료될 수 있을만큼 명령이 단순하므로 thread간 간섭이 없어 문제가 발생하지 않는 것처럼 보이는 것이다. (직접 위 코드를 release로 빌드하여 assembly를 확인해보면 더욱 명확하다)</p>

<p>위 문제를 해결하기 위한 적어도 3가지 방법을 하나씩 알아보자.</p>

<h3>lock 사용</h3>

<p>가장 손쉬운 해결법은 lock을 사용하는 것이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">add_entry</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">loop_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">loop_index</span> <span class="o">&lt;</span> <span class="n">loop_count</span><span class="p">;</span> <span class="o">++</span><span class="n">loop_index</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
        <span class="o">++</span><span class="n">counter</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>간단하게 전역 변수로 mutex를 추가하고, <code>++counter</code> 수행 전후의 단일 thread 진입을 보장해주기 위해 lock을 걸었다. 수행시간이 굉장히(!) 오래 걸리고 cpu도 엄청 소모하지만 한참 기다리면 어쨌든 actual과 expect가 동일하게 나오는 것을 볼 수 있다.</p>

<h3>atomic_int</h3>

<p>두 번째 해결책은 <code>atomic_int</code>를 사용하는 것이다. <a href="/2011/08/02/volatile-interlocked-operation/">volatile과 interlocked operation</a></p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">atomic_int</span> <span class="n">counter</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">add_entry</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">loop_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">loop_index</span> <span class="o">&lt;</span> <span class="n">loop_count</span><span class="p">;</span> <span class="o">++</span><span class="n">loop_index</span><span class="p">)</span>
        <span class="o">++</span><span class="n">counter</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>결과도 굉장히 빠르게 나오고, 제대로 actual과 expect가 같게 나온다. <code>atomic_int::operator++ ()</code>은 내부에서 <code>atomic_fetch_add()</code> 함수를 부르게 된다. 여기서 memory_order를 지정할 수 있는데  windows api는 (arm을 사용하지 않을 경우) memory order가 뭐인지와 상관없이 <code>_InterlockedExchangeAdd()</code> Intrinsic 함수를 부른다. (물론 기본 memory_order 값은 <code>memory_order_seq_cst</code>이다)</p>

<p>세 번째 해결책으로 넘어가기 전에 두 번째 해결책에서 배운 atomic을 사용하여 첫 번째 해결책의 성능을 개선해보자. lock을 직접 만들어서 성능을 개선하는 것이다. <a href="http://en.cppreference.com/w/cpp/atomic/atomic_flag">Cppref: atomic_flag</a></p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">volatile</span> <span class="kt">int</span> <span class="n">counter</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">atomic_flag</span> <span class="n">lock</span> <span class="o">=</span> <span class="n">ATOMIC_FLAG_INIT</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">add_entry</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">loop_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">loop_index</span> <span class="o">&lt;</span> <span class="n">loop_count</span><span class="p">;</span> <span class="o">++</span><span class="n">loop_index</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">lock</span><span class="p">.</span><span class="n">test_and_set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">))</span>
             <span class="p">;</span> <span class="c1">// spin</span>
        <span class="o">++</span><span class="n">counter</span><span class="p">;</span>
        <span class="n">lock</span><span class="p">.</span><span class="n">clear</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>동기화를 위해 <code>atomic_flag</code>를 사용한다. lock이라는 flag를 획득하지 못할 경우 spin-wait을 수행하고, 얻으면 <code>++counter</code>를 한다. 작업이 끝나면 lock flag를 clear해서 다른 thread가 진입하게 하는 것이다. 이전에 lock을 쓸 때에 비해서 성능이 훨씬 좋아졌다. (그래도 <code>atomic_int</code>를 사용하는 것에 비하면 많이 느리다.)</p>

<h3>message passing with actor</h3>

<p>세 번째 방법은 actor 기반의 message passing을 사용하는 것이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">enum</span> <span class="kt">message_t</span> <span class="p">{</span>
    <span class="n">msg_none</span><span class="p">,</span>
    <span class="n">msg_add</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">actor_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">actor_t</span><span class="p">()</span> 
        <span class="o">:</span> <span class="n">exited</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">worker</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="kt">actor_t</span><span class="o">::</span><span class="n">dispatch</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="kt">actor_t</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">exited</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">worker</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">dispatch</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">message_t</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">msg_none</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">message_queue</span><span class="p">.</span><span class="n">try_pop</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">exited</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">switch</span> <span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="n">msg_none</span>:
                <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="n">msg_add</span>:
                <span class="o">++</span><span class="n">value</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">msg_none</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">request</span><span class="p">(</span><span class="kt">message_t</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">message_queue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
    <span class="p">}</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
<span class="nl">private:</span>
    <span class="kt">bool</span> <span class="n">exited</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">worker</span><span class="p">;</span>
    <span class="n">concurrency</span><span class="o">::</span><span class="n">concurrent_queue</span><span class="o">&lt;</span><span class="kt">message_t</span><span class="o">&gt;</span> <span class="n">message_queue</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">actor_t</span> <span class="n">counter</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">add_entry</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">loop_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">loop_index</span> <span class="o">&lt;</span> <span class="n">loop_count</span><span class="p">;</span> <span class="o">++</span><span class="n">loop_index</span><span class="p">)</span>
        <span class="n">counter</span><span class="p">.</span><span class="n">request</span><span class="p">(</span><span class="n">msg_add</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p><code>actor_t</code>는 <code>dispatch()</code> 함수에서 <code>message_queue</code>에 쌓인 message를 자체적인 worker thread를 사용하여 비동기로 처리되도록 구성된 class이다(대충 구현해서 성능은 안 좋다). <code>concurrent_queue</code>가 비어있을 때(<code>empty</code>)에는 <code>try_pop()</code>이 바로 실패하므로, worker thread가 message를 과도하게 busy-waiting하지 않도록 대충 <code>sleep(0)</code>을 넣어주었다.</p>

<p>어쨌든 각 test thread들은 <code>add_entry()</code>에서 <code>counter</code>라는 actor에게 <code>msg_add</code>를 전달하고, <code>msg_add</code>는 <code>counter</code>의 <code>message_queue</code>에 쌓이게 된다. 그러면 <code>counter</code>내의 worker thread가 <code>message_queue</code>에 쌓인 <code>msg_add</code>를 하나씩 처리하기 때문에 <code>counter::value</code> 변수는 하나의 thread만 (write를 위해) 접근하게 되고, 이 변수는 간섭없이 증가할 수 있는 것이다.</p>

<p>다만 위 코드를 수행할 경우 프로그램의 수행 시간이 굉장히 오래 걸린다. (<code>std::mutex</code>/<code>lock</code>을 사용했을 때 보다도 몇 배는 더 오래 걸린다.) 그 이유는 actor를 대충 구현해서 그런 것도 있지만 <code>concurrent_queue</code>가 너무 느린 것도 한 몫 하는 것 같다-_-</p>

<h3>정리</h3>

<p>다양한 방법으로 counter example의 공유 자원 정합성 문제를 해결해보았다. 게임 등의 다른 로직에서도 위에서 언급한 방법 혹은 다른 방법을 통해 동시성 보장을 위해 상황에 맞는 적절한 방법을 찾아 구현하면 되겠다. (물론 난 별로 자신 없다-_-)</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">volatile과 interlocked operation</h1>
				<p class="page-date">02 Aug 2011</p>
				<p class="page-tags">
						
						
					<code class="tag">concurrency</code>
						
						
						
					<code class="tag">c++</code>
						
						
						
						
				</p>
				<div class="content"><h3>volatile</h3>

<p>다음과 같은 코드가 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="c1">// 공유되는 변수, static 이라든지 member 변수라든지 전역변수라든지</span>
<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="o">++</span><span class="n">count</span><span class="p">;</span>
<span class="o">++</span><span class="n">count</span><span class="p">;</span>
<span class="o">++</span><span class="n">count</span><span class="p">;</span>
</code></pre></div>
<p>세 번의 ++ 연산을 모두 a 라는 변수에 수행하므로, 컴파일러는 최적화를 통해 다음과 같은 코드를 만들어낼 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">count</span><span class="p">]</span>
<span class="n">add</span> <span class="n">eax</span><span class="p">,</span> <span class="mi">1</span>
<span class="n">add</span> <span class="n">eax</span><span class="p">,</span> <span class="mi">1</span>
<span class="n">add</span> <span class="n">eax</span><span class="p">,</span> <span class="mi">1</span>
<span class="n">mov</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">count</span><span class="p">],</span> <span class="n">eax</span>
</code></pre></div>
<p>만약 multi-thread 환경에서 저 코드가 여러 thread에 의해 수행된다고 하면, <code>add eax</code>를 수행하고 <code>mov dword ptr [count], eax</code>를 수행하기 전에 switching이 되면, 다른 코드에서는 아직 count 연산이 반영되지 않은 연산을 수행하게 될 것이다.</p>

<p>즉, thread 1에서는 아직 연산결과가 eax에서 count로 반영이 안 되었는데, thread 2에서는 count로부터 값을 읽어서 연산을 수행해버리므로 계산 결과가 안드로메다로 간다는 것.</p>

<p>이럴 때 <code>volatile</code> 키워드를 사용한다. <code>volatile</code> 키워드를 붙이면 해당 변수의 값을 다른 무언가가 바꿀 수 있다는 의미, 즉 값이 보장되지 않음을 명시해주게 된다. 때문에 저렇게 최적화 과정을 통해 register를 사용하여 연산을 진행하고 그 값을 바로 메모리에 반영을 안해주는 것을 막아준다.</p>

<p>아래와 같이 바로바로 연산을 수행한 다음에 메모리에 넣어준다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">count</span><span class="p">]</span>
<span class="n">add</span> <span class="n">eax</span><span class="p">,</span> <span class="mi">1</span>
<span class="n">mov</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">count</span><span class="p">],</span> <span class="n">eax</span>
<span class="n">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">count</span><span class="p">]</span>
<span class="n">add</span> <span class="n">eax</span><span class="p">,</span> <span class="mi">1</span>
<span class="n">mov</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">count</span><span class="p">],</span> <span class="n">eax</span>
<span class="n">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">count</span><span class="p">]</span>
<span class="n">add</span> <span class="n">eax</span><span class="p">,</span> <span class="mi">1</span>
<span class="n">mov</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">count</span><span class="p">],</span> <span class="n">eax</span>
</code></pre></div>
<p>그래서 공유되는 변수에 <code>volatile</code>을 쓰면 바로 연산 결과를 메모리에 바로 반영해주고, 값을 읽어올 때도 register에 저장되어있는 것을 읽어오는게 아니라 바로 메모리에 있는 것을 읽어오니까 문제가 해결된다는 것 같은데</p>

<p>이게 수행의 <em>원자성(atomic)</em>과는 또 다른 이야기라서 그것까지 고려하려면 좀 다른 수를 써야한다.
위에서 보면 ++count 연산을 수행하기 위해 3개의 assembly 명령어가 수행되는데, 만약 add eax, 1 까지 수행했지만 mov eax, dword ptr [count] 를 수행하지 않은 시점에서 다른 thread 가 count 의 값을 접근해버리면? 역시 마찬가지로 잘못된 값을 읽을 것이다.</p>

<p>이 때문에 수행 구간의 배타성(exclusive)을 보장해주기 위해서 mutex(mutual exclusion)를 설정해주는 것이다. 공부를 대충해서 설명을 참 못해놨는데, 마침 <a href="http://skyul.tistory.com/337">설명이 잘 된 링크</a>를 찾았으니 들어가서 보면 좋겠다.</p>

<p><code>volatile</code>을 붙이면 메모리에 값을 바로 반영해주므로 여러 thread 에서 공유되는 flag 변수를 사용할 때는 volatile keyword를 사용해야 문제가 덜 생긴다. 하지만 flag 값 역시 누군가는 대입하고, 누군가는 읽을텐데 대입의 과정 역시 assembly instruction으로 한 명령이 아니기 때문에 문제가 될 수 있다.
즉, 대입하는 thread 가 아직 메모리에 반영을 안한 시점에 읽는 thread가 읽어버리면 잘못된 flag 값을 통해 잘못된 수행을 할 수 있다는 것이다.</p>

<p>이 때문에 lock을 써 mutex 구간으로 설정하든 아래의 interlocked operation을 사용해야한다.</p>

<h3>interlocked</h3>

<p>연산의 원자성이란 해당 연산이 multi-thread 환경에서 중간에 switching이 되어도 그 연산에 문제가 안 생기게 잘 수행된다는 이야기인데, 다음 예제를 보자</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Object</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">Hit</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="o">++</span><span class="n">mCount</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">Object</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="o">:</span> <span class="n">mCount</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">mCount</span><span class="p">;</span>
</code></pre></div>
<p>이 <code>Object</code> class의 객체는 몇 개의 thread에서 공유되는 변수이다. 그리고 <code>Hit</code>이라는 함수를 통해 각 Thread가 Object에 접근하는 회수를 측정한다고 하자.</p>

<p>이 연산에 대해 컴파일러는 대충 이런 기계어를 만들어낼거다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="k">this</span><span class="p">]</span>
<span class="n">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">eax</span><span class="p">]</span>
<span class="n">add</span> <span class="n">ecx</span><span class="p">,</span> <span class="mi">1</span>
<span class="n">mov</span> <span class="n">edx</span><span class="p">,</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="k">this</span><span class="p">]</span>
<span class="n">mov</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">edx</span><span class="p">],</span> <span class="n">ecx</span>
</code></pre></div>
<ul>
<li>먼저 this의 주소의 주소 값을 가져와서 eax에 넣는다. 그럼 거기가 this의 주소가 될 것이다.</li>
<li>그 this를 또 dword ptr, 즉 this 가 가리키는 첫 번째 지점이 첫 번째 멤버 변수인 mCount가 되므로 ecx는 mCount 의 값이 들어간다.</li>
<li>그리고 add 로 1을 증가시키고, 그 결과를 다시 this 가 가리키는 곳에 넣는다.</li>
</ul>

<p>(위 assembly 는 visual studio 2010 에서 만들어준 코드인데, 값을 쓰는 과정에서 this 를 다시 edx에 가져오는 코드를 사용하는 이유는 잘 모르겠지만 추측해보면 최적화 없이 기계적으로 만들어진 코드이므로 eax의 값이 변경될 것을 고려하여 다시 this의 위치를 가져오는 것이 아닐까 한다)</p>

<p>위에서 언급했지만 Thread가 2개가 있을 때, Thread 1이 <code>add ecx, 1</code>까지만 수행한 상태에서 Thread 2가 <code>mov ecx, dword ptr [eax]</code>를 수행해버리면 Thread 1의 연산결과가 아직 mCount에 반영되어있지 않으므로 Thread 2는 Thread 1의 연산 결과를 무시할 것이다.</p>

<p>즉, Thread 1이 처음에 0을 가져와서, 1을 더해서 그 결과를 mCount에 넣는다.
Thread 2가 처음에 0을 가져와서(아직 Thread 1의 연산 결과가 반영되지 않았으므로), 1을 더해서(그러므로 결과는 1) 그 결과를 mCount에 넣는다. (따라서 mCount 의 최종 결과는 1이 된다)</p>

<p>이렇듯 두 개 이상의 Thread가 동시에(하나의 core에서 switching 되든 다른 core에서 simultaneously 하게 돌아가든) 수행될 경우 전혀 예측과 다른 결과가 나온다는 것이다.</p>

<p>따라서 저렇게 여러 Thread에서 접근하여 수행되는 코드 중 공유되는 자원이 있을 경우 올바른 수행을 위해서 lock 등을 사용하여 배타적 실행을 보장해준다.<br>
(하지만 kernel 단에서 관리해주는 세마포어는 꽤 큰 비용이 들고, spin lock 역시 cpu 소모를 피할 수 없다. 하지만 lock 을 사용했을 경우 가장 곤란한 문제는 dead lock이다.)</p>

<p>위와 같은 <code>Hit</code> 함수를 lock 으로 보호한다면 대충 이럴 것이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">Object</span><span class="o">::</span><span class="n">Hit</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">lock</span><span class="p">();</span>
    <span class="o">++</span><span class="n">mCount</span><span class="p">;</span>
    <span class="n">unlock</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>하지만 lock 등으로 보호해야 할 영역을 생각해보면 굉장히 그 영역이 축소된다.</p>

<ul>
<li>위의 코드에서는 단순히 mCount를 증가시키는 부분만 원자적으로 수행되면 되고,</li>
<li>여타 Concurrent Data Structure를 보면 Stack(Node 기반)에서는 공유되는 변수인 Stack Head Pointer,</li>
<li>Queue(Node 기반)에서는 공유되는 변수인 Head와 Tail</li>
</ul>

<p>즉 공유되는 변수, 즉 멤버 변수만 원자적인 연산을 사용하게 되면 lock 범위를 함수 전체가 아니라 한 명령 구문으로 줄일 수 있다는 것이다. (Compare And Swap 등)</p>

<p>그래서 intel에서는 이를 위한 interlocked instruction을 제공해 주었고, MS에서는 이를 wrapping하여 <a href="http://msdn.microsoft.com/en-us/library/ms684122.aspx">Interlocked API</a>으로 지원해준다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">Object</span><span class="o">::</span><span class="n">Hit</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 함수 인자 type 맞춰주기 위해 mCount 는 LONG type 이 되어야한다.</span>
    <span class="n">InterlockedIncrement</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">mCount</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>위와 같이 작성하면 내부에서 mCount의 주소를 <code>InterlockedIncrement</code>로 넘겨준다. 그러면 <code>InterlockedIncrement</code> 함수에서는 저 메모리 주소를 가지고 있다가 내부에 lock 붙은 operation 수행을 통해(?) 그 주소가 가리키는 값을 1 증가시켜주는 것을 원자적으로 수행시켜준다.</p>

<p>즉, 저 코드는 여러 thread 에서 동시에 실행을 해도 증가시켜주는 구문인 <code>InterlockedIncrement</code> 함수가 원자적으로 증가시켜줌을 보장해주기 때문에 문제가 없다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">객체별 함수 수행 동기화</h1>
				<p class="page-date">11 Aug 2011</p>
				<p class="page-tags">
						
						
					<code class="tag">concurrency</code>
						
						
						
					<code class="tag">c++</code>
						
						
						
					<code class="tag">async</code>
						
						
						
						
				</p>
				<div class="content"><p>(주의, 아래 글은 Visual Studio 2010 을 쓴다는 가정하에 작성하였다. 아무튼 C++11 이 지원되어야 한다)<br>
여러 Thread가 동시에 접근을 수행하는 객체를 보호하기 위해서는 어떤 방법이 있을까?</p>

<ul>
<li>lock을 건다</li>
<li>각 Thread들은 하나의 queue에 요청할 작업을 쌓아두고, 그 객체 전담 Thread가 그 작업들을 처리한다.</li>
<li>Read / Write Phase를 나누어서 Read는 다같이, Write는 역시 작업을 모아 하나의 Thread만 진입하여 처리한다.</li>
</ul>

<p>lock을 걸면 당연히 속도가 떨어진다. 따라서 본 글에서는 lock을 걸지 않는 방법을 논의해볼 것이고 설계적으로 복잡한 3번 보다는 2번에 초점을 맞출 계획이다.</p>

<p>상황적으로 볼 때, 하나의 객체에 여러 Thread가 접근할 일은 많다. 만약 2명의 User가 Party를 맺고 사냥을 하다가, 각자 동시에 한 마리씩 몬스터를 잡았다는 message가 동시에 Server에 도착해 경험치를 각 User 객체에 넣어준다고 하자.</p>

<p>User에는 AddExp함수를 통해 내부에 경험치를 증가시킨다. 그런데 만약 두 Thread가 경쟁적으로 AddExp를 호출할 경우, 결과 값이 제대로 들어간다는 보장이 없다. <a href="/2011/08/02/volatile-interlocked-operation/">volatile과 interlocked operation</a></p>

<p>물론 이런 경우는 InterlockedAdd 함수를 써서 해결할 수도 있겠지만, 공유 객체에 요청되는 작업들을 Queue에 모아 동기적으로 하나의 Thread 가 처리하는 방법으로 문제를 해결해보도록 하자</p>

<h3>설계</h3>

<p>생산자와 소비자 모델에서 생산자와 소비자는 Queue 객체를 공유한다. 생산자가 데이터를 Queue에 넣으면 소비자는 Queue에서 데이터를 꺼내서 처리한다. 이 때 데이터가 공유 객체에 요청하는 작업이고, 소비자가 단일 Thread로 구성된다면, 여러 Thread에서 요청하는 작업들을 Queue에 넣어 소비자, 즉 단일 Thread가 처리하므로 공유 객체는 Lock 없이 Thread Safe하게 돌아가게 된다.</p>

<p>위에서 언급한 경쟁적 상황에서 값이 제대로 반영되지 않는 문제도 있고, STL의 경우 Container를 변경시킬 경우 Iterator가 무효화될 수 있으므로 여러 Thread가 접근할 때에는 반드시 Lock을 걸어서 보호를 해주어야하는데, 이러한 부담을 제거할 수 있다는 것이다.</p>

<h3>InterlockedExchange</h3>

<p>공유 객체에 작업을 요청하는 Thread는 많다. 하지만 실질적으로 이 작업들을 처리하는 Thread는 단 하나다. 그렇다고 객체마다 Thread를 다 만들 수는 없다. 가장 좋은 해결책은 어떤 것일까?</p>

<p>Lock을 생각해보자. Lock이라는 것은 여러 Thread가 접근해서 수행하는 영역의 시작과 끝에서 <code>Lock</code>, <code>Unlock</code>을 사용, 그 구간을 상호 배타적 구간(Mutual Exclusion)으로 설정하여 Thread가 동시에 접근하지 못하도록 보호하는 장치이다.<br>
즉, <code>AcquireLock</code> Logic은 여러 Thread가 동시에 접근하여 수행할 수 있지만, 실제로 그 routine을 벗어나 Mutex에 진입하여 코드를 실행하는 Thread는 하나로 보장이 된다. 아래의 간단한 <code>SpinLock</code> 예제를 보자 (Windows via C/C++)</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">SpinLock</span><span class="o">::</span><span class="n">Lock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">InterlockedExchange</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">mLockFlag</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">Sleep</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">SpinLock</span><span class="o">::</span><span class="n">Unlock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">InterlockedExchange</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">mLockFlag</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p><code>InterlockedExchange</code>는 원자적으로 해당 변수에 값을 대입하고 그 변수의 초기값을 반환하는 연산이다. <code>SpinLock</code>은 처음에 <code>mLockFlag</code>가 0 이다. 따라서 누군가 <code>Lock</code> 함수를 요청하면 <code>mLockFlag</code>의 값을 1로 바꾸고, 0 (초기값) 을 반환한다. 따라서 바로 함수 수행이 종료된다.<br>
하지만 다른 Thread가 동시에 <code>Lock</code>을 요청할 경우 <code>InterlockedExchange</code> 함수는 1을 반환할 것이고, 그렇다면 무한 loop 를 돌면서 <code>Sleep (0)</code>, 즉 다른 Thread에게 수행 시간을 양보한다 (물론 자신보다 우선순위가 같거나 높은 Thread들에 대해서)</p>

<p>위 방법을 사용하여 어떠한 함수에 진입하는 Thread 의 단일성을 보장할 수 있겠다. 따라서 저 방법을 사용하여 문제를 해결해보자.</p>

<h3>bind function object</h3>

<p>함수를 수행하려면, 적어도 함수의 주소와 각 인자에 대해 알아야한다. 만약 함수가 특정 객체의 멤버 함수라면, 멤버 함수의 주소와 해당 객체가 필요할 것이다.</p>

<p>함수는 각기 다른 형태(signature)을 갖고 있고, 수행에 필요한 인자가 각기 다르다. 따라서 모든 함수의 요청을 객체화(functor) 하기 위해서는 동일한 interface 로 함수 요청을 통일시켜줄 필요가 있다. 이러기 위해 사용하는 것이 std::bind 이다.
아래의 예제는 각 함수의 요청을 무항 함수 객체(nullary functor)로 변환하는 코드이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
<span class="k">struct</span> <span class="n">Adder</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// ...</span>
<span class="n">Adder</span> <span class="n">adder</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">functor1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;::</span><span class="n">add</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">functor2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Adder</span><span class="o">::</span><span class="n">add</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adder</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="n">functor1</span><span class="p">();</span>
<span class="n">functor2</span><span class="p">();</span>
</code></pre></div>
<p>정확한 type 은 표기하기 어렵지만, 아무튼 함수 수행에 대해 함수의 주소와 객체, 그리고 인자까지 완벽하게 하나의 객체로 묶을 수 있게 되었다.</p>

<h3>general functor</h3>

<p>하지만 이건 compile time에 가능한 일이고, 저것들을 runtime에 한군데 모아놓고 수행하기는 어렵다. runtime에 객체들을 모아놓는다는 것은 하나의 Container에 객체들을 담아두고 iterating을 한다는 것인데 저것들의 type은 모두 다르기 때문이다. 따라서 type을 맞춰주기 위해 interface를 작성한다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="n">RequestJob</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="k">operator</span> <span class="p">()</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">RequestJob</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>
</code></pre></div>
<p>그리고 간단한 template 함수를 통해 함수 호출 요청 객체를 받아 저 interface를 상속받은 struct를 생성하도록 한다. 함수 내에서 template struct를 갖을 수는 없지만 함수 자체가 template이면 문제가 해결된다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Functor</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Request</span><span class="p">(</span><span class="k">const</span> <span class="n">_Functor</span><span class="o">&amp;</span> <span class="n">functor</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">_RequestJobImpl</span> <span class="o">:</span> <span class="k">public</span> <span class="n">RequestJob</span>
    <span class="p">{</span>
        <span class="n">_RequestJobImpl</span><span class="p">(</span><span class="k">const</span> <span class="n">_Functor</span><span class="o">&amp;</span> <span class="n">functor</span><span class="p">)</span>
            <span class="o">:</span> <span class="n">mFunctor</span> <span class="p">(</span><span class="n">functor</span><span class="p">)</span> <span class="p">{}</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="k">operator</span> <span class="p">()</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="n">mFunctor</span><span class="p">();</span> <span class="p">}</span>

        <span class="n">_Functor</span> <span class="n">mFunctor</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="n">mJobQueue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">RequestJobPtr</span><span class="p">(</span><span class="k">new</span> <span class="n">_RequestJobImpl</span><span class="p">(</span><span class="n">functor</span><span class="p">)));</span>
</code></pre></div>
<p>당연한 이야기이지만 가상 소멸자가 중요하다. 객체에 대한 함수 수행이 지금 바로 수행되는 것이 아니라 요청되어 언제 수행될지 모르는, 즉 비동기적 수행을 요청하는 것이기 때문에 그때까지 객체가 살아있으리란 보장이 없다.</p>

<p>따라서 <code>shared_ptr</code> 같은 것을 써야하는데, <code>RequestJob struct</code>가 가상 소멸자를 갖지 않으면 <code>_RequestJobImpl struct</code>의 멤버 변수인 <code>_Functor</code>가 소멸되지 않고, 그러면 <code>shared_ptr</code>의 Reference Count가 감소하지 않아 메모리 누수가 발생하게 된다.</p>

<p>아무튼 저렇게 inner struct로 <code>_RequestJobImpl struct</code>를 만들어서 template type인 <code>_Functor</code> 객체를 멤버로 갖고, <code>operator ()</code>에서 그 함수를 호출해줄 수 있도록 한다. 그렇게 만든 <code>RequestJob</code> 객체를 <code>JobQueue</code>에 넣는다.
물론 <code>JobQueue</code>는 여러 Thread에서 동시에 Push를 수행하고, 다른 Thread에서 Pop을 수행해야하므로 thread safe해야한다. 따라서 concurrent_queue.h에 정의된 <code>Concurrency::concurrent_queue</code>를 사용한다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="n">Concurrency</span><span class="o">::</span><span class="n">concurrent_queue</span><span class="o">&lt;</span><span class="n">RequestJobPtr</span><span class="o">&gt;</span> <span class="n">JobQueue</span><span class="p">;</span>
<span class="n">JobQueue</span> <span class="n">mJobQueue</span><span class="p">;</span>
</code></pre></div>
<h3>single entrance</h3>

<p>마지막으로 <code>JoqQueue</code>에 들어간 작업을 처리할 Thread 1개만 통과시켜서 Queue에 들어있는 작업을 처리하게 해야한다. <code>SpinLock</code>에서 공부했던 내용을 <code>Request</code> 함수 뒤에 끼얹어보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp">    <span class="k">if</span> <span class="p">(</span><span class="n">InterlockedExchange</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">mExclusiveFlag</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">RequestJobPtr</span> <span class="n">job</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">mJobQueue</span><span class="p">.</span><span class="n">try_pop</span><span class="p">(</span><span class="n">job</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">job</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;)</span>
    <span class="p">{</span>
        <span class="p">(</span><span class="o">*</span><span class="n">job</span><span class="p">)();</span>
        <span class="k">delete</span> <span class="n">job</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">InterlockedExchange</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mExclusiveFlag</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p><code>InterlockedExchange</code> 함수를 사용해서 <code>mExclusiveFlag</code> 값을 통해 한 개의 Thread만 통과시킨다. 나머지는 어차피 수행해야할 작업들을 <code>JobQueue</code>에 추가시켰으니 마음놓고 <code>Request</code> 함수를 나온다.</p>

<p>진입에 성공한 Thread는 이제 독박을 쓴다. <code>JobQueue</code>가 빌 때까지 <code>RequestJob</code> 객체를 하염없이 꺼내서 수행을 해준다. 물론 수행 후 job 객체를 제거하는 것도 잊지 않는다. 이 때문에 Thread가 작업을 처리하는 동안 다른 Thread들이 계속 <code>JobQueue</code>에 작업을 채워주면 그 Thread는 이 함수를 못 빠져나올지도 모른다.</p>

<p>하지만 상식적으로, 그런 경우는 대부분 일어날 수 없다. 왜냐하면 객체의 수정을 촉발하는 네트워크 IO 작업의 속도보다 작업을 처리하는 속도가 더 빠르기 때문이다. 그럼에도 불구하고 너무 많은 작업이 몰린다면, 그 Thread는 적절한 tuning을 통해 몇 초만 <code>JobQueue</code>를 처리하다가 안되면 그냥 반환하고 나오면 될 일이다. 그럼 다음 Thread가 진입해서 이어서 할테니까.</p>

<h3>예제</h3>

<p>이제 모든 준비가 끝났다. 공유되어 여러 Thread로부터 처리가 동시에 일어날 수 있는 class는 위 class를 상속받으면 된다. <code>User</code> class가 위 class를 상속받았고, User 객체가 <code>AddExp</code> 함수를 가질 때, 다음과 같은 방법으로 요청할 수 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">UserRef</span><span class="p">;</span>
<span class="n">UserRef</span> <span class="n">user</span> <span class="o">=</span> <span class="n">UserRef</span> <span class="p">(</span><span class="k">new</span> <span class="n">User</span><span class="p">);</span>
<span class="n">user</span><span class="o">-&gt;</span><span class="n">Request</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bind</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">User</span><span class="o">::</span><span class="n">AddExp</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="mi">100</span><span class="p">));</span>
</code></pre></div>
<p>User 객체에게 멤버 함수 수행 요청을 <code>Request</code> 함수를 통해 전달한다. 수행에 필요한 정보는 <code>std::bind</code>로 묶어줬다. 한 가지 아쉬운 점은 Request를 부르는 대상이 이미 user 객체로 정해졌으므로 <code>User::AddExp</code>를 수행할 대상도 Request를 요청한 user 객체인데, <code>std::bind</code>를 묶어줄 때 두 번째 인자로 이 <code>AddExp</code> 함수를 수행할 객체인 user 객체를 한 번 더 넣어줘야한다는 것이다.</p>

<p>이 문제에 대해서는 딱히 좋은 방법이 없는 것 같다.<br>
(UserRef는 User에 대한 <code>shared_ptr</code>로 분명 <code>User::AddExp</code> 함수를 수행하기 위해서는 <code>User *</code> 를 인자로 받아야하지만 <code>shared_ptr</code>은 원본 Type 에 대한 casting operator를 overloading 했으므로 문제가 없다.)</p>

<p>예제 코드 전문을 보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="cp">#include &lt;windows.h&gt;</span>
<span class="cp">#include &lt;functional&gt; </span>
<span class="cp">#include &lt;algorithm&gt; </span>
<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;concurrent_queue.h&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>

<span class="k">class</span> <span class="nc">RequestBase</span>
<span class="p">{</span>
<span class="nl">private:</span>
    <span class="k">struct</span> <span class="n">RequestJob</span>
    <span class="p">{</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="k">operator</span> <span class="p">()</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">RequestJob</span><span class="p">()</span> <span class="p">{}</span>
    <span class="p">};</span>
    <span class="k">typedef</span> <span class="n">RequestJob</span><span class="o">*</span> <span class="n">RequestJobPtr</span><span class="p">;</span>

<span class="nl">public:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Functor</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">Request</span><span class="p">(</span><span class="k">const</span> <span class="n">_Functor</span><span class="o">&amp;</span> <span class="n">functor</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">struct</span> <span class="n">_RequestJobImpl</span> <span class="o">:</span> <span class="k">public</span> <span class="n">RequestJob</span>
        <span class="p">{</span>
            <span class="n">_RequestJobImpl</span><span class="p">(</span><span class="k">const</span> <span class="n">_Functor</span><span class="o">&amp;</span> <span class="n">functor</span><span class="p">)</span>
                <span class="o">:</span> <span class="n">mFunctor</span> <span class="p">(</span><span class="n">functor</span><span class="p">)</span> <span class="p">{}</span>
            <span class="k">virtual</span> <span class="kt">void</span> <span class="k">operator</span> <span class="p">()</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="n">mFunctor</span><span class="p">();</span> <span class="p">}</span>

            <span class="n">_Functor</span> <span class="n">mFunctor</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="n">mJobQueue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">RequestJobPtr</span><span class="p">(</span><span class="k">new</span> <span class="n">_RequestJobImpl</span><span class="p">(</span><span class="n">functor</span><span class="p">)));</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">InterlockedExchange</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mExclusiveFlag</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">RequestJobPtr</span> <span class="n">job</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">mJobQueue</span><span class="p">.</span><span class="n">try_pop</span><span class="p">(</span><span class="n">job</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">job</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;)</span>
        <span class="p">{</span>
            <span class="p">(</span><span class="o">*</span><span class="n">job</span><span class="p">)();</span>
            <span class="k">delete</span> <span class="n">job</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">InterlockedExchange</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mExclusiveFlag</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">RequestBase</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">mExclusiveFlag</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>

<span class="nl">private:</span>
    <span class="k">typedef</span> <span class="n">Concurrency</span><span class="o">::</span><span class="n">concurrent_queue</span><span class="o">&lt;</span><span class="n">RequestJobPtr</span><span class="o">&gt;</span> <span class="n">JobQueue</span><span class="p">;</span>
    <span class="n">JobQueue</span> <span class="n">mJobQueue</span><span class="p">;</span>
    <span class="n">LONG</span>     <span class="n">mExclusiveFlag</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">User</span> <span class="o">:</span> <span class="k">public</span> <span class="n">RequestBase</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">AddExp</span><span class="p">(</span><span class="kt">int</span> <span class="n">exp</span><span class="p">)</span>    <span class="p">{</span> <span class="n">mExp</span> <span class="o">+=</span> <span class="n">exp</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">int</span>  <span class="n">GetExp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">mExp</span><span class="p">;</span> <span class="p">}</span>

    <span class="n">User</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="o">:</span> <span class="n">mExp</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
    <span class="o">~</span><span class="n">User</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>

<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">mExp</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">UserRef</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">_tmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">_TCHAR</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">UserRef</span><span class="o">&gt;</span> <span class="n">Users</span><span class="p">;</span>
    <span class="n">Users</span> <span class="n">users</span><span class="p">;</span>

    <span class="n">users</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">UserRef</span><span class="p">(</span><span class="k">new</span> <span class="n">User</span><span class="p">));</span>
    <span class="n">users</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">UserRef</span><span class="p">(</span><span class="k">new</span> <span class="n">User</span><span class="p">));</span>
    <span class="n">users</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">UserRef</span><span class="p">(</span><span class="k">new</span> <span class="n">User</span><span class="p">));</span>
    <span class="n">users</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">UserRef</span><span class="p">(</span><span class="k">new</span> <span class="n">User</span><span class="p">));</span>

    <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">users</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">users</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">(</span><span class="n">UserRef</span><span class="o">&amp;</span> <span class="n">user</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">user</span><span class="o">-&gt;</span><span class="n">Request</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">User</span><span class="o">::</span><span class="n">AddExp</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">7</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">));</span>
    <span class="p">});</span>

    <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">users</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">users</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">UserRef</span><span class="o">&amp;</span> <span class="n">user</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Exp (&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">user</span><span class="o">-&gt;</span><span class="n">GetExp</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;)&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">});</span>

    <span class="n">users</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">users</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">users</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3>정리</h3>

<p>멀티 Thread 프로그래밍에서 Lock 없는 코드를 작성하는 것은 성능적으로 꽤나 중요한 일이다. 따라서 위와 같은 방법을 통해 공유 객체에 대한 수행을 보호하는 것도 좋은 방법일 것이다.</p>

<p>물론 위 구조를 사용하기 위해서는 비동기적으로 로직을 구성해야할 것이고, 물론 이게 만만한 작업은 아니다. 그에 대해서는 프로그램의 성능과 구현의 복잡도에 대한 적절한 타협을 통해 결론지어야 할 것이다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">환형큐의 thread unsafety 문제</h1>
				<p class="page-date">23 Feb 2012</p>
				<p class="page-tags">
						
						
					<code class="tag">concurrency</code>
						
						
						
					<code class="tag">c++</code>
						
						
						
						
				</p>
				<div class="content"><p>어떤 자원에 대한 환형큐가 있다고 해보자. size는 2의 자승이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="kt">resource_t</span> <span class="n">res</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">atomic_inc32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rear_</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">size_</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">array</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">resource_t</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">atomic_inc32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">front_</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">size_</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">array</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div>
<p>위 코드는 당연히 thread safety 하지 않다. 하지만 문제가 발생하지 않도록 나름 머리를 써서 다음과 같이 위 코드를 사용한다고 해보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">work</span><span class="p">(</span><span class="kt">resource_t</span> <span class="n">old</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">push</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>  <span class="c1">// release old resource</span>
    <span class="kt">resource_t</span> <span class="n">newone</span> <span class="o">=</span> <span class="n">pop</span><span class="p">();</span> <span class="c1">// acquire new on</span>
    <span class="c1">// do some work</span>
<span class="p">}</span>
</code></pre></div>
<p>예전 자원을 반환하고, 새로운 자원을 할당받아 그것으로 무슨 작업을 하는 것이다.<br>
이렇게 되면 pop 을 부르는 시점의 thread 는 적어도 자신이 push 한 자원 1개가 반드시 존재함을 보장할 수 있으니까 문제가 생기지 않는다.</p>

<p>라고 생각하면 함정.</p>

<p>thread 4개가 동시에 work 함수를 수행한다고 해보자.</p>

<ul>
<li>push를 수행했으니까 <code>rear_</code>는 4만큼 증가한다.</li>
<li>가장 마지막으로 <code>rear_</code>를 증가시킨 thread만 <code>array</code>에 <code>resource_t</code>를 대입하였고,</li>
<li>나머지 thread들은 아직 <code>array</code>에 대입하기 전이다.</li>
<li>그러면 <code>index</code>만 증가해있고, 실제 배열은 비어있다.</li>
<li>그래서 마지막 thread가 <code>pop</code>을 할 때 access violation으로 프로그램이 사망한다.</li>
</ul>

<p>즉, <code>index</code>의 증가는 atomic함을 보장하지만 그것이 배열에 자원이 대입되었음을 보장해주지 못하므로 사망한다.</p>

<p>척 봐도 당연한 소리를 여기에 쓰고 있는 이유는, 이걸 직접 당해보고도 몇 달 지나니까 다시 이 사실을 까먹기 때문이다-_-;</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1><a id="database" href="#database">database</a></h1>
				<hr />
				<div class="page-breaker"></div>
							
						
				<h1 class="page-title">debian 계열 db 덮어쓸 때 주의점</h1>
				<p class="page-date">21 Dec 2010</p>
				<p class="page-tags">
						
						
					<code class="tag">database</code>
						
						
						
						
				</p>
				<div class="content"><p>debian-sys-maint 계정 암호가 바뀌면 안된다</p>

<p>이 암호는 <code>/etc/mysql/debian.cnf</code>에서 볼 수 있으니 여기서 암호를 찾아서,</p>
<div class="highlight"><pre><code class="sql language-sql" data-lang="sql"><span class="k">GRANT</span> <span class="k">ALL</span> <span class="k">PRIVILEGES</span> <span class="k">ON</span> <span class="o">*</span><span class="p">.</span><span class="o">*</span> <span class="k">TO</span> <span class="s1">&#39;debian-sys-maint&#39;</span><span class="o">@</span><span class="s1">&#39;localhost&#39;</span> <span class="n">IDENTIFIED</span> <span class="k">BY</span> <span class="s1">&#39;YOUR-PASSWORD&#39;</span> <span class="k">WITH</span> <span class="k">GRANT</span> <span class="k">OPTION</span>
<span class="k">GRANT</span> <span class="n">RELOAD</span><span class="p">,</span> <span class="n">SHUTDOWN</span><span class="p">,</span> <span class="n">PROCESS</span><span class="p">,</span> <span class="k">SHOW</span> <span class="n">DATABASES</span><span class="p">,</span> <span class="n">SUPER</span><span class="p">,</span> <span class="k">LOCK</span> <span class="n">TABLES</span> <span class="k">ON</span> <span class="o">*</span><span class="p">.</span><span class="o">*</span> <span class="k">TO</span> <span class="s1">&#39;debian-sys-maint&#39;</span><span class="o">@</span><span class="s1">&#39;localhost&#39;</span> <span class="n">IDENTIFIED</span> <span class="k">BY</span> <span class="s1">&#39;YOUR-PASSWORD&#39;</span>
</code></pre></div>
<p>한번 해줘서 계정 암호 갱신하면 된다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1><a id="design" href="#design">design</a></h1>
				<hr />
				<div class="page-breaker"></div>
							
						
				<h1 class="page-title">Object Database와 Value Object</h1>
				<p class="page-date">22 Feb 2011</p>
				<p class="page-tags">
						
						
					<code class="tag">design</code>
						
						
						
					<code class="tag">database</code>
						
						
						
						
				</p>
				<div class="content"><p>프로그램이 Client, Server의 2-tier 모델에서 Server가 Data의 persistence를 위해 database를 사용한다. 이 때 client가 요청한 정보를 server가 database로부터 반환받아 client에게 넘겨주는 framework를 작성해보자.</p>

<h3>설계 1</h3>

<p>일단 Client와 Server가 주고 받을 데이터를 담는 객체를 설계한다.
기본(primitive) type과 String, Date 등의 간단한 정보를 속성(멤버 변수)로 갖는 JavaBean 객체를 설계한다.</p>

<h3>설계 2</h3>

<p>Client의 요청에 대해 Server가 Database로 Query를 날려서 그 결과를 JavaBean 객체에 남아서 Client로 반환한다.</p>

<h3>설계 3</h3>

<p>여러 프로그램을 작성하는 과정에서 Database Table에 대해 데이터를 삽입(Insert)하거나 갱신(Update)하는 등의 경우에서 유사한 코드가 자주 중복된다. 이러한 부분을 Framework으로 묶고자 Object 기반의 Database Adapter를 설계한다.</p>

<p>Database Table에 대응되는 객체를 설계(class)하고,
각 객체에 대해 Database Adapter의 CRUD(Insert, Select, Update, Delete)를 수행할 때 객체 내부의 Member 정보를 Reflection을 통해 접근해서 Query를 자동으로 생성할 수 있도록 한다.</p>

<p>이러한 Database Adapter를 통해서 굉장히 간단한 방법으로, 객체 기반의 Database 접근이 가능해진다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="n">Database</span> <span class="n">db</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MySQLDatabase</span><span class="o">();</span>
<span class="n">db</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="s">&quot;lacti&quot;</span><span class="o">,</span> <span class="s">&quot;poolc&quot;</span><span class="o">));</span>
<span class="n">Person</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="s">&quot;lacti&quot;</span><span class="o">);</span>
<span class="n">db</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
<span class="n">db</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
</code></pre></div>
<h3>문제점</h3>

<p>해당 Database Adapter는 Relation Database를 Object Database로 adapting해버리므로 JOIN 등의 Select query를 처리할만한 좋은 방법이 없다. 즉, 객체 단위의 데이터베이스 작업에 대해서는 간단한 작업을 보장하지만 각 Table의 Relation을 고려해야할 경우에 문제가 생긴다.</p>

<p>또한, 특정 값을 Update하거나, Where 조건이 복잡해지거나, 특정 항목만 Select할 경우에 대해서는 설계적으로 명확히 제공해주지 않기 때문에 구현이 복잡해지거나 자원 낭비가 발생한다.</p>

<h3>문제점 원인 분석</h3>

<p>본 모델은 Mysql J/Connector의 QueryAdapter를 기반으로 설계된 모델로, Query를 직접 작성하지 않고 객체의 class 정보를 reflection으로 읽어서 자동으로 Query를 구성해주어 작업의 편의를 도모하고자 설계한 것이다.</p>

<p>그렇기 때문에 Query를 직접 구성해야하는 경우에는 이러한 모델이 적합하지 않다.</p>

<p>따라서 위의 Object Database Adapter는 MySQL 등의 RDB에 붙여서 사용하는 것보다는 테스트를 위해 Memory Model을 사용할 때 더 적합하며, Relation이 적게 고려되는 간단한 Database 프로그래밍을 해야할 때 사용될 수 있겠다.</p>

<h3>문제점 해결</h3>

<p>이러한 Adapter를 통해 Query를 직접 작성하지 않고 Database로부터의 결합을 분리시키기 위해서는, Query를 Modeling하여 이에 대해 각 Database별 구현을 가질 수 있도록 한다.</p>

<p>하지만 이러한 경우를 고려하기에는 부담이 크므로 이에 대해서는 본 설계에서는 단순히 MySQL을 사용한다고 가정한다.</p>

<ul>
<li>물론 이렇게 될 경우 Test 코드를 작성해도 MySQL에서 돌려야하는 문제점이 있으므로 좋지 않다.</li>
<li>Test 용 데이터베이스를 따로 관리해야할 수도 있다.</li>
<li>물론 ror 등에서는 이를 위해 Test 용 데이터베이스를 생성해주는 기능이 있는데 이는 다음에 다루어보자</li>
</ul>

<p>jdbc를 사용하여 MySQL에 접속하여 Connection 객체를 얻을 것이다.
인자의 안정성 보장을 위해 PreparedStatement 객체를 생성한 후 직접 작성한 Query를 통해 결과를 ResultSet으로 받아온다.</p>

<p>이 때,</p>

<ol>
<li>결과를 담는 객체를 Generalize하기 위해서 Map 형태의 결과 담기 객체를 사용할 수 있다.</li>
<li>결과를 명시적으로 담는 객체를 각 결과에 대응하여 생성한다.</li>
</ol>

<p>1)로 설계할 경우 훨씬 유연하고(어차피 내부에서 String 등으로 각 값에 접근할테니 오류가 나서 죽는 경우는 있어도 Database 모델이 변경된다고 해도 class가 바뀔 일은 없다) 위험성을 갖는다.<br>
2)로 설계할 경우 1)에 비해 유연성은 다소 떨어지고 작업량이 증가하겠지만 훨씬 안전한 프로그래밍이 가능하다.</p>

<p>이에 대해서 본인의 생각을 이야기하자면,<br>
당연히 2)의 설계 방향으로 진행하되, 2)에서 이야기하는 &quot;결과를 담을 객체&quot;의 설계는 굉장히 기계적인 프로그래밍이 될 수 있으므로 이에 대해서는 code를 generating하는 방식을 사용하는게 어떨까 싶다.</p>

<p>아무튼 이러한 객체를 <code>ValueObject</code>라고 해서 DAO 패턴에서 볼 수 있게 된다. 따라서 Server는 Client의 요청에 대해 Database에 필요한 정보를 요청하여 그 정보를 담는 VO 객체를 반환하면 된다.</p>

<h3>결론</h3>

<p>프로그래밍을 함에 있어 Data의 Persistence를 고려하지 않는 프로그램은 없을 정도로 이는 기본 요소라고 할 수 있겠다. 하지만 프로그램에서 어떤 수준을 요구하냐에 따라서 그에 적합한 설계를 해야할 것이고,</p>

<p>가장 중요한 것은 어느 특정 하나에 지나치게 결합되어 분리되지 않는 경우에는 나중에 크게 당할 수 있으니 이에 대한 고려를 하면서 프로그래밍을 진행하는 것이다. 간단한 방법으로 Test Code를 작성하기 용이한 설계인가? 정도를 고려해봐도 괜찮겠다.</p>

<p>간단한 Object 기반의 Database와 복잡한 Query 기반의 Database 모두 자주 사용되는 것으로 이에 대한 공통된 interface를 갖는 framework를 설계하고 싶지만 간단한 일이 아니다.</p>

<p>따라서 본 문서에서는 간단히 각 경우에 대해 적합한 설계를 하자는 흐지부지한 결론을 내렸다. 물론 C#의 DataSource, DataTable, DataAdapter 개념, LINQ 등을 잘 고려해보면 만들고자 하는 framework을 못 만들 것도 없겠지만, 과연 <em>간단히</em> 만들 수 있을까 싶다.</p>

<p>해당 사항은 나중에 논의해보자.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">게임 데이터 작성하기 1</h1>
				<p class="page-date">25 Jul 2013</p>
				<p class="page-tags">
						
						
					<code class="tag">design</code>
						
						
						
					<code class="tag">game</code>
						
						
						
					<code class="tag">data</code>
						
						
						
						
				</p>
				<div class="content"><p>보통 프로그램을 작성할 때에는 필요한 데이터를 읽고, 해석하여 동작하는 구조로 많이 작성한다.
게임 역시 마찬가지의 구조를 갖는데, <strong>데이터의 종류가 좀 많고, 상호 연관성이 있으며, 양도 꽤 많다</strong>는 점이 특징이라 할 수 있겠다.</p>

<p>나는 회사에서 게임 코딩을 할 때 보통 다음의 순서로 진행했다.</p>

<ol>
<li>기획서/사양서를 보고 대충 시스템을 설계한다.</li>
<li>기획자가 데이터를 입력할 수 있도록 적절히 코드와 데이터를 분리한다.</li>
<li>기획자에게 데이터 구조를 알려주고(예제 전달 등) 유지 보수를 진행한다.</li>
</ol>

<p>기획자가 데이터의 구조를 잡아서 주는 경우도 있지만 (합의 하에) 구조를 변경하여 진행하였으므로 사실상 프로그래머 주도로 데이터가 설계된 것이다.</p>

<p>완벽하게 독립적인 기능을 만든다, 라는 것이 가능할지는 모르겠지만 적어도 게임 데이터가 그런 경우는 없는 것 같다. 즉 하나 이상의 다른 기능과 연관된 데이터를 작성하게 된다는 것이다. 경험상 위처럼 데이터를 작성할 경우 데이터의 구조가 금새 엉망이 되었고 흐트러지기 일쑤였다.</p>

<p>프로그램을 먼저 작성하고 데이터의 구조를 나중에 잡는 경우에는 프로그램에서 읽기 편한대로 데이터를 작성하게 되는 경우가 많고, 그 과정에서 데이터의 정합성이 깨진다거나 미처 고려하지 못한 많은 요소들로 인해 문제가 발생했기 때문이다. (데이터 입력이 불편함, 연관된 데이터를 찾기 어려움, Localization 작업이 어려움 등)</p>

<p>따라서 데이터를 먼저 설계하고 그에 맞추어 프로그램을 작성하는 것이 좋다는 이야기를 시작해보려 한다.</p>

<p>데이터를 설계할 때 적어도 다음의 요소에 대한 고려가 필요하다고 생각한다.</p>

<ol>
<li>데이터 입력이 편리한가?</li>
<li>데이터 구조를 직관적으로 이해할 수 있고, 컨텐츠와 연결지어 생각할 수 있는가?</li>
<li>업데이트 히스토리를 기록하기 용이한 구조로 작성되었는가?</li>
<li>하나의 파일에 하나의 의미를 지니는 데이터가 들어가 있는가?</li>
<li>Localization 작업이 수월한가?</li>
<li>서버, 클라이언트, 툴에서 읽기에 무리가 없고, 각자 필요한 데이터가 잘 분리되어 입력된 구조인가?</li>
<li>각 데이터의 식별자는 명확한가?</li>
<li>연관성을 데이터 수준에서 검증할 수 있는가?</li>
<li>형 검사(type validation)가 가능한 형태로 작성되었는가?</li>
<li>Branch와 Merge에 견고한 구조로 작성되었는가?</li>
</ol>

<p>더 많이 있겠지만 일단 생각나는대로 적다보니 부족한 내용이 있을텐데 글 쓰다보면 기억날 것이라 믿고 일단 넘어간다-_-</p>

<p>대충 묶어보면 <strong>작업 편의성, 직관성, 식별성, 정합성</strong> 정도가 될 것 같다.</p>

<h3>직관성, 편의성</h3>

<p>데이터의 직관성은 작업 편의성과도 연결된다.</p>

<p>데이터가 직관적으로 작성되어 있어 그 의도에 대해 원 시스템 설계자에게 물어보거나, 다른 문서를 찾아볼 필요가 없다면 최고이다. 게다가 직관적이면 입력하기 어렵지도 않을테니 작업하기도 쉽다.
더 나아가서 데이터를 읽는 것 만으로 시스템의 의도를 이해할 수 있고 해당 컨텐츠에 대해 이해할 수 있다면 정말 좋을 것이다. 그리고 해당 데이터의 변경 사항을 버전 관리 도구로 파악하여 이전 작업자의 의도까지 파악한다면?</p>

<p>꿈 같은 소리라고 생각할 수 있지만 의외로 프로그래머에게는 익숙한 내용이다. 직관적으로 작성된 코드는 그 의도에 대해 원 작업자에게 물어볼 필요도 없이 이해가 가능하고, 해당 코드를 읽는 것만으로도 컨텐츠에 대해 이해할 수 있고 유지보수 하기도 쉽다. 그리고 버전 관리 도구의 로그를 통해 변경 사항과 그 의도를 파악할 수 있다.</p>

<p>필요한 부분에만 주석으로 정보를 추가한다. 너무 많은 주석은 주석에 대한 유지 보수 비용이 발생하기 때문이다. 해당 코드를 설명하는 추가적인 문서를 작성했다면? 주석에 대한 유지 보수 비용보다 더 큰 비용이 발생하기 때문에 오히려 더 비효율을 야기하는 작업일 것이라 생각한다. 즉 코드를 직관적으로 잘 작성하는게 최고라고 생각한다.</p>

<p>코드가 되는데 데이터가 안 될리가 없다. 다만 데이터 입력은 생각보다 중요한 작업이 아니라고 생각하기 때문에 대충 돌아가는 수준으로 데이터를 입력하는 경우가 많고, 그 때문에 대충 작성한 코드처럼 난해하고 작성하기 어려운 구조의 데이터가 만들어지게 되는 것이다.</p>

<p>프로그래머가 깨끗한 코드를 작성하려 노력하는 것처럼 데이터 작성에 있어서도 깨끗한 데이터 작성을 위해 노력해야 한다는 것이다. <del>제발 key 이름을 a, b, c 이런 것 좀 쓰지 말고.</del> 그리고 버전 관리 도구에 변경 사항에 대한 로그는 빈 칸으로 남기고 업데이트 히스토리를 따로 작성해서 남기지 말고, 제발 좀!</p>

<h3>툴</h3>

<p>직관적으로 작성된 데이터가 literal programming 수준으로 진화하다보면 데이터가 소설이 되는 경우가 있다. 개인적으로 그러한 경향이 옳은지는 잘 모르겠는데 이것을 작업 편의성과 묶어서 생각해보면 좋을 것 같다.</p>

<p>패키지 게임을 만들거나, 3달 서비스할 게임을 만들면 상관이 없겠지만 만약 그보다 더 긴 기간의 서비스를 진행하는 게임이라면 데이터 작업이 쉽도록 데이터가 설계되어야 한다. 하지만 직관성과 충돌이 발생할 경우에는 반드시 직관성을 우선해야 한다고 생각한다. <del>(입력하기 귀찮다고 key 이름을 a, b, c로 짓지 말고 좀!)</del></p>

<p>그렇다면 어떻게 하면 직관성과 편의성을 모두 얻을 수 있을까? 그것을 위해 필요한 것이 툴과 스크립트라고 생각한다.</p>

<p>툴을 통한 데이터 template, scaffolding, assist 등을 지원하고 스크립트를 통해 대규모 작업을 쉽게 수행할 수 있도록 한다. 기획자들은 <code>툴 + 스크립트</code>를 <code>Excel + VBA</code>로 사용하는 경우가 많기 때문에 별도의 툴을 만들어준다고 해도 잘 쓰지 않는 경우가 많다. 때문에 <code>툴 + 스크립트</code>를 <code>VSTO Excel + C#</code>으로 해결하는 것이 현재는 가장 합리적인 해결책이라고 생각한다. 이에 대해서는 추후 다른 글에서 다루도록 하겠다.</p>

<p>결국 적절한 툴/스크립트가 제공되어 기획자들의 작업 효율이 향상될 수 있도록 해야 한다는 것인데 이 때 고려할 점은 다음과 같다고 생각한다.</p>

<ol>
<li>최대한 단일 툴에서 모든 데이터를 다룰 수 있도록 구현</li>
<li>툴만 봐도 게임이 어떻게 흘러가는지 알 수 있도록 직관적으로 구성</li>
<li>반드시 툴을 사용하지 않아도 데이터 작업이 가능할 수 있도록 작성</li>
<li>툴로 인해 생성되는 임시/중간/결과 파일 등이 merge 가능한 형태가 되도록 구성</li>
<li>툴에서 데이터의 유효성 검사가 가능하도록 구현</li>
<li>가능하다면 인-게임 툴로 구현</li>
</ol>

<ul>
<li>이것 역시 VSTO Excel 이야기할 때 같이 이야기해보도록 하겠다.</li>
</ul>

<h3>데이터 정의</h3>

<p>프로그램을 잘 작성하기 위해 먼저 큰 그림을 그린다. 데이터 역시 마찬가지로 데이터가 어떻게 작성되어야 할지 설계를 해야 한다. (보통 이런 작업을 안하고 데이터를 만들다보면 모든 자잘한 데이터가 다 담긴 창고(warehouse) 파일 같은 것이 생긴다.)</p>

<p>데이터를 설계할 때에는, 약간 과하게 생각해본다면 RDB처럼 설계할 수 있다. 각 데이터가 고유 식별자를 갖고(Primary-Key) 다른 데이터를 참조(Foreign-Key) 할 수 있는 것이다. 그리고 여러 제약 조건을 가질 수 있도록 만든다. 이러한 정보는 metadata에 속하니 이를 기록할 수 있는 파일을 먼저 만든다. 보통 data definition이라고 하는데 직접 언어를 만들어서 서술해도 좋고 XSD 같은 것을 사용해도 좋다고 생각한다.</p>

<p>위와 같은 작업을 해두면 무엇이 좋을까?</p>

<ol>
<li>데이터만 보고 컨텐츠 간의 명확한 연관관계를 파악할 수 있다. (참조 그래프를 제대로 그렸다면)</li>
<li>데이터의 정합성을 쉽게 판단할 수 있다. (해당 아이템에 연결된 퀘스트가 존재하지 않습니다. 즉 퀘스트만 삭제함)</li>
<li>데이터의 형 오류를 쉽게 판단할 수 있다. (공격력에 0.5 입력해봐야 서버에서 int로 읽으면 0이다)</li>
<li>데이터의 연결성을 파악할 수 있으니 데이터 template 작성에 좋다. 즉 scaffolding이 쉽다.</li>
<li>data definition 기반으로 model, parser 등의 코드를 자동 생성할 수 있다.</li>
<li>고유 식별자를 통해 데이터의 변경점을 원자적으로 분리할 수 있고 이는 데이터 merge에 큰 도움이 된다.</li>
</ol>

<ul>
<li>6번 항목에 대해서는 데이터 merge 글에서 다시 다루도록 하겠다.</li>
</ul>

<p>당연한 이야기를 써놓은 것 같지만 의외로 잘 지켜지지 않는 내용들이다.<br>
데이터를 설계를 먼저하고 데이터를 입력한다는 것은 data definition을 먼저 작성하고 실 데이터를 입력한다는 것이기 때문에 기존 데이터의 구조를 고려하여 새로운 데이터의 식별성, 연관성, 형, 제약 조건들을 먼저 입력한다는 것이다. 보다 주의깊게 데이터를 설계하게 될 것이라고 생각한다. (물론 이를 도와주는 적절한 data design가 있으면 더욱 좋을 것이다.)</p>

<p>반면 데이터를 먼저 입력하고 그것을 기반으로 data definition을 만들어냈을 경우 data definition이 제대로 만들어지지 않을 가능성이 높다. 좁은 시야로 자기가 원하는 데이터를 작성하기 때문인데, 실제로 회사에서 클라이언트 개발자와 서버 개발자가 작성한 같은 컨텐츠의 다른 데이터의 정합성이 전혀 맞지 않는 문제가 있었다-_-</p>

<p>하나의 동일한 의미를 가리키는 key가 전혀 달라서 발생한 문제인데 그 이유는 단순히 서버/클라이언트에서 각자 읽기 쉬운 구조로 데이터의 식별자를 정의하였기 때문이다. 이 데이터는 추후 data definition 정리 및 툴 작성의 가장 큰 걸림돌이 되었다.</p>

<ul>
<li>localization 관련 내용에 대해서는 추후 다른 글에서 다루도록 하겠다.</li>
</ul>

<h3>정리</h3>

<p>대충 썼는데 요약하면 데이터를 입력하기에 앞서 data definition을 먼저 잘 정의하자는 것이다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">서버 프로그래밍</h1>
				<p class="page-date">22 Dec 2013</p>
				<p class="page-tags">
						
						
					<code class="tag">design</code>
						
						
						
					<code class="tag">server</code>
						
						
						
						
				</p>
				<div class="content"><h3>설계</h3>

<p>동기화 수준과 성능(규모) 수준을 고려해서 작성한다.</p>

<ul>
<li>완전 비동기나 느슨한 비동기 수준으로 괜찮다면 웹 서버를 사용해도 좋다.</li>
<li>실시간 비동기가 필요하면서 성능이 중요할 경우 직접 서버를 구현하는 편이 좋다.</li>
<li>morpg나 fps 정도의 서버라면 stmp(single thread multiple process) 구조로 가도 좋다.</li>
<li>mmorpg나 그 이상의 성능을 요구하는 서버라면 task parallelism 기반이면서 scaleable한 서버를 만드는 편이 좋지만 필요한 규모에 따라 적절한 수준으로 적용하면 된다.</li>
</ul>

<p>결국 <strong>어떤 서버</strong>를 만들 것인지에 대한 기술 명세를 한 후 그에 맞는 설계/구현을 해야 한다는 것.</p>

<h3>비동기</h3>

<p>io와 비동기 개념을 공부한다.</p>

<ul>
<li>간단히 application은 io(file, network 등) 작업을 kernel에게 요청(request)하고, kernel은 해당 요청이 완료(completion)되면 application에게 알려준다.</li>
<li>요청한 후 완료될 때까지 기다리면(blocking) 동기(sync) 작업이라고 하고, 요청해놓고 완료된 사실을 나중에 따로(poll, interrupt) 알게되면 비동기(async) 작업이라고 한다.</li>
<li>여러 클라이언트와 동시에 통신해야 하는 서버를 구현한다고 하면 각 클라이언트와의 연결을 유지하면서 각각에 대한 io 작업(메시지 보내기/받기)를 수행해야 한다.</li>
<li>이 때 io 작업을 동기적으로 처리하면 각 요청이 완료될 때까지 blocking되므로 동시에 여러 작업을 처리하기 위해서는 각각이 blocking되어도 문제 없도록 thread를 여러 개 만들거나, 비동기 io를 사용한다.</li>
</ul>

<p>당연히 thread를 여러 개 만드는 것은 효율이 좋지 않으므로 효율을 고려한 서버를 구현할 경우에는 비동기 io를 사용한다.</p>

<h3>언어</h3>

<p>성능(throughput) 수준과 개인의 취향에 따라 사용할 언어를 적절히 선택해주면 된다.</p>

<ul>
<li>javascript가 좋고 logic 부담이 적다면 <strong>nodejs</strong>는 좋은 선택이 될 것이다.</li>
<li>visual studio가 좋지만 c++이 싫다면 <strong>c#</strong>은 좋은 선택이 될 것이다.</li>
<li>높은 수준의 성능이 요구된다면 <strong>c++</strong>도 좋은 선택이 될 것이다. <del>그리고 지옥을 보겠지</del></li>
</ul>

<p>공부나 재미를 위한 상황이라면 그냥 본인의 취향에 맞게 선택하면 된다. 그렇지 않고 결과물을 위해서 언어를 선택해야 한다면 신중한 결정이 필요하다. 보통 io와 logic의 부담을 제대로 구별하지 못하고 과도한 최적화를 들먹이며 native를 고집하는 경우가 있는데 본인에게도, 미래의 본인에게도 별로 좋은 선택은 아니다. <del>c++밖에 할 줄 아는 언어가 없어서라는 이유가 있기는 한데 그건 좀...</del></p>

<p>대부분의 도메인에서는 nodejs나 c# 정도면 충분히 문제를 해결할 수 있다. nodejs나 c# 모두 network library에 대한 기본 내장이 잘 되어 있으므로 약간의 기반 코드 작성 후 logic에 집중할 수 있다.</p>

<h3>라이브러리</h3>

<p>c++이나 java로 서버를 직접 작성하게 될 경우에는 기반 library를 사용하는 것이 좋다.
개인적으로 c++은 <a href="http://www.boost.org/doc/libs/release/doc/html/boost_asio.html">asio</a>가 괜찮고 java는 <a href="http://netty.io/">netty</a>가 괜찮다고 생각한다.</p>

<p>어느 정도 비동기 프로그래밍 패턴이 익숙하다면 예제 코드 좀 보면 어떻게 써먹을 수 있을 지 대충은 이해할 수 있다. 그리고 워낙 저 두 프로젝트는 문서화가 잘 되어 있으니 문서만 읽어도 대부분은 이해된다.</p>

<h3>구조</h3>

<p>구조는 event model과 queue model 정도로 구분이 가능하다.</p>

<ul>
<li>event model은 메시지를 받은 즉시 처리해서 그 결과를 클라이언트에게 다시 알려주는 방식이고,</li>
<li>queue model은 받은 메시지를 queue에 쌓아두고, 서버에서 tick을 돌면서 queue에 있는 메시지를 꺼내 처리하고 그 결과를 클라이언트로 다시 알려주는 방식이다.</li>
<li>event model의 경우 stateless/tickless한 요청에 대한 처리를 할 때 유리하고,</li>
<li>queue model의 경우 tick 단위로 수행해야 하는 작업이 있을 때 유리하다.</li>
</ul>

<p>여기서 유리하다는건 최적화가 하기가 좋다거나 코드 작성/유지보수가 쉽다는 소리다.</p>

<p>예를 들어 별로 크지 않은 게임 서버를 만든다면,</p>

<ul>
<li>io thread 한 두어 개 돌려서 message 받아 message queue에 넣고</li>
<li>logic thread 한 개가 tick 돌면서 tick 작업도 처리하고 message queue에 들어온 메시지도 처리하는 구조가 될 것이다.</li>
</ul>

<p>각 thread가 늘어날 때 공유 자원에 대한 동기화 문제도 잘 고민해주어야 한다.</p>

<h3>정리</h3>

<p>메시지가 뭐고, 소켓이 뭐고, 이것들이 어떻게 관리되고는 그냥 기초 네트워크 프로그래밍 책만 읽어도 잘 소개되어 있는 내용이기 때문에 책을 읽어보면 되겠다. 그 정도의 내용은 TCP/IP 네트워크 프로그래밍 정도에도 잘 나와 있다. poll이니 interrupt이니 이런 내용은 논리회로, ca, os, sysp에도 자주 등장하고, 동기/비동기는 pp/os/sysp에 등장한다. 고로 수업만 잘 들어도 대충 기반 개념을 다 배우는 셈.</p>

<p>뭐 그게 잘 안 되었다고 하더라도 인터넷에 잘 정리된 문서가 많고 여기 풀씨에도 관련 글이 많으니 진입하는데 별로 어려움은 없다. 다만 실질적으로 어떻게 코딩을 하느냐는 직접 해보면서 감을 잡는 것과 남이 작성하는 것을 읽고 공부하는 것인데, 전자는 그냥 해보면 되고, 후자의 경우 github에 널리고 널린게 서버 프로그램이니 그걸 보고 공부하면 된다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1><a id="distributed" href="#distributed">distributed</a></h1>
				<hr />
				<div class="page-breaker"></div>
							
						
				<h1 class="page-title">concurrency pattern과 분산 시스템 스터디</h1>
				<p class="page-date">26 Aug 2013</p>
				<p class="page-tags">
						
						
					<code class="tag">distributed</code>
						
						
						
					<code class="tag">concurrency</code>
						
						
						
					<code class="tag">study</code>
						
						
						
						
				</p>
				<div class="content"><p>Concurrency Pattern부터 Distributed System까지! 근데 대충함 [...]</p>

<h3><a href="http://en.wikipedia.org/wiki/Concurrency_pattern">Concurrency pattern</a></h3>

<p>대충 정리해보자.</p>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Active_Object">Wiki: Active Object</a>

<ul>
<li>Active Object는 Actor Model 구현하면서 써봤다. asynchronous method invocation과 request scheduling이 관건이다. 지난 글에서는 함수 요청을 functor로 만들어서 요청을 queueing하고, 처음 진입하는 thread가 해당 queue의 모든 작업을 처리하는 식으로 구현하였다.</li>
</ul></li>
<li><a href="http://en.wikipedia.org/wiki/Double_checked_locking_pattern">Wiki: Double checked locking pattern</a>

<ul>
<li>보호해야 하는 특정 구간에 대해 단순 if 문으로 조건을 검사할 경우 여러 thread가 동시에 진입하여 concurrency problem이 발생할 수 있다. 따라서 해당 if문도 lock으로 보호해야 하는데, if 문 내의 코드가 정말 드물게 실행되는 경우 매번 lock을 걸고 if 문을 검사하는 것은 뭔가 아까워서, 일단 lock 없이 if 문으로 대충 검사해보고, lock 걸고, 다시 if 문으로 검사하여 안전하게 코드를 수행시키는 방법이다.

<ul>
<li>물론 memory order 문제가 있을 수 있다. 이와 관련해서는 <a href="http://board.poolc.org/generation03/512">PoolC: C++ 싱글톤</a> 문서의 <code>ThreadSafe::create()</code> 함수를 보면 된다.</li>
</ul></li>
<li>보통 singleton 객체의 초기화를 위해 많이 사용되는 방법이다.</li>
<li>c++11에서는 function 내의 static variable의 초기화에 대해 하나의 thread만 초기화를 수행하도록 표준으로 정해져서 wiki 예제에서는 단순히 static 변수를 써서 singleton을 구현하는 방법을 보여주고 있다.</li>
</ul></li>
<li><a href="http://en.wikipedia.org/wiki/Balking_pattern">Balking</a>, <a href="http://en.wikipedia.org/wiki/Guarded_suspension">Guarded suspension</a>, Leaders/Followers, <a href="http://en.wikipedia.org/wiki/Scheduler_pattern">Scheduler</a>, <a href="http://en.wikipedia.org/wiki/Thread_pool_pattern">Threadpool</a>, <a href="http://en.wikipedia.org/wiki/Thread-Specific_Storage">TLS</a> 등은 그냥 읽어보면 된다.</li>
</ul>

<h3><a href="http://en.wikipedia.org/wiki/Read_write_lock_pattern">Readers–writer lock</a></h3>

<p>Read Write Lock Pattern은 multiple-readers(shared), single-writer(exclusive) lock을 구현하는 것. writer starvation은 limit-read-count를 쓰던, timeout을 쓰던 잘 처리하면 된다.</p>

<p>재귀(recursive-policy)를 고려하면 문제가 약간 복잡해진다. 같은 객체의 여러 method가 read/write lock을 걸 수 있고, 그 함수들간의 호출이 가능하다고 가정하자. 그러면 다음의 4가지 경우에 대해서 고민이 필요하다.</p>

<ul>
<li>read lock 걸고 read lock 또 걸면?</li>
<li>read lock 걸고 write lock 걸면?</li>
<li>write lock 걸고 write lock 또 걸면?</li>
<li>write lock 걸고 read lock 걸면?</li>
</ul>

<ol>
<li>read/read는 read가 shared lock이니 그냥 둬도 문제가 없겠다.</li>
<li>write/write와 write/read를 허용하려면, write lock을 획득하는 당시 획득한 thread-id를 기록해두어 재귀를 허용하도록 구현해야 한다.</li>
<li>read/write를 허용하는 좋은 방법은 없다. 처음에 read lock을 획득하고 시작해서, 갑자기 write lock으로 상승(upgrade)해버리면 같이 진입한 read lock thread들의 처치가 곤란하기 때문이다.</li>
</ol>

<p>때문에 upgradable-read mode를 추가한다. 그래서 read, upgradable-read, write 간의 상관관계를 재정의하여 재진입성을 다시 고려한다. 이에 대한 개념은 데이터베이스에서 잘 확인해볼 수 있다.</p>

<ul>
<li><a href="http://msdn.microsoft.com/en-us/library/system.threading.readerwriterlockslim.aspx">MSDN: ReaderWriterLockSlim</a></li>
<li><a href="http://technet.microsoft.com/en-us/library/ms186396.aspx">MSDN: Lock Compatibility (Database Engine)</a></li>
</ul>

<h3>asynchronous method</h3>

<p>잘 기억은 안 나는데 asynchronous method에 대해서 잠깐 이야기가 있었다. async-method를 요청할 때의 코드 패턴에 대한 이야기였는데</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">request_async</span><span class="p">(</span><span class="n">request_context</span> <span class="n">context</span><span class="p">,</span> <span class="n">async_state</span> <span class="n">state</span><span class="p">,</span> <span class="kt">callback_t</span> <span class="n">callback</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">async_result</span> <span class="n">result</span> <span class="o">=</span> <span class="n">magical_async_method</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
    <span class="n">callback</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>비동기 함수 요청을 할 때, 요청자의 상태를 저장하기 위한 async_state를 callback과 함께 async_method에 넘기면, async_method에서는 인자로 받은 async_state를 async 수행 결과 결과(async_result)와 함께 callback으로 넘겨준다는 이야기이다.</p>

<p>iocp의 경우 overlapped 구조체를 상속받아서 async_state와 async_result 역할을 하나의 구조체에서 수행하기도 한다. proactor pattern 중 이를 async token이라고 표현하기도 한다.</p>

<h3><a href="http://en.wikipedia.org/wiki/MapReduce">MapReduce</a></h3>

<p>map/reduce는 functional programming에 있는 그 개념을 그대로 분산시스템에 적용했다고 보면 되겠다. 다만 fault tolerant를 고려해주면 되겠다.</p>

<h3>Remote Session</h3>

<p>RemoteSession은 java.rmi와 같이 stateless한 rpc에서 proxy가 내부적으로 session key를 갖고 session을 유지해주기 위해 본인이 직접 구현한 library인데 본인이 wiki에 추가해놓은 것 같다. 넘어가자.</p>

<h3><a href="http://eincs.net/2013/07/misleading-and-truth-of-cap-theorem">eincs: CAP Theorem, 오해와 진실 (PACELC)</a></h3>

<p>분산 시스템은 네트워크 시스템을 전제로 하니 P를 고려하지 않을 수 없다. 그리고 장애 발생 상황과 정상 상황에서는 고려해야 할 요소가 다르니 두 상황을 대칭적으로 비교할 수 없다.</p>

<p>그래서 결론은 <strong>PACELC</strong>. 장애 상황에서는 availability와 consistency를 고민하고, 정상 상황에서는 latency와 consistency를 고민하겠다는 것. availability은 장애 상황에서의 서비스 가용 상태를 뜻하고, latency는 정상 상황에서 모든 cluster가 동일한 값으로 갱신되는 시간이라고 생각하면 될 것 같다.</p>

<h3>fault tolerant</h3>

<p>분산 시스템을 설계할 때에는 장애 상황에 대한 복구(fault tolerant)를 고민해서 작성해야 하기 때문에 기존에 고민하지 않았던 예외 상황에 대한 고찰이 많이 필요하겠다. 그러니까 시간나면 읽어보자.</p>

<ul>
<li><a href="http://www.joinc.co.kr/modules/moniwiki/wiki.php/Site/Network_Programing/Documents/Sockettimeout">joinc: SocketTimeout</a></li>
<li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;linkClass=33090105&amp;barcode=9788996241003">책: 서버 인프라를 지탱하는 기술</a></li>
</ul>

<p>특히 각 cluster로 요청된 작업이 실패했을 경우 이 작업에 대해 다시 요청하여 결과를 얻어내도록 하는 과정은 잊지 말고 고려하도록 하자.</p>

<h3>actor model</h3>

<p>지난 번에 구현한 actor model은 진정한 actor가 아니기 때문에 자원 접근 측면에서 문제가 발생할 수 있다. 진정한 actor model이라면 다른 actor의 정보에 접근할 때에도 정보 접근 요청 message 같은 것을 보내서 처리해야 할 텐데, 만약에 해당 정보에 lock을 걸고 접근할 수 있도록 코드를 작성하였다고 해보자.</p>

<p>즉, actor A, B가 있고, B가 A의 특정 데이터를 가져올 때 A의 lock을 걸고 데이터를 가져오게 된다는 것이다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">a_t</span> <span class="o">:</span> <span class="k">public</span> <span class="kt">actor_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">some_struct_t</span> <span class="n">get_some</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">auto</span> <span class="n">_</span> <span class="o">=</span> <span class="n">read_lock</span><span class="p">();</span> <span class="k">return</span> <span class="n">_some_struct</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">b_t</span> <span class="o">:</span> <span class="k">public</span> <span class="kt">actor_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">process</span><span class="p">(</span><span class="kt">a_t</span><span class="o">*</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">some_a</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">get_some</span><span class="p">();</span>
        <span class="c1">// .. do anything</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>actor model로 구현한 주제에 lock을 쓴다는 점부터가 마음에 안 들지만 일단 그 부분은 그냥 넘어가자. 기존에 구현한 actor model의 job scheduling 방식은 <em>&quot;해당 actor를 먼저 점유한 thread가 있으면 그 thread가 해당 actor의 job_queue가 빌 때까지 모두 처리한다&quot;</em>이다.</p>

<p>때문에 A에서 B로 함수를 호출할 때, A의 함수 수행이 끝나기 전에 B의 함수가 호출될 수 있다. 이는 A가 A에게 message를 보낼 때와 다른 수행 양상을 보인다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">a_t</span> <span class="o">:</span> <span class="k">public</span> <span class="kt">actor_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">proc1</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">post</span><span class="p">(</span><span class="o">&amp;</span><span class="kt">a_t</span><span class="o">::</span><span class="n">proc1</span><span class="p">);</span>
        <span class="n">_b</span><span class="o">-&gt;</span><span class="n">post</span><span class="p">(</span><span class="o">&amp;</span><span class="kt">b_t</span><span class="o">::</span><span class="n">pass1</span><span class="p">);</span>
        <span class="c1">// do something 1</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">proc2</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// do something 2</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">b_t</span> <span class="o">:</span> <span class="k">public</span> <span class="kt">actor_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">pass1</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// do something 3</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>만약 단일 thread가 a_t::proc1() 함수로 진입했을 경우의 수행 흐름은 어떻게 될까?<br>
<strong>do something 3, 1, 2 순으로 수행될 것이다.</strong></p>

<p>때문에 위의 코드로 돌아가서 lock 문제를 다시 살펴보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">a_t</span> <span class="o">:</span> <span class="k">public</span> <span class="kt">actor_t</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">update</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">_</span> <span class="o">=</span> <span class="n">write_lock</span><span class="p">();</span>
        <span class="c1">// update some_struct upper half</span>
        <span class="n">_b</span><span class="o">-&gt;</span><span class="n">post</span><span class="p">(</span><span class="o">&amp;</span><span class="kt">b_t</span><span class="o">::</span><span class="n">process</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
        <span class="c1">// update some_struct bottom half</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<ol>
<li><code>a_t::update()</code> 함수가 호출된다. 일단 <code>some_struct</code>의 상위 반만 변경이 된다.</li>
<li><code>b_t::process()</code> 함수가 호출된다. 이 때 <code>a_t::_some_struct</code>를 접근한다. lock이 걸려있지만 lock의 재진입 허용으로 인해 상위 반만 변경된 <code>a_t::_some_struct</code>를 가져가게 된다.</li>
</ol>

<p>즉, invalid한 값으로 작업을 수행하게 된다.</p>

<p>정리를 하면, 일관되지 않은 함수 수행 패턴으로 인해 문제가 발생할 수 있다는 것이다. (A에서 A로 요청하면 함수가 끝나야 다음 함수가 수행되는데, A에서 B로 요청하면 함수 수행 도중에 다음 함수가 불린다). 이러한 상황에서 발생할 수 있는 문제까지 잘 고려하여 프로그램을 설계해야 할 것이다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">분산 시스템 구현 과제 정리</h1>
				<p class="page-date">27 Aug 2013</p>
				<p class="page-tags">
						
						
					<code class="tag">distributed</code>
						
						
						
					<code class="tag">study</code>
						
						
						
						
				</p>
				<div class="content"><p>뭐라도 좋으니 간단한 분산 시스템을 구현해보자!<br>
단일 시스템과 비교하여 성능 혹은 가용성을 높이기 위해 분산 시스템을 설계해야 하는 것이니 일단 네트워크 프로그래밍은 필수이다. 효율을 높이기 위해 얼마나 작업을 잘 쪼개고 합치는가도 고민해야 하고, 장애가 발생했을 때 얼마나 복구될 수 있는지도 고민해야 한다.</p>

<h3><a href="http://blog.fegs.kr/" title="blog.fegs.kr">angdev</a>님의 시스템</h3>

<ul>
<li>풀씨 프로그래밍 대회 채점 서버를 nodejs/c++로 구현했다. aws 위에 서비스를 올렸으며 elb, ec2를 통해 서비스를 구성하였다.</li>
<li>elb의 health check에 채점 서버의 service를 연결하여 해당 ec2 instance가 아닌 service의 상태를 점검하도록 하였다.</li>
<li>그리고 front-end에서 elb를 통해 채점 service에 code를 queueing하고, 각 service는 다시 dashboard-service에 자신의 상태를 기록한다.</li>
<li><p>일단 ec2 instance에 장애가 발생하면 queue 자체가 소멸되므로 이미 제출된 데이터가 삭제될 문제가 있는데, elb 대신 sqs를 써서 해결하였다.</p></li>
<li><p>dashboard-service에 직접 http 통신으로 데이터를 주고 받는데 simpledb나 rds를 쓰는게 어떨까 생각한다.</p></li>
<li><p>뭐 어쨌든 분산, 장애 상황을 적절히 고려해서 잘 만든 시스템인듯. sqs 관련 내용은 철주가 게시판에 써주기로 했다.</p></li>
</ul>

<h3><a href="https://twitter.com/ltearain" title="TeaRain (LTeaRain) on Twitter">LTeaRain</a>님의 시스템</h3>

<ul>
<li>무난한 map/reduce 시스템. master/slave 구조이다.</li>
<li><p>sequence에 대한 sum을 분산처리하는 시스템으로 seq를 적절히 round-robin으로 쪼개서 slave에게 전달, slave가 처리한 결과를 master가 받아서 취합하는 구조.</p></li>
<li><p>단, network 장애 등이 발생했을 때 해당 seq에 대해 다시 다른 slave를 배정하여 결과를 처리하도록 하는 등의 에러 복구에 대한 설계는 부족했지만, 그 자리에서 보완했다.<br>
(요청 context 유지 후 해당 slave 장애 발생 시 다른 slave 배정)</p></li>
</ul>

<h3><a href="https://twitter.com/kjkpoi" title="kjkpoi on Twitter">kjkpoi</a>님의 시스템</h3>

<ul>
<li>DLBP double load balancer pattern</li>
<li>흥미로운 map/reduce 시스템. map을 하기 위한 load balancer와 reduce를 하기 위한  load balancer가 따로 있는 구조이다.</li>
<li>먼저 요청이 들어오면 map-lb에서 적절히 node를 분배해서 작업을 쪼개준다.</li>
<li><p>분배된 각 node들 중 하나가 작업이 완료되는 시점에 reduce-lb에서 적절히 reduce를 수행할 node를 찍고, 그 node가 reduce를 수행하게 된다. (나름 지연된 reduce node 선정)</p></li>
<li><p>굳이 lb를 2개 두지 않고, 작업이 끝난 node가 master-lb에 completion signal을 보내면 reduce node를 mapping하는 식으로 설계해도 될 것 같다.</p></li>
<li><p>그리고 역시 장애 대응 로직이 없는데 이는 context 잘 유지해서 처리해주면 되겠다.</p></li>
</ul>

<h3>aws가 제안하는 기본적인 분산 시스템</h3>

<ul>
<li>elb - ec2 instances</li>
<li>cloud watch - auto scaling</li>
<li>elb로 request를 적절히 ec2 instance에게 넘긴다.</li>
<li>이 때 cloud watch로 metrics를 분석해 필요할 경우 auto scaling에게 요청하여 scale in/out을 수행한다.</li>
</ul>

<h3>big table</h3>

<ul>
<li>동일한 데이터를 담는 cluster를 묶어 cluster군을 형성, read replica 같은 느낌으로 처리 속도를 향상시킨다.</li>
<li>chubby service가 어느 위치에 데이터를 읽고 쓸지 관리하는데 이 service가 죽으면 곤란해지니까 대충 5대를 묶어서 구성한다.</li>
<li>5개의 chubby 중 chubby leader와 chubby follower가 생기고, leader가 죽으면 남은 chubby들이 투표해서 다음 leader를 뽑는 식으로 장애에 대응할 수 있게 구성됨</li>
</ul>

<h3>정리</h3>

<p>분산 시스템을 구성함에 있어 잘 쪼개고 잘 합치는 것 만큼이나 장애 상황이 발생했을 때 어떻게 복구할 것인지에 대한 고려도 중요하다. 따라서 이미 구현된 분산 시스템의 설계를 보고 그들이 어떻게 해당 문제들을 해결하였는지 살펴보자. aws같은 cloud service 내의 component나 nosql의 설계를 보면 좋겠다.</p>

<p>잘 쪼개고 합치는 부분에 대해서는 hadoop의 mapreduce와 impala를 비교해보면 좋겠다. 그리고 replica 등을 통해 성능을 향상할 경우 발생하는 버전 충돌 문제에 대해서도 공부하면 좋겠다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">분산 처리 환경 구현 1</h1>
				<p class="page-date">22 Apr 2013</p>
				<p class="page-tags">
						
						
					<code class="tag">distributed</code>
						
						
						
					<code class="tag">c#</code>
						
						
						
						
				</p>
				<div class="content"><p>잉여 컴퓨팅 자원을 십분 활용하여 처리량을 늘리기 위한 분산 처리 환경을 구축해보자.<br>
(hadoop, incredibuild 같은 프로그램을 만드려면 어떤 고민이 필요한지 생각해볼 수 있겠다.)</p>

<p>자세하게 파고들면 밑도 끝도 없을테니 간단하게 살펴보자.</p>

<p>분산 처리 환경을 구축할 때 적어도 다음의 항목에 대한 고민이 필요하다.</p>

<ul>
<li>플랫폼은 무엇을 사용할 것인가?</li>
<li>언어는 무엇을 사용할 것인가?</li>
<li>p2p로 만들 것인가, master-slave로 만들 것인가?</li>
</ul>

<p>물론 더 고민할 것이 많겠지만 일단 위 정도만 고민해도 간단한 체계는 만들 수 있다.</p>

<p>다양한 플랫폼을 고려할 때</p>

<ul>
<li>jvm같이 밑단이 있는 녀석을 사용하거나 script 언어를 사용할 경우에는 native 언어를 사용할 때에 비해 target별로 cross-compile해줄 수고를 덜 수 있다는 장점이 있다.</li>
<li>반면 수행 속도가 중요할 경우에는 native 언어를 사용해야 할 수도 있다.</li>
</ul>

<p>본 글에서는 <strong>귀찮으니 windows, c#, master-slave로 작성하자.</strong></p>

<h3>master-slave 구조</h3>

<p>가장 간단한 master-slave 구조를 보면 다음과 같다.</p>

<p><img src="http://lacti.me/images/mdf_basic.png" alt="master-slave 구조"></p>

<p>master는 여러 slave들을 관리하고, 실제 작업들은 slave가 처리한다고 보면 된다.
master는 작업 요청을 받아서, <strong>적절히 쪼개서</strong>, <strong>적절히 slave에게 넘겨서 처리시키고</strong>, <strong>결과를 적절히 받아서 합친다</strong></p>

<p>즉, master는 job을 쪼개고(**map**), slave들을 잘 scheduling해서 처리시킨 결과를 받고, 그 결과를 취합한다(**reduce**). 분산 framework의 성능을 결정하는건 결국 얼마나 잘 쪼개고, 잘 스케쥴링 해주냐에 달렸다는 것이다.<br>
(물론 각 job이 어떤 특성을 지니냐에 따라서 최적화 방법은 천차만별일 것이다)</p>

<h3>상태 정보</h3>

<p>master-slave는 job/result 이외에도 주고 받아야 할 정보가 있다. 대표적인 정보가 slave의 상태(state) 정보이다. master는 각 slave가 어떤 상태인지(on/off-line, cpu usage, memory/disk available, io scheduling 등) 잘 알고 있어야 job을 더욱 적절하게 분배하여 전체적인 성능을 높힐 수 있다.</p>

<p>이 때 slave가 주기적으로 master에게 해당 정보를 알려줘야 한다. (원격으로 slave의 상태를 가져갈 수 있도록 설정해도 되지만 논외로 친다.)</p>

<p>그런데 만약 result를 master가 취합할 필요가 없는 형태, 즉 function 형태의 job이 아닌 <strong>action 형태의 job</strong>일 경우에는 master가 굳이 slave와 connection을 유지할 필요가 없다. 이렇게 될 경우 master는 여러 connection을 관리하지 않아도 되기 때문에 복잡도가 현저히 줄게 된다.<br>
(분산 웹 크롤러를 예로 들 수 있다. master는 slave에게 수집할 url만 넘기고 slave는 master에게 결과를 전달하기 않고 db에 직접 저장할 수 있다.)</p>

<h3>sync with db 구조</h3>

<p>이 때 slave의 상태를 master에게 보고하기 위해 connection을 유지하거나 다시 connection을 맺는 것은 귀찮은 일이므로 다음과 같은 구조를 생각해볼 수 있다.</p>

<p><img src="http://lacti.me/images/mdf_sync_db.png" alt="sync-db 구조"></p>

<p>slave들은 자신의 상태를 주기적으로 state db에 기록하고, master는 state db에 기록된 정보를 참고해서 slave에게 명령을 내린다. 이 경우 master는 slave와 connection을 유지할 필요가 없게 되고 이는 master의 구현 부담을 줄일 수 있을 뿐더러 connectivity가 좋지 않은 master-slave 환경에서 보다 유연하게 동작할 수 있다.</p>

<h3>slave + state-d 구조</h3>

<p>약간 다른 관점이지만 다음과 같은 모델도 생각해볼 수 있다.</p>

<p><img src="http://lacti.me/images/mdf_stated.png" alt="stated 구조"></p>

<p>slave 프로그램이 해야할 일은 두 가지이다. master로부터 받은 job 처리와 master에게 state를 보고하는 것. 이 둘을 나눈 구조라고 생각하면 된다.</p>

<p>이 때 얻는 장점은 (간단한 구조에서는) 데이터의 방향성이 정해져서 프로그램 구현이 쉬워진다는 것이다.</p>

<ul>
<li>master는 state로부터 데이터를 받기만 하면 되고,</li>
<li>slave는 master로부터 job을 받아서 처리만 하면 된다.</li>
</ul>

<p>그리고 만에 하나 slave 프로그램이 오동작하여 사망할 경우 state가 이를 감지하여 master에게 보고할 수 있다. 그 후 상태에 따라 slave 프로그램을 다시 시작해줄 수 있다.
이러한 구조는 보다 견고한 분산 처리 환경을 구축하는데 도움이 될 것이다.</p>

<h3>정리</h3>

<p>훨씬 더 다양한 방법이 있을테지만 생각나는 구조를 간략히 살펴봤고, 다음 글에서는 C#을 사용하여 간단한 분산 처리 환경을 구축하는 방법을 소개할 예정이다. 중요한 것은, <strong>어떻게 job을 쪼개고, 분산시키고, 취합할 것인가</strong> 이다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">분산 처리 환경 구현 2</h1>
				<p class="page-date">07 May 2013</p>
				<p class="page-tags">
						
						
					<code class="tag">distributed</code>
						
						
						
					<code class="tag">c#</code>
						
						
						
						
				</p>
				<div class="content"><ul>
<li><a href="https://github.com/lacti/DistWork/tree/simplest">Github: DistWork - simplest</a></li>
</ul>

<p>지난 번 글에서는 분산 처리 환경에 대한 구조를 대충 알아봤다. 이번 글에서는 대충 알아본 것 중 하나를 선택해서 C#으로 구현을 해볼 것이다.</p>

<p>가장 간단해보이는 M-S 모델 (master-slave)을 C#으로 구현해보자.</p>

<p>일단 구현하기에 앞서 간단히 설계도를 살펴보자.</p>

<p><img src="http://lacti.me/images/mdf_arch.png" alt="구현 설계도"></p>

<p>master에는 여러 slave가 연결한다. 각 연결된 slave는 master 내에 어떤 작업을 수행하는지/했는지 info를 갖는다. master에 command가 들어오면 수행할 work를 만든다. 연결된 slave의 info를 살펴보고 적절한 slave를 선택한 후 work를 보내준다**(distribute)**. 그러면 slave는 그 작업을 처리하고 결과를 master에게 보내주던가 한다.</p>

<p>위 구현을 위해서는,</p>

<ul>
<li>c# network programming 기술</li>
<li>c# object serialization 기술</li>
</ul>

<p>정도만 알면 된다.</p>

<p>하지만 본 글에서 위 내용을 설명하는 것은 매우 무의미하기 때문에 이 부분에 대해서는 설명하지 않는다. 자세한 내용은 <a href="https://github.com/lacti/DistWork/tree/simplest">소스 코드</a>의 <a href="https://github.com/lacti/DistWork/blob/simplest/DistWork/Util/AsyncSocketExtension.cs">AsyncSocketExtension.cs</a>와 <a href="https://github.com/lacti/DistWork/blob/simplest/DistWork/Core/WorkSocketHelper.cs">WorkSocketHelper.cs</a> 파일을 보면 된다.</p>

<h3>구현</h3>

<p>먼저 master와 slave가 주고 받을 작업의 추상 형태인 IWork interface부터 살펴보면 다음과 같다.</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">interface</span> <span class="n">IWork</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">Execute</span><span class="p">(</span><span class="n">Socket</span> <span class="n">endPoint</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>이 interface를 구현한 class가 Serializable하면 Master와 Slave간에 serialize/deserialize되어 전달될 수 있고, 전달된 후에 <code>Execute</code>를 호출해주면 되므로 사실상 RPC와 같은 형태가 된다. 이 때 <code>endPoint</code>의 Socket을 받는 이유는 수행한 결과에 대해 상대측으로 다시 결과를 전달하기 위함이다. (이는 마지막 예제에서 볼 수 있다.)</p>

<p><code>Master</code> class는 <code>Slave</code>의 통신을 위한 <code>Socket</code>과, 각 <code>Slave</code>의 상태에 대한 Information을 갖는다. 그리고 작업 분산이 요청될 경우(<code>DistributeWork</code>) 적절한 <code>Slave</code>의 <code>Socket</code>을 고르기 위한 알고리즘 함수를 갖는다. Java같은 언어라면 interface로 해당 알고리즘을 분리하겠지만, C#이니 그냥 delegate로 빼서 관리한다.</p>

<p>위 구현 사항을 분할해서 살펴보자. 먼저 Slave와 연결을 맺고 Slave가 전달하는 Work를 처리하기 위한 함수이다.</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="c1">// Master class</span>
<span class="k">public</span> <span class="k">async</span> <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">listener</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Socket</span><span class="p">(</span><span class="n">AddressFamily</span><span class="p">.</span><span class="n">InterNetwork</span><span class="p">,</span> <span class="n">SocketType</span><span class="p">.</span><span class="n">Stream</span><span class="p">,</span> <span class="n">ProtocolType</span><span class="p">.</span><span class="n">Tcp</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">localEndPoint</span> <span class="p">=</span> <span class="k">new</span> <span class="n">IPEndPoint</span><span class="p">(</span><span class="n">IPAddress</span><span class="p">.</span><span class="n">Any</span><span class="p">,</span> <span class="n">_port</span><span class="p">);</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="n">listener</span><span class="p">.</span><span class="n">Bind</span><span class="p">(</span><span class="n">localEndPoint</span><span class="p">);</span>
        <span class="n">listener</span><span class="p">.</span><span class="n">Listen</span><span class="p">(</span><span class="m">100</span><span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">clientSocket</span> <span class="p">=</span> <span class="k">await</span> <span class="n">listener</span><span class="p">.</span><span class="n">AcceptAsync</span><span class="p">();</span>
            <span class="n">ProcessSocket</span><span class="p">(</span><span class="n">clientSocket</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="n">Logger</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">e</span><span class="p">);</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">async</span> <span class="k">void</span> <span class="nf">ProcessSocket</span><span class="p">(</span><span class="n">Socket</span> <span class="n">socket</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">_container</span><span class="p">.</span><span class="n">AddSocket</span><span class="p">(</span><span class="n">socket</span><span class="p">);</span>

    <span class="n">Logger</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="s">&quot;Connected from: &quot;</span> <span class="p">+</span> <span class="n">socket</span><span class="p">.</span><span class="n">RemoteEndPoint</span><span class="p">);</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">work</span> <span class="p">=</span> <span class="k">await</span> <span class="n">socket</span><span class="p">.</span><span class="n">ReceiveWork</span><span class="p">();</span>
            <span class="n">work</span><span class="p">.</span><span class="n">Execute</span><span class="p">(</span><span class="n">socket</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="n">Logger</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">e</span><span class="p">);</span> <span class="p">}</span>

    <span class="k">try</span> <span class="p">{</span> <span class="n">socket</span><span class="p">.</span><span class="n">Shutdown</span><span class="p">(</span><span class="n">SocketShutdown</span><span class="p">.</span><span class="n">Both</span><span class="p">);</span> <span class="p">}</span>
    <span class="k">catch</span> <span class="p">{</span> <span class="p">}</span>
    <span class="n">_container</span><span class="p">.</span><span class="n">RemoveSocket</span><span class="p">(</span><span class="n">socket</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>지정된 port에 bind된 socket이 <code>Slave</code>와 연결되면 그 <code>Socket</code>으로부터 <code>Work</code>를 하나씩 받아서(deserialize) 처리하는 형태이다. awaitable한 프로그램을 작성했기 때문에 managed thread pool이 적절히 잘 운영해준다.</p>

<p><code>_container</code>는 <code>SocketContainer</code> 객체로 slave의 socket을 관리해준다. <code>SocketContainer</code>에서 관리하는 Socket 집합은 추후 작업을 분산시키기 위해 특정 slave를 선택할 때 사용된다.</p>

<p><code>Slave</code>는 <code>Master</code>에 연결한 뒤, 역시 동일하게 <code>Master</code>로부터 <code>Work</code>를 받아서 처리하는 구조로 작성하면 된다. 때문에 이 부분은 <code>Master</code>의 코드와 크게 차이가 없다.</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">class</span> <span class="nc">Slave</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">async</span> <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">try</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">socket</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Socket</span><span class="p">(</span><span class="n">AddressFamily</span><span class="p">.</span><span class="n">InterNetwork</span><span class="p">,</span> <span class="n">SocketType</span><span class="p">.</span><span class="n">Stream</span><span class="p">,</span>
                    <span class="n">ProtocolType</span><span class="p">.</span><span class="n">Tcp</span><span class="p">);</span>
            <span class="n">socket</span><span class="p">.</span><span class="n">Connect</span><span class="p">(</span><span class="n">_host</span><span class="p">,</span> <span class="n">_port</span><span class="p">);</span>
            <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="kt">var</span> <span class="n">work</span> <span class="p">=</span> <span class="k">await</span> <span class="n">socket</span><span class="p">.</span><span class="n">ReceiveWork</span><span class="p">();</span>
                <span class="n">work</span><span class="p">.</span><span class="n">Execute</span><span class="p">(</span><span class="n">socket</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="n">Logger</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">e</span><span class="p">);</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p><code>Slave</code>의 <code>Socket</code>을 관리하는 <code>SocketContainer</code>는 <code>Slave</code>의 연결이 동시 다발적으로 일어나므로 내부에 Lock을 가지고 Container를 관리하는 객체이다.</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="c1">// SocketContainer class</span>
<span class="n">ReaderWriterLockSlim</span> <span class="n">_lock</span> <span class="p">=</span>
    <span class="k">new</span> <span class="nf">ReaderWriterLockSlim</span><span class="p">(</span><span class="n">LockRecursionPolicy</span><span class="p">.</span><span class="n">SupportsRecursion</span><span class="p">);</span>
<span class="k">private</span> <span class="k">readonly</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">Socket</span><span class="p">,</span> <span class="n">SocketInformation</span><span class="p">&gt;</span> <span class="n">_sockets</span> <span class="p">=</span>
    <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">Socket</span><span class="p">,</span> <span class="n">SocketInformation</span><span class="p">&gt;();</span>

<span class="k">public</span> <span class="k">void</span> <span class="nf">AddSocket</span><span class="p">(</span><span class="n">Socket</span> <span class="n">socket</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">_lock</span><span class="p">.</span><span class="n">DoWriteLock</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">_sockets</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="n">SocketInformation</span><span class="p">.</span><span class="n">Invalid</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">void</span> <span class="nf">RemoveSocket</span><span class="p">(</span><span class="n">Socket</span> <span class="n">socket</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">_lock</span><span class="p">.</span><span class="n">DoWriteLock</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">_sockets</span><span class="p">.</span><span class="n">Remove</span><span class="p">(</span><span class="n">socket</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">public</span> <span class="n">Socket</span> <span class="nf">SelectSocket</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">List</span><span class="p">&lt;</span><span class="n">KeyValuePair</span><span class="p">&lt;</span><span class="n">Socket</span><span class="p">,</span> <span class="n">SocketInformation</span><span class="p">&gt;&gt;,</span> <span class="n">Socket</span><span class="p">&gt;</span> <span class="n">selector</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">_lock</span><span class="p">.</span><span class="n">DoReadLock</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">selector</span><span class="p">(</span><span class="n">_sockets</span><span class="p">.</span><span class="n">ToList</span><span class="p">()));</span>
<span class="p">}</span>
</code></pre></div>
<p>약간이나마 효율을 높이기 위해 <code>ReaderWriterLock</code>을 사용했다.
재미있는 부분은 <code>SelectSocket</code>을 수행하는 부분인데, 이 과정에서는 모든 <code>Socket</code>과 그에 대한 <code>SocketInformation</code>을 순회하면서 적절한 <code>Socket</code>을 뽑아내야한다. 하지만 해당 자료구조를 순회하려면 자료구조가 Lock으로 보호된 상태이어야 하므로 Socket을 선택하는 selector를 delegator 형태로 받아서 <code>ReadLock</code> 구간 내에서 수행될 수 있도록 한다.</p>

<p>그런데 작업을 분산시키기 위해 필요한 정보는 <code>Socket</code>, <code>SocketInformation</code> 뿐만 아니라 어떤 작업인지(<code>IWork</code>)의 정보도 필요하다. 때문에 <code>Master</code>에서는 이 정보까지 취합해서 적절한 <code>Slave</code>를 선택할 수 있도록 delegator를 제공한다.</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">DistributeContext</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">readonly</span> <span class="n">IList</span><span class="p">&lt;</span><span class="n">KeyValuePair</span><span class="p">&lt;</span><span class="n">Socket</span><span class="p">,</span> <span class="n">SocketInformation</span><span class="p">&gt;&gt;</span> <span class="n">Sockets</span><span class="p">;</span>
    <span class="k">public</span> <span class="k">readonly</span> <span class="n">IWork</span> <span class="n">Work</span><span class="p">;</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">SocketContainer</span> <span class="n">_container</span><span class="p">;</span>
</code></pre></div>
<p>필요한 정보(<code>Socket</code>, <code>SocketInformation</code>, <code>IWork</code>)를 <code>DistributeContext</code>로 감싸서 <code>SelectSocketDecl</code>로 넘겨준다. 이 delegator는 <code>_container</code>의 <code>SelectSocket()</code> 내에서 수행되므로 <code>_container</code>의 ReadLock 내에서 수행된다. 이렇게 socket을 하나 선택하게 되면 해당 socket으로 work를 전달한다. 즉 해당 slave에게 work를 전달한다.</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="c1">// Master class</span>
<span class="k">public</span> <span class="k">delegate</span> <span class="n">Socket</span> <span class="nf">SelectSocketDecl</span><span class="p">(</span><span class="n">DistributeContext</span> <span class="n">context</span><span class="p">);</span>
<span class="k">private</span> <span class="n">SelectSocketDecl</span> <span class="n">_socketSelector</span><span class="p">;</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">DistributeWork</span><span class="p">(</span><span class="n">IWork</span> <span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">socket</span> <span class="p">=</span> <span class="n">_container</span><span class="p">.</span><span class="n">SelectSocket</span><span class="p">(</span><span class="n">sockets</span> <span class="p">=&gt;</span>
            <span class="n">_socketSelector</span><span class="p">(</span><span class="k">new</span> <span class="n">DistributeContext</span><span class="p">(</span><span class="n">_container</span><span class="p">,</span> <span class="n">sockets</span><span class="p">.</span><span class="n">AsReadOnly</span><span class="p">(),</span> <span class="n">work</span><span class="p">)));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">socket</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullReferenceException</span><span class="p">();</span>

    <span class="n">socket</span><span class="p">.</span><span class="n">SendWork</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>굉장히 간단한 구조로 분산 시스템을 만들어봤다.</p>

<ul>
<li>Master는 Slave의 연결을 기다리고, Slave가 연결되면 각 상태를 적절하게 고려해서 작업을 전달한다.</li>
<li>Slave는 Master에게 연결한 뒤, Master의 작업을 기다리고 있다가 받는 즉시 처리해준다.</li>
</ul>

<h3>예제</h3>

<p>소스 코드에 첨부된 간단한 예제 코드를 직접 보면 다음과 같다.</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="na">[Serializable]</span>
<span class="k">internal</span> <span class="k">class</span> <span class="nc">SlaveWork</span> <span class="p">:</span> <span class="n">IWork</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Execute</span><span class="p">(</span><span class="n">Socket</span> <span class="n">endPoint</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Do my work: &quot;</span> <span class="p">+</span> <span class="n">endPoint</span><span class="p">.</span><span class="n">RemoteEndPoint</span><span class="p">);</span>
        <span class="n">endPoint</span><span class="p">.</span><span class="n">SendWork</span><span class="p">(</span><span class="k">new</span> <span class="n">MasterWork</span><span class="p">(</span><span class="k">new</span> <span class="n">SlaveResult</span><span class="p">(</span><span class="s">&quot;TEST MESSAGE&quot;</span><span class="p">)));</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="na">[Serializable]</span>
<span class="k">internal</span> <span class="k">class</span> <span class="nc">SlaveResult</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">readonly</span> <span class="kt">string</span> <span class="n">SlaveGeneratedMessage</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">SlaveResult</span><span class="p">(</span><span class="kt">string</span> <span class="n">message</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">SlaveGeneratedMessage</span> <span class="p">=</span> <span class="n">message</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="na">[Serializable]</span>
<span class="k">internal</span> <span class="k">class</span> <span class="nc">MasterWork</span> <span class="p">:</span> <span class="n">IWork</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">SlaveResult</span> <span class="n">_result</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">MasterWork</span><span class="p">(</span><span class="n">SlaveResult</span> <span class="n">result</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_result</span> <span class="p">=</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Execute</span><span class="p">(</span><span class="n">Socket</span> <span class="n">endPoint</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Do master work: &quot;</span> <span class="p">+</span> <span class="n">endPoint</span><span class="p">.</span><span class="n">RemoteEndPoint</span><span class="p">);</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Received from slave: &quot;</span> <span class="p">+</span> <span class="n">_result</span><span class="p">.</span><span class="n">SlaveGeneratedMessage</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">internal</span> <span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">master</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Master</span><span class="p">(</span><span class="m">12345</span><span class="p">);</span>
        <span class="n">Task</span><span class="p">.</span><span class="n">Factory</span><span class="p">.</span><span class="n">StartNew</span><span class="p">(</span><span class="n">master</span><span class="p">.</span><span class="n">Start</span><span class="p">);</span>

        <span class="n">Thread</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>

        <span class="k">const</span> <span class="kt">int</span> <span class="n">slaveCount</span> <span class="p">=</span> <span class="m">10</span><span class="p">;</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">index</span> <span class="k">in</span> <span class="n">Enumerable</span><span class="p">.</span><span class="n">Range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="n">slaveCount</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">slave</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Slave</span><span class="p">(</span><span class="s">&quot;127.0.0.1&quot;</span><span class="p">,</span> <span class="m">12345</span><span class="p">);</span>
            <span class="n">Task</span><span class="p">.</span><span class="n">Factory</span><span class="p">.</span><span class="n">StartNew</span><span class="p">(</span><span class="n">slave</span><span class="p">.</span><span class="n">Start</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">master</span><span class="p">.</span><span class="n">ConnectedSlaveCount</span> <span class="p">!=</span> <span class="n">slaveCount</span><span class="p">)</span>
            <span class="n">Thread</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">0</span><span class="p">);</span>

        <span class="n">Logger</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="s">&quot;Start!&quot;</span><span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">master</span><span class="p">.</span><span class="n">DistributeWork</span><span class="p">(</span><span class="k">new</span> <span class="n">SlaveWork</span><span class="p">());</span>
            <span class="n">Thread</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<ol>
<li><code>Master</code>를 시작하고, <code>Slave</code>를 10개 만들어서 <code>Master</code>에 연결한다.</li>
<li><code>Master</code>는 <code>SlaveWork</code> 객체를 만들어서 적절히 <code>Slave</code>에게 넘겨준다. 기본 알고리즘은 RoundRobin이므로 첫 번째 <code>Slave</code>부터 차례대로 일을 받게 된다.</li>
<li><code>Slave</code>는 <code>SlaveWork</code>를 처리한 후, 수행한 결과를 <code>SlaveResult</code>에 담아서 <code>MasterWork</code> 객체를 <code>Master</code>에게 전달한다.</li>
<li><code>Master</code>는 <code>MasterWork</code>를 받아서 그 내부에 있는 <code>SlaveResult</code>를 출력해준다.</li>
</ol>

<p>모두 네트워크로 전송되기 위해 <code>SerializableAttribute</code>를 붙이고 있다.</p>

<h3>정리</h3>

<p>본 글에서는 작업을 원격지에서 수행하고, 적절히 분산시킬 수 있는 분산 처리 환경을 C#으로 간단히 구현해봤다. Master와 Slave의 코드를 한 Assembly에 넣어놨기 때문에 Serialize/Deserialize를 수행함에 있어서 아주 편했다.</p>

<p>하지만 제대로 된 분산 환경에서 Master와 Slave가 같은 코드를 공유한다는 것은 다양한 작업/변경된 작업을 수행함에 있어서 매우 불리하다. 왜냐하면 Slave가 수행되는 머신의 바이너리가 지속적으로 교체되어야 하기 때문이다.</p>

<p>또한 위 코드는 단순한 RPC 작업을 수행함에 있어서 너무 많은 코드를 작성해야 한다. (적어도 두 개의 Work와 하나의 Result class를 작성해야 했다.)</p>

<p>따라서 다음 글에서는</p>

<ul>
<li>Master/Slave가 코드를 공유하지 않아도 수행될 수 있는 구조와</li>
<li>RpcWork와 WorkGroup 설계를 추가하여 보다 간편한 분산 작업을</li>
</ul>

<p>작성할 수 있도록 고민해보자.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">분산 처리 환경 구현 3</h1>
				<p class="page-date">08 Jun 2013</p>
				<p class="page-tags">
						
						
					<code class="tag">distributed</code>
						
						
						
					<code class="tag">c#</code>
						
						
						
					<code class="tag">rpc</code>
						
						
						
						
				</p>
				<div class="content"><ul>
<li><a href="https://github.com/lacti/DistWork/tree/simpler">Github: DistWork - simpler</a></li>
</ul>

<p>지난 글에서 예고한 RpcWork와 Dll 전달 방법에 대해 알아보자.<br>
<em>(원래는 WorkGroup까지 보려고 했는데 자세한 구현은 귀찮으니 나중에 기회가 되면 쓰도록 하겠다)</em></p>

<h3>RPC 구현</h3>

<p><code>RpcWork</code>는 다음의 방법으로 쉽게 구현할 수 있다.</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="na">[Serializable]</span>
<span class="k">public</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">RpcWork</span><span class="p">&lt;</span><span class="n">TReturn</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">IWork</span>
<span class="p">{</span>
<span class="na">    [Serializable]</span>
    <span class="k">private</span> <span class="k">class</span> <span class="nc">ReturnWork</span> <span class="p">:</span> <span class="n">IWork</span>
    <span class="p">{</span>
        <span class="k">private</span> <span class="k">readonly</span> <span class="n">RpcWork</span><span class="p">&lt;</span><span class="n">TReturn</span><span class="p">&gt;</span> <span class="n">_parentWork</span><span class="p">;</span>
        <span class="k">private</span> <span class="k">readonly</span> <span class="n">TReturn</span> <span class="n">_returnValue</span><span class="p">;</span>

        <span class="k">public</span> <span class="nf">ReturnWork</span><span class="p">(</span><span class="n">RpcWork</span><span class="p">&lt;</span><span class="n">TReturn</span><span class="p">&gt;</span> <span class="n">parentWork</span><span class="p">,</span> <span class="n">TReturn</span> <span class="n">returnValue</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">_parentWork</span> <span class="p">=</span> <span class="n">parentWork</span><span class="p">;</span>
            <span class="n">_returnValue</span> <span class="p">=</span> <span class="n">returnValue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">void</span> <span class="nf">Execute</span><span class="p">(</span><span class="n">Socket</span> <span class="n">endPoint</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">_parentWork</span><span class="p">.</span><span class="n">ExecuteReturn</span><span class="p">(</span><span class="n">_returnValue</span><span class="p">,</span> <span class="n">endPoint</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Execute</span><span class="p">(</span><span class="n">Socket</span> <span class="n">endPoint</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">returnValue</span> <span class="p">=</span> <span class="n">ExecuteWork</span><span class="p">(</span><span class="n">endPoint</span><span class="p">);</span>
        <span class="n">endPoint</span><span class="p">.</span><span class="n">SendWork</span><span class="p">(</span><span class="k">new</span> <span class="n">ReturnWork</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">returnValue</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">protected</span> <span class="k">abstract</span> <span class="n">TReturn</span> <span class="nf">ExecuteWork</span><span class="p">(</span><span class="n">Socket</span> <span class="n">endPoint</span><span class="p">);</span>
    <span class="k">protected</span> <span class="k">abstract</span> <span class="k">void</span> <span class="nf">ExecuteReturn</span><span class="p">(</span><span class="n">TReturn</span> <span class="n">returnValue</span><span class="p">,</span> <span class="n">Socket</span> <span class="n">endPoint</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>원격지에서 수행할 함수를 담는 <code>RpcWork</code> class와 그 수행 결과를 담아 다시 돌려줄 <code>ReturnWork</code> class로 구성되어 있다. <code>RpcWork</code>의 <code>ExecuteWork()</code> 함수가 원격지에서 수행될 함수이고, <code>ExecuteReturn()</code> 함수가 원격지에서 수행된 결과를 받아서 처리할 함수이다.</p>

<ul>
<li><code>RpcWork</code>의 <code>Execute()</code> 함수는 원격지에서 수행된다. 수행에 필요한 정보는 <code>RpcWork</code>를 상속받는 class의 멤버 변수로 가지고 있을테니 잘 serialize 되어서 전달될 것이다.</li>
<li><code>Execute()</code> 함수는 <code>ExecuteWork()</code> 함수를 수행해서 그 결과를 받은 뒤, <code>endPointSocket</code>에게 그 결과를 <code>ReturnWork</code> class에 담아 전달하게 된다.</li>
</ul>

<p>이 때 재미있는 것은 <code>ReturnWork</code> 객체의 생성자로 <code>RpcWork</code>를 받는다는 것이다. 그 이유는 <code>ReturnWork</code>의 <code>Execute()</code> 함수에서 <code>RpcWork</code> 객체의 <code>ExecuteReturn()</code> 함수를 불러주기 위함이다. 즉 처음 Rpc를 요청한 호출자가 <code>ReturnWork</code> 객체를 받아서 <code>Execute()</code> 함수를 수행하면, <code>ReturnWork</code> 객체는 멤버로 가지고 있는 <code>RpcWork</code> 객체의 <code>ExecuteReturn()</code> 함수를 불러준다는 뜻이다.</p>

<p>결국 호출자가 대상자에게 Rpc를 요청할 때 보냈던 <code>RpcWork</code> 객체와 실제 결과가 도착한 뒤에 <code>ExecuteReturn()</code> 함수가 불리는 <code>RpcWork</code> 객체는 <strong>전혀 다른 객체</strong>라는 뜻이다. 다만 처음 보냈던 <code>RpcWork</code> 객체의 모든 context (멤버 변수)가 그대로 대상자에게 전달되었다가, 고스란히 호출자에게 다시 전달되다 보니 같은 객체인 것처럼 보이는 것이다.<br>
(**Equals() == true이지만 ReferenceEquals() == false인 것**이다.)</p>

<p>뭐 위처럼 만들면 Master와 Slave가 주고 받을 데이터의 양이 많아지니 네트워크 IO 비용에서는 좋지 않을 수 있다. 그래도 Master/Slave를 만드는 입장에서는 요청에 대한 응답을 기다리기 위한 context 유지 코딩을 안해줘도 되니 편하다.<br>
<span style="color: #aaa;">마치 stateless한 http처럼, a+b+c 좀 계산해줄래 slave야? a+b+c 계산해달라던 master야, 결과는 이거다! 하는 느낌</span></p>

<h3>RPC 예제</h3>

<p>간단한 덧셈 Rpc를 구현해보면 다음과 같다.</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="na">[Serializable]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">RemoteSumWork</span> <span class="p">:</span> <span class="n">RpcWork</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="kt">int</span> <span class="n">_leftValue</span><span class="p">;</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="kt">int</span> <span class="n">_rightValue</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">RemoteSumWork</span><span class="p">(</span><span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_leftValue</span> <span class="p">=</span> <span class="n">left</span><span class="p">;</span>
        <span class="n">_rightValue</span> <span class="p">=</span> <span class="n">right</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">protected</span> <span class="k">override</span> <span class="kt">int</span> <span class="nf">ExecuteWork</span><span class="p">(</span><span class="n">Socket</span> <span class="n">endPoint</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">_leftValue</span> <span class="p">+</span> <span class="n">_rightValue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">ExecuteReturn</span><span class="p">(</span><span class="kt">int</span> <span class="n">returnValue</span><span class="p">,</span> <span class="n">Socket</span> <span class="n">endPoint</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Return from: &quot;</span> <span class="p">+</span> <span class="n">returnValue</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>두 인자를 생성자로 받아 멤버로 저장한다. <code>ExecuteWork()</code> 함수에서는 멤버의 두 값을 더해서 반환하고, <code>ExecuteReturn()</code> 함수에서는 인자로 그 결과를 받아서 화면에 출력한다.</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="n">master</span><span class="p">.</span><span class="n">DistributeWork</span><span class="p">(</span><span class="k">new</span> <span class="n">RemoteSumWork</span><span class="p">(</span><span class="m">100</span><span class="p">,</span> <span class="m">200</span><span class="p">));</span>
</code></pre></div>
<p><code>RemoteSumWork</code>의 <code>ExecuteReturn()</code> 함수가 수행될 때, <code>_leftValue</code>와 <code>_rightValue</code> 값은 master에서 slave로 요청할 때 한 번, slave에서 master로 <code>ReturnWork</code> 보낼 때 다시 묻어서 한 번, 총 두 번 network trip을 하게 된다.</p>

<p><strong>결과는 4Bytes(int)인데 context 유지를 위해 무려 12Bytes를 받다니!</strong> 그런데 class를 <code>BinaryFormatter</code>로 serialize하는 이상 이미 type 정보 같은 것들 때문에 더 큰 bytes가 소모되고 있다-_-;</p>

<h3>코드 분리</h3>

<p>이제 Master와 Slave가 코드를 공유하지 않는 형태를 구현해보자.
Master에서 Slave에게 수행시키고 싶은 함수가 있는데 Slave에게는 아쉽게도 코드가 없다. 이 문제를 해결하기 위해서는 Slave에게 시키고 싶은 코드를 Dll에 담아서 Slave에게 전달해주면 된다.</p>

<p>첨부된 소스를 보면 이 예제를 쉽게 확인할 수 있도록 프로젝트를 잘게 쪼개놨다.</p>

<ul>
<li><code>DistWork</code>는 분산 처리 관련 모듈이 들어있는 Library Project이고,</li>
<li><code>DistMaster</code>와 <code>DistSlave</code>는 각각 Master/Slave 객체 하나씩 만들어서 프로그램 수행하는 <code>Main()</code>을 포함한 Console Project이다.</li>
<li>그리고 <code>DistFunctions</code>가 Master로부터 Slave에게 공유될 소스 코드가 담긴 Library Project이다.</li>
</ul>

<p>결국 <code>DistFunctions</code>로부터 만들어지는 <em>DistFunctions.dll</em>를 Slave에게 전달해주면, Master가 보내는 코드도 Slave가 잘 실행해줄 수 있다는 것이다.</p>

<p>일단 파일을 보내기 위한 Work부터 만들어보자.</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="na">[Serializable]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">FileSendWork</span> <span class="p">:</span> <span class="n">IWork</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="kt">string</span> <span class="n">_fileName</span><span class="p">;</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="kt">byte</span><span class="p">[]</span> <span class="n">_fileBytes</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">FileSendWork</span><span class="p">(</span><span class="kt">string</span> <span class="n">filePath</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_fileName</span> <span class="p">=</span> <span class="n">Path</span><span class="p">.</span><span class="n">GetFileName</span><span class="p">(</span><span class="n">filePath</span><span class="p">);</span>
        <span class="n">_fileBytes</span> <span class="p">=</span> <span class="n">File</span><span class="p">.</span><span class="n">ReadAllBytes</span><span class="p">(</span><span class="n">filePath</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Execute</span><span class="p">(</span><span class="n">Socket</span> <span class="n">endPoint</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">File</span><span class="p">.</span><span class="n">Exists</span><span class="p">(</span><span class="n">_fileName</span><span class="p">))</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="k">using</span> <span class="p">(</span>
            <span class="kt">var</span> <span class="n">stream</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FileStream</span><span class="p">(</span><span class="n">_fileName</span><span class="p">,</span> <span class="n">FileMode</span><span class="p">.</span><span class="n">CreateNew</span><span class="p">,</span>
                                        <span class="n">FileAccess</span><span class="p">.</span><span class="n">Write</span><span class="p">,</span> <span class="n">FileShare</span><span class="p">.</span><span class="n">Write</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">stream</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">_fileBytes</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">_fileBytes</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>파일 이름은 서버가 지정해준대로 사용한다. 만약 동일한 파일 이름이 이미 Slave에 있다면 파일을 저장하지 않는다**(!)**</p>

<p>자세한 설명은 잠시 뒤에 하고, Master와 Slave가 어떤 코드를 갖는지 보자.</p>

<p><a href="https://github.com/lacti/DistWork/blob/simpler/DistMaster/Program.cs#L25-L26"><em>DistMaster/Program.cs</em></a></p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="n">master</span><span class="p">.</span><span class="n">DistributeWork</span><span class="p">(</span><span class="k">new</span> <span class="n">FileSendWork</span><span class="p">(</span><span class="s">&quot;DistFunctions.dll&quot;</span><span class="p">));</span>
<span class="n">master</span><span class="p">.</span><span class="n">DistributeWork</span><span class="p">(</span><span class="k">new</span> <span class="n">RemoteSumWork</span><span class="p">(</span><span class="m">100</span><span class="p">,</span> <span class="m">200</span><span class="p">));</span>
</code></pre></div>
<p><a href="https://github.com/lacti/DistWork/blob/simpler/DistSlave/Program.cs#L12-L16"><em>DistSlave/Program.cs</em></a></p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">slave</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Slave</span><span class="p">(</span><span class="s">&quot;127.0.0.1&quot;</span><span class="p">,</span> <span class="m">12345</span><span class="p">);</span>
<span class="n">Task</span><span class="p">.</span><span class="n">Factory</span><span class="p">.</span><span class="n">StartNew</span><span class="p">(</span><span class="n">slave</span><span class="p">.</span><span class="n">Start</span><span class="p">);</span>

<span class="n">Logger</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="s">&quot;Slave Start!&quot;</span><span class="p">);</span>
<span class="n">Console</span><span class="p">.</span><span class="n">ReadKey</span><span class="p">();</span>
</code></pre></div>
<p>Slave 프로젝트는 DistFunctions 프로젝트를 Reference로 등록해놓지 않았기 때문에 <code>RemoteSumWork</code> 클래스의 존재를 모른다. 따라서 Master가 <code>RemoteSumWork</code> 객체를 보내면 deserialize 과정에서 Type 객체를 찾을 수 없다고 예외가 발생해야 한다.</p>

<p>하지만 그 <code>RemoteSumWork</code> 객체를 보내기 전에 <code>DistFunctions.dll</code>을 보냈다. Slave는 이 파일을 받아서 <strong>자신의 exe 파일이 있는 위치에 저장하게 된다.</strong> 덕분에 <code>RemoteSumWork</code> 객체를 전달받았을 때에는 <strong>exe 주변의 dll을 알아서 검색해서 알아서 deserialize를 해준다.</strong> 즉, dll만 보내주면 끝이라는 이야기이다.</p>

<p>물론 DistFunctions.dll 파일의 버전이 올라갈 경우에 대해서는 신경을 좀 써줘야 한다.</p>

<ul>
<li>예전에 보낸 DistFunctions.dll은 이미 Slave에 load된 상태이기 때문에 삭제를 하거나 덮어쓰는 등의 작업을 할 수 없다. (이미 사용 중인 파일이라고 나온다)</li>
<li>때문에 WinSxS처럼 버전 별로 dll을 쌓아놓는 방법을 쓰면서 Slave가 재시작될 때 적절히 Dll 파일들을 삭제해주는 정책을 쓰면 되겠다.</li>
</ul>

<p>단, <em>여러 버전의 Dll 파일을 사용</em>하려면 위처럼 <strong>보내기만 하면 자동으로 Assembly에 포함되는</strong> 기법을 사용할 수가 없다. 따라서 Slave에게 작업 요청할 때 이 Work 객체가 어떤 Dll 밑의 Assembly에 포함되어 있는지를 명시해주어 serialize할 때마다 적절한 Assembly를 참조할 수 있도록 코딩해줘야 한다. <code>Assembly.LoadFile(Path.GetFullName(...)).GetType(...)</code> 같은 작업을 해줘야 하는데 이 부분을 설명하려면 내용이 굉장히 길어지니 추후 기회가 있으면 언급해보도록 하겠다.</p>

<h3>정리</h3>

<p>요새 이것 저것 바빠서 글을 못 썼다기 보다는 다른 재밌는 주제가 많아지다 보니 이 주제에 대한 흥미가 많이 떨어져버렸다-_-;<br>
이러다간 영영 못 쓸 것 같아서 고민하고 있다가, 이 글을 완료하지 못하면 다음 주제로 넘어갈 수가 없으니(orz) 대충이라도 끝을 내야겠다싶어 급하게 글을 끝내버렸다.</p>

<p>솔직히 좀 많이 아쉬운 주제인데 나중에 기회가 되면 또 도전해보고 싶다 [...]</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1><a id="io" href="#io">io</a></h1>
				<hr />
				<div class="page-breaker"></div>
							
						
				<h1 class="page-title">IO와 메모리 복사</h1>
				<p class="page-date">14 Aug 2011</p>
				<p class="page-tags">
						
						
					<code class="tag">io</code>
						
						
						
					<code class="tag">memory</code>
						
						
						
						
				</p>
				<div class="content"><p>동기와 비동기 IO 에 대해 지난번에 이야기했었다. <a href="/2011/08/07/asynchronous-io/">비동기 IO 함수</a></p>

<p>간단히 요약하면, 함수는 완료 알림 시점 때문에 동기와 비동기로 구분된다는 것이다.</p>

<ul>
<li><p>동기는 함수의 완료를 반환을 통해 알린다. 따라서 요청한 작업이 끝나기 전까지는 함수가 반환되지 않는다는 것. 덕분에 작업이 다른 작업에 의존적일 경우 흐름이 멈추는(Blocking) 경우가 많다.</p></li>
<li><p>비동기는 함수의 완료를 반환을 통해 알리지 않는다. Callback 을 불러주든 Event나 Signal을 날려주든, 완료 통지를 가져갈 때까지 모아두든 어쨌든 요청하는 함수는 바로 반환된다. (물론 요청 즉시 바로 완료되어 끝날 수 있지만) 그래서 흐름이 안 멈춘다(Non-Blocking)</p></li>
</ul>

<p>이런 것에 익숙하지 않은 이유는 여지껏 작성한 함수들이 전부 로직 함수였기 때문이다. 단순히 더하고 빼고 하는데 함수 수행이 흐름을 멈춘다고 생각하지는 않으니까. 하지만 다른 Thread, Process의 수행에 의존적이거나 장치(Device) IO에 대기해야한다면 함수는 그 의존 작업이 해결될 때까지 대기(Blocking) 하는 수 밖에 없다. 그게 싫으면 작업 요청만 받아두고(Promise) 완료 통지는 나중에(Future) 해야지.</p>

<p>효율성에 대해 이야기하자면, 동기 방식은 수행 흐름을 멈추어야 하기 때문에 Scheduling 정책을 변경해야한다는 것이고, 그러면 커널 모드로 진입해야하니까 Mode Switch 에 현재 수행 흐름을 멈추고(Sleep, Suspend) 다른 수행 흐름을 재개(Wakeup, Resume)해야하므로 Context Switch 비용도 들어간다. 이게 CPU Cycle 을 엄청 잡아먹고 메모리 작업도 엄청 많고 그러다보면 IO 작업(Swap out 된 메모리 복구) 도 생길 수 있고 아무튼 기타 등등 무지하게 느려지게 된다.</p>

<p>고로 비동기를 쓰면 빠르다는 이야기가 나오는 것이고, 실제로 Java에서도 1.4에서 Non-Blocking IO 를 지원하는 NIO(New IO)를 내세워 우리도 빠르다! 를 외쳤다.</p>

<p>어쨌든 Non-Blocking은 Thread 사용량을 줄여주고, 흐름이 방해되지 않으며, Mode/Context Switch 이 덜 일어난다는 등 성능이 향상될 좋은 이유가 많다. 그러나 IO  효율을 이야기함에 있어서는 그것이 끝이 아니다.</p>

<h3>메모리</h3>

<p>IO 의 효율을 이야기할 때는 메모리 관점 역시 빼 놓을 수가 없다.
IO 작업을 처리함에 있어서 꽤나 메모리 복사가 일어나기 때문인데, 그 이유는 가상 메모리(virtual memory)를 사용하기 때문이다.</p>

<p><a href="http://en.wikipedia.org/wiki/Virtual_memory">가상 메모리</a>가 무엇인가?<br>
간단히 말하면, 운영체제가 각 프로세스에게 가상의 메모리 주소 체계를 제공하고, 그 가상 메모리 공간이 실제 물리 메모리 공간과 마법같이 연결(mapping)되어 프로세스가 메모리에 접근할 때 주소 변환 과정을 거쳐 실제 물리 메모리에 접근 가능하게 해주는 것이다.</p>

<p>이게 뭐가 좋은가?
* 메모리 주소 몰라도 코딩 가능하다. 16bit 시절 real address 시절을 살지 않았던 사람은 무슨 말인지 모르겠지. 물론 나도 모른다.
* 보안 정책이 강화된다. 다른 프로세스의 메모리 주소 공간과 내 주소 공간이 다른 세계이므로 그 쪽에 함부로 접근할 수 있는 방법이 없다. 접근하려면 운영체제에게 요청하고 허락받아야 한다.
* 물리 메모리는 작아도, 각 프로세스는 논리(가상) 메모리만 보기 때문에 넓다고 착각하고 살 수 있다. 실제 물리 메모리로의 연결은 운영체제가 해주니까. 메모리 공간 부족하면 알아서 하드 디스크로 내리겟지(swap out). 그러다가 다시 필요하면(page fault) 알아서 다시 읽어 줄 것이다.</p>

<p>메모리 영역은 커널 영역과 유저 영역으로 나누어진다. Windows 경우 32 bit일 때 대충 2GB, 2GB씩 갈라서 쓴다.<br>
당연한 이야기이지만, 유저 영역과 커널 영역의 보안 정책은 다를 것이고, 무엇보다 중요한 건 유저 영역의 메모리는 실제 물리 메모리에 존재하지 않을 수 있다는 것이다. (swap out된 상태)</p>

<p>이 때문에 커널에 무언가 요청을 하는데 그것이 유저 메모리에 복사해주어야 경우, 즉 대부분의 IO 요청에 대해서는 문제가 발생할 수 있다.</p>

<p>잠깐 간단한 전제를 다함께 집고 넘어가자.
커널은 시스템을 보호해야할 목적이 있다. 하나의 악의적인 목적을 가진 프로세스로부터 다른 프로세스의 안정성을 지켜줘야할 필요가 있다.
유저는 위험하고, 멍청하고, 적이다!</p>

<p>다음의 예제를 보자.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>
<span class="n">read_async</span> <span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">4096</span><span class="p">);</span>
<span class="k">delete</span> <span class="n">buffer</span><span class="p">;</span> <span class="c1">// 훼이크다, 커널아!</span>
</code></pre></div>
<p>위의 <code>read_async</code> 요청은 적법하다. buffer 포인터도 유효하고, 공간도 잘 할당되어있다. 하지만 완료 통지는 언제 될지 모른다. 여기서 커널은 유저를 <strong>믿고</strong> 유저가 넘긴 포인터에다가 데이터를 덮어쓰면, 잘 돌아갈까?</p>

<p>잘못된 주소 공간에 덮어쓰거나, 운이 없으면 KERNEL PANIC (CRASH) 이 발생해서 시스템이 멈출 수 있다.
따라서 커널 모드에서 유저 영역의 메모리에 접근하는 것은 금기시? 되어버렸고,
적어도 죽어도 유저 모드에서 죽어라! 라는 심정으로 작업 결과를 커널 버퍼에 넣어주면, CRT (C Runtime) 함수들이 거기서 유저가 요청한 영역으로 다시 복사를 수행해주는 방법을 사용하는 것이다.</p>

<p>결국 커널에 유저 영역의 버퍼에 뭔가를 얻어오는 요청을 할 경우에는</p>

<ol>
<li>유저 영역에 있는 API 함수 진입점에서 메모리 주소의 유효성 검사를 한다</li>
<li>유저 영역에 있는 API 함수에서 커널 영역에 있는 API 함수에게 요청을 한다.</li>
<li>커널 영역에 있는 API 함수가 결과를 커널 영역 내에 저장해둔다.</li>
<li>유저 영역에 있는 API 함수가 커널 영역에 있는 결과를 유저가 요청한 영역에 복사해준다.</li>
</ol>

<p>따라서 API 함수는 유저 영역과 커널 영역 양 쪽으로 분할된다.<br>
이렇게 되면 커널에서 잘못된 유저 메모리에 접근할 일이 없고, 접근한다고 해도 유저 영역의 API 함수 내에서 접근하기 때문에 그 프로세스만 종료되게 되는 것이다(segmentation fault)</p>

<p>같은 맥락으로 유저 영역 메모리에 있는 내용을 커널 모드에서 참조해야할 경우, 유저 영역 메모리가 없을 수도 있다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>
<span class="c1">// 뭔가 내용을 buffer 에 쓴다</span>
<span class="n">write_async</span> <span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">written</span><span class="p">);</span>
<span class="k">delete</span> <span class="n">buffer</span><span class="p">;</span> <span class="c1">// 훼이크다, 커널아!</span>
</code></pre></div>
<p><code>write_async</code> 함수는 비동기 수행을 하므로, 이 함수의 수행이 delete보다 나중에 실행될 수 있다. 그 때 유저 영역의 메모리에 접근하려 한다면? 결과는 알 수 없다.<br>
따라서 이러한 경우에도 <code>write_async</code>함수에서 유저가 요청한 데이터를 <strong>안전한</strong> 커널 영역으로 복사해와야 하는 것이다.<br>
(linux kernel의 <code>copy_from_user</code>, <code>copy_to_user</code>)</p>

<p><span style="color: #888;">물론 이걸 제대로 설명하려면 paged pool 과 nonpaged pool 을 설명해야하지만 너무 내용이 길어지니 일단 이정도로 넘어가자.</span></p>

<h3>다시 IO로</h3>

<p>위의 장황한 설명을 IO 로 초점을 맞추어 다시 이야기해보자.</p>

<p><strong>SEND 를 수행하려고 한다.</strong> 그럼 유저 영역에 있는 메모리의 내용을 커널 쪽에 요청해야할 것이다.</p>

<ol>
<li>유저 영역의 메모리가 커널 영역에 복사가 된다.(Async 함수 요청할 때)</li>
<li>커널 영역의 데이터를 IO 드라이버를 통해 해당 장치로 내보낸다.(사용자의 IO 요청을 처리할 때)</li>
</ol>

<p><strong>RECV 를 수행하려고 한다.</strong> 그럼 커널 영역의 메모리를 거쳐서 유저 영역으로 복사해와야 한다.</p>

<ol>
<li>유저 영역의 메모리 주소로 비동기적 Read 를 요청한다.</li>
<li>커널에서 IO 의 interrupt 를 받는다. interrupt handler 가 수행되고, 데이터를 보니까 아까 Read 요청한 거였네? 그러면 일단 IO 드라이버를 통해 수신 받은 데이터를 커널 영역에 복사해온다.(IO 장치의 IO 요청을 처리할 때)</li>
<li>IO 완료 통지를 유저에게 해준다. 이 때 커널 영역에 있는 데이터가 유저가 지정했던 메모리로 다시 복사가 일어난다.</li>
</ol>

<p>적어도 2번 일어난다. 유저와 커널. IO 드라이버 내에서 사용하는 것까지 하면 더 일어나겠지만 그건 어쩔 수 없는 영역이니 일단 넘어가자.</p>

<p>동기와 비동기에 대해서 묶어서 설명하고 있는데, 동기든 비동기든 메모리 복사는 어쨌거나 저 규칙을 따른다. 다만 수행 흐름이 멈추느냐, 완료 통지를 동기적으로 받을 수 있느냐의 차이일 뿐.</p>

<p>Java 의 IO 가 느린 이유가 여기있다.<br>
예를 들어 Recv 작업을 요청한다고 했을 때, IO 버퍼, 커널 버퍼, JVM, Java Memory로의 복사 단계를 거쳐야하므로 속도가 훨씬 느릴 수 밖에 없다. 따라서 JVM 내의 native 한 메모리를 직접 IO에 사용할 수 있게 해준 ByteBuffer로 인해서 Java IO 속도가 개선되었고, 이것은 NIO의 핵심 개념 중 하나가 되었다.</p>

<h3>속도 개선?</h3>

<p>유저가 코드를 잘 작성했다. 즉, 비동기 IO 요청이 끝나기 전까지 메모리 관리를 잘 해주었다.
그리고 커널이 튼튼해졌다. 유저의 악의적인 장난 쯤은 사소하게 여기면서 유저 프로세스를 종료시켜준다.
이러한 상황에서는, 커널 버퍼라는 중간 지점의 필요성이 모호해진다. 오히려 성능적 저해 요인이 될 뿐이다.</p>

<p>그렇다고 해도 저 문제를 한 번에 해결할 수는 없다. IO 요청과 메모리 Paging 수행의 IRQL 문제로 인해서 IO 요청이 일어날 때 해당 메모리가 Swap out 되어있으면 안되기 때문이다.<br>
(이건 Windows 에만 해당되는 것 같고, 사실 그마저도 아직 잘 모르겠어서 공부가 더 필요하다.)</p>

<ul>
<li><a href="http://studyrespire.tistory.com/tag/IRQL">http://studyrespire.tistory.com/tag/IRQL</a></li>
<li><a href="http://bugtruck.blogspot.com/2009/03/non-paged-memory.html">http://bugtruck.blogspot.com/2009/03/non-paged-memory.html</a></li>
</ul>

<p>커널이 유저 영역의 메모리에다가 결과를 직접 넣어주고 싶어도 해당 메모리가 swap out이 되어버린다면 그 처리가 애매해진다는 것. 그 이유는 디스크로 내려간 메모리를 물리 메모리로 올려주는 작업을 처리하는 것도 interrupt에 의한 것이고, IO 요청을 처리하는 것도 interrupt이기 때문이다.<br>
(물론 지연된 수행 방식에 따라 interrupt handler 에서는 최소한의 작업만 수행하고 실질적인 IO 드라이버가 동작하는건 kernel thread 에서 수행을 하겠지만)</p>

<p>논리 메모리 주소를 CPU가 fetch 하기 위해 여러 레지스터의 도움을 받아 실제 물리 메모리 주소를 접근했을 때, 그것이 디스크에 저장되어있으면 page fault exception (soft interrupt)이 발생한다. 그러면 그걸 처리하는 interrupt handler가 수행되면서 메모리를 적당한 곳에 복구해준다.<br>
<del>그런데 이게 IRQL 때문에 문제가 생기나?</del> 아무튼 그래서 Windows에서는 유저가 IO 요청을 하면 그 버퍼에 직접 작업하기 위해서는 그 메모리 공간을 swap out이 불가능한 상태로 만들어준다. 이것을 <strong>locked page</strong> 라고 한다.
<span style="color: #888;">(비겁한 변명이지만 사실 이쪽은 아직 잘 모르겠다)</span></p>

<p>간단히 말해 유저가 요청한 버퍼 공간을 lock 을 걸어서 paging 이 안되게 하겠다는 것. 그러면 IO 요청이 언제 수행되더라도 해당 메모리가 물리 메모리에 있음을 보장할 수 있으니까 문제가 없다는 것이다.<br>
<span style="color: #888;">(동기 IO 든 비동기 IO 든 IO 요청은 IO 드라이버 내의 로직에 따라 언제 수행될지 모른다. 그저 완료 통지가 함수 반환으로 일어나느냐 아니냐의 차이일 뿐)</span></p>

<p>즉, 어설프게 중간 다리인 커널 버퍼를 두지 않더라도 유저 영역에서 직접 IO 버퍼에 값을 쓰거나, IO 버퍼로부터 값을 읽어올 수 있게 된다는 것이다. 메모리를 복사하는데 들어가는 CPU 사용을 줄이니 당연히 효율이 좋아질 수 밖에 없다. 뿐만 아니라 multi core 인 현 세상을 고려해볼 때, cache나 memory access 등을 고려해보면 효율이 좋아지는 것은 어찌보면 당연할 수 밖에 없는 것 같다.</p>

<h3>정리</h3>

<p>약간의 커널적 개념과 하드웨어적 개념이 들어가서 글이 길어졌는데 요약해보면,</p>

<ul>
<li>IO 요청을 할 때는 적어도 유저 영역, 커널 영역, IO 드라이버 영역 간의 메모리 복사가 이루어진다.</li>
<li>Windows 에서는 locked page를 사용하여 IO 요청을 할 때, 커널 모드에서 유저 영역과 IO 드라이버 영역의 메모리를 직접 교환 가능하게 하여 성능 효율을 향상시켰다.</li>
</ul>

<p>하지만 locked page는 몇 가지 문제점을 야기하는데, 아무래도 물리적 메모리에서 디스크로 안 내려가는 메모리가 많아질 수록 가용 메모리 공간은 줄어들 것이고 시스템 성능은 저하될 것이다. 심해지면 커널 크래시가 날 것이다.</p>

<p>IRQL과 non paged pool에 대해서는 개념 부족으로 설명을 완전 대충했는데, 이에 대해서 좋은 내용이 있으면 거침없는 조언 부탁드린다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1><a id="java" href="#java">java</a></h1>
				<hr />
				<div class="page-breaker"></div>
							
						
				<h1 class="page-title">EventHandler와 Message Passing</h1>
				<p class="page-date">20 Dec 2011</p>
				<p class="page-tags">
						
						
					<code class="tag">java</code>
						
						
						
					<code class="tag">message</code>
						
						
						
						
				</p>
				<div class="content"><p>객체(object)는 상태(state)를 갖고 외부의 조작(mutator)에 의해서 변경될 수 있다.
이러한 객체를 다루는 프로그래밍을 할 때는, 관찰자(observer)가 객체의 상태 변화(property change)를 감지하여 어떠한 동작(action)을 수행하는 경우가 많이 있다.</p>

<p>이러한 코드를 작성할 경우, 관찰 당하는 객체(subject)와 관찰자(observer)의 관계를 어떻게 정의하냐에 따라서, 확장성, 결합성 등이 많이 달라지게 된다. 이 글에서는 간단한 EventHandler와 Message Passing에 대해서 다루어보려고 한다.<br>
<a href="http://en.wikipedia.org/wiki/Observer_pattern">http://en.wikipedia.org/wiki/Observer_pattern</a></p>

<h3>hard binding</h3>

<p>명부(List)는 내부에 사람(Person)을 포함한다. 사람은 이름(name)이라는 속성(property)을 갖고, 이 값은 외부에서 변경될 수 있다(mutator method). 명부는 사람의 이름이 변경되는 것을 감지해야한다.</p>

<p>이를 위한 가장 간단한 방법은 아래와 같다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">List</span> <span class="n">observer</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Person</span><span class="o">()</span> <span class="o">{}</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">setName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">observer</span><span class="o">.</span><span class="na">nameChanged</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">,</span> <span class="n">name</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">attach</span><span class="o">(</span><span class="n">List</span> <span class="n">observer</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">observer</span> <span class="o">=</span> <span class="n">observer</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">List</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="n">Person</span> <span class="n">person</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">person</span><span class="o">.</span><span class="na">attach</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">nameChanged</span><span class="o">(</span><span class="n">String</span> <span class="n">oldName</span><span class="o">,</span> <span class="n">String</span> <span class="n">newName</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>간단한 구조에서는 위와 같이 하는 것이 더 직관적일 수 있다. 하지만 Person과 List는 강결합되고, 추후에 Person 객체의 name 값이 변경되는 것을 감지하려는 대상(observer)이 늘어날 수록 코드는 복잡해질 것이다.</p>

<h3>interface 도입</h3>

<p>두 객체 간의 강결합을 피하기 위해 이를 분리하기 위한 중간 interface를 도입한다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">interface</span> <span class="nc">NameObserver</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">nameChanged</span><span class="o">(</span><span class="n">String</span> <span class="n">oldName</span><span class="o">,</span> <span class="n">String</span> <span class="n">newName</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p>이제 Person과 List의 관계는 NameObserver를 통해서 약간은 분리되었다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="n">NameObserver</span> <span class="n">observer</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">attach</span><span class="o">(</span><span class="n">NameObserver</span> <span class="n">observer</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">observer</span> <span class="o">=</span> <span class="n">observer</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">List</span> <span class="kd">implements</span> <span class="n">NameObserver</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div>
<p><code>Person</code>은 자신의 이름이 변경될 때 그 사실을 알려주어야 할 대상을 <code>NameObserver</code>로 한정지을 수 있다. 즉, <code>NameObserver</code>를 구현하는(implements) 모든 대상들은 <code>Person</code>의 <code>name</code> 변경에 대한 고지(notify)를 받을 수 있는 것이다.</p>

<h3>multiple observer</h3>

<p>하나의 <code>Person</code>이 여러 <code>NameObserver</code>에게 사실을 알려주어야 한다면, <code>NameObserver</code> 객체에 대한 reference를 Collection 형태로 가지고 있으면 된다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">NameObserver</span><span class="o">&gt;</span> <span class="n">observers</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">NameObserver</span><span class="o">&gt;();</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">attach</span><span class="o">(</span><span class="n">NameObserver</span> <span class="n">observer</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">observers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">observer</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="n">String</span> <span class="n">newName</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">NameObserver</span> <span class="nl">each:</span> <span class="k">this</span><span class="o">.</span><span class="na">observers</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">each</span><span class="o">.</span><span class="na">nameChanged</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">,</span> <span class="n">newName</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">newName</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>위 같은 작업은 속성(property)를 갖는 많은 JavaBean 객체에서 주로 사용되므로, Java 쪽에서는 <code>PropertyChangeSupport</code>라는 Utility class를 통해 위 작업을 편하게 구현할 수 있게 해준다.</p>

<h3>PropertyChangeEvent</h3>

<p>interface 쪽으로 분리되었다고 해도, <code>Person</code>의 변경에 대해 통지해야할 속성 값의 개수가 늘어나거나, 그 내용이 변경되거나 하면 이 interface의 수정은 불가피하다.</p>

<p>예를 들어, <code>Person</code> class에 나이(age)속성이 추가된다고 하자.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div>
<p>그리고 <code>age</code>에 대해서도 변경 통지를 해주고 싶다. 그러면 <code>AgeObserver</code>를 하나 새로 만들어야 할까? 아니면 <code>NameObserver</code>를 적절히 <code>PersonObserver</code>로 변경한 다음 <code>ageChanged</code>라는 함수를 추가해줄까? 이전에 <code>NameObserver</code>를 구현(implements)하고 있던 class들이 모두 <code>age</code>에 대한 변경 통지를 원할까?</p>

<p>즉, 중간 interface 분리를 통해 <code>Person</code>과 <code>List</code> class의 결합도는 낮아졌지만, <code>Person</code>과 <code>NameObserver</code>, <code>NameObserver</code>와 <code>List</code>의 결합은 상속(Java 에서는 interface 에 의한 구현implements 이지만 runtime에 변경될 수 없는 정적 binding 이라는 점에서는 매한가지다) 관계이므로 이쪽은 여전히 강결합이라는 것이다.</p>

<p>이 문제를 해결하기 위해서는 약간의 추상화가 더 필요하다.
<code>Person</code> class는 자신의 상태(속성)가 변화될 때의 정보를 적절히 capsulation하여 객체로 구성하고, 이를 통지받는 쪽에서는 그 정보 객체를 받아 적절히 처리하는 것이다.</p>

<p>즉, 정보를 담기 위한 중간 객체가 등장한다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">class</span> <span class="nc">PropertyChangeEvent</span> <span class="o">{</span>
    <span class="n">String</span> <span class="n">propertyName</span><span class="o">;</span>
    <span class="n">Object</span> <span class="n">oldValue</span><span class="o">;</span>
    <span class="n">Object</span> <span class="n">newValue</span><span class="o">;</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">PropertyListener</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">propertyChanged</span><span class="o">(</span><span class="n">PropertyChangeEvent</span> <span class="n">event</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p>이제 <code>Person</code>은 자신의 정보가 변경될 때마다 <code>PropertyChangeEvent</code> 객체를 자신에게 등록되어있는(subscribe) <code>PropertyListener</code> 객체들에게 던진다. 그러면 그 <code>PropertyListener</code>의 구현체들은(implements or concrete) <code>PropertyChangeEvent</code> 객체를 받았을 때 자신이 원하는 이벤트에 대해서만 처리하는 것이다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">PropertyChangeListener</span><span class="o">&gt;</span> <span class="n">listeners</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="n">String</span> <span class="n">newName</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">PropertyChangeListener</span> <span class="nl">each:</span> <span class="n">listeners</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">each</span><span class="o">.</span><span class="na">propertyChanged</span><span class="o">(</span><span class="k">new</span> <span class="n">PropertyChangedEvent</span><span class="o">(</span><span class="s">&quot;name&quot;</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">,</span> <span class="n">newName</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">newName</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div><div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">class</span> <span class="nc">List</span> <span class="kd">implements</span> <span class="n">PropertyChangeListener</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">propertyChanged</span><span class="o">(</span><span class="n">PropertyChangeEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">propertyName</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">&quot;name&quot;</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// name changed</span>
</code></pre></div>
<p>실제로 위 방법의 <code>PropertyChageEvent</code>는 너무 일반적(generic) 해서 정보를 가져올 때 썩 좋지는 않다. 어떤 속성 값이 바뀌었는지 String 변수를 통해 판단하므로 판단에 위험도 있고, 그 값도 모두 Object이므로 type-cast 위험도 있다.</p>

<p>이를 해결해주기 위해서 적절히 <code>Event</code> class 를 분화한다던지, <code>Event</code>의 각 Id 값을 enum이나 int 등으로 분류하여 관리한다던지 한다.</p>

<p>그리고 위 경우에도 자신이 관심있는 속성에 대해서만 <code>PropertyChangeEvent</code>를 받는 것이 아니라 모든 변경에 대해 받게 된다. 이 역시 <code>Person</code> class (사실상 Model 객체)에 <code>Listener</code>를 attach 할 때 어떤 속성에 대한 변화 통지를 받을 것인지를 따로 관리하게 하는 방법으로 해결할 수 있다.
(하지만 더 이상의 자세한 설명은 생략한다.)</p>

<p>또한 Reflection 등을 사용하여 각 Event type마다 다른 Handler를 호출되게 하는 방법도 있다. <a href="/2011/11/27/java-message-dispatcher/">간단한 Message 체계 구현</a></p>

<p>요약하자면 결국 송신/수신 객체간의 낮은 결합성을 고려한 상태 변화 통지의 설계가 Event Handler (Listener) 방식이라는 것이다.</p>

<h3>message passing</h3>

<p>Message Passing이야기를 해보자.
Event와 Message는 정보를 담은 객체이면서, 송신/수신 객체의 의존성을 분리하기 위한 추상화 방법이라는 점에서 매우 유사해보인다. 그런데 억지로 가장 큰 차이를 들어보자면,</p>

<ul>
<li>Event는 Event 발생자와 수신자(Listener) 간의 1:N 관계 (Event 발생자가 여러 수신자에게 Event 객체를 넘겨주는 식)이고,</li>
<li>Message는 여러 Message 수신자(Listener)가 Message 생성자와 MessageQueue를 공유해서 N:M 의 처리가 이루어지는 구조이다.</li>
</ul>

<p><em>(너무 억지다)</em></p>

<p>사실상 Java에서도 UI Event에서 처리 동기화를 위해 단일화된 EventQueue를 쓰고, 이를 처리하는 Event Dispatch Thread (EDT)가 EventQueue에 들어있는 Event를 하나씩 꺼내서 처리한다.</p>

<p>즉, UI Components들은 자신들에게서 일어나는 일에 대한 처리를 <strong>위임</strong>하기 위해 그 정보를 Event 객체에 담아 EventQueue에 넣고, EDT는 그걸 하나씩 꺼내서 자신에게 등록된 Listener들을 하나씩 불러서 처리할 수 있게 해주는 것이다.</p>

<p>Event, Message, Signal 개념적으로 모두 자신의 할 일을 남에게 위임(delegation) 하는 상황에서 객체간의 결합성을 낮추기 위해서 사용되는 개념이고, 안에 들어있는 정보가 작을 수록 Event에서 Signal 쪽으로 부르는 것 같기는 하지만 보면 그냥 각자의 취향같다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">go interface 구현하기</h1>
				<p class="page-date">21 Jun 2012</p>
				<p class="page-tags">
						
						
					<code class="tag">java</code>
						
						
						
						
				</p>
				<div class="content"><p>사실 go interface가 어떤 스펙을 가졌는지는 모르겠고
그냥 <a href="https://twitter.com/summerlight00" title="summerlight00">summerlight</a>님께서 그걸 c++로 구현하면 재미있겠다고 해서 시작을 한건데 대충 내용은 다음과 같다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
<span class="nl">public:</span> <span class="kt">void</span> <span class="n">a</span><span class="p">();</span> <span class="kt">void</span> <span class="nf">b</span><span class="p">();</span> <span class="kt">void</span> <span class="nf">c</span><span class="p">();</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">X</span> <span class="p">{</span>
<span class="nl">public:</span> <span class="kt">void</span> <span class="n">a</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">Y</span> <span class="p">{</span>
<span class="nl">public:</span> <span class="kt">void</span> <span class="n">b</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">Z</span> <span class="p">{</span>
<span class="k">public</span> <span class="kt">void</span> <span class="n">c</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">A</span> <span class="n">obj</span><span class="p">;</span>
<span class="n">X</span><span class="o">*</span> <span class="n">x</span> <span class="o">=</span> <span class="cm">/* 어떻게든 obj랑 연결 */</span><span class="p">;</span>
<span class="n">x</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">();</span> <span class="c1">// A::a() 함수가 호출됨</span>
</code></pre></div>
<p>A라는 class는 a, b, c라는 함수를 가지고 있지만, 명시적으로 X, Y, Z interface를 구현하고 있지 않기 때문에 X, Y, Z pointer로 A 객체를 지칭할 수 없다. 하지만 암시적으로라도, 동일한 함수 signature가 존재한다면 interface로 지칭할 수 있게 해주는 것이 목적이다. (template 함수에서 암시적 interface를 요구하는 것을 객체화하여 접근할 수 있게 하였다고 봐도 되겠다)</p>

<p>reflection을 사용하면 저걸 구현하는건 쉽다. 그렇지만 컴파일 시점에 대입 가능성을 보장해주려면 metaprogramming을 해야 한다.</p>

<p>이 때 함수 signature를 비교하여 대입가능성을 검사해야 하는데, 문제는 함수 signature에 함수 이름이 포함된다는 것이다. 이름은 string literal이 될 것이고, 이를 compile time에 비교하려면 적어도 constexpr을 쓰거나 char typelist(variadic template)를 써야하는데, constexpr와 variadic template 모두 vs2012에서 지원 안하니 <del>(그렇다고 gcc를 쓸 생각은 없으니)</del> 일단 무시한다.</p>

<p>결국 reflection을 써서 저 기능을 구현하면 되는데 c++로 reflection부터 만드려면 귀찮으니 java로 예제를 만들어 보자.</p>

<p>안타깝게도 (혹은 다행스럽게도) java에서는 연산자 overloading이 없으므로, interface 객체에 대상 객체를 대입하기 위한 static 함수를 하나 만들 것이다.</p>

<p>java reflection 중에는 <code>Proxy</code>라고 하여 해당 interface에 대한 method가 호출될 때, 그 method와 argument 정보를 하나의 함수로 모아주는(<code>InvocationHandler</code>) 좋은 class가 있다. (마치 ruby의 missing method나 php의 <code>__call</code>처럼)</p>

<p>덕분에 어떤 interface를 넣어도 <code>Proxy</code>를 적절히 써서, 해당 interface의 함수가 호출될 때 이 정보를 대상 객체(target)의 함수로 잘 넘겨서 실행해주면 되겠다.</p>

<p>이에 대한 코드는 다음과 같다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kn">import</span> <span class="nn">java.lang.reflect.InvocationHandler</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Method</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Proxy</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">InfOp</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">assign</span><span class="o">(</span><span class="n">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">infClazz</span><span class="o">,</span> <span class="n">Object</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">infClazz</span><span class="o">.</span><span class="na">cast</span><span class="o">(</span><span class="n">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span><span class="n">infClazz</span><span class="o">.</span><span class="na">getClassLoader</span><span class="o">(),</span> 
                <span class="k">new</span> <span class="n">Class</span><span class="o">&lt;?&gt;[]</span> <span class="o">{</span> <span class="n">infClazz</span> <span class="o">},</span> <span class="k">new</span> <span class="n">InvocImpl</span><span class="o">(</span><span class="n">target</span><span class="o">)));</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">InvocImpl</span> <span class="kd">implements</span> <span class="n">InvocationHandler</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="n">Object</span> <span class="n">target</span><span class="o">;</span>
        <span class="kd">private</span> <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">targetClazz</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">InvocImpl</span><span class="o">(</span><span class="n">Object</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">super</span><span class="o">();</span>
            <span class="k">this</span><span class="o">.</span><span class="na">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">targetClazz</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">Object</span> <span class="n">proxy</span><span class="o">,</span> <span class="n">Method</span> <span class="n">method</span><span class="o">,</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>
                <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
            <span class="n">Method</span> <span class="n">targetMethod</span> <span class="o">=</span> <span class="n">targetClazz</span><span class="o">.</span><span class="na">getMethod</span><span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> 
                    <span class="n">method</span><span class="o">.</span><span class="na">getParameterTypes</span><span class="o">());</span>
            <span class="k">return</span> <span class="n">targetMethod</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">target</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>핵심은 <code>InvocationHandler::Invoke()</code> 내에 있는 코드이다. interface class에서 호출되는 method의 정보(name, parameter = 결국 signature)를 사용하여 target 객체의 method 정보를 찾는다. 그리고 invoke를 하면서 argument도 넘겨주면 끝이다.</p>

<p>이제 다음과 같이 사용해볼 수 있다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Character</span> <span class="n">ch</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Character</span><span class="o">();</span>
        <span class="n">Drawable</span> <span class="n">dr</span> <span class="o">=</span> <span class="n">InfOp</span><span class="o">.</span><span class="na">assign</span><span class="o">(</span><span class="n">Drawable</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">ch</span><span class="o">);</span>
        <span class="n">dr</span><span class="o">.</span><span class="na">draw</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">Drawable</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">draw</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">Movable</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">move</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Character</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">draw</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;draw!&quot;</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">move</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;move!&quot;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p><code>Character</code> class와 <code>Drawable</code> interface는 명시적인 구현 관계(implements)가 없지만, 어쨌든 <code>draw()</code>라는 동일한 함수 signature를 갖는다. 따라서 <code>Character</code> 객체를 적절히 proxy로 감싸서 <code>Drawable</code> interface와 연결하여 위 코드처럼 실행시킬 수 있는 것이다.</p>

<p><em>(조만간 compile time check를 포기한 c++ 버전도 올리도록 하겠다.)</em></p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">java annotation과 reflection을 사용한 xml mapping</h1>
				<p class="page-date">31 May 2012</p>
				<p class="page-tags">
						
						
					<code class="tag">java</code>
						
						
						
					<code class="tag">reflection</code>
						
						
						
						
				</p>
				<div class="content"><p>마침 요즘 spring을 쓰면서 자바를 공부한다는 친구를 채팅방에서 만나게 되어 reflection과 annotation을 사용한 xml mapping에 대한 코드를 작성해보라고 이야기하였다. 그 친구가 언급한 DI와는 좀 다른 방향이지만, annotation을 사용한 metadata 사용과 reflection을 통한 설계적 유연성을 공부해보면 spring framework을 이해하는데 도움이 되지 않을까 하여 이야기했던 것이다.</p>

<p>annotation은 java에서 코드 내에 metadata를 넣기 위해 도입한 개념으로 1.5부터 추가되었다. 특정 지점(ElementType: Type, Method, Field, ...)에 특정 시점(Retention: Source, Class, Runtime)까지 유지되는 metadata 정보를 남길 수 있다.</p>

<p>reflection은 class나 method, field 등에 대한 type, signature 정보를 runtime에도 알 수 있도록 코드 구조 정보 등을 메모리에 올려서 접근 가능하게 해주는 기능으로 c/c++같은 native한 언어들을 제외한 대부분의 고급 언어에서 제공해주는 기능이다.</p>

<p>따라서 본 글에서는 model class에 적절한 annotation으로 어떻게 xml과 연결지을지에 대한 metadata를 기록하고, reflection으로 이를 적절히 읽어서 model과 xml의 상호 변환(mapping)하는 코드를 작성할 것이다.</p>

<p>먼저 model을 하나 만들자.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Customer</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="n">order</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div>
<p><em>(본 예제에서는 getter/setter의 필요성을 못 느끼므로 작성하지 않는다.)</em></p>

<p><code>Customer</code> class가 xml로 기록되어야 할 때에는 customer라는 노드 이름을 가져야할까? name이라는 field는 xml에 attribute로 기록되어야 할까? 아니면 child-element가 되어야할까? 그리고 그 이름은 꼭 name이어야 할까?</p>

<p>이러한 정보를 위 model class에 적절히 넣기 위한 가장 좋은 방법이 annotation을 사용하는 것이다.</p>

<p>class에 사용할 annotation을 정의한다(import 생략).</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="nd">@Target</span><span class="o">(</span><span class="n">ElementType</span><span class="o">.</span><span class="na">TYPE</span><span class="o">)</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="n">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="n">XmlClassBind</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">nodeName</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>
<p>특정 <code>ElementType</code>이 TYPE이니 class에만 사용할 수 있는 annotation이고 그 정보를 <code>RUNTIME</code>까지 남긴다. 왜냐하면 해당 annotation 정보를 reflection으로 읽어서 runtime에 사용해야하기 때문이다. 그리고 <code>nodeName</code>이라는 annotation 값을 하나 같는데, 해당 class가 mapping될 xml element의 이름 정보를 넣기 위해 쓸 것이다.</p>

<p>이제 field에 사용할 annotation을 정의한다(import 생략).</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="nd">@Target</span><span class="o">(</span><span class="n">ElementType</span><span class="o">.</span><span class="na">FIELD</span><span class="o">)</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="n">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="n">XmlAttrBind</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">string</span> <span class="nf">nodeName</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">useAttribute</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>
<p><code>XmlClassBind</code>와 유사한데 <code>ElementType</code>을 <code>FIELD</code>로 선언하여 Field에만 사용할 수 있도록 한다. 그리고 <code>useAttribute</code>라는 boolean 속성을 추가하여 true이면 attribute로 기록하고 false이면 child-element를 만들도록 할 것이다.</p>

<p>이제 정의한 annotation으로 model class에 metadata를 넣어보자.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="nd">@XmlClassBind</span><span class="o">(</span><span class="n">nodeName</span><span class="o">=</span><span class="s">&quot;customer&quot;</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Customer</span> <span class="o">{</span>
    <span class="nd">@XmlAttrBind</span><span class="o">(</span><span class="n">nodeName</span><span class="o">=</span><span class="s">&quot;name&quot;</span><span class="o">,</span> <span class="n">useAttribute</span><span class="o">=</span><span class="kc">true</span><span class="o">)</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="nd">@XmlAttrBind</span><span class="o">(</span><span class="n">nodeName</span><span class="o">=</span><span class="s">&quot;age&quot;</span><span class="o">,</span> <span class="n">useAttribute</span><span class="o">=</span><span class="kc">true</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
    <span class="nd">@XmlAttrBind</span><span class="o">(</span><span class="n">nodeName</span><span class="o">=</span><span class="s">&quot;customer-order&quot;</span><span class="o">,</span> <span class="n">useAttribute</span><span class="o">=</span><span class="kc">false</span><span class="o">)</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="n">order</span><span class="o">;</span>

    <span class="cm">/* default constructor, constructor for all of fields, toString method for debugging */</span>
<span class="o">}</span>
</code></pre></div>
<p><code>Customer</code> class는 xml customer element에 대응될 것이고, <code>name</code>과 <code>age</code>는 attribute로 기록된다. <code>order</code> 문자열만 child element로 생성되는데 이 때 element 이름은 customer-order가 될 것이다.</p>

<p>모든 정보가 준비되었으니 이제 Xml과 mapping만 하면 되겠다. Java 기본 Xml Api를 사용하면 코드가 장황해지므로, 예전부터 사용하던 자체 구현 XmlElement을 사용하여 Bind를 수행하는 코드를 작성할 것이다.</p>

<p>먼저 model 객체들을 Xml로 변환하는 코드는 다음과 같다(예외 선언 생략).</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="n">XmlElement</span> <span class="nf">ToXml</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;?&gt;</span> <span class="n">models</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">models</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">();</span>

    <span class="c1">// get class type for first element</span>
    <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">clazz</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">getClass</span><span class="o">();</span>

    <span class="n">String</span> <span class="n">classNodeName</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getAnnotation</span><span class="o">(</span><span class="n">XmlClassBind</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">nodeName</span><span class="o">();</span>
    <span class="n">String</span> <span class="n">listNodeName</span> <span class="o">=</span> <span class="n">classNodeName</span> <span class="o">+</span> <span class="s">&quot;-list&quot;</span><span class="o">;</span>

    <span class="c1">// convert model to xml-element</span>
    <span class="n">XmlElement</span> <span class="n">rootElement</span> <span class="o">=</span> <span class="k">new</span> <span class="n">XmlElement</span><span class="o">(</span><span class="n">listNodeName</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Object</span> <span class="nl">model:</span> <span class="n">models</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">XmlElement</span> <span class="n">classElement</span> <span class="o">=</span> <span class="k">new</span> <span class="n">XmlElement</span><span class="o">(</span><span class="n">classNodeName</span><span class="o">);</span>

        <span class="c1">// write fields</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Field</span> <span class="nl">field:</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getFields</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">XmlAttrBind</span> <span class="n">attrBind</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="na">getAnnotation</span><span class="o">(</span><span class="n">XmlAttrBind</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">attrBind</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="k">continue</span><span class="o">;</span>

            <span class="n">field</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
            <span class="n">String</span> <span class="n">stringValue</span> <span class="o">=</span> <span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">field</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">model</span><span class="o">));</span>

            <span class="c1">// attribute or child-element</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">attrBind</span><span class="o">.</span><span class="na">useAttribute</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">classElement</span><span class="o">.</span><span class="na">setAttribute</span><span class="o">(</span><span class="n">attrBind</span><span class="o">.</span><span class="na">nodeName</span><span class="o">(),</span> <span class="n">stringValue</span><span class="o">);</span>

            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">XmlElement</span> <span class="n">childElement</span> <span class="o">=</span> <span class="k">new</span> <span class="n">XmlElement</span><span class="o">(</span><span class="n">attrBind</span><span class="o">.</span><span class="na">nodeName</span><span class="o">());</span>
                <span class="n">childElement</span><span class="o">.</span><span class="na">setTextContent</span><span class="o">(</span><span class="n">stringValue</span><span class="o">);</span>
                <span class="n">classElement</span><span class="o">.</span><span class="na">appendChild</span><span class="o">(</span><span class="n">childElement</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">rootElement</span><span class="o">.</span><span class="na">appendChild</span><span class="o">(</span><span class="n">classElement</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">rootElement</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div>
<p>model이 여럿 들어있는 List를 받아서 그것을 <code>XmlElement</code>로 변환해주는 코드이다. List 내에는 모두 동일한 type의 model 객체가 있다고 가정하였고, 해당 model class는 <code>XmlClassBind</code>와 <code>XmlAttrBind</code>가 적절히 선언되어있다고 가정하였다.</p>

<p>reflection으로 class의 <code>XmlClassBind</code> annotation 정보를 얻어서 class에 mapping 될 xml node 이름을 얻고, 그 집합에 대한 xml node 이름을 대충 -list 를 붙여서 쓴다.</p>

<p>그리고 모든 <code>XmlAttrBind</code>가 annotated된 field를 순회하면서 그 값을 <code>useAttribute</code>에 따라 attribute에 쓰거나 child-element에 기록한다. 다만 값을 가져오기 위한 Field가 private, default, protected 등 접근하지 못할 수 있으므로 <code>setAccessible()</code> 함수를 통해 접근 권한을 먼저 확보하고 접근한다.<br>
(따로 getter/setter 이름을 만들어서 <code>Method.Invoke()</code>로 접근하는 것보다는 이 편이 더 나아 보인다.)</p>

<p><code>XmlElement</code>로부터 Model 객체를 생성하는 방식은 위와는 좀 다르다. 그 이유는 Model 객체에 대한 type 정보를 먼저 구해와야 하기 때문이다.</p>

<ul>
<li>class의 full name을 xml에 기록하여 Class.forName으로 해당 class에 대한 정보를 가져와서 사용하는 방법도 있고,</li>
<li>아래 예제처럼 Class<T> 자체를 인자로 받아서 구현할 수도 있다(예외 선언 생략).</li>
</ul>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">ToModel</span><span class="o">(</span><span class="n">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">clazz</span><span class="o">,</span> <span class="n">XmlElement</span> <span class="n">rootElement</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">models</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;();</span>

    <span class="n">String</span> <span class="n">classNodeName</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getAnnotation</span><span class="o">(</span><span class="n">XmlClassBind</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">nodeName</span><span class="o">();</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">XmlElement</span> <span class="nl">classElement:</span> <span class="n">rootElement</span><span class="o">.</span><span class="na">findByTagName</span><span class="o">(</span><span class="n">classNodeName</span><span class="o">))</span> <span class="o">{</span>
        <span class="c1">// create new model instance</span>
        <span class="n">T</span> <span class="n">model</span> <span class="o">=</span> <span class="n">ReflectionHelper</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="n">clazz</span><span class="o">);</span>

        <span class="c1">// fill fields&#39; value</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Field</span> <span class="nl">field:</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getFields</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">XmlAttrBind</span> <span class="n">attrBind</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="na">getAnnotation</span><span class="o">(</span><span class="n">XmlAttrBind</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">attrBind</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="k">continue</span><span class="o">;</span>

            <span class="c1">// get value from attribute or child-element</span>
            <span class="n">String</span> <span class="n">stringValue</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">attrBind</span><span class="o">.</span><span class="na">useAttribute</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">stringValue</span> <span class="o">=</span> <span class="n">classElement</span><span class="o">.</span><span class="na">getAttribute</span><span class="o">(</span><span class="n">attrBind</span><span class="o">.</span><span class="na">nodeName</span><span class="o">());</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">stringValue</span> <span class="o">=</span> <span class="n">classElement</span><span class="o">.</span><span class="na">getChildByTagName</span><span class="o">(</span>
                        <span class="n">attrBind</span><span class="o">.</span><span class="na">nodeName</span><span class="o">()).</span><span class="na">getTextContent</span><span class="o">();</span>
            <span class="o">}</span>

            <span class="c1">// parse and set value</span>
            <span class="n">ReflectionHelper</span><span class="o">.</span><span class="na">setValue</span><span class="o">(</span><span class="n">model</span><span class="o">,</span> <span class="n">field</span><span class="o">,</span> <span class="n">stringValue</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">models</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">model</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">models</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div>
<p>model class type 정보를 인자로 받아서, <code>XmlClassBind</code>에 명시된 xml element에 대해 model 객체를 만든 후 <code>XmlAttrBind</code>를 사용하여 field에 기록할 값을 찾아서 model 객체에 넣어준다. 결국 <code>ToXml()</code>의 역순이다.</p>

<p>이 과정에서 두 가지 주의할 점이 있는데 <code>ReflectionHelper.newInstance()</code>를 수행하는 부분과, <code>ReflectionHelper.setValue()</code>를 수행하는 부분이다.</p>

<p><code>newInstance()</code>를 사용하여 model class의 객체를 만들 때 해당 class에 default constructor가 정의되어있지 않으면 생성할 수가 없다. 때문에 bean class들은 기본 생성자만 정의하고 field를 초기화하는 paramter를 갖는 생성자를 안 만드는 경향이 있다.</p>

<p>그런데 POJO를 사용하다보면 기본 생성자를 놓치는 경우가 있는데, 그럴 경우 reflection을 사용하더라도 호출할 적절한 생성자를 찾기가 힘드므로 생성하기가 좀 곤란해진다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Customer</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Customer</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>
    <span class="cm">/* there is no default constructor! */</span>
<span class="o">}</span>
</code></pre></div>
<p>위와 같은 <code>Customer</code> class는 reflection으로 생성한다고 해도 constructor의 signature가 init (String, int) 형태가 되므로, 인자를 받지 않는 생성자를 호출할 수가 없다. 따라서 이런 구조에서는 원치 않더라도 기본 생성자를 만들어주어야 하고, 정말 원치 않는다면 기본 생성자를 만들고 private이나 default로 선언하게 된다. (private으로 선언하면 안 불린다고 필요없는 코드로 자바 컴파일러가 경고를 낸다.)</p>

<p><code>Class.newInstance()</code> 함수는 기본 생성자가 있고, 해당 생성자가 접근 가능(public)할 때만 사용할 수 있는 함수이다. 따라서 외부에서 접근할 수 없는 private, default, protected로 선언한 기본 생성자가 있다면 문제가 될 수 있다.</p>

<p>이를 고려하여 <code>ReflectionHelper.newInstance()</code> 함수를 작성하면 다음과 같다. (예외 선언 생략)</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">newInstance</span><span class="o">(</span><span class="n">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">clazz</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Constructor</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">defaultConstructor</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getConstructor</span><span class="o">();</span>
    <span class="n">defaultConstructor</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">defaultConstructor</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>
<p>즉, defaultConstructor를 가져오고, 그것에 대한 접근 권한을 주고(<code>setAccessible()</code>) 해당 생성자로 <code>newInstance()</code> 를 호출해야 한다는 것이다.</p>

<p>값을 Field의 type에 맞게 적절히 parsing해서 넣어주는 <code>ReflectionHelper.setValue()</code> 함수는 우아하지 못하다. 그냥 Field의 type을 case by case로 검사해서 값을 직접 넣어주는 방법 밖에 없다.<br>
간단하게 int, String에 대해서만 구현을 해보면 다음과 같다. (예외 선언 생략)</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">setValue</span><span class="o">(</span><span class="n">Object</span> <span class="n">target</span><span class="o">,</span> <span class="n">Field</span> <span class="n">field</span><span class="o">,</span> <span class="n">String</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">fieldType</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="na">getType</span><span class="o">();</span>
    <span class="n">field</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">fieldType</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="kt">int</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">||</span> <span class="n">fieldType</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">Integer</span><span class="o">.</span><span class="na">class</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">field</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">target</span><span class="o">,</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">value</span><span class="o">));</span>

    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">fieldType</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">field</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">target</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>

    <span class="o">}</span> <span class="k">else</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&quot;type doesn&#39;t support!&quot;</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p>field의 type을 가져온다. 그리고 접근 권한을 준 다음에, fieldType에 대해 하나씩 비교하면서 각 type에 맞게 parsing하여 넣어준다. primitive type의 경우 wrapper type도 있어서 처리가 좀 귀찮은데, 위처럼 각 쌍으로 묶어서 처리해주면 좀 낫다. map 같은 것을 써서 type별로 어떻게 처리할지 보다 깔끔하게 등록할 수도 있겠지만, 결국 최종 코드는 거기서 거기인 듯 싶다.</p>

<p>요약하면, field에 대한 type 정보는 reflection을 사용하여 class로부터 가져올 수 있으므로 따로 xml 등에 기록할 필요는 없다는 것이다. 따라서 그 정보를 보고 type에 맞게 값을 적절히 넣어주면 된다.</p>

<p>여기까지해서 간략하게 annotation을 사용하여 xml과 java model을 bind하는 코드를 작성해 보았다.
하고 싶었던 이야기는 코드 자체에 annotation을 사용하여 어떤 수행을 해야하는지에 대한 추가 정보를 metadata로 기록하여 좀 더 유연하고 확장성 있는 프로그래밍을 해볼 수 있다는 것이다.</p>

<ul>
<li>만약 model class에 대해서 xml 뿐만 아니라 SQL에 대해서도 binding을 해야한다면?</li>
<li>SQL의 각 table과 column에 대해 bind하기 위한 annotation을 작성하고,</li>
</ul>

<p>그에 대한 적절한 bind helper class를 작성하면 되겠다.
(이왕 작성하는 김에 xml binder와 sql binder의 interface를 맞춰서 보다 유연한 설계를 해볼 수도 있겠다.)</p>

<ul>
<li>만약 해당 model을 network로 전송하기 위해 적절히 string serialize, deserialize를 해야한다면?</li>
</ul>

<p>역시 이에 대한 metadata 정보를 annotation 등으로 기술하고 적절한 bind helper를 구현하여 사용할 수 있을 것이다. 그리고 이렇게 구현한 bind helper, binding annotation은 추후 다른 application을 개발할 때에도 유용하게 사용할 수 있을 것이다.</p>

<p>annotation, reflection 관련하여 혹시 다른 예제를 보고 싶으면 아래의 링크를 참고하면 된다.</p>

<ul>
<li><a href="%%20post_url%202011-03-02-implementation-instance-id-with-java-annotation%20%%7D">java annotation을 사용한 InstanceId 구현</a></li>
<li><a href="%%20post_url%202011-11-27-java-message-dispatcher%20%%7D">reflection을 사용한 간단한 Message 체계 구현</a></li>
</ul>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">java annotation을 사용한 InstanceId 구현</h1>
				<p class="page-date">02 Mar 2011</p>
				<p class="page-tags">
						
						
					<code class="tag">java</code>
						
						
						
						
				</p>
				<div class="content"><p>Java에서 생성하는 <code>Object</code>마다 InstanceId를 부여하는 방법에 대해 고민해보고 코드를 작성해보자.</p>

<p>Index 발급 Group 관련해서 파일을 하나 작성하여 <code>IndexGeneratingManager</code>를 구성해서 발급해도 되고, 아니면 발급 받는 시점을 적절히 조절하거나 발급 함수의 인자로 Group할 Class 정보를 넣어줘도 되겠다.<br>
하지만 본 글에서는 Java 1.5부터 추가된 <code>Annotation</code>을 사용하여 source code에 metadata를 추가하여 문제를 해결하는 방법을 써 보겠다.</p>

<p>Java의 <code>Annotation</code>은 특정 지점(ElementType: Type, Method, Field, ...)에 특정 시점(Retention: Source, Class, Runtime)까지 유지되는 metadata이다.<br>
<code>@interface keyword</code>로 정의할 수 있고, 지정된 지점에 맞게 class, method, field, parameter 등에 선언될 수 있고, 이는 지정된 시점까지 유지된다.</p>

<p>위 문제를 해결하기 위해 새로 작성하는 <code>IndexCategory</code>라는 annotation은 index를 발급할 <code>category</code> class를 지정한다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kn">import</span> <span class="nn">java.lang.annotation.ElementType</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.annotation.Retention</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.annotation.RetentionPolicy</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.annotation.Target</span><span class="o">;</span>

<span class="nd">@Target</span><span class="o">(</span><span class="n">ElementType</span><span class="o">.</span><span class="na">TYPE</span><span class="o">)</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="n">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="n">IndexCategory</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">category</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>
<p>이 annotation은 <code>Type</code>에 선언될 수 있는데, 여기서 <code>Type</code>은 <code>class</code>를 뜻한다.<br>
또한 Runtime까지 유지되는 정보인데, 그 이유는 객체가 &quot;생성되는 시점&quot;인 runtime에 해당 정보를 통해서 어떤 category의 class type으로 index를 발급받을지 얻어내야하기 때문이다.</p>

<p>annotation은 속성<code>property</code>를 갖는데, <code>IndexCategory</code>는 <code>category()</code>라는 속성을 갖는다. 이는 <code>Class&lt;?&gt;</code>를 값으로 갖는 속성으로 그 이름은 category가 된다.</p>

<p>위와 같은 <code>IndexCategory</code> annotation을 다음과 같이 사용하고자 할 class에 적용한다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Skill</span> <span class="kd">extends</span> <span class="n">Thing</span> <span class="o">{}</span>

<span class="nd">@IndexCategory</span><span class="o">(</span><span class="n">category</span><span class="o">=</span><span class="n">Skill</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">class</span> <span class="nc">Magic</span> <span class="kd">extends</span> <span class="n">Skill</span> <span class="o">{}</span>

<span class="nd">@IndexCategory</span><span class="o">(</span><span class="n">category</span><span class="o">=</span><span class="n">Skill</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">class</span> <span class="nc">Mastery</span> <span class="kd">extends</span> <span class="n">Skill</span> <span class="o">{}</span>
</code></pre></div>
<p><code>Magic</code> class와 <code>Mastery</code> class는 <code>IndexCategory</code>에 의해 어떤 category에 따라 index를 발급받을지 code 상에 명시한다.
분명 이 annotation은 프로그램의 동작에 영향을 주지만, 어떠한 코드로써 그 정보를 제공한다기 보다는 metadata로 그 정보를 제공한다는 점에서 충분히 매력적이다. 어떠한 class의 특성을 명시하기 위해 method나 field, 상속 등의 무거운 방법을 사용하지 않고, 위처럼 <code>annotation</code>을 통해 충분히 정보를 제공할 수 있다.</p>

<p>문법상 annotation을 사용할 때 앞에 @ 을 붙이고 annotation 이름을 쓴다. 그리고 () 안에 <em>속성=값</em>의 형태로 나열하면 되고, 배열의 경우 {}를 통해 묶어주면 된다.</p>

<p>이러한 annotation을 가장 많이 접하는 경우가 <code>Override annotation</code>과 <code>Deprecated annotation</code>, 그리고 <code>SuppressWarnings annotation</code>이다.<br>
간단히 <code>Override annotation</code>만 설명하자면 이는 method에 선언 가능하며 source 시간까지 유지되는 <code>annotation</code>이다. 즉 compiler가 확인하고 버리는 시점까지 유지되는 <code>annotation</code>으로 <code>override</code> 되지 않은 method가 이 <code>annotation</code>을 가지고 있을 경우 compile error를 띄워주는 역할을 하여 compile time에 잘못된 override를 사전에 보고하는 역할을 한다.</p>

<p>위와 같이 <code>IndexCategory</code> annotation을 명시한 뒤, 객체를 생성하여 index를 발급하는 코드에서는 이를 반영하여 index를 해주면 된다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">generateNextIndex</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">String</span> <span class="n">callerClassName</span> <span class="o">=</span> <span class="n">findCallerClassName</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">callerClass</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="n">callerClassName</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">callerClass</span><span class="o">.</span><span class="na">isAnnotationPresent</span><span class="o">(</span><span class="n">IndexCategory</span><span class="o">.</span><span class="na">class</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">IndexCategory</span> <span class="n">category</span> <span class="o">=</span> <span class="n">callerClass</span><span class="o">.</span><span class="na">getAnnotation</span><span class="o">(</span><span class="n">IndexCategory</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
            <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">categoryClass</span> <span class="o">=</span> <span class="n">category</span><span class="o">.</span><span class="na">category</span><span class="o">();</span>
            <span class="k">return</span> <span class="nf">generateNextIndex</span><span class="o">(</span><span class="n">categoryClass</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nf">generateNextIndex</span><span class="o">(</span><span class="n">callerClass</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="nf">generateNextIndex</span><span class="o">(</span><span class="n">callerClassName</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p><code>callerClassName</code>을 가져와서 그로부터 Class 정보를 가져온 뒤, 그 Class가 <code>IndexCategory</code> annotation이 존재<code>present</code>할 경우 해당 annotation에 명시된 category로부터 category class 정보를 가져와서 그 class로 index를 발급하겠다는 코드이다.</p>

<p>즉, 반드시 <code>IndexCategory</code>를 통해 index grouping을 수행하겠다는 것이 아니라 <code>IndexCategory</code> annotation이 present된 경우에만 해당 class로 index를 발급받는 것이므로, annotation이 선언되지 않은 경우까지 완벽히 처리하게 됩니다.</p>

<p>물론 <code>callerClassName</code>에서 잘못된 class 이름을 얻을 경우에 대비해서 예외처리 코드를 추가했지만 이는 <code>Class#forName</code> 함수가 반드시 예외를 처리하게 하는(명시적 예외처리) 구조이므로 try-catch 문을 작성한 것이지 위 경우에서는 예외가 발생할 가능성이 없다.</p>

<p>본 문서에서는 <a href="http://en.wikipedia.org/wiki/Annotation#Java_annotations">Java Annotation</a>의 문법에 대해 설명하는 것이 취지가 아니므로, 이 정도로 글을 마친다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">Java Graphics와 AffineTransform, 그리고 JScrollPane</h1>
				<p class="page-date">04 Jan 2009</p>
				<p class="page-tags">
						
						
					<code class="tag">java</code>
						
						
						
						
				</p>
				<div class="content"><p>예전에 디비랩 알바를 할 때, 어떤 이미지에 대해 확대, 축소, 이동을 해야할 일이 생겼다.
<code>MouseEvent</code> 처리 시 좌표 계산 등, 몇 가지 계산을 해서 Image를 확대, 축소, 이동해서 볼 수 있도록 하였다.</p>

<p><code>Applepie(YPE2)</code>를 만들 때 역시 이미지에 대해 확대, 축소, 이동을 할 일이 있었는데 이 때는 이미지가 하나가 아니라, 여러 이미지를 그려야하는 상황이었다.<br>
각각에 대해 동일한 비율로 확대, 축소, 이동을 도무지 못 해서 결국 이미지를 <code>BufferedImage</code>에 다 그려놓고, 그걸 화면에 확대해서 그리는 방식으로 했었다.
덕분에 메모리가 더 많이 사용되었고, 더 느렸다.</p>

<p>EventHandling은 역시 별도로 계산해주어야 했다.</p>

<h3>AffineTransform</h3>

<p>Game Programming 시간에 <code>AffineTransform</code>을 배웠다.
전에 Gepard를 만들 때 동아리 선배 한 분이 이를 써서 지형을 그려주셨는데, 그 때만 해도 이게 무슨 역할을 하는지 몰랐었다.
이번에, 또, 확대, 축소, 이동을 하는 부분을 짜야하는데 이번에는 여러 이미지 뿐만 아니라 그 위에 여러 shape도 그려야 했고, 현재 편집모드에 따라 다른 것들이 그려야 했다.</p>

<p>이걸 어찌해야하나 고민을 했는데 <code>AffineTransform</code>을 쓰니까 한번에 끝난다 [...]</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="n">AffineTransform</span> <span class="n">oldTransform</span> <span class="o">=</span> <span class="n">g2d</span><span class="o">.</span><span class="na">getTransform</span><span class="o">();</span>
<span class="n">AffineTransform</span> <span class="n">newTransform</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AffineTransform</span><span class="o">(</span><span class="n">oldTransform</span><span class="o">);</span>
<span class="n">newTransform</span><span class="o">.</span><span class="na">scale</span><span class="o">(</span><span class="n">factor</span><span class="o">,</span> <span class="n">factor</span><span class="o">);</span>
<span class="n">newTransform</span><span class="o">.</span><span class="na">translate</span><span class="o">(-</span><span class="n">viewport</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="o">-</span><span class="n">viewport</span><span class="o">.</span><span class="na">y</span><span class="o">);</span>
</code></pre></div>
<p>scale와 translate를 해서 Graphics에 지정해주고 그냥 전체를 화면에 다 그리게 하면, 지정된 viewport 영역에 대해 scale되어 나오게 된다.<br>
물론 EventHandling은 자체 계산해야 한다 [...]</p>

<h3>clipping</h3>

<p>clipping을 하기 위해 viewport 영역으로 clipping을 해주면 되겠구나라는 생각을 했다.
그래서 <code>JScrollPane</code>으로 감싸고, 그 안에 <code>Graphics</code>를 수행하는 <code>Panel</code> 객체를 넣어서 Clipping을 했는데, <code>JScrollPane</code>의 ScrollBar가 안 그려지는 것이었다.</p>

<p>찾아보니까,<br>
<code>JScrollPane</code>는 자신이 현재 보여주고 있는 viewport만을 그리기 위해 이미 자기가 알아서 clipping을 수행한다는 것.<br>
그래서 <code>JScrollPane</code>의 viewport보다 작은 영역을 clipping하는 것은 상관 없지만, 더 큰 영역을 clipping하면 오히려 <code>JScrollPane</code>이 망가지게 된다는 것이다. JScrollPane 쓴 덕분에 Clipping까지 그냥 끝</p>

<h3>JScrollPane</h3>

<p><code>JScrollPane</code> 안에 들어있는 JPanel 등의 객체들은 아무리 내가 원하는 크기를 <code>PreferredSize</code>로 지정을 해도 viewport의 크기게 맞게 맞춰져버리는 성질이 있다. (이게 바로 clipping 효과 때문이 아닐까 하는데, 그리는건 둘째치고 Event 영역 한정지어줘야 하는게 귀찮다.)</p>

<p>그래서 쓰는 방법이,</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">final</span> <span class="n">JPanel</span> <span class="n">container</span> <span class="o">=</span> <span class="k">new</span> <span class="n">JPanel</span><span class="o">(</span><span class="k">new</span> <span class="n">GridBagLayout</span><span class="o">());</span>
<span class="kd">final</span> <span class="n">JScrollPane</span> <span class="n">scrollPane</span> <span class="o">=</span> <span class="k">new</span> <span class="n">JScrollPane</span><span class="o">(</span><span class="n">container</span><span class="o">);</span>
<span class="k">this</span><span class="o">.</span><span class="na">setPreferredSize</span><span class="o">(</span><span class="k">new</span> <span class="n">Dimension</span><span class="o">(</span><span class="mi">600</span><span class="o">,</span> <span class="mi">480</span><span class="o">));</span>
<span class="n">container</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</code></pre></div>
<p>바로 이것이다. (물론 다른 Container에 이 덩어리를 추가할 때는 scrollPane 객체로 추가해줘야 한다. 그래야 scroll 생긴다.)
<code>Graphics</code>를 수행하는 Component가 this일 때, 자신의 크기를 <code>setPrefferedSize</code>로 정하고, 자기를 바로 <code>JScrollPane</code>에 추가하는 것이 아니라 중간에 container 객체를 하나 두는데, 이 container의 <code>LayoutManager</code>로 <code>GridBagLayout</code>을 사용하는 것이다.
그러면 this는 container 객체의 가운데에 위치하게 되고, container가 this의 크기보다 작아지면 <code>JScrollPane</code>에 의해 ScrollBar가 생기게 된다.</p>

<p>물론 this의 <code>PreferredSize</code>를 변경해준 뒤에는 revalidate를 호출해서 <code>JScrollPane</code>이 크기가 변경되었음을 감지할 수 있도록 해주어야 한다.</p>

<h3>정리</h3>

<p>Viewport와 Magnification을 이용한 Graphics, 그리고 JScrollPane을 통한 Scrolling을 수행하려면 <code>AffineTransform</code>과 <code>GridBagLayout</code> container를 이용하는 것이 좋다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">Java ObjectStream의 Input/Ouput Blocking이야기</h1>
				<p class="page-date">29 Apr 2010</p>
				<p class="page-tags">
						
						
					<code class="tag">java</code>
						
						
						
						
				</p>
				<div class="content"><p>Java의 <code>ObjectInputStream</code> / <code>ObjectOutputStream</code>을 사용하여 데이터 통신을 할 때 Client와 Server 양측에서 <code>ObjectInputStream</code>을 먼저 생성하면 프로그램이 더이상 진행되지 않는 경우가 있는데, 그 이유는 다음과 같다.</p>

<p><code>ObjectInputStream</code>의 ctor 코드를 보면 아래와 같이 <code>readStreamHeader();</code> 함수를 호출한다.  </p>
<div class="highlight"><pre><code class="java language-java" data-lang="java">    <span class="kd">public</span> <span class="nf">ObjectInputStream</span><span class="o">(</span><span class="n">InputStream</span> <span class="n">in</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="n">verifySubclass</span><span class="o">();</span>
        <span class="n">bin</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BlockDataInputStream</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
        <span class="n">handles</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HandleTable</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
        <span class="n">vlist</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ValidationList</span><span class="o">();</span>
        <span class="n">enableOverride</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="n">readStreamHeader</span><span class="o">();</span>
        <span class="n">bin</span><span class="o">.</span><span class="na">setBlockDataMode</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre></div>
<p><code>readStreamHeader()</code> 함수는 아래와 같다. 이는 bin이라는 멤버 변수를 사용하여 short값 2개를 읽는다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java">    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">readStreamHeader</span><span class="o">()</span>
        <span class="kd">throws</span> <span class="n">IOException</span><span class="o">,</span> <span class="n">StreamCorruptedException</span>
    <span class="o">{</span>
        <span class="kt">short</span> <span class="n">s0</span> <span class="o">=</span> <span class="n">bin</span><span class="o">.</span><span class="na">readShort</span><span class="o">();</span>
        <span class="kt">short</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">bin</span><span class="o">.</span><span class="na">readShort</span><span class="o">();</span>
</code></pre></div>
<p>그런데 bin이라는 녀석은 <code>BlockDataInputStream</code>이다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java">    <span class="cm">/** filter stream for handling block data conversion */</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">BlockDataInputStream</span> <span class="n">bin</span><span class="o">;</span>
</code></pre></div>
<p>이 때문에 양측에서 먼저 InputStream을 생성하면 둘다 short 값 2개를 서로 기다리다가 프로그램이 진행이 안되는 것.</p>

<p>이것을 해결하기 위해서 ObjectOutputStream을 먼저 생성하는데, 그 이유는 이와 같다.</p>

<p><code>ObjectOutputStream</code>의 ctor를 보면, <code>writeStreamHeader();</code> 를 호출한다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java">    <span class="kd">public</span> <span class="nf">ObjectOutputStream</span><span class="o">(</span><span class="n">OutputStream</span> <span class="n">out</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="n">verifySubclass</span><span class="o">();</span>
        <span class="n">bout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BlockDataOutputStream</span><span class="o">(</span><span class="n">out</span><span class="o">);</span>
        <span class="n">handles</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HandleTable</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span> <span class="mf">3.00</span><span class="o">);</span>
        <span class="n">subs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReplaceTable</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span> <span class="mf">3.00</span><span class="o">);</span>
        <span class="n">enableOverride</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="n">writeStreamHeader</span><span class="o">();</span>
        <span class="n">bout</span><span class="o">.</span><span class="na">setBlockDataMode</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">extendedDebugInfo</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">debugInfoStack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DebugTraceInfoStack</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">debugInfoStack</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>   
    <span class="o">}</span>
</code></pre></div>
<p><code>writeStreamHeader();</code> 함수에서는 short값 2개를 <code>write</code>한다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java">    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">writeStreamHeader</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="n">bout</span><span class="o">.</span><span class="na">writeShort</span><span class="o">(</span><span class="n">STREAM_MAGIC</span><span class="o">);</span>
        <span class="n">bout</span><span class="o">.</span><span class="na">writeShort</span><span class="o">(</span><span class="n">STREAM_VERSION</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre></div>
<p>이것이 바로 <code>ObjectInputStream</code>에서 기다리고 있는 <code>MAGIC_NUMBER</code>였던 것이다.</p>

<p>이와 같은 작용으로 인해 ObjectStream은 서로 Object를 주고받을 준비가 되었는지(양쪽다 ObjectStream인지) 확인하고 데이터를 주고 받을 수 있는 것이다.</p>

<h3>결론</h3>

<ul>
<li>ObjectInputStream을 양쪽에서 먼저 생성하면 blocking,</li>
<li>따라서 ObjectOutputStream을 먼저 생성해줘야 stream에 값을 write 후, InputStream에서 읽을 수 있으므로 제대로 돌아간다.</li>
</ul>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">java remotelib 개발</h1>
				<p class="page-date">17 Feb 2010</p>
				<p class="page-tags">
						
						
					<code class="tag">java</code>
						
						
						
					<code class="tag">rpc</code>
						
						
						
						
				</p>
				<div class="content"><p>심심한 상황에서 뭘 코딩할까 고민중에 java rmi app를 만들다가 고생한 기억이 있어서 이걸 좀 쉽게 사용할 수 있는 remote lib를 만들어보자는 생각에 시작하였다.</p>

<h3>개발 목표</h3>

<ol>
<li>기존의 java rmi와 유사한 code로 remote method interface call을 구현할 수 있어야하고,</li>
<li>쌍방통신이 쉽게 가능했으면 한다.<br>
※ rmi는 보안상의 이유로 단방향을 기본적으로 지원하는데, 보통 클라이언트에서 서버의 함수를 호출하는 방식이다.<br>
서버에서 클라이언트의 함수를 호출하려면 약간 설정해줘야하는게 더 있고, 실행하기가 귀찮아진다-_-</li>
<li>또한 기본 socket을 이용하여 방화벽 혹은 가상ip로 인한 rmi binding 문제가 안 일어났으면 좋겠고,</li>
<li>가능하다면 socket proxy를 사용해서 뭐가 날라가는지도 가려보고 싶고</li>
<li>80 port를 이용, http message로 둔갑하여 netcare같이 packet 내용까지 보는 녀석에게도 안 걸렸으면 좋겠고,</li>
<li>c, c++ 등의 다른 언어와도 통신이 가능했으면 좋겠다.</li>
<li>server는 효율적이고 scalable하면 좋겠다.</li>
</ol>

<h3>구현</h3>

<h4>기본 골격, object-portage</h4>

<ol>
<li>기본 java socket를 이용하여 서버와 클라이언트 간의 data 통신이 가능한 socket을 얻는다.</li>
<li>이 socket의 stream에 objectstream을 끼워 쌍방에서 object를 주고 받을 수 있도록 한다.</li>
<li>서버와 클라이언트가 object를 주고 받는다.</li>
<li>이 때 각 socket에 대하여</li>
</ol>

<h4>요청/분기/반환, request/response dispatcher</h4>

<ol>
<li>서버와 클라이언트가 주고 받는 메시지 객체(object)를 class화 하여 주고 받는다.</li>
<li>보내는 쪽(sender)는 상대방(receiver)에게 메시지(message)를 보내고(request) 답변(response)이 올 때까지 기다린다(wait)</li>
<li>받는 쪽(receiver)는 상대방(sender)이 보낸(request) 메시지(message)를 적절한 함수가 처리(process)하게 한 뒤, 그 결과를 상대방에게 보낸다(send, response)</li>
<li>기다리고 있던 보낸 쪽(sender)의 receiving thread는 아까 요청한 메시지에 대한 답변(response)를 받으면, wait하고 있던 send thread에 notify를 해서 lock을 풀어준다. 그리고 받은 response message를 반환받게 한다.</li>
</ol>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="c1">// send part (pseudo)</span>
<span class="n">stream</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
<span class="n">lock</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
<span class="k">return</span> <span class="n">responseMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">message</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>

<span class="c1">// receive part (pseudo)</span>
<span class="n">message</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="na">receive</span><span class="o">();</span>
<span class="n">responseMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">message</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span> <span class="n">message</span><span class="o">);</span>
<span class="n">responseLock</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">message</span><span class="o">.</span><span class="na">getId</span><span class="o">()).</span><span class="na">notify</span><span class="o">();</span>
</code></pre></div>
<h4>함수 호출 메시지, function call message</h4>

<ol>
<li>함수 호출을 위한 정보(함수 이름, 함수 인자 타입parameters&#39; type, 함수 인자arguments)를 담는 call message class 작성</li>
<li>함수 반환 값 전달 위한 return message class 작성</li>
<li>수행 도중 예외 담을 exception message class 작성</li>
</ol>

<h4>원격객체 연결/호출, binding and call remote-object</h4>

<ol>
<li>제공할 함수에 대한 interface class 작성</li>
<li>제공할 곳(server) 해당 interface를 구현하는 원격객체 작성, 이름(bindname) 부여, map에 등록(여러 원격객체 연결binding 가능)</li>
<li>호출할 곳(client) 해당 interface에 대한 proxy instance 생성, method가 실행될 때 지정된 bindname과 호출한 method 정보를 call message(2-3)로 만들어서 server로 전달</li>
<li>call message를 받은 server는 bindname으로 binding된 remote-object를 가져와서 reflection으로 해당 method을 invoke함</li>
<li>그 결과값을 return message에 담아 client에게 전송</li>
<li>client에서는 호출한 call message에 대한 return message가 올 때까지 대기(wait, 2-2)</li>
</ol>

<h4>호출 간 xml message 사용</h4>

<ol>
<li>기존의 방법은 java의 objectstream을 사용하였기 때문에 c, c++ 등과 통신 불가능. 따라서 <code>javax.beans.XMLEncoder</code>/<code>XMLDecoder</code>을 사용</li>
</ol>

<h4>http message로 위장</h4>

<ol>
<li><code>HTTP Header</code>를 붙임.</li>
<li>받는 쪽에서 위와 같은 메시지를 받아서 header는 무시하고 body의 xml을 이용, remote message로 사용</li>
<li>하지만 <code>XMLEncoder</code>/<code>XMLDecoder</code>는 serializable할 class의 기본생성자가 필수여야하고, 딱히 그에 대응되는 다른 언어(c or c++) library가 안 보여서 그냥 <code>XMLEncoder</code>, <code>XMLDecoder</code>를 만드는게 낫지 않을까 고민중(recursive한 object에 대한 serializing 문제를 해결 못함)</li>
</ol>
<div class="highlight"><pre><code class="http language-http" data-lang="http"><span class="nf">POST</span> <span class="nn">remote</span> <span class="kr">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Content-Type</span><span class="o">:</span> <span class="l">xml</span>
<span class="na">Content-Length</span><span class="o">:</span> <span class="l">1123</span>

&lt;?xml...
</code></pre></div>
<h4>http message compaction</h4>

<ol>
<li>ZipStream을 이용, http body message 부분의 data를 plain/text가 아닌 zip data로 보냄. data 전송량을 줄일 수 있음</li>
</ol>

<h4>타언어와의 통신</h4>

<ol>
<li>c 계열의 통신을 가정했을 경우, 먼저 code generator를 통해 주고받을 argument들의 대응 객체 생성. 즉 java에서 작성한 bean에 대응되는 c의 구조체를 작성해야함.</li>
<li>c 계열의 xml-decoder에서 해당 구조체에 값을 올바른 순서로 넣기 위한 RTTI에 버금가는 정보/순서를 구현해야함</li>
<li>String, List 등 java에서 제공하는 기초 api를 c/c++로 converting하는 library 제작</li>
<li>한글 등 unicode/multibyte 문자를 적절히 변환해주는 charset library 제작-_-(힘들다)</li>
</ol>

<h4>고가용서버</h4>

<ol>
<li>SelectableChannel과 Selector을 이용, server단 thread 개수 감소를 통한 프로그램 효율 증가</li>
<li>ByteBuffer 등 nio를 이용한 stream 성능 향상</li>
<li>ByteBufferPool, ThreadPool을 이용한 객체 재사용</li>
</ol>

<h3>현재 상황</h3>

<p>일단 object-stream을 이용한 remote lib 구현 완료, 주석까지 달아서 지금 올리는 중.<br>
성능 개선이 절실히 필요한데, 일단 오늘은 시간이 없으니 여기까지만-_-</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">Java Swing을 한다면 1</h1>
				<p class="page-date">03 Jan 2009</p>
				<p class="page-tags">
						
						
					<code class="tag">java</code>
						
						
						
						
				</p>
				<div class="content"><p>Java Swing에 대해 어떻게 GUI를 배워나가는 지에 대한 이야기를 해보고 싶었다.<br>
물론 어느 순서가 바른 순서인지는 나도 모르고, 단지 내가 해온 순서는 이렇다는 이야기를 해보고 싶어서 글을 쓴다.</p>

<h3>Basic GUI</h3>

<p>Java Basic GUI는</p>

<ul>
<li>창을 띄우고</li>
<li>Button을 띄우고,</li>
<li>Text를 입력받는 등의</li>
</ul>

<p>간단한 UI 코딩이다.</p>

<ul>
<li>Model, Editor, Renderer의 개념을 몰라도 괜찮고,</li>
<li>NetBeans 같은 도구를 이용하여 보다 쉽게 GUI를 그려나갈 수 있고,</li>
<li>그에 대한 Event Handling으로 간단한 GUI Application을 만들어 나가는 단계이다.</li>
</ul>

<h3>with LayoutManager</h3>

<p>Java Basic GUI with <code>LayoutManager</code>는 사실 단계가 어느 지점이 적합할지는 잘 모르겠는데,
이정도가 적당할 것이라고 생각해서 여기 써본다.</p>

<p>Java는 <strong>유동적인 Layout</strong>을 위해 <code>LayoutManager</code>라는 재미난 개념을 도입했다. 이는 말 그대로 <code>Component</code>들을 배치시켜주는 것이다.</p>

<ul>
<li><code>GridLayout</code>은 Grid 형식으로 <code>JComponent</code>를 배치시켜주고,</li>
<li><code>FlowLayout</code>은 줄줄이 Component가 나오게 해주는 식이다.</li>
</ul>

<p><code>Container</code>에 <code>Component</code>를 추가해놓고, <code>LayoutManager</code>만 바꿈으로써 <code>Component</code>의 배치가 달라지게 되는 것이다.</p>

<p>이는 종래 UI 제작의 모든 <code>Component</code>의 Bound[x, y, width, height]를 지정하던 방식인 <code>NullLayout</code>에 비해 상당히 유동적인 UI 구성이 가능하게 했으며,
무엇보다도 UI를 그리는 도구 없이도 간단한 UI를 만들 수 있을 뿐더러 합으로 복잡한 UI 구성도 가능하게 해주었다.</p>

<p>NetBeans의 <code>GroupLayout</code>의 등장으로 ui designer로 FreeDesign이 가능해졌고, 그 기능으로 많이 개발하는 것도 같다. 하지만 <code>GroupLayout</code>는 도구가 생성하는 코드라서 굉장히 코드가 복잡해진다는 단점이 있다.</p>

<p><code>LayoutManager</code>를 구현하여 자신이 만든 <code>LayoutManager</code>로 Component의 배치를 직접 제어해보는 것도 상당한 도움이 된다. 물론, 빠르게 구현해야 할 때에는 NetBeans로 Design해서 Design 코드를 복사해서 Eclipse로 편집하기는 하지만, 간단한 UI를 설계하거나 배치에 모종의 규칙을 갖는 UI 설계의 경우 기존에 존재하는 Layout 조합만큼 좋은 것은 없다.</p>

<p>특히 Mustang(Java6)의 <code>SpringLayout</code>은 뭔가 재밌어보인다. 하지만 아직 깊에 안 봐서 잘 모르겠다.</p>

<h3>with Advanced Event Handler</h3>

<p>Java는 굉장히 많은 <code>EventHandler</code>를 지원한다.</p>

<p>Event Handling을 한다는 것은 해당 <code>Component</code>에서 발생한 Event에 대해 어떤 일을 수행할 것인지에 대해 코드를 작성하는 것이다.</p>

<ul>
<li>Handler는 Event를 처리하기 위해 기술된 코드 집합, 즉 함수이고,</li>
<li>보통 <code>{EventName}Listener</code>라는 이름 구조를 갖는다.</li>
<li>어떤 Event에 대해서 그 Event를 기다리는 자(<code>Listener</code>)라는 의미로 대부분 Event를 처리하기 위한 함수 원형이 기술된 <code>interface</code>이다.</li>
</ul>

<p>즉, 이걸 구현하면 함수 객체가 되는 것이고, 이것을 해당 Component의 EventHandler로 등록해주는 것이다.</p>

<p>보통 쉽게 접하는 것은 <code>ActionListener</code>, <code>KeyListener</code>, <code>MouseListener</code>, <code>FocusEvent</code> 정도 인데, 이것들 이외에도 <code>ComponentEvent</code>나 <code>HierarchyEvent</code>, <code>AncestorEvent</code>, <code>ContainerEvent</code>, <code>PropertyChangeEvent</code> 등이 있다.</p>

<ul>
<li><code>ComponentEvent</code>는 해당 Component가 나타났나, 사라졌나에 대한 Event 등을 포함하고 있고,</li>
<li><code>ContainerEvent</code>는 자신에게 어떤 다른 <code>JComponent</code>가 추가됬나, 제거됬나 등에 대한 Event가 포함되어있고,</li>
<li><code>AncestorEvent</code>와 <code>HierarchyEvent</code>는 부모 쪽에서 모종의 변경이 일어났을 때에 대한 Event가 포함되어있다.</li>
</ul>

<p>위의 것들은 그냥 그러려니 하면서, 실제로 쓸 일이 없어서 잘 안 쓰는 그런 종류일 수 있다. 하지만 <code>PropertyChangeEvent</code>는 쓸만한, 그리고 재미있는 event이다.</p>

<p><code>Property</code>는 Component의 상태를 표현하기 위해 필요한 정보들로, <code>Visible</code>, <code>Enable</code> 등이 있다. NetBeans에서는 아예 Property라고 해서 Table로 이를 편집할 수 있게 해준다.</p>

<p>보통 <code>set{PropertyName}</code>으로 설정하고, <code>[get|is]{PropertyName}</code>로 가져온다. 즉, 속성을 멤버 변수로 두고, getter/setter로 접근하도록 한다는 것이다. (VB나 C#에서는 Property라는 좀 더 재미난 개념을 제공하지만 별로 OO스럽지 않아서 Java는 지원 안하나 보다. 하지만 개인적 취향은 PHP의 getter가 좋다.)</p>

<p>그럼 이 <code>PropertyChangeEvent</code>를 Listening하면 해당 Component의 속성 변화를 알 수 있다는 것인데, 기껏해야 Visible, Enable 등의 변화를 알 수 있다는 것일까?</p>

<p>Java 진영에서는 <code>JComponent(javax.swing.JComponent)</code> 간의 데이터 교환을 위해서 <code>javax.accessibility.AccessibleContext</code>를 제공하고, 이것은 각 <code>JComponent</code>의 <code>getAccessibleContext()</code> 함수를 통해 얻어올 수 있다.<br>
Java Swing에는 수많은 <code>JComponent</code>가 존재하고, 각 <code>JComponent</code>마다 관리하는 저마다의 값(Model)이 있다.</p>

<ul>
<li><code>JTextField</code>이면 String type의 text를 관리할 것이고,</li>
<li><code>JSlider</code>이면 int 값의 value를 관리할 것이다.</li>
</ul>

<p>이러한 정보들이 각 <code>JComponent</code>마다 천차만별이고 <strong>(심지어 Tree나 Table은 어찌할 것인가!)</strong> 이쯤 되니까 각각의 reference로 접근해서 해당 데이터를 접근하는 것은 쉬워도, 이들을 공통적으로 접근하기는 애매해진 것이다. <del>(사실 나는 그래서 모 코드에서 instanceof 로 모든 <code>JComponent</code> 객체의 type로 분기해서 처리해주는 굉장한 것도 봤다.)</del></p>

<p>그래서 각 <code>JComponent</code>마다 자신의 <code>Context</code>를 반환할 수 있는데, 그 중에서 <code>Accessible</code>한 것들, 즉 관리하는 값(Model)에 대한 접근을 class로 묶어서 객체를 반환하도록 한 것이다.
이 객체로 데이터만 접근할 수 있는 것이라면 재미가 없다. 재밌는 것은 이 Context의 값이 변화하면 여기서도 <code>PropertyChangeEvent</code>가 발생한다는 것이다.</p>

<p>즉, 이 Context 객체에 <code>PropertyChangeListener</code>를 걸면 해당 Component의 값(Model)의 변화를 감지할 수 있고, 이것은 <strong>두 Component의 Data Binding을 쉽게 해줄 수 있는 요소</strong>가 된다.</p>

<ul>
<li>예를 들어 <code>JSlider</code> 객체의 <code>AccessibleContext</code>를 가져와서 해당 <code>ProperyChangeEvent</code>를 Listening을 하여 <code>JTextField</code> 객체의 값으로 <code>setText()</code> 함수를 통해 지정해줄 수 있다는 것이다.</li>
</ul>

<p>물론 그냥 <code>JSlider</code>의 <code>ChangeListener</code>를 걸어서 처리할 수도 있지만, 요는 추상화를 통한 다형성, 즉 모든 <code>JComponent</code>에 대해 동일한 방법을 제공한다는 것이다. (어떤 것은 <code>ActionListener</code>, 어떤 것은 <code>ItemListener</code>, 어떤 것은 <code>ChangeListener</code>, 등등이라면 각각 <code>JComponent</code>에 대해서 할 경우에는 모두 다른 Listener를 걸어주어 객체간의 Data Binding을 위한 Event 구독 관계가 복잡하게 꼬일 것이다.)</p>

<p>정리하면 다음과 같다.</p>

<ul>
<li>각 <code>JComponent</code>는 자신의 데이터를 접근할 수 있는 Context class를 모든 <code>Component</code>에 대해 추상화해놓은 <code>AccessibleContext</code>를 구현하여 반환할 수 있고,</li>
<li>이 객체의 <code>PropertyChangeEvent</code>를 Listener하면 Data Binding을 수행할 수 있다.</li>
</ul>

<p>요즘 같이 데이터가 많아진 시대에 데이터 중심의 코딩이 예전보다 중요해졌다. 고로 Data Binding 기술에 대한 이야기가 여기저기서 많이 나오고 있는데(너무 나와서 이제는 안 나오나;) Java에서는 이를 구현하기 위해 이와 같은 방법을 이용할 수도 있다는 것이다.</p>

<h3>마무리</h3>

<p>쓰다보니 뭔가 재밌어져서 이것저것 쓰다보니 당초에 쓰고 싶었던 D&amp;D나 Dockable이 아래로 내려가 버렸다.<br>
그리고 의외로 <code>AccessibleContext</code>에 대해서 열변을 토해버렸는데, 그만큼 저 쪽에는 재밌는게 많다는 것이다.</p>

<p>지난 번에 잠깐 Qt를 보면서 <code>SIGNAL</code>과 <code>SLOT</code>, <code>emit</code> 등의 개념을 보면서 참 재밌게도 연결하는구나 싶었는데, <code>AccessibleContext</code>도 나름 그런 방식으로 각자 다른 Data에 대해 객체로 추상화하고, 동일하게 접근할 수 있는 <code>interface</code>를 제공해준다는 점에서 재밌다는 것이다. 물론 내공이 더 쌓이면 더 재미난 짓을 할 수 있겠지만 말이다.</p>

<p>혼자 예제도 만들고 하면서 하다보니 시간이 너무 걸려서, 일단 쓰는 걸 멈춘다.</p>

<p>추후 이어서 올릴 예정.<br>
아래는 목차</p>

<ul>
<li>Java GUI with Model, Editor, Renderer</li>
<li>Java Graphics</li>
<li>Drag and Drop, Dockable or Floatable</li>
<li>Java GUI with Reflection</li>
<li>Look and Feel</li>
</ul>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">Java에서 LayoutManager로 인해 width가 뜻대로 안될 때</h1>
				<p class="page-date">15 May 2011</p>
				<p class="page-tags">
						
						
					<code class="tag">java</code>
						
						
						
						
				</p>
				<div class="content"><p>Java의 <code>LayoutManager</code>는 유연한 component 배치를 위해 parent component의 width에 딱 맞춰서 자식 control을 배치해주는 작업을 수행한다. 그러다보니 자식의 가로 길이를 고정으로 하고 싶은 경우에도 그 크기가 변경되어서 문제가 생기는 경우가 있다.</p>

<p>여러 개의 출력 Pane이 하나의 Container Pane 안에 들어갈 때, Container Pane은 ScrollPane 내에 있어서 여러 개가 들어갈 경우 scrolling이 가능하도록 해보자.</p>

<p>이 때 한 개의 출력 Pane만 들어가게 될 경우에는 지정된 창의 크기가 출력 Pane의 크기보다 커서, <code>GridLayout</code> 같은 <code>LayoutManager</code>를 쓸 경우 그 출력 Pane의 가로 길이가 ContainerPane의 가로 길이와 같아지는 문제가 발생한다. 즉, Layout이 늘어나버린다.</p>

<p>이를 해결하기 위한 가장 간단한 방법은 <code>LayoutManager</code>를 새로 만드는 것이다.
GridLayout을 상속받은 <code>CustomLayout</code>을 하나 만들고, layoutContainer method를 override해서 control의 boundary를 지정하는 곳에서 width 값을 고정으로 지정해버리면 해당 문제를 막을 수 있다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">layoutContainer</span><span class="o">(</span><span class="n">Container</span> <span class="n">parent</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">synchronized</span> <span class="o">(</span><span class="n">parent</span><span class="o">.</span><span class="na">getTreeLock</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">Insets</span> <span class="n">insets</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="na">getInsets</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">ncomponents</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="na">getComponentCount</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="na">getWidth</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="na">getHeight</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">nrows</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">ncols</span> <span class="o">=</span> <span class="n">paneCount</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">hgap</span> <span class="o">=</span> <span class="n">getHgap</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">vgap</span> <span class="o">=</span> <span class="n">getVgap</span><span class="o">();</span>
        <span class="kt">boolean</span> <span class="n">ltr</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="na">getComponentOrientation</span><span class="o">().</span><span class="na">isLeftToRight</span><span class="o">();</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">ncomponents</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nrows</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ncols</span> <span class="o">=</span> <span class="o">(</span><span class="n">ncomponents</span> <span class="o">+</span> <span class="n">nrows</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="n">nrows</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">nrows</span> <span class="o">=</span> <span class="o">(</span><span class="n">ncomponents</span> <span class="o">+</span> <span class="n">ncols</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="n">ncols</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">DEFAULT_OUTPUT_WIDTH</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">height</span> <span class="o">-</span> <span class="o">(</span><span class="n">insets</span><span class="o">.</span><span class="na">top</span> <span class="o">+</span> <span class="n">insets</span><span class="o">.</span><span class="na">bottom</span><span class="o">);</span>
        <span class="n">h</span> <span class="o">=</span> <span class="o">(</span><span class="n">h</span> <span class="o">-</span> <span class="o">(</span><span class="n">nrows</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">*</span> <span class="n">vgap</span><span class="o">)</span> <span class="o">/</span> <span class="n">nrows</span><span class="o">;</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">ltr</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">insets</span><span class="o">.</span><span class="na">left</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">ncols</span><span class="o">;</span> <span class="n">c</span><span class="o">++,</span> <span class="n">x</span> <span class="o">+=</span> <span class="n">w</span> <span class="o">+</span> <span class="n">hgap</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">insets</span><span class="o">.</span><span class="na">top</span><span class="o">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">nrows</span><span class="o">;</span> <span class="n">r</span><span class="o">++,</span> <span class="n">y</span> <span class="o">+=</span> <span class="n">h</span>
                        <span class="o">+</span> <span class="n">vgap</span><span class="o">)</span> <span class="o">{</span>
                    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">ncols</span> <span class="o">+</span> <span class="n">c</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">ncomponents</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">parent</span><span class="o">.</span><span class="na">getComponent</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">setBounds</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">w</span><span class="o">,</span> <span class="n">h</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">width</span> <span class="o">-</span> <span class="n">insets</span><span class="o">.</span><span class="na">right</span> <span class="o">-</span> <span class="n">w</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">ncols</span><span class="o">;</span> <span class="n">c</span><span class="o">++,</span> <span class="n">x</span> <span class="o">-=</span> <span class="n">w</span>
                    <span class="o">+</span> <span class="n">hgap</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">insets</span><span class="o">.</span><span class="na">top</span><span class="o">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">nrows</span><span class="o">;</span> <span class="n">r</span><span class="o">++,</span> <span class="n">y</span> <span class="o">+=</span> <span class="n">h</span>
                        <span class="o">+</span> <span class="n">vgap</span><span class="o">)</span> <span class="o">{</span>
                    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">ncols</span> <span class="o">+</span> <span class="n">c</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">ncomponents</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">parent</span><span class="o">.</span><span class="na">getComponent</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">setBounds</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">w</span><span class="o">,</span> <span class="n">h</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>component 배치는 <code>GridLayout</code>과 동일하게 수행하되 22번째 줄에서 볼 수 있듯이 component의 width 값(w)만 고정으로 박아버리면 되겠다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">Java와 Getter/Setter</h1>
				<p class="page-date">03 Oct 2011</p>
				<p class="page-tags">
						
						
					<code class="tag">java</code>
						
						
						
						
				</p>
				<div class="content"><p>객체지향 프로그래밍이라는 개념은 이름만으로는 상당히 추상적이라서 이해하기 영 좋지 않다. 약간 다르게 생각을 해보자. 객체지향이라는 개념이 왜 나왔는가를 통해서 대충 당시의 사람들이 무엇을 상상하고 만들었는지를 통해 이해해보는 것이다.</p>

<h3>옛날 이야기</h3>

<p>예전에는 절차지향 프로그래밍이라는 방식이 있었다. 프로그램이란, 기계(전자회로)의 동작을 제어하는 것으로, 이렇게, 저렇게, 의 명령 집합으로 생각되던 시절이었다. 당시에는 데이터나 명령이나 크게 구분이 없었다. 그래서 프로그램은 어떤 순서로 어떤 동작을 수행할지에 대한 나열인 방식으로 작성되었다</p>

<p>프로그램의 규모가 커지면서, 저러한 수행의 방식이 비슷한 곳이 많아졌다. 내가 짠 부분에서도, 남이 짠 부분에서도 최대 공약수를 구해야하는데, 매번 구하는 프로그램을 짜는 건 비효율적이다. 따라서 함수가 분리되고 라이브러리가 생겼다</p>

<p>처리해야할 자료의 양이 조금씩 늘어나면서, 프로그램 내에서 자료를 어떻게 관리해야할 지에 대한 고민도 시작되었다. 단순히 함수(코드의 집합)만으로는 데이터를 보관할 무언가를 만들 수가 없었다. 왜냐하면 그건 원래부터 데이터를 <strong>조작</strong> 하기 위한 것이었으니까.<br>
그래서 자료를 담기 위한 공간인 <strong>자료구조</strong>라는 개념이 나왔고, 어떤 프로그램을 작성할 때 어떻게 담아야 프로그램의 효율이 좋아질지를 고민하게 되었다.</p>

<p>데이터를 담기 위해 같은 타입의 데이터 집합인 배열과, 다른 타입의 데이터 집합인 구조체가 있다. 이들을 적절히 이용해서 자료를 담을 수 있는 공간을 만들었다. 여러 라이브러리들은, 이러한 자료를 담을 수 있는 공간에 대한 정의와, 그 자료들을 조작할 수 있는 함수들을 라이브러리라는 이름으로 묶어서 만들기 시작했다.</p>

<p>프로그램의 규모가 보다 더 커지고, 처리해야할 데이터의 양이 꽤 증가했다. 이 때문에 프로그래밍을 하면서 데이터를 관리하는 작업이 더욱 많아졌으며, 자료구조는 더욱 빈번히 사용되었다. 그 때마다 자료를 저장하는 공간(구조체 혹은 배열)과 이를 조작하는 함수를 따로 관리하는 것은 번거롭게 느껴졌다. 그래서 이 둘을 하나로 합치면 어떨까, 라고 해서 객체지향이 나왔다. <em>(는 뻥이다.)</em></p>

<p>절차지향 프로그래밍은 함수 중심이다. 여러 함수를 데이터가 통과해 가면서 데이터가 적절히 조작되고, 그 결과물을 만들어내는 형식이다. 객체지향 프로그래밍은 객체 스스로가 자신의 상태를 관리하고, 그 객체들의 조합을 통해 결과를 얻어내는 형식이다.</p>

<p>상태(데이터)와 조작(함수)를 하나로 묶는다는 개념은, 프로그래밍 관리 측면에서도 해당 세부를 알 필요 없다는 것과(추상화, 은닉) 기능을 확장하여 재사용하기 쉽다는 것(다형성) 등 여러 장점을 만들어냈다.</p>

<p>객체는 스스로 상태(데이터)를 관리한다. 어떻게 관리하냐하면 자신의 상태를 조작할 수 있는 함수(멤버 함수)를 외부로 노출(public) 함으로써 관리한다. 그리고 필요에 의해서, 객체는 자신의 상태를 외부로 공개해야할 수도 있다. 그래서 개념적으로, 이 둘을 상태를 변하게 하고, 접근할 수 있게 해주니까 mutator, accessor라고 부르게 되었다.</p>

<p>객체지향의 개념이 널리 퍼지면서, 많은 개발자들이 객체지향 세계로 뛰어들게 되었다. 하지만 C라는 괴물이 버티고 있는 개발의 세계에서 객체지향의 개념은 꿈도 꾸기 어려웠다.</p>

<p>마침 이 때, 비야네 아저씨가 <em>&#39;내 언어가 세계 최고의 언어!&#39;</em> 시대에 이것저것 개념을 하나로 합쳐 C++ 이라는 더 무시무시한 괴물을 만들어버렸다. 많은 언어적 패러다임을 담은 C++ 이라는 언어는 객체지향도 가능하게 해주었지만, 그 외의 다른 많은 것들도 가능하게 해주었다. 덕분에 C++ 로 객체지향을 공부하는 사람들은 객체지향이 아닌 C++ 을 배우게 되면서 그것이 객체지향인 줄 잘못 오해하게 되는 일이 생기게 되었다.</p>

<p>이에 통탄한 고슬링 아저씨가 순수 객체지향을 지향하는? Java를 만들었다. C++ 보다 훨씬 객체지향적 개념에 근접했던 이 언어는, 덕분에 프로그램 설계를 하는 사람들의 많은 사랑을 받았다. 그러면서 나름 객체지향 하기 좋은 언어란 칭호도 얻었던 것 같다.</p>

<h3>객체? 자료구조?</h3>

<p>은근슬쩍 넘어갔는데, 객체랑 자료구조랑은 좀 다르다. 관심있게 읽어준 사람은, 초반에는 분명 자료구조를 이야기하다가 어느순간 능구렁이 담 넘어가듯 객체 이야기로 넘어갔다는 것을 감지했을 것이다.</p>

<p>자바 프로그래밍을 하면서 가장 많이 실수하는 것이 이 둘을 구분짓지 못하는 것인데 왜 그런지 보자. 객체지향을 자바라는 언어로 공부하면서 가장 많이 배우는 잘못된 것은 아래와 같은 코드이다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Person</span><span class="o">()</span> <span class="o">{}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAge</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">age</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setAge</span><span class="o">(</span><span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">name</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>Person이라는 객체는 상태를 갖는다. 나이와 이름이라는 상태를 갖는데 이를 제어할 수 있도록 age와 name에 대한 <em>getter, setter를 만들어서 객체지향에 맞는 좋은 프로그래밍을 한 것일까?</em></p>

<ul>
<li>객체의 상태가 잘 은닉화 되었나? (어차피 public 으로 그냥 다 노출되었다.)</li>
<li>get, set 계열 함수를 Person 을 상속받는 자식에서 override 할건가? (이건 + operator를 overloading해서 - 연산을 하는 짓)</li>
<li>아니면 Person class 에서 name과 age를 관리하여 모종의 작업을 하는 무언가가 있는가?<br>
(그럴거면 그 작업을 수행하는 함수를 만들어서 노출시키지 뭐하러 set 함수까지 만들었는가)</li>
</ul>

<p>뭐 get/set 좋다. 취향이니 존중해줄 수는 있지만 아무 생각없이 get/set 코드 찍어내면서 난 정말 멋진 객체지향 프로그래머야! 라고 생각하지는 않았으면 좋겠다.</p>

<p>실제로, 위와 같은 class는 객체라기보다는 자료구조이다. 객체는 상태를 갖고 스스로 그걸 관리해주는, 즉 그걸 조작하는 함수를 갖는 것이다. 자료구조는? 자료를 담는 것이다.</p>

<p>어차피 Person class를 사용해서 사람에 대한 정보를 처리하는 코드를 작성한다면, 그 코드가 Person가 아닌 Person 자료를 관리하는 곳에 들어가기 때문이다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">class</span> <span class="nc">PeopleManager</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">people</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;();</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">calcaulteAverageAge</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">averageAge</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Person</span> <span class="nl">p:</span> <span class="n">people</span><span class="o">)</span> <span class="n">averageAge</span> <span class="o">+=</span> <span class="n">p</span><span class="o">.</span><span class="na">age</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">averageAge</span> <span class="o">/</span> <span class="n">people</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div>
<p>Person 객체들은 List에 의해 관리되고 있고, 그걸 소유하는 PeopleManager에서 접근, 계산하고 있다.
여기서 Person class가 age와 name에 대해 getter/setter 를 가질 필요는 전혀 없다. 오히려 있으면 더럽다. (안그래도 느린데, getter 접근하면 더 느려진다! 물론 javac가 최적화해줄 수 있지만 그걸 바라고 getter를 쓰는건 좀 이상하다.)</p>

<p>단순히 사람에 대한 정보를 담는, 즉 자료구조라면 굳이 getter/setter를 두지 않고 public으로 멤버를 노출시키는게 더 올바른 설계라는 것이다.</p>

<h3>왜 getter/setter를 붙이는 습관이 들었을까</h3>

<p>Java가 가장 많이 사용되는 시장은 Web이다. J2EE가 크게 성공하면서 EJB가 대세! 인 세상이 있었다. EJB 는 Enterprise Java Bean의 약자인데, 여기서 Bean은 아래와 같은 코드를 말했다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">class</span> <span class="nc">PersonBean</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div>
<p>즉, DB와 어떻게 보여줄 지 연산하는 부분과 웹 페이지 만드는 부분에서 데이터를 공유하기 위해 정보를 담는 자료구조인 것이다. 이런 값 객체(ValueObject: VO) 들이 많아지면서 코드 여기저기를 누비게 되었다.</p>

<p>그런데 값이란게 로직과 떨어질 수가 없는 운명이다.</p>

<p>예를 들면, 저 나이에서 만 나이를 구하는 경우를 생각해보자. age에서 1을 빼면 된다. 따라서 만 나이가 사용되는 경우에는 다 - 1 연산을 사용하였다. 사실 이건 중복되는 로직이니까 Person class에서 이걸 반환하는 함수를 하나 넣어주면 되는데, 안타깝게도 저 부분은 거의 auto generation 되는 코드이거나, convention으로 강력하게 박혀있기 때문에 함부로 수정하지를 않았다. 그래서 로직 코드가 중복되고, 코드의 품질이 저하되었다.</p>

<p>크고 아름다운 설계에도 불구하고 EJB가 저런 많은 문제를 야기하자, 이 문제를 수정하기 위해 여러 설계자들은 대안을 모색하였다.</p>

<p>그 결과 자바가 VO를 남발하면서 로직 중복되는 이유는 기존의 높고 높은 객체지향의 뜻을 잃었기 때문이고, 그 이유는 사람들이 기존의 객체 설계법을 EJB라는 멋진 기법에 가려 잊어가고 있기 때문이다, 라는 결론에 도달하게 되었다.</p>

<p>그들은, 기존의 방법이 EJB만큼 멋진 이름이 없기 때문에 잘 사용하지 않는다는 것을 깨닫고, POJO(Plain Old Java Object)라는 멋진 이름을 통해 기존의 클래스 설계 방법을 널리 장려하였다.</p>

<p>그 후 EJB의 기세는 로직 중복 코드와 함께 서서히 망해가기 시작했고, 이에 환멸을 느낀 사람들이 POJO를 적극 권장하면서 public member에 대한 증오심을 표출했다. 덕분에 모든 member는 getter와 setter로 감싸졌고, 이것은 자바 프로그래밍의 큰 미덕이 되어 널리 퍼졌다. <em>(는 뻥)</em></p>

<h3>정리</h3>

<p>웃자고 한 소리인데, 아무튼 자바에 특히 getter/setter가 많은 건 사실.
내용이 기니까 세 줄 요약하자면,</p>

<ul>
<li>C++은 객체지향이 영 좋지 못하니까 Java 를 통해 객체지향을 공부해보자.</li>
<li>public으로 member를 노출시키는건 미개한 C 언어나 하는 짓이잖아? 난 고고하게 getter/setter를 쓰겠음</li>
<li><del>써보니까 은닉 좋네, 나도 이제 객체지향 프로그래머? getter/setter 안 쓰면 원시인ㅋ</del> <em>이러지 맙시다</em></li>
</ul>

<p>아무튼 Getter, Setter을 은닉을 위해 쓰겠다는건 말도 안되는 이야기고, 진짜 쓰겠다면 Mutator와 Accessor의 개념으로 접근해서 설계를 하는 마음을 먹고 써야한다.</p>

<p>물론 Java에서는 멤버의 Readonly를 위해 Getter만 존재하는 경우도 있다. 이 경우에는 final keyword를 사용해서 수정이 불가능하게 해줘도 되는데, 이게 객체 멤버를 반환할 경우에는 좀 애매해진다. final은 객체 멤버의 reference을 못 바꾸게 하는거지 반환된 객체를 수정하지 못하게하는건 아니니까.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Program</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Code</span><span class="o">&gt;</span> <span class="n">codes</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Code</span><span class="o">&gt;();</span>
    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Code</span><span class="o">&gt;</span> <span class="nf">getCodes</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">codes</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// 중략</span>
<span class="n">Program</span> <span class="n">program</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Program</span><span class="o">();</span>
<span class="n">program</span><span class="o">.</span><span class="na">getCodes</span><span class="o">().</span><span class="na">clear</span><span class="o">();</span> <span class="c1">// 수정할 수 있다</span>
</code></pre></div>
<p>이 때문에 @Readonly annotation이 추가되려 하였으나 실패했다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
						
				<h1 class="page-title">java의 FutureTask를 사용한 간단한 수행 대기</h1>
				<p class="page-date">28 May 2012</p>
				<p class="page-tags">
						
						
					<code class="tag">java</code>
						
						
						
						
				</p>
				<div class="content"><p>어떤 작업에 timeout을 주고 실행하고 싶은 경우가 있다. 예를 들어 web crawler를 만들 때에는 해당 페이지에 대한 응답이 10초정도 없을 경우에 그냥 그 페이지를 읽지 않도록 예외처리 하는 것이다.</p>

<p>이 글에서는 <code>ExecutorService</code>와 <code>FutureTask</code>를 사용하여 timeout 처리를 하는 간단한 예제를 소개한다.</p>

<ul>
<li><code>ExecutorService</code>는 java 1.5 때 Doug Lea 아저씨가 추가한 좋은 Library이다. 이 글에서는 ThreadPool을 사용하기 위한 용도로 쓴다.</li>
<li><code>FutureTask</code> 역시 Doug Lea 아저씨가 추가한 class로 javadoc에서 그 설명을 간략히 따오면 cancellable asynchronous computation이다. 즉, 수행 Thread와 결과를 받는 Thread가 분리되고, 취소 가능하다. 이 class는 <code>RunnableFuture</code>를 구현하는데, 이는 <code>Runnable</code>와 <code>Future</code> 두 interface의 합성체이다.</li>
</ul>

<p>어떤 작업에 timeout을 걸기 위해서는 적어도 수행 thread과 timeout을 걸어주는 thread가 분리되어야 한다. 간단하게 fork-join model을 생각해보자면 수행할 task는 fork된 thread에게 맡기고, join하는 main thread에서 join을 얼마나 기다려줄지 timeout을 지정해준다고 생각하면 되겠다.</p>

<p>java에서도 1.7부터 <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ForkJoinPool.html">fork/join pool</a>을 지원해주지만, 본 글에서는 안 다룬다.</p>

<p>일단 무엇을 작업해서 반환할지에 대한 <code>FutureTask</code>를 구현한다. <code>FutureTask</code>는 이름 그대로 Future + Task이다. 즉 Task를 수행한 결과를 Future로 받아볼 수 있는 구조로, 생성자로 <code>Callable</code> 객체를 받고 수행을 위한 <code>run()</code> 함수와 결과 값을 받기 위한 <code>get()</code> 함수를 갖는다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="n">FutureTask</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">task</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FutureTask</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;(</span>
    <span class="k">new</span> <span class="n">Callable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="n">String</span> <span class="nf">call</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
            <span class="k">return</span> <span class="cm">/* complicated crawling code */</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">});</span>
</code></pre></div>
<p>뭔가 내부에서 복잡한 작업을 수행하는 callable object를 생성자로 받는 task 객체를 생성했다. 이제 task의 멤버 함수인 <code>run()</code>을 호출하게 되면 저 callable object가 실행되고, 그 수행 결과가 task 내부에 저장되는 것이다. 그러면 저 task의 상태가 completed(<code>isDone()</code>으로 확인) 인지 보고, <code>get()</code> 함수로 결과를 가져오면 되는 것이다.</p>

<p>이제 열심히 만든 task 객체를 수행할 thread를 생성하도록 하자. 하지만 thread를 매번 만드는 것은 매우 아깝고 귀찮은 일이므로 <code>ExecutorService</code>를 사용해보도록 하자.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="n">ExecutorServicce</span> <span class="n">threadPool</span> <span class="o">=</span> <span class="n">Executors</span><span class="o">.</span><span class="na">newCachedThreadPool</span><span class="o">();</span>
</code></pre></div>
<p>다 만들었다-_-; 이제 만든 ThreadPool을 사용하여 task를 실행해보자.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="n">threadPool</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>
</code></pre></div>
<p>정말 간단하게 ThreadPool을 만들었고, 해당 ThreadPool 내에 cache된 thread에게 우리가 만든 task를 수행시켰다. 이제 main thread에서는 적절히 timeout을 걸고 기다려보자.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="k">try</span> <span class="o">{</span>
    <span class="n">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">5</span> <span class="cm">/* TIMEOUT */</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">);</span>
    <span class="cm">/* some codes for processing result */</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">TimeoutException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// timeout occurred!</span>
<span class="o">}</span>
</code></pre></div>
<p>결과값을 가져오는 <code>get()</code> 함수는 해당 task가 완료될 때까지 기다리는 함수이다(blocking). 이 함수는 timeout 시간을 인자로 받는 함수가 overload되어있는데, 위 예시처럼 해당 함수를 쓰면 해당 수행이 5초내로 끝나지 않으면 <code>TimeoutException</code>을 던지게 되는 것이다. 따라서 <code>TimeoutException</code>을 적절히 catch해서 적절하게 처리해주면 된다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">JPanel 상속</h1>
				<p class="page-date">15 Feb 2011</p>
				<p class="page-tags">
						
						
					<code class="tag">java</code>
						
						
						
						
				</p>
				<div class="content"><p>Java에서 UI 코드를 작성할 때, 가장 많이 하는 코딩 방식이 UI Pane class를 만들고 이 class가 JPanel을 상속받는 것이다.<br>
하지만 생각해보면 그 class는 전혀 <code>JPanel</code>을 상속받을 필요가 없고 그냥 <code>JPanel</code> 객체를 멤버 변수로 하나 만들어서 contain pane으로 사용해도 된다.<br>
그러면 그 class는 정확히 <code>controller</code> 역할을 수행할 것이고(event handling을 포함하여) <code>controller</code>가 view(<code>JPanel</code>, <code>JLabel</code>... 등) 객체들의 reference 변수를 알고 변경시키는 깔끔한 MVC 구조가 성립된다.</p>

<p>하지만 <code>JPanel</code>을 상속받은 객체 내에서 controller일을 수행하면,<br>
<code>JPanel</code>을 상속받은 시점에서 그 class가 view class화 되기 때문에 <code>V</code>랑 <code>C</code>가 합쳐지는 듯한 해석이 가능해지는데 어차피 코드 입장에서는 크게 달라지는게 없으므로 이런 해석은 사실상 의미가 없기는 하지만 생각해보면 굳이 상속을 받아야할 필요는 없으므로 상당히 애매한 위치에 놓인다.</p>

<p>요약하면</p>

<ol>
<li>상속을 받아서 UI를 구성해도 되고</li>
<li>상속을 받지 않고 변수로 UI를 구성해도 된다.</li>
</ol>

<p>다만, 자주 사용되는 UI class의 경우에는 1)의 방법은 상속을 통한 객체 기능 확장, 2)의 방법은 합성을 통한 객체 구성이니까 내부 method를 직접 공개(public)할 것이냐 아니면 위임(delegation)할 것이냐의 약간의 차이가 발생하겠다.<br>
아무튼 생각해보면 별 것도 아닌데 원래 별 것 아닌 것에 대해서 의미를 읽어서 명확히 하는 설계 짓을 하는 것이기 때문에-_- 한 번쯤은 고민해볼 가치가 있다고 생각한다.</p>

<p>하지만 대부분의 UI 설계는 <code>JPanel</code>을 상속받으면서부터 시작한다. 이러한 습관이 들어버린건 다 NetBeans 때문이다-_-</p>

<p>View와 Controller가 섞이면 coupling이 심해져 코드가 좀 더러워진다. 때문에 중간에 interface를 두고 나누는 방법도 생각해볼 수 있겠다.<br>
(이걸 심하게 해주시는 분이 로버드 C. 마틴 이란 분인데 <a href="http://www.yes24.com/24/goods/4492519">UML 실전에서는 이것만 쓴다</a> 책이 재밌다)</p>

<p>최근에 운 좋게도 그래디 부치 책을 구했으니 좀 더 공부를 해봐야겠다.</p>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Robert_Cecil_Martin">http://en.wikipedia.org/wiki/Robert_Cecil_Martin</a></li>
<li><a href="http://en.wikipedia.org/wiki/Grady_Booch">http://en.wikipedia.org/wiki/Grady_Booch</a></li>
</ul>

<p>유명하신 분들이다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">간단한 Message 체계 구현 (Java)</h1>
				<p class="page-date">27 Nov 2011</p>
				<p class="page-tags">
						
						
					<code class="tag">java</code>
						
						
						
					<code class="tag">message</code>
						
						
						
						
				</p>
				<div class="content"><p>본 글을 객체 간의 메시지 통신이 아니라 모듈 간의 메시지 통신에 대해 다룬다.
즉, 특정 대상 객체를 지정하여 메시지를 보내는 내용이 아니라 전역 MessageQueue에 대해 어떤 Message를 수신할지를 등록하는 Handler 객체에 대한 내용이다.</p>

<ul>
<li><code>MessageQueue</code>는 전역 객체이다. <code>Message</code>를 받아서 이를 수신 Handler 객체에게 전달한다.</li>
<li>여러 Thread에서 접근할 수 있으므로 Concurrent DataStructure를 사용한다.</li>
<li>내부적으로 각 Message 에 대해 여러 Worker Thread 를 두어 처리할 수도 있겠지만, 일단 Message 처리의 순서를 보장하기 위해 공유 Queue 를 갖고 단일 Thread 가 처리하는 방식으로 구현한다.<br>
(글 쓰면서 생각해보니 이 지점에서 성능 병목이 생길텐데, 고민을 더 해봐야겠다)</li>
</ul>

<p><code>Message</code>는 무슨 class 가 될지 모르니까 간단하게 mark interface로 만든다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Message</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div>
<p><code>MessageQueue</code> class는 Message를 공유하는 Queue 객체와 이를 처리할 수 있도록 내부 Thread를 하나 돌린다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">private</span> <span class="n">BlockingQueue</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedBlockingQueue</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;();</span> 

<span class="kd">private</span> <span class="nf">MessageQueue</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">new</span> <span class="nf">Thread</span><span class="o">()</span> <span class="o">{</span>
        <span class="cm">/* public this() */</span> <span class="o">{</span>
            <span class="n">setDaemon</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">process</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}.</span><span class="na">start</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">process</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Message</span> <span class="n">message</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">((</span><span class="n">message</span> <span class="o">=</span> <span class="n">pop</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">delegate</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="n">Message</span> <span class="nf">pop</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">queue</span><span class="o">.</span><span class="na">take</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div>
<p>보통의 단순한 Message Handler라면, Message에 MessageType이나 id 값을 넣어서 그 내부적으로 switch case로 분기하여 처리하는 구조가 될 것이다. 이에 대해서는 multiple-dispatch를 사용하면 보다 깔끔한 구조의 Handler를 작성할 수 있는데, Java는 어차피 느리니 Reflection을 통해 이 기능을 구현해보자.</p>

<p>Handler는 <code>handleMessage</code>이라는 method를 갖는다. 이 때 parameter는 <code>Message</code> class를 하나만 갖는다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kt">void</span> <span class="nf">handleMessage</span><span class="o">(</span><span class="n">StringMessage</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
<span class="o">}</span>
<span class="kt">void</span> <span class="nf">handleMessage</span><span class="o">(</span><span class="n">IntMessage</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div>
<p>이 때 <code>MessageQueue</code>에 <code>StringMessage</code> 객체를 넣으면 첫 번째 함수가, <code>IntMessage</code> 객체를 넣으면 후자의 함수가 호출되도록 하겠다는 것이다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">HANDLER_NAME</span> <span class="o">=</span> <span class="s">&quot;handleMessage&quot;</span><span class="o">;</span>
<span class="kd">private</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Class</span><span class="o">&lt;?&gt;,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;&gt;</span> <span class="n">handlerMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcurrentHashMap</span><span class="o">&lt;</span><span class="n">Class</span><span class="o">&lt;?&gt;,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;&gt;();</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">addHandler</span><span class="o">(</span><span class="n">Object</span> <span class="n">handler</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">handlerClass</span> <span class="o">=</span> <span class="n">handler</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Method</span> <span class="nl">method:</span> <span class="n">handlerClass</span><span class="o">.</span><span class="na">getDeclaredMethods</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">HANDLER_NAME</span><span class="o">))</span>
            <span class="k">continue</span><span class="o">;</span>

        <span class="n">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">paramTypes</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="na">getParameterTypes</span><span class="o">();</span>
        <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">messageClass</span> <span class="o">=</span> <span class="n">paramTypes</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">Message</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">isAssignableFrom</span><span class="o">(</span><span class="n">messageClass</span><span class="o">)</span> <span class="o">||</span> <span class="n">paramTypes</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="k">new</span> <span class="n">MessageQueueException</span><span class="o">(</span><span class="s">&quot;Invalid Handler in &quot;</span> <span class="o">+</span> <span class="n">handlerClass</span><span class="o">.</span><span class="na">getSimpleName</span><span class="o">()</span> 
                    <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">method</span><span class="o">.</span><span class="na">toGenericString</span><span class="o">()));</span>

            <span class="k">continue</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(!</span><span class="n">handlerMap</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">messageClass</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">handlerMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">messageClass</span><span class="o">,</span> <span class="k">new</span> <span class="n">CopyOnWriteArrayList</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;());</span>
        <span class="o">}</span>
        <span class="n">handlerMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">messageClass</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">handler</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>Handler 객체를 등록할 때, Handler 객체에 선언된 모든 Method를 가져온다. 그 Method 중 이름이 <code>handleMessage</code>인 것들을 찾는다. 이 때 parameter는 반드시 한 개이어야 하고, 그 type은 <code>Message</code> class를 상속받는 class이어야(<code>assignableFrom</code>) 한다.</p>

<p>그러한 method들을 찾았다면, 그 <code>Message</code> class에 대응되는 Handler들의 목록을 저장해둔다. (여기서 Method도 같이 저장해둔다면, 나중에 invoke할 때 또 Method를 찾는 부담을 덜 수 있을 것이다.)</p>

<p>이제 <code>Message</code>가 들어오면 그 class type에 해당하는 Handler를 찾아서 invoke를 해주면 된다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">private</span> <span class="kt">void</span> <span class="nf">delegate</span><span class="o">(</span><span class="n">Message</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Set</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">invoked</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;();</span>

    <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">clazz</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">clazz</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">Object</span><span class="o">.</span><span class="na">class</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">handlerMap</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">clazz</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">Object</span> <span class="nl">handler:</span> <span class="n">handlerMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">clazz</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// prevent bubbling</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">invoked</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">handler</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">invoke</span><span class="o">(</span><span class="n">handler</span><span class="o">,</span> <span class="n">clazz</span><span class="o">,</span> <span class="n">message</span><span class="o">);</span>
                    <span class="n">invoked</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">handler</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="n">clazz</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getSuperclass</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">invoked</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">Logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="k">new</span> <span class="n">MessageQueueException</span><span class="o">(</span><span class="s">&quot;Cannot Find MessageHandler(&quot;</span> <span class="o">+</span> <span class="n">message</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot;)&quot;</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">Object</span> <span class="n">handler</span><span class="o">,</span> <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">messageClass</span><span class="o">,</span> <span class="n">Message</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">handlerClass</span> <span class="o">=</span> <span class="n">handler</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">Method</span> <span class="n">method</span> <span class="o">=</span> <span class="n">handlerClass</span><span class="o">.</span><span class="na">getDeclaredMethod</span><span class="o">(</span><span class="n">HANDLER_NAME</span><span class="o">,</span> <span class="n">messageClass</span><span class="o">);</span>
        <span class="n">method</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
        <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">handler</span><span class="o">,</span> <span class="n">message</span><span class="o">);</span>

    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>다만, bubbling을 막기 위해서 한 번 Invoke된 Handler는 다시 Invoke되지 않도록 했다. 예를 들어서,</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">class</span> <span class="nc">StringMessage</span> <span class="kd">implements</span> <span class="n">Message</span> <span class="o">{}</span>
<span class="kd">class</span> <span class="nc">SpecialStringMessage</span> <span class="kd">extends</span> <span class="n">StringMessage</span> <span class="o">{}</span>
<span class="kt">void</span> <span class="nf">handleMessage</span><span class="o">(</span><span class="n">StringMessage</span> <span class="n">message</span><span class="o">)</span> <span class="o">{}</span>
<span class="kt">void</span> <span class="nf">handleMessage</span><span class="o">(</span><span class="n">SpecialStringMessage</span> <span class="n">message</span><span class="o">)</span> <span class="o">{}</span>
</code></pre></div>
<p><code>SpecialStringMessage</code> 객체를 전달했을 때 원하는 상황은 두 번째 함수가 호출되는 것이겠지만, 사실 <code>SpecialStringMessage</code> class는 <code>StringMessage</code> class로 assignable하기 때문에 첫 번째 함수도 호출될 수 있다.</p>

<p>따라서 delegate 함수에서는 처리할 Message type을 가장 구체화된(derived) type부터 역순으로 올라가면서, 그 type 에 대응되는 Handler를 호출해준 뒤, 더 이상 호출되지 않도록 invoked set을 유지하는 것이다.</p>

<p>invoke를 할 때 굳이 <code>setAccessible</code>을 true 해주는 이유는, message handler 함수가 굳이 객체 외부에서 불릴 필요가 없는데 public으로만 선언되어야 하는 것을 막기 위함이다. (물론 그렇다고 private으로 선언하면 해당 handler는 <em>not read locally warning</em>이 발생하게 되므로, 안타깝지만 default 정도로 선언해주는게 적당한 것 같다)</p>

<p>작성된 <code>MessageQueue</code>는 다음과 같이 사용될 수 있다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kt">void</span> <span class="nf">handleMessage</span><span class="o">(</span><span class="n">StringMessage</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">message</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">handleMessage</span><span class="o">(</span><span class="n">IntMessage</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">message</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">MessageQueue</span><span class="o">.</span><span class="na">listen</span><span class="o">(</span><span class="k">new</span> <span class="n">ExampleHandler</span><span class="o">());</span>
    <span class="n">MessageQueue</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="k">new</span> <span class="n">StringMessage</span><span class="o">(</span><span class="s">&quot;hello world&quot;</span><span class="o">));</span>
    <span class="n">MessageQueue</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="k">new</span> <span class="n">IntMessage</span><span class="o">(</span><span class="mi">12345</span><span class="o">));</span>

    <span class="k">try</span> <span class="o">{</span>
        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p><code>IntMessage</code> class는 int를 생성자로 받고 <code>StringMessage</code> class는 String을 생성자로 받는 단순한 wrapper class이다. <code>MessageQueue</code>에 <code>ExampleHandler</code> 객체를 등록하고 각 type의 message 객체를 넣으면, 첫 번째는 <code>StringMessage</code> parameter type을 갖는 handler가, 두 번째는 <code>IntMessage</code> parameter type을 갖는 handler가 호출된다.</p>

<p>(마지막의 <code>Thread.sleep</code>은 daemon Thread로 <code>Message</code>를 처리하는 <code>MessageQueue</code>가 Queue에 있는 Message를 처리하기 전에 main 함수가 끝나 프로그램이 종료되어 Message 처리가 되지 못하는 것을 막기 위함이다)</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">자바 네트워크 프로그래밍 1 - 기초</h1>
				<p class="page-date">01 May 2010</p>
				<p class="page-tags">
						
						
					<code class="tag">java</code>
						
						
						
						
				</p>
				<div class="content"><p>네트워크라는 것에 대해 깊게 설명할 생각은 없다. 단지 자바 언어에서 <em>어떻게 네트워크 프로그래밍을 할 수 있을까</em> 정도에 대해 간략하게 소개할 생각이다. 이 글을 보고 관심을 조금만 갖고 구글링해보시면 당연한 이야기이지만 훨씬 잘 설명된 좋은 글이 많을테니, 이 글에서 단순히 흥미유도 차원 글을 쓴다.</p>

<h3>기초</h3>

<p>네트워크 프로그래밍은 두 원격지(HOST) 간의 데이터 통신을 위한 프로그래밍이다.
간단히 비유하자면,</p>

<ol>
<li>집에서 웹 페이지(서버)를 여는 것이나</li>
<li>덕질을 위해 FTP에 접속하여 파일을 내려받거나</li>
<li>과제를 위해 친구와 메신저로 대화를 하는</li>
</ol>

<p>것 정도가 되겠다. 위의 상황을 네트워크의 원격지, 데이터로 구분해보면</p>

<ol>
<li>내 컴퓨터, 웹 서버, HTML 데이터 등</li>
<li>내 컴퓨터, FTP서버, 애니메이션 데이터 등</li>
<li>내 컴퓨터, 친구 컴퓨터, 대화(String) 데이터 등</li>
</ol>

<p>이 될 수 있겠다.</p>

<p>통신을 한다는 건 두 HOST가 네트워크로<span style="color: #aaa;">(wired or wireless)</span> 연결되어있다는 것이다.<br>
네트워크에 속한 HOST는 그 특정 주소를 갖는데, 흔히 생각하는 <code>IP Address</code>라고 보면 되겠다. 흔히 우리는 네트워크를 사용하기 위해 TCP/IP Protocol을 사용하기 때문이다.<br>
<a href="http://en.wikipedia.org/wiki/Transmission_Control_Protocol">http://en.wikipedia.org/wiki/Transmission_Control_Protocol</a><br>
<span style="color: #aaa;">(다른 곳에 더욱 설명이 잘 있으니 자세한 설명은 생략한다)</span><br>
<span style="color: #aaa;">(기계적 주소인 MAC Address와 함께 같이 찾아보면서 공부해보는 것도 좋다. 하지만 이 글은 자바 네트워크 프로그래밍이 주라서 이 부분은 제외)</span></p>

<p>두 HOST가 서로의 주소를 안다고 해서 TCP/IP 통신할 수 있는 것은 아니다. TCP/IP 통신에는 <code>IP Address</code> 말고 <code>Port</code>라는 Unsigned Short Integer(16bit) 값이 하나 더 필요하기 때문이다.<br>
<a href="http://en.wikipedia.org/wiki/TCP_and_UDP_port">http://en.wikipedia.org/wiki/TCP_and_UDP_port</a></p>

<p>간단히 하나의 HOST 내에 실행되고 있는 수많은 네트워크 사용 프로그램들에 대해 데이터를 빠르고 명확하게 구분하기 위한 하나의 키 값이라고 보면 되겠다. <strong>SSH는 22번, HTTP는 80번</strong>과 같이 사실상 고유의 값으로 지정된 것고 있다.<br>
<a href="http://en.wikipedia.org/wiki/TCP_and_UDP_port_numbers">http://en.wikipedia.org/wiki/TCP_and_UDP_port_numbers</a></p>

<p>TCP/IP 프로토콜에서는 데이터를 보낼 때 <strong>Packet</strong>으로 쪼개어 보내는데 이 쪽을 공부해두면 장차 네트워크 프로그래밍할 때 도움되는게 많다.<br>
<a href="http://en.wikipedia.org/wiki/Packet_(information_technology">http://en.wikipedia.org/wiki/Packet_(information_technology)</a>)</p>

<h3>서버와 클라이언트</h3>

<p>전화를 할 때도 거는 사람과 받는 사람이 있다. 전화라는 것은 </p>

<ul>
<li>전화선으로 연결된<span style="color: #aaa;">(네트워크에 속한)</span></li>
<li>두 사람<span style="color: #aaa;">(HOST)</span> 간에서</li>
<li>대화<span style="color: #aaa;">(데이터 통신)</span>을 하는 것</li>
</ul>

<p>을 이야기한다.</p>

<p>이 때 거는 사람<code>(클라이언트)</code>은 받을 사람<code>(서버)</code>의 전화번호<span style="color: #aaa;">(IP Address와 Port)</span>를 눌러 전화를 걸고, 받을 사람<code>(서버)</code>은 전화가 걸려오기를 기다리고 있다가 전화가 오면 받는 것이다.</p>

<p>이것이 간략한 서버와 클라이언트의 개념이고, 자세한 내용은 다음 글에서 코드로 보면 되겠다.</p>

<h3>결론</h3>

<p>TCP와 UDP의 특성, <code>IP Protocol</code>, <code>Packet</code> 등 네트워크 프로그래밍 기초라고 해도 들먹일 개념이 굉장히 많지만 그것들은 wiki 등 더욱 잘 나와있는 곳이나 동아리 사람들에게 질문해보시면 더욱 확실하게 배울 수 있고,<br>
<strong>서버와 클라이언트의 개념, <code>IP Address</code>와 <code>Port</code> 번호가 무엇인지 정도만 알겠다 싶으면 된 것이다.</strong></p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">자바 네트워크 프로그래밍 2 - Socket</h1>
				<p class="page-date">01 May 2010</p>
				<p class="page-tags">
						
						
					<code class="tag">java</code>
						
						
						
						
				</p>
				<div class="content"><p>자바 네트워크 프로그래밍을 설명하려면 당연히 IO부터 이야기해야하는 것이 맞겠지만 이왕 저지른거 막장으로 달려보자.</p>

<h3>Socket</h3>

<p>전 글에서 네트워크 통신을 사람 간의 전화로 비유했었다.<br>
네트워크 통신을 한다는 것은 <a href="http://en.wikipedia.org/wiki/Network_Interface_Controller">NIC(Network Interface Controller)</a>를 사용하여 데이터를 주고 받겠다는 것이고 이는 <strong>하드웨어를 제어해야 한다는 뜻이다.</strong> 하드웨어는  <strong>운영체제가 관리하고 있는 자원</strong>이기 때문에 일반 프로그램들이 접근할 수 없다.</p>

<p>처음 c/c++ 배울 때 사용했떤 파일 읽기/쓰기도 <strong>하드디스크</strong>라는 하드웨어 자원을 쓰는데 잘은 몰랐지만 프로그램이 제어를 했었다. 그 이유는 <del>모르는 사이에</del> open, read, write와 같은 <strong>운영체제가 제공하는 API</strong>를 사용했기 때문이다. 요약하자면, <strong>하드웨어 자원은 운영체제가 관리하니 운영체제가 제공하는 API를 사용하여 프로그래밍을 해야 한다</strong>는 것이다.</p>

<p>고로 네트워크 프로그래밍을 하기 위해 운영체제가 주는 API가 있는데 그것이 바로 <strong>소켓:Socket</strong>이라고 보면 되겠다.<br>
<span style="color: #aaa;">짧은 지식으로는 더 잘 설명할 재간이 없으니 [...] 그냥 그렇다고 넘어가자.</span></p>

<p>코드 한 줄 없이 이렇게 장문을 쓰는 것도 괴로운 일이므로 바로 코드로 넘어가보자.</p>

<h3>Client</h3>

<p>클라이언트는 요청하는 쪽이다. 서버를 끊임없이 괴롭혀서 자신이 원하는 정보를 받아가는 녀석이다.<br>
대표적인 예로 웹이 있다. 지금도 웹 서버에게 웹 페이지 데이터를 받아서 읽고 있는 것이다.</p>

<p>클라이언트가 <strong>TCP/IP</strong> 데이터 통신을 하기 위한 순서는 다음과 같다.</p>

<ol>
<li>Socket을 만든다.</li>
<li>생성된 Socket으로 서버와 연결한다</li>
<li>신나게 데이터 통신을 한다.</li>
<li>연결을 종료한다.</li>
</ol>

<p>말은 길고 코드는 짧으니 바로 코드로 넘어가보자.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.Socket</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.UnknownHostException</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Client</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">UnknownHostException</span><span class="o">,</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="n">Socket</span> <span class="n">socket</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Socket</span><span class="o">(</span><span class="s">&quot;127.0.0.1&quot;</span><span class="o">,</span> <span class="mi">3112</span><span class="o">);</span> <span class="c1">// 소켓 생성과 동시에 연결</span>
        <span class="n">InputStream</span> <span class="n">inStream</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">();</span> <span class="c1">// 데이터 수신을 위한 InputStream 가져오기</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">chunk</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">4096</span><span class="o">];</span> <span class="c1">// 데이터를 받을 byte 배열 생성</span>
        <span class="kt">int</span> <span class="n">receiveLength</span> <span class="o">=</span> <span class="n">inStream</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">chunk</span><span class="o">);</span> <span class="c1">// 데이터를 읽고, 얼마나 가져왔는지를 반환받음</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="n">chunk</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">receiveLength</span><span class="o">));</span> <span class="c1">// 수신받은 데이터를 콘솔에 출력</span>
        <span class="n">inStream</span><span class="o">.</span><span class="na">close</span><span class="o">();</span> <span class="c1">// InputStream을 닫음</span>
        <span class="n">socket</span><span class="o">.</span><span class="na">close</span><span class="o">();</span> <span class="c1">// 소켓을 닫음</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<ul>
<li>소켓 생성과 동시에 연결(connect)를 할 수 있다.

<ul>
<li>물론 소켓 생성 후에 connect 함수를 통해서도 접속 가능하다.</li>
<li>이 때 첫 번째 인자가 연결할 서버의 <strong>hostname 혹은 ip address</strong>이고 두 번째 인자가 <strong>port 번호</strong>이다.</li>
</ul></li>
<li>연결 후 데이터 통신을 위한 <strong>InputStream</strong>과 <strong>OutputStream</strong>을 가져와 통신할 수 있다.</li>
<li>통신이 끝난 후 스트림과 소켓을 <strong>닫아주면</strong> 된다.

<ul>
<li>효율적인 자원관리를 위해 <strong>다 쓴 자원은 꼭 주자.</strong></li>
</ul></li>
</ul>

<p>위 예제에서는 예외처리를 제대로 하지 않고 밖으로 다 던져**throws**버렸는데 실제 코드를 작성할 때에는 반드시 수행하는 하나하나에 대해 적절한 예외처리를 해주어야 한다.</p>

<h3>Server</h3>

<p>서버는 응답자라고 보시면 되겠다. 클라이언트의 요청에 대한 결과물을 회신하는 쪽이다.<br>
이는 웹 서버가 열심히 웹 페이지를 보내주고 있는 것으로 생각하시면 되겠다.</p>

<p>서버가 <strong>TCP/IP</strong> 데이터 통신을 하기 위한 순서는 다음과 같다.</p>

<ol>
<li>ServerSocket을 만든다.</li>
<li>클라이언트의 연결 요청에 대해 accept를 하여 클라이언트와 데이터 통신을 수행할 Socket 객체를 만든다.</li>
<li>신나게 데이터 통신을 한다.</li>
<li>연결을 종료한다.</li>
</ol>

<p>바로 코드로 넘어가보자.</p>

<p>서버는 클라이언트로부터의 연결을 계속 기다리고 있다. 단, 클라이언트가 어떤 <strong>PORT 번호</strong>로 접속해야 할지를 알고 그 PORT에 달라붙어서(**bind**) 기다리고(**listen**) 있으면 된다. 그리고 클라이언트가 접속하면, 해당 클라이언트에 대한 소켓을 낚으면(**accpet**) 된다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.OutputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.ServerSocket</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.Socket</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Server</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="n">ServerSocket</span> <span class="n">server</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ServerSocket</span><span class="o">(</span><span class="mi">3112</span><span class="o">);</span> <span class="c1">// PORT를 열고 접속을 대기</span>
        <span class="n">Socket</span> <span class="n">socket</span> <span class="o">=</span> <span class="n">server</span><span class="o">.</span><span class="na">accept</span><span class="o">();</span> <span class="c1">// 클라이언트의 연결로부터 소켓을 만듬</span>
        <span class="n">OutputStream</span> <span class="n">outStream</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">();</span> <span class="c1">// OuputStream을 얻음</span>
        <span class="n">outStream</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">&quot;Hello Java Network Programming World!&quot;</span><span class="o">.</span><span class="na">getBytes</span><span class="o">());</span> <span class="c1">// 클라이언트에게 환영 인사를 보냄</span>
        <span class="n">outStream</span><span class="o">.</span><span class="na">close</span><span class="o">();</span> <span class="c1">// OutputStream을 닫음</span>
        <span class="n">socket</span><span class="o">.</span><span class="na">close</span><span class="o">();</span> <span class="c1">// 클라이언트와의 연결 소켓을 닫음</span>
        <span class="n">server</span><span class="o">.</span><span class="na">close</span><span class="o">();</span> <span class="c1">// 클라이언트 접속 대기 소켓을 닫음</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>서버는 클라이언트와 다르게 두 개의 소켓 개념이 존재한다. 하나는 <strong>서버소켓</strong>이고, 하나는 <strong>클라이언트와 데이터 통신을 수행하기 위한 소켓</strong>이다.</p>

<ul>
<li><strong>서버소켓</strong>은 <strong>클라이언트가 접속하는 것을 대기하는 소켓</strong>이다. 따라서 클라이언트가 접속할 PORT 번호에서 <strong>대기(bind, listen)</strong>하고, 클라이언트가 연결을 요청할 때 <strong>수락(accept)</strong>하여 해당 클라이언트와 데이터 통신을 하기 위한 소켓을 만들어준다.</li>
<li>그렇게 만든 소켓을 사용하여 방금 연결된 클라이언트와 데이터 통신을 할 수 있는데, 이 때 소켓의 사용 방법은 클라이언트 때와 동일합니다.</li>
</ul>

<p>위의 두 예제를 실행하면, 서버가 클라이언트의 접속을 기다리고 있다가 클라이언트가 접속하면 &quot;Hello Java Network Programming World!&quot;라는 문자열을 보내고, 클라이언트가 이를 받아 console에 출력한 뒤 끝나는 결과를 볼 수 있다.</p>

<h3>결론</h3>

<p>쓰다보니 필요한 많은 개념들을 대충대충 넘어갔다.<br>
특히 중요한 blocking 개념을 설명하지 않고 넘어가다 보니 피상적으로 코드를 읽어주는 글이 되어버려서 아쉽다.</p>

<p>따라서 다음 글에서는 io의 blocking과 이를 해결하기 위한 multi-thread programming에 대해 간략히 알아보도록 하자.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">자바로 만드는 비행기 게임 1</h1>
				<p class="page-date">21 Sep 2011</p>
				<p class="page-tags">
						
						
					<code class="tag">java</code>
						
						
						
					<code class="tag">game</code>
						
						
						
						
				</p>
				<div class="content"><p>본 글타래에서는 자바를 사용하여 간단한 비행기 게임을 만드는 과정을 서술해볼까 한다.</p>

<p>원활한 자바 프로그래밍을 위해서, <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">JDK</a>와 <a href="http://eclipse.org/downloads/">Eclipse</a>가 설치되어있어야 한다.
이에 대한 자세한 설명은 생략하고, 멋들어진 이름으로 프로젝트를 하나 만들어보자.</p>

<p>예전에 제출했던 이름을 따와서 타티을(Tatieul)이라는 이름으로 class를 하나 만들었다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Tatieul</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>간단한 슈팅 게임을 만들어보자.</p>

<ul>
<li>비행기 같은게 나와서, (Graphics)</li>
<li>화살표 키를 통해 움직이고, (Event Handling)</li>
<li>적기가 등장하면 그걸 미사일을 쏴서 맞추고, (Collision Detecting)</li>
<li>적기가 쏘는 미사일을 피해야 한다. (Enemy AI)</li>
<li>여러 사람이 할 수 있다면 더 재밌을 것 같다. (Network)</li>
</ul>

<p>먼저 화면에 무언가를 그리려면 창을 띄워야 한다.
자바에서 창을 띄우려면 AWT(Abstract Window Toolkit)을 쓰거나, AWT의 확장 버전인 Swing을 쓰면 된다. 본 글에서는 개인적인 취향에 따라 Swing을 쓰도록 하겠다.</p>

<p>창을 띄우기 위해 <code>JFrame</code>을 사용하겠다. 사용하기 가장 쉬운 방법은? <strong>상속</strong> 해보는거다.
하지만 <code>JFrame</code>을 상속받으면 나중에 Graphics를 할 때 상당한 성능적 문제가 생긴다. (마치 ERASE_BACKGROUND 메시지에 의해 flickering 이 지속적으로 발생하는 것과 같은.)</p>

<p>아무튼 그런고로 무언가를 담을 수 있는 좋은 class인 <code>JPanel</code> class를 상속받는다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kn">import</span> <span class="nn">javax.swing.*</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Tatieul</span> <span class="kd">extends</span> <span class="n">JPanel</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">Tatieul</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">setPreferredSize</span><span class="o">(</span><span class="k">new</span> <span class="n">Dimension</span><span class="o">(</span><span class="mi">640</span><span class="o">,</span> <span class="mi">480</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">JFrame</span> <span class="n">frame</span> <span class="o">=</span> <span class="k">new</span> <span class="n">JFrame</span><span class="o">(</span><span class="s">&quot;Tatieul - New Generation Shooting Game&quot;</span><span class="o">);</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">setContentPane</span><span class="o">(</span><span class="k">new</span> <span class="n">Tatieul</span><span class="o">());</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">pack</span><span class="o">();</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">setDefaultCloseOperation</span><span class="o">(</span><span class="n">JFrame</span><span class="o">.</span><span class="na">EXIT_ON_CLOSE</span><span class="o">);</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">setVisible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>코드의 양이 확 늘어났지만 별로 하는 일은 없다.  </p>

<ul>
<li><code>JPanel</code> class를 상속 받은 <code>Tatieul</code> class가 생성될 때 자신의 크기를 640, 480으로 정한다.</li>
<li><code>main</code> 함수에서는 창을 띄우기 위한 <code>JFrame</code> 객체를 하나 만든다. 생성 인자로는 창의 Title을 넣을 수가 있다.</li>
<li><code>setContentPane</code> 함수를 사용해서 <code>Tatieul</code> 객체를 넣는다. 이제 창에 우리가 만든 Tatieul 객체가 보여지게 되는 것이다.</li>
<li><code>pack</code> 함수를 통해 창 크기를 contentPane의 크기에 맞춘다. contentPane은 방금 Tatieul 객체로 지정했는데, Tatieul 객체는 생성할 때 640, 480으로 크기를 지정했으니까 창의 크기도 <code>pack</code> 함수에 의해 640, 480이 된다.</li>
<li><code>setDefaultCloseOperation</code> 함수는 창이 종료될 때 어떤 동작을 할지 결정하는 함수다. <code>JFrame.EXIT_ON_CLOSE</code> 값을 인자로 주면 창을 끌 때 프로그램이 같이 끝난다. 만약 이 코드를 추가하지 않으면, 이 자바 프로그램은 창을 닫아도 메모리에 계속 남아있게 될 것이다!</li>
<li>마지막으로 <code>setVisible</code> 함수를 통해 완성된 <code>JFrame</code> 객체를 화면에 띄워준다.</li>
</ul>

<p>민둥 창 하나가 떴다. 이제 그림을 그려보자.
그림을 그리기 위해서는 <code>paintComponent</code> 함수를 override하면 된다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kn">import</span> <span class="nn">java.awt.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.swing.*</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Tatieul</span> <span class="kd">extends</span> <span class="n">JPanel</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">Tatieul</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">setPreferredSize</span><span class="o">(</span><span class="k">new</span> <span class="n">Dimension</span><span class="o">(</span><span class="mi">640</span><span class="o">,</span> <span class="mi">480</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">paintComponent</span><span class="o">(</span><span class="n">Graphics</span> <span class="n">g</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">g</span><span class="o">.</span><span class="na">setColor</span><span class="o">(</span><span class="n">Color</span><span class="o">.</span><span class="na">black</span><span class="o">);</span>
        <span class="n">g</span><span class="o">.</span><span class="na">fillRect</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">640</span><span class="o">,</span> <span class="mi">480</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">JFrame</span> <span class="n">frame</span> <span class="o">=</span> <span class="k">new</span> <span class="n">JFrame</span><span class="o">(</span><span class="s">&quot;Tatieul - New Generation Shooting Game&quot;</span><span class="o">);</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">setContentPane</span><span class="o">(</span><span class="k">new</span> <span class="n">Tatieul</span><span class="o">());</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">pack</span><span class="o">();</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">setDefaultCloseOperation</span><span class="o">(</span><span class="n">JFrame</span><span class="o">.</span><span class="na">EXIT_ON_CLOSE</span><span class="o">);</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">setVisible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p><code>paintComponent</code>란 함수를 보면 인자로 <code>Graphics</code> 객체를 받는다. <code>Graphics</code> 객체는 그림을 그리는데 필요한 여러 함수들을 가지고 있다.
일단 색상을 지정하는 <code>setColor</code> 함수와 사각 영역을 칠해주는 <code>fillRect</code> 함수를 통해서 창을 검게 만들어봤다.</p>

<p>이제 비행기를 그려보자.
일단, 비행기를 어디에 그려야할지 위치 정보가 있어야겠다. 화면은 2D이니까 x, y 좌표만 있으면 되겠다. 이를 저장하기 적절한 <code>Point</code> 객체를 써보자.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kn">import</span> <span class="nn">java.awt.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.swing.*</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Tatieul</span> <span class="kd">extends</span> <span class="n">JPanel</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Point</span> <span class="n">shipPos</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="o">(</span><span class="mi">320</span><span class="o">,</span> <span class="mi">400</span><span class="o">);</span>
    <span class="kd">public</span> <span class="nf">Tatieul</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">setPreferredSize</span><span class="o">(</span><span class="k">new</span> <span class="n">Dimension</span><span class="o">(</span><span class="mi">640</span><span class="o">,</span> <span class="mi">480</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">paintComponent</span><span class="o">(</span><span class="n">Graphics</span> <span class="n">g</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">g</span><span class="o">.</span><span class="na">setColor</span><span class="o">(</span><span class="n">Color</span><span class="o">.</span><span class="na">black</span><span class="o">);</span>
        <span class="n">g</span><span class="o">.</span><span class="na">fillRect</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">640</span><span class="o">,</span> <span class="mi">480</span><span class="o">);</span>
        <span class="n">g</span><span class="o">.</span><span class="na">setColor</span><span class="o">(</span><span class="n">Color</span><span class="o">.</span><span class="na">yellow</span><span class="o">);</span>
        <span class="n">g</span><span class="o">.</span><span class="na">fillOval</span><span class="o">(</span><span class="n">shipPos</span><span class="o">.</span><span class="na">x</span> <span class="o">-</span> <span class="mi">8</span><span class="o">,</span> <span class="n">shipPos</span><span class="o">.</span><span class="na">y</span> <span class="o">-</span> <span class="mi">16</span><span class="o">,</span> <span class="mi">16</span><span class="o">,</span> <span class="mi">32</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">JFrame</span> <span class="n">frame</span> <span class="o">=</span> <span class="k">new</span> <span class="n">JFrame</span><span class="o">(</span><span class="s">&quot;Tatieul - New Generation Shooting Game&quot;</span><span class="o">);</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">setContentPane</span><span class="o">(</span><span class="k">new</span> <span class="n">Tatieul</span><span class="o">());</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">pack</span><span class="o">();</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">setDefaultCloseOperation</span><span class="o">(</span><span class="n">JFrame</span><span class="o">.</span><span class="na">EXIT_ON_CLOSE</span><span class="o">);</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">setVisible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p><code>Point</code> 객체를 멤버 변수로 하나 갖는데 그 이름이 무려 <code>shipPos</code>다. 이름에서 느껴지듯이 플레이어의 Ship의 x, y 좌표 값을 저장한다. 기본값을 320, 480으로 주었다.
그리고 <code>paint</code> 함수에서 이 값을 사용해서 Ship을 그린다.
색을 노란색으로 지정하고, <code>fillOval</code> 함수를 사용해서 타원을 채운다. <code>shipPos</code>를 중심으로 가로길이 16, 세로길이 32짜리 타원을 그리는데 <code>shipPos</code>가 Ship의 중앙 지점이 되어야하므로 길이를 반으로 나눈 값을 x, y에서 빼주어서 중심 좌표에 타원을 그리도록 하였다.</p>

<p>이제 화살표키 입력을 통해 Ship 을 움직여보자.<br>
화살표키 입력을 받으려면 <code>KeyListener</code> 인터페이스의 구현체가 필요하다. 그리고 이 구현체를 <code>addKeyListener</code> 함수를 통해 넣어주면 키 입력에 대한 통지를 받을 수 있다.</p>

<p>간단하게 <code>Tatieul</code> class 에서 <code>KeyListener</code> interface를 구현해보자.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kn">import</span> <span class="nn">java.awt.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.awt.event.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.swing.*</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Tatieul</span> <span class="kd">extends</span> <span class="n">JPanel</span> <span class="kd">implements</span> <span class="n">KeyListener</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Point</span> <span class="n">shipPos</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="o">(</span><span class="mi">320</span><span class="o">,</span> <span class="mi">400</span><span class="o">);</span>
    <span class="kd">public</span> <span class="nf">Tatieul</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">setPreferredSize</span><span class="o">(</span><span class="k">new</span> <span class="n">Dimension</span><span class="o">(</span><span class="mi">640</span><span class="o">,</span> <span class="mi">480</span><span class="o">));</span>
        <span class="n">setFocusable</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
        <span class="n">addKeyListener</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">keyPressed</span><span class="o">(</span><span class="n">KeyEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">switch</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getKeyCode</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">case</span> <span class="n">KeyEvent</span><span class="o">.</span><span class="na">VK_UP</span><span class="o">:</span>    <span class="n">shipPos</span><span class="o">.</span><span class="na">y</span> <span class="o">-=</span> <span class="mi">10</span><span class="o">;</span> <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="n">KeyEvent</span><span class="o">.</span><span class="na">VK_DOWN</span><span class="o">:</span>  <span class="n">shipPos</span><span class="o">.</span><span class="na">y</span> <span class="o">+=</span> <span class="mi">10</span><span class="o">;</span> <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="n">KeyEvent</span><span class="o">.</span><span class="na">VK_LEFT</span><span class="o">:</span>  <span class="n">shipPos</span><span class="o">.</span><span class="na">x</span> <span class="o">-=</span> <span class="mi">10</span><span class="o">;</span> <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="n">KeyEvent</span><span class="o">.</span><span class="na">VK_RIGHT</span><span class="o">:</span> <span class="n">shipPos</span><span class="o">.</span><span class="na">x</span> <span class="o">+=</span> <span class="mi">10</span><span class="o">;</span> <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">repaint</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">keyReleased</span><span class="o">(</span><span class="n">KeyEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">{}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">keyTyped</span><span class="o">(</span><span class="n">KeyEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">{}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">paintComponent</span><span class="o">(</span><span class="n">Graphics</span> <span class="n">g</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">g</span><span class="o">.</span><span class="na">setColor</span><span class="o">(</span><span class="n">Color</span><span class="o">.</span><span class="na">black</span><span class="o">);</span>
        <span class="n">g</span><span class="o">.</span><span class="na">fillRect</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">640</span><span class="o">,</span> <span class="mi">480</span><span class="o">);</span>
        <span class="n">g</span><span class="o">.</span><span class="na">setColor</span><span class="o">(</span><span class="n">Color</span><span class="o">.</span><span class="na">yellow</span><span class="o">);</span>
        <span class="n">g</span><span class="o">.</span><span class="na">fillOval</span><span class="o">(</span><span class="n">shipPos</span><span class="o">.</span><span class="na">x</span> <span class="o">-</span> <span class="mi">8</span><span class="o">,</span> <span class="n">shipPos</span><span class="o">.</span><span class="na">y</span> <span class="o">-</span> <span class="mi">16</span><span class="o">,</span> <span class="mi">16</span><span class="o">,</span> <span class="mi">32</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">JFrame</span> <span class="n">frame</span> <span class="o">=</span> <span class="k">new</span> <span class="n">JFrame</span><span class="o">(</span><span class="s">&quot;Tatieul - New Generation Shooting Game&quot;</span><span class="o">);</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">setContentPane</span><span class="o">(</span><span class="k">new</span> <span class="n">Tatieul</span><span class="o">());</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">pack</span><span class="o">();</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">setLocationRelativeTo</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">setDefaultCloseOperation</span><span class="o">(</span><span class="n">JFrame</span><span class="o">.</span><span class="na">EXIT_ON_CLOSE</span><span class="o">);</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">setVisible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p><code>KeyListener</code> interface를 구현하면 3개의 함수를 반드시 구현해야한다.
<code>keyPressed</code>, <code>keyReleased</code>, <code>keyTyped</code> 함수가 그것인데, 비행기를 움직일 때는 키가 눌렸을 때 바로 처리할 것이기 때문에 나머지 두 개의 함수는 쓸 일이 없고, <code>keyPressed</code> 함수에서만 어떤 key가 눌렸는지 분기해서 <code>shipPos</code> 값을 변경하도록 한다.</p>

<p>그리고 변경을 한 다음에는 반드시 <code>repaint</code> 함수를 호출하여 변경된 비행기를 화면에 다시 그려주어야 한다.</p>

<p>이러한 key 처리 코드가 제대로 동작하려면 key 입력 통지를 받아야 한다.<br>
생성자에서 보면 <code>addKeyListener(this)</code>와 같은 코드가 있다. <code>JPanel</code> class를 상속받은 Tatieul 객체에서 키 입력이 발생하면 그것을 <code>this</code>에게 알려주겠다는 것이다. 즉, 키가 눌리면 <code>Tatieul</code> class의 <code>keyPressed</code> 함수가 호출되게 된다는 것이다.</p>

<p>빼먹으면 안 되는 것이 하나 있다. 바로 <code>addKeyListener</code> 함수 위에 있는 <code>setFocusable(true)</code> 인데,
이것을 true로 주지 않으면 <code>JPanel</code> 객체는 focusable하지 않은 상태가 되어서 키 입력을 받지 못하는 상태가 되어버린다!<br>
따라서 키 입력을 받을 수 있도록 focusing이 가능하게 해주어야 한다는 것이다.</p>

<p>숨가쁘게 비행기를 움직이는 것까지 진행해보았다.
다음은 미사일을 쏘는 것에 대해서 해보자.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">자바로 만드는 비행기 게임 2</h1>
				<p class="page-date">22 Sep 2011</p>
				<p class="page-tags">
						
						
					<code class="tag">java</code>
						
						
						
					<code class="tag">game</code>
						
						
						
						
				</p>
				<div class="content"><p>노란색 타원 대신 비행기 이미지를 제대로 띄워보자.<br>
자바에서 이미지를 읽는 것은 간단하다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="n">java</span><span class="o">.</span><span class="na">awt</span><span class="o">.</span><span class="na">Image</span> <span class="n">ship</span> <span class="o">=</span> <span class="n">java</span><span class="o">.</span><span class="na">awt</span><span class="o">.</span><span class="na">Toolkit</span><span class="o">.</span><span class="na">getDefaultToolkit</span><span class="o">().</span><span class="na">getImage</span><span class="o">(</span><span class="s">&quot;player.gif&quot;</span><span class="o">);</span>
</code></pre></div>
<p>AWT에서 제공해주는 <code>Toolkit</code>의 helper function인 <code>getImage</code> 함수를 통해 이미지 객체를 얻을 수 있다. (물론 player.gif 는 프로젝트 안에 들어있어야 한다.)</p>

<p>그럼 이제 그리는 방법을 알아보자.<br>
그림을 그리는 것도 당연하지만, <code>Graphics</code> 객체가 존재하는 <code>paintComponent</code> 함수에서 이루어진다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">paintComponent</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">awt</span><span class="o">.</span><span class="na">Graphics</span> <span class="n">g</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">g</span><span class="o">.</span><span class="na">drawImage</span><span class="o">(</span><span class="n">ship</span><span class="o">,</span> <span class="n">shipPos</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">shipPos</span><span class="o">.</span><span class="na">y</span><span class="o">,</span> <span class="k">this</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p>마지막에 들어가는 this는 <code>ImageObserver</code> 라고 한다.
Toolkit은 큰 Image를 읽어달라고 요청받으면 MediaTracker라는 요상한 것을 써서 비동기적으로 읽고 그 결과를 <code>ImageObserver</code>에게 알려준다.
즉,</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="n">java</span><span class="o">.</span><span class="na">awt</span><span class="o">.</span><span class="na">Image</span> <span class="n">ship</span> <span class="o">=</span> <span class="n">java</span><span class="o">.</span><span class="na">awt</span><span class="o">.</span><span class="na">Toolkit</span><span class="o">.</span><span class="na">getDefaultToolkit</span><span class="o">().</span><span class="na">getImage</span><span class="o">(</span><span class="s">&quot;veryBigShip.bmp&quot;</span><span class="o">);</span>
<span class="kt">int</span> <span class="n">shipWidth</span> <span class="o">=</span> <span class="n">ship</span><span class="o">.</span><span class="na">getWidth</span><span class="o">()</span>
</code></pre></div>
<p>와 같이 했을 때 ship 객체는 아직 데이터가 읽어지지 않은 상태에서 <code>getWidth</code> 함수가 호출되어 저기서 반환되는 값이 이상한 값이 될 수가 있다. (이 때문에 ImageIO 와 BufferedImage 객체를 쓰지만 그건 나중에 이야기하자)<br>
따라서 <code>ImageObserver</code>라는 callback을 써서 데이터가 없을 때는 일단 가짜 정보가 반환되고, 실제로 로딩이 완료되면 <code>ImageObserver</code> 내의 <code>imageUpdate</code> 함수를 호출해주어서 이미지 로딩 완료를 알려준다는 것이다.</p>

<p>여기서 this는 <code>JPanel</code> 객체이다. AWT 라이브러리들은 기본 <code>imageUpdate</code> 함수가 구현되어있으므로 처리하기 귀찮은 <code>ImageObserver</code>에는 <code>this</code>를 넣어주면 된다.<br>
(자세하게 설명하는건 이 글타래의 취지에 맞지 않으니 더 이상의 자세한 설명은 생략한다.)</p>

<p>아무튼 위의 방법으로 비행기를 그리면 중앙이 맞지 않기 때문에 그림의 width, height 값으로 보정을 해주어야한다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">paintComponent</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">awt</span><span class="o">.</span><span class="na">Graphics</span> <span class="n">g</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">g</span><span class="o">.</span><span class="na">drawImage</span><span class="o">(</span><span class="n">ship</span><span class="o">,</span> <span class="n">shipPos</span><span class="o">.</span><span class="na">x</span> <span class="o">-</span> <span class="n">ship</span><span class="o">.</span><span class="na">getWidth</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="n">shipPos</span><span class="o">.</span><span class="na">y</span> <span class="o">-</span> <span class="n">ship</span><span class="o">.</span><span class="na">getHeight</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="k">this</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p>매번 width와 height를 가져와달라고 호출하니 효율이 영 좋지 못할 것 같지만, 자바로 짜는 상황에서 효율을 너무 고려하면 슬퍼지니까 그러려니 하고 넘어가자.</p>

<p>player.gif 파일의 배경이 흰색이므로, 게임 전체 배경색도 흰색으로 바꾸자.
그러면 전체적으로 아래와 같은 코드가 된다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kn">import</span> <span class="nn">java.awt.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.awt.event.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.swing.*</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Tatieul</span> <span class="kd">extends</span> <span class="n">JPanel</span> <span class="kd">implements</span> <span class="n">KeyListener</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Point</span> <span class="n">shipPos</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="o">(</span><span class="mi">320</span><span class="o">,</span> <span class="mi">400</span><span class="o">);</span>
    <span class="kd">private</span> <span class="n">Image</span> <span class="n">ship</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Tatieul</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">setPreferredSize</span><span class="o">(</span><span class="k">new</span> <span class="n">Dimension</span><span class="o">(</span><span class="mi">640</span><span class="o">,</span> <span class="mi">480</span><span class="o">));</span>
        <span class="n">setFocusable</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
        <span class="n">addKeyListener</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="n">ship</span> <span class="o">=</span> <span class="n">Toolkit</span><span class="o">.</span><span class="na">getDefaultToolkit</span><span class="o">().</span><span class="na">getImage</span><span class="o">(</span><span class="s">&quot;player.gif&quot;</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">keyPressed</span><span class="o">(</span><span class="n">KeyEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">switch</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getKeyCode</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">case</span> <span class="n">KeyEvent</span><span class="o">.</span><span class="na">VK_UP</span><span class="o">:</span>    <span class="n">shipPos</span><span class="o">.</span><span class="na">y</span> <span class="o">-=</span> <span class="mi">10</span><span class="o">;</span> <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="n">KeyEvent</span><span class="o">.</span><span class="na">VK_DOWN</span><span class="o">:</span>  <span class="n">shipPos</span><span class="o">.</span><span class="na">y</span> <span class="o">+=</span> <span class="mi">10</span><span class="o">;</span> <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="n">KeyEvent</span><span class="o">.</span><span class="na">VK_LEFT</span><span class="o">:</span>  <span class="n">shipPos</span><span class="o">.</span><span class="na">x</span> <span class="o">-=</span> <span class="mi">10</span><span class="o">;</span> <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="n">KeyEvent</span><span class="o">.</span><span class="na">VK_RIGHT</span><span class="o">:</span> <span class="n">shipPos</span><span class="o">.</span><span class="na">x</span> <span class="o">+=</span> <span class="mi">10</span><span class="o">;</span> <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">repaint</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">keyReleased</span><span class="o">(</span><span class="n">KeyEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">{}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">keyTyped</span><span class="o">(</span><span class="n">KeyEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">{}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">paintComponent</span><span class="o">(</span><span class="n">Graphics</span> <span class="n">g</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">g</span><span class="o">.</span><span class="na">setColor</span><span class="o">(</span><span class="n">Color</span><span class="o">.</span><span class="na">white</span><span class="o">);</span>
        <span class="n">g</span><span class="o">.</span><span class="na">fillRect</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">640</span><span class="o">,</span> <span class="mi">480</span><span class="o">);</span>
        <span class="n">g</span><span class="o">.</span><span class="na">drawImage</span><span class="o">(</span><span class="n">ship</span><span class="o">,</span> <span class="n">shipPos</span><span class="o">.</span><span class="na">x</span> <span class="o">-</span> <span class="n">ship</span><span class="o">.</span><span class="na">getWidth</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="n">shipPos</span><span class="o">.</span><span class="na">y</span> <span class="o">-</span> <span class="n">ship</span><span class="o">.</span><span class="na">getHeight</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="k">this</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">JFrame</span> <span class="n">frame</span> <span class="o">=</span> <span class="k">new</span> <span class="n">JFrame</span><span class="o">(</span><span class="s">&quot;Tatieul - New Generation Shooting Game&quot;</span><span class="o">);</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">setContentPane</span><span class="o">(</span><span class="k">new</span> <span class="n">Tatieul</span><span class="o">());</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">pack</span><span class="o">();</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">setLocationRelativeTo</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">setDefaultCloseOperation</span><span class="o">(</span><span class="n">JFrame</span><span class="o">.</span><span class="na">EXIT_ON_CLOSE</span><span class="o">);</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">setVisible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>자 이제 총알을 날려보자.<br>
Space키를 누르면 총알을 만든다. 그 총알은 당연히 위로(-y) 올라갈 것이고, 화면에서 사라지면(y &lt; 0) 소멸될 것이다.</p>

<p>먼저 Space키를 누르면 총알을 만들자. 총알의 종류가 하나 밖에 없으니, 위치 정보만 저장해두자.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">bullets</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;();</span>
</code></pre></div>
<p>이제 Space \를 누르면 총알을 만들어보자.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="k">switch</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getKeyCode</span><span class="o">())</span> <span class="o">{</span>
<span class="k">case</span> <span class="n">KeyEvent</span><span class="o">.</span><span class="na">VK_SPACE</span><span class="o">:</span> <span class="n">bullets</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Point</span><span class="o">(</span><span class="n">shipPos</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">shipPos</span><span class="o">.</span><span class="na">y</span><span class="o">);</span> <span class="k">break</span><span class="o">;</span>
</code></pre></div>
<p>비행기가 어차피 <code>shipPos</code>를 중앙 삼아서 그려지므로, 위와 같이 총알을 만들면 비행기 한 가운데서 총알이 나가는 것 처럼 보일 것이다.</p>

<p>이제 시간에 따라 총알이 앞으로 나가야할 것이다.</p>

<p>시간에 따라 이벤트가 발생하려면 Timer 를 쓰면 된다.<br>
하지만 Timer 라고 하면 <code>java.util.Timer</code>와 <code>javax.swing.Timer</code> 2개가 있다.
UI Thread에 의해 동기적으로 처리하는 것이 로직 구성하는데 편하니까 <code>javax.swing.Timer</code>를 쓸거다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">public</span> <span class="nf">Tatieul</span><span class="o">()</span> <span class="o">{</span> <span class="c1">// Constructor</span>
    <span class="k">new</span> <span class="n">javax</span><span class="o">.</span><span class="na">swing</span><span class="o">.</span><span class="na">Timer</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span> <span class="k">this</span><span class="o">);</span>
</code></pre></div>
<p>이제 Timer는 100ms마다 한 번씩 this의 <code>actionPerformed</code> 함수를 불러준다. 즉, <code>Tatieul</code> class는 <code>ActionListener</code> interface를 구현해야 한다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Tatieul</span> <span class="kd">extends</span> <span class="n">JPanel</span> <span class="kd">implements</span> <span class="n">KeyListener</span><span class="o">,</span> <span class="n">ActionListener</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">actionPerformed</span><span class="o">(</span><span class="n">ActionEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// update bullets</span>
    <span class="o">}</span>
</code></pre></div>
<p>총알은 <code>bullets</code>에 저장되어있다. 이 자료구조를 한 번 돌면서 y 값을 갱신해주면 되겠다.
하지만, y가 음수인 것에 대해서는 목록에서 빼야하니까, 귀찮다. 이 두 가지를 한 번에 하기 위해 Iterator를 쓰자. (enhanced for 문에서는 중간에 remove 가 불가능하니까.)</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="n">Iterator</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">bullets</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
<span class="k">while</span> <span class="o">(</span><span class="n">iterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
    <span class="n">Point</span> <span class="n">bullet</span> <span class="o">=</span> <span class="n">iterator</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
    <span class="n">bullet</span><span class="o">.</span><span class="na">y</span> <span class="o">-=</span> <span class="mi">20</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">bullet</span><span class="o">.</span><span class="na">y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
        <span class="n">iterator</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
<span class="o">}</span>
<span class="n">repaint</span><span class="o">();</span>
</code></pre></div>
<p>총알의 위치를 갱신했으면 꼭 <code>repaint</code> 함수를 불러줘야 한다. 그래야 갱신된 위치로 총알을 다시 그린다.</p>

<p>이제 <code>paintComponent</code> 함수에서 <code>bullets</code> 목록을 돌면서, 총알을 그려보자.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">paintComponent</span><span class="o">(</span><span class="n">Graphics</span> <span class="n">g</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">g</span><span class="o">.</span><span class="na">setColor</span><span class="o">(</span><span class="n">Color</span><span class="o">.</span><span class="na">black</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Point</span> <span class="nl">bullet:</span> <span class="n">bullets</span><span class="o">)</span>
        <span class="n">g</span><span class="o">.</span><span class="na">drawLine</span><span class="o">(</span><span class="n">bullet</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">bullet</span><span class="o">.</span><span class="na">y</span><span class="o">,</span> <span class="n">bullet</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">bullet</span><span class="o">.</span><span class="na">y</span> <span class="o">-</span> <span class="mi">4</span><span class="o">);</span>
</code></pre></div>
<p>여기까지하면 전체적인 코드는 다음과 같다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.awt.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.awt.event.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.swing.*</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Tatieul</span> <span class="kd">extends</span> <span class="n">JPanel</span> <span class="kd">implements</span> <span class="n">KeyListener</span><span class="o">,</span> <span class="n">ActionListener</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Point</span> <span class="n">shipPos</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="o">(</span><span class="mi">320</span><span class="o">,</span> <span class="mi">400</span><span class="o">);</span>
    <span class="kd">private</span> <span class="n">Image</span> <span class="n">ship</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">bullets</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;();</span>
    <span class="kd">public</span> <span class="nf">Tatieul</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">setPreferredSize</span><span class="o">(</span><span class="k">new</span> <span class="n">Dimension</span><span class="o">(</span><span class="mi">640</span><span class="o">,</span> <span class="mi">480</span><span class="o">));</span>
        <span class="n">setFocusable</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
        <span class="n">addKeyListener</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="n">ship</span> <span class="o">=</span> <span class="n">Toolkit</span><span class="o">.</span><span class="na">getDefaultToolkit</span><span class="o">().</span><span class="na">getImage</span><span class="o">(</span><span class="s">&quot;player.gif&quot;</span><span class="o">);</span>
        <span class="k">new</span> <span class="n">javax</span><span class="o">.</span><span class="na">swing</span><span class="o">.</span><span class="na">Timer</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span> <span class="k">this</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">keyPressed</span><span class="o">(</span><span class="n">KeyEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">switch</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getKeyCode</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">case</span> <span class="n">KeyEvent</span><span class="o">.</span><span class="na">VK_UP</span><span class="o">:</span>    <span class="n">shipPos</span><span class="o">.</span><span class="na">y</span> <span class="o">-=</span> <span class="mi">10</span><span class="o">;</span> <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="n">KeyEvent</span><span class="o">.</span><span class="na">VK_DOWN</span><span class="o">:</span>  <span class="n">shipPos</span><span class="o">.</span><span class="na">y</span> <span class="o">+=</span> <span class="mi">10</span><span class="o">;</span> <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="n">KeyEvent</span><span class="o">.</span><span class="na">VK_LEFT</span><span class="o">:</span>  <span class="n">shipPos</span><span class="o">.</span><span class="na">x</span> <span class="o">-=</span> <span class="mi">10</span><span class="o">;</span> <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="n">KeyEvent</span><span class="o">.</span><span class="na">VK_RIGHT</span><span class="o">:</span> <span class="n">shipPos</span><span class="o">.</span><span class="na">x</span> <span class="o">+=</span> <span class="mi">10</span><span class="o">;</span> <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="n">KeyEvent</span><span class="o">.</span><span class="na">VK_SPACE</span><span class="o">:</span> <span class="n">bullets</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Point</span><span class="o">(</span><span class="n">shipPos</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">shipPos</span><span class="o">.</span><span class="na">y</span><span class="o">));</span> <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">repaint</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">actionPerformed</span><span class="o">(</span><span class="n">ActionEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">bullets</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">iterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">Point</span> <span class="n">bullet</span> <span class="o">=</span> <span class="n">iterator</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
            <span class="n">bullet</span><span class="o">.</span><span class="na">y</span> <span class="o">-=</span> <span class="mi">20</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">bullet</span><span class="o">.</span><span class="na">y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
                <span class="n">iterator</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">repaint</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">keyReleased</span><span class="o">(</span><span class="n">KeyEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">{}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">keyTyped</span><span class="o">(</span><span class="n">KeyEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">{}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">paintComponent</span><span class="o">(</span><span class="n">Graphics</span> <span class="n">g</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">g</span><span class="o">.</span><span class="na">setColor</span><span class="o">(</span><span class="n">Color</span><span class="o">.</span><span class="na">white</span><span class="o">);</span>
        <span class="n">g</span><span class="o">.</span><span class="na">fillRect</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">640</span><span class="o">,</span> <span class="mi">480</span><span class="o">);</span>
        <span class="n">g</span><span class="o">.</span><span class="na">drawImage</span><span class="o">(</span><span class="n">ship</span><span class="o">,</span> <span class="n">shipPos</span><span class="o">.</span><span class="na">x</span> <span class="o">-</span> <span class="n">ship</span><span class="o">.</span><span class="na">getWidth</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="n">shipPos</span><span class="o">.</span><span class="na">y</span> <span class="o">-</span> <span class="n">ship</span><span class="o">.</span><span class="na">getHeight</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="k">this</span><span class="o">);</span>
        <span class="n">g</span><span class="o">.</span><span class="na">setColor</span><span class="o">(</span><span class="n">Color</span><span class="o">.</span><span class="na">black</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Point</span> <span class="nl">bullet:</span> <span class="n">bullets</span><span class="o">)</span>
            <span class="n">g</span><span class="o">.</span><span class="na">drawLine</span><span class="o">(</span><span class="n">bullet</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">bullet</span><span class="o">.</span><span class="na">y</span><span class="o">,</span> <span class="n">bullet</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">bullet</span><span class="o">.</span><span class="na">y</span> <span class="o">-</span> <span class="mi">4</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">JFrame</span> <span class="n">frame</span> <span class="o">=</span> <span class="k">new</span> <span class="n">JFrame</span><span class="o">(</span><span class="s">&quot;Tatieul - New Generation Shooting Game&quot;</span><span class="o">);</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">setContentPane</span><span class="o">(</span><span class="k">new</span> <span class="n">Tatieul</span><span class="o">());</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">pack</span><span class="o">();</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">setLocationRelativeTo</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">setDefaultCloseOperation</span><span class="o">(</span><span class="n">JFrame</span><span class="o">.</span><span class="na">EXIT_ON_CLOSE</span><span class="o">);</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">setVisible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>여기까지 따라 해봤다면, 키 입력에 상당한 불만이 생길 것이다.
Space키를 누르면서 방향 키를 누르면, 분명 총알도 나가면서 이동도 되면 좋겠지만 전혀 그렇지 않고 총알이 안 나간채로 움직이기만 하는 것을 볼 수 있다.</p>

<p>이러한 것을 단박에 개선하고 싶지만, 일단 다음은 적기 출현과 충돌 검사를 먼저 구현해보자.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">자바로 만드는 비행기 게임 3</h1>
				<p class="page-date">06 Nov 2011</p>
				<p class="page-tags">
						
						
					<code class="tag">java</code>
						
						
						
					<code class="tag">game</code>
						
						
						
						
				</p>
				<div class="content"><p>이번에는 적기의 등장과 충돌검사를 해보자.</p>

<p>적기는, <code>y=0</code>에서 등장해서 <code>y=height</code>까지 진행한다. 즉, 화면 위쪽에서 아래쪽으로 일직선으로 진행하도록 하자. 그러면 진행하는 y 값은 항상 동일할테니까<code>(0 -&gt; height)</code> 시작과 끝 x 값을 random으로 뽑으면 된다.</p>

<p>적기의 속도를 다양하게 한다고 한다면 원래 속도를 랜덤하게 구해서 그만큼씩 이동하게 하겠지만, 그렇게 계산해주기 귀찮으니까 등장 시간을 랜덤하게 뽑고(5초에서 10초 사이) 그 시간에 대해 랜덤한 시작좌표 ~ 끝좌표를 토대로 매 tick(100ms)마다 얼마나 이동하면 될지 delta를 구한다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">class</span> <span class="nc">EnemyPos</span> <span class="o">{</span>
    <span class="n">Point2D</span> <span class="n">delta</span><span class="o">,</span> <span class="n">current</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">EnemyPos</span><span class="o">(</span><span class="kt">int</span> <span class="n">shipHeight</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Random</span> <span class="n">rand</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Random</span><span class="o">();</span>
        <span class="kt">float</span> <span class="n">lifetime</span> <span class="o">=</span> <span class="n">rand</span><span class="o">.</span><span class="na">nextFloat</span><span class="o">()</span> <span class="o">*</span> <span class="mi">50</span> <span class="o">+</span> <span class="mi">50</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">startX</span> <span class="o">=</span> <span class="n">rand</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">640</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">endX</span> <span class="o">=</span> <span class="n">rand</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">640</span><span class="o">);</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point2D</span><span class="o">.</span><span class="na">Float</span><span class="o">((</span><span class="n">endX</span> <span class="o">-</span> <span class="n">startX</span><span class="o">)</span> <span class="o">/</span> <span class="n">lifetime</span><span class="o">,</span> <span class="o">(</span><span class="mi">480</span> <span class="o">+</span> <span class="n">shipHeight</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span> <span class="o">/</span> <span class="n">lifetime</span><span class="o">);</span>
        <span class="n">current</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point2D</span><span class="o">.</span><span class="na">Float</span><span class="o">(</span><span class="n">startX</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">shipHeight</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>그러면 매 tick마다 current는 delta만큼 더해주면 된다. 시작 y와 끝 y는 적기가 완전히 지나갈 수 있도록 비행기 그림의 height만큼씩 더 고려해주었다.</p>

<p>적기를 만들어주는 것도 여러 고려할 것이 있겠지만, 귀찮으니까 랜덤한 시간으로 만들어준다. 일단 <code>spawnTick</code>이라는걸 두어서, 현재 시간이 <code>spawnTick</code>을 넘어갈 때만 적기를 만들고, 그 후 <code>spawnTick</code>을 랜덤하게 갱신한다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">private</span> <span class="kt">long</span> <span class="n">spawnTick</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">generateEnemy</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">spawnTick</span> <span class="o">&lt;</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">spawnTick</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()</span> <span class="o">+</span> <span class="k">new</span> <span class="n">Random</span><span class="o">().</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">2000</span><span class="o">)</span> <span class="o">+</span> <span class="mi">500</span><span class="o">;</span>
        <span class="n">enemies</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">EnemyPos</span><span class="o">(</span><span class="n">enemy</span><span class="o">.</span><span class="na">getHeight</span><span class="o">(</span><span class="k">this</span><span class="o">)));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>이제 매 Tick마다 적기가 움직일 수 있도록 위치 갱신을 해준다. 적기는 +y 방향으로 진행하며, 대충 화면 크기 height가 480 이니까 560정도 지나갈 때 비행기를 없애준다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">private</span> <span class="kt">void</span> <span class="nf">updateEnemyPos</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">EnemyPos</span><span class="o">&gt;</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">enemies</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">iterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">EnemyPos</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">iterator</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
        <span class="n">pos</span><span class="o">.</span><span class="na">current</span><span class="o">.</span><span class="na">setLocation</span><span class="o">(</span><span class="n">pos</span><span class="o">.</span><span class="na">current</span><span class="o">.</span><span class="na">getX</span><span class="o">()</span> <span class="o">+</span> <span class="n">pos</span><span class="o">.</span><span class="na">delta</span><span class="o">.</span><span class="na">getX</span><span class="o">(),</span> 
                <span class="n">pos</span><span class="o">.</span><span class="na">current</span><span class="o">.</span><span class="na">getY</span><span class="o">()</span> <span class="o">+</span> <span class="n">pos</span><span class="o">.</span><span class="na">delta</span><span class="o">.</span><span class="na">getY</span><span class="o">());</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">pos</span><span class="o">.</span><span class="na">current</span><span class="o">.</span><span class="na">getY</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">560</span><span class="o">)</span>
            <span class="n">iterator</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>미리 매 tick마다 얼마나 움직일 지 계산해놨으니까, 현재의 위치는 거기서 더해주기만 하면 된다.</p>

<p>이제 적기도 그려주자. <code>paint</code> 함수에 현재 존재하는 적기들을 그려주도록 하면 된다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="k">for</span> <span class="o">(</span><span class="n">EnemyPos</span> <span class="nl">enemyPos:</span> <span class="n">enemies</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">g</span><span class="o">.</span><span class="na">drawImage</span><span class="o">(</span><span class="n">enemy</span><span class="o">,</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">enemyPos</span><span class="o">.</span><span class="na">current</span><span class="o">.</span><span class="na">getX</span><span class="o">()</span> <span class="o">-</span> <span class="n">enemy</span><span class="o">.</span><span class="na">getWidth</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span>
        <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">enemyPos</span><span class="o">.</span><span class="na">current</span><span class="o">.</span><span class="na">getY</span><span class="o">()</span> <span class="o">-</span> <span class="n">enemy</span><span class="o">.</span><span class="na">getHeight</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="k">this</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p>이제 랜덤한 시간에 랜덤한 위치로 적기가 생성되어서 +y 방향으로 진행하는 것을 볼 수 있다.</p>

<p>여기까지 코드는 다음과 같다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.awt.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.awt.event.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.awt.geom.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.swing.*</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Tatieul</span> <span class="kd">extends</span> <span class="n">JPanel</span> <span class="kd">implements</span> <span class="n">KeyListener</span><span class="o">,</span> <span class="n">ActionListener</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Point</span> <span class="n">shipPos</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="o">(</span><span class="mi">320</span><span class="o">,</span> <span class="mi">400</span><span class="o">);</span>
    <span class="kd">private</span> <span class="n">Image</span> <span class="n">ship</span><span class="o">,</span> <span class="n">enemy</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">bullets</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;();</span>
    <span class="kd">private</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">EnemyPos</span><span class="o">&gt;</span> <span class="n">enemies</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">EnemyPos</span><span class="o">&gt;();</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">spawnTick</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Tatieul</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">setPreferredSize</span><span class="o">(</span><span class="k">new</span> <span class="n">Dimension</span><span class="o">(</span><span class="mi">640</span><span class="o">,</span> <span class="mi">480</span><span class="o">));</span>
        <span class="n">setFocusable</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
        <span class="n">addKeyListener</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="n">ship</span> <span class="o">=</span> <span class="n">Toolkit</span><span class="o">.</span><span class="na">getDefaultToolkit</span><span class="o">().</span><span class="na">getImage</span><span class="o">(</span><span class="s">&quot;player.png&quot;</span><span class="o">);</span>
        <span class="n">enemy</span> <span class="o">=</span> <span class="n">Toolkit</span><span class="o">.</span><span class="na">getDefaultToolkit</span><span class="o">().</span><span class="na">getImage</span><span class="o">(</span><span class="s">&quot;enemy.png&quot;</span><span class="o">);</span>
        <span class="k">new</span> <span class="n">javax</span><span class="o">.</span><span class="na">swing</span><span class="o">.</span><span class="na">Timer</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span> <span class="k">this</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">keyPressed</span><span class="o">(</span><span class="n">KeyEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">switch</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getKeyCode</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">case</span> <span class="n">KeyEvent</span><span class="o">.</span><span class="na">VK_UP</span><span class="o">:</span>    <span class="n">shipPos</span><span class="o">.</span><span class="na">y</span> <span class="o">-=</span> <span class="mi">10</span><span class="o">;</span> <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="n">KeyEvent</span><span class="o">.</span><span class="na">VK_DOWN</span><span class="o">:</span>  <span class="n">shipPos</span><span class="o">.</span><span class="na">y</span> <span class="o">+=</span> <span class="mi">10</span><span class="o">;</span> <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="n">KeyEvent</span><span class="o">.</span><span class="na">VK_LEFT</span><span class="o">:</span>  <span class="n">shipPos</span><span class="o">.</span><span class="na">x</span> <span class="o">-=</span> <span class="mi">10</span><span class="o">;</span> <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="n">KeyEvent</span><span class="o">.</span><span class="na">VK_RIGHT</span><span class="o">:</span> <span class="n">shipPos</span><span class="o">.</span><span class="na">x</span> <span class="o">+=</span> <span class="mi">10</span><span class="o">;</span> <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="n">KeyEvent</span><span class="o">.</span><span class="na">VK_SPACE</span><span class="o">:</span> <span class="n">bullets</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Point</span><span class="o">(</span><span class="n">shipPos</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">shipPos</span><span class="o">.</span><span class="na">y</span><span class="o">));</span> <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">repaint</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">actionPerformed</span><span class="o">(</span><span class="n">ActionEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">updateEnemyPos</span><span class="o">();</span>
        <span class="n">updateBullets</span><span class="o">();</span>
        <span class="n">generateEnemy</span><span class="o">();</span>
        <span class="n">repaint</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">generateEnemy</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">spawnTick</span> <span class="o">&lt;</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">spawnTick</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()</span> <span class="o">+</span> <span class="k">new</span> <span class="n">Random</span><span class="o">().</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">2000</span><span class="o">)</span> <span class="o">+</span> <span class="mi">500</span><span class="o">;</span>
            <span class="n">enemies</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">EnemyPos</span><span class="o">(</span><span class="n">enemy</span><span class="o">.</span><span class="na">getHeight</span><span class="o">(</span><span class="k">this</span><span class="o">)));</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">updateEnemyPos</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">EnemyPos</span><span class="o">&gt;</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">enemies</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">iterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">EnemyPos</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">iterator</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
            <span class="n">pos</span><span class="o">.</span><span class="na">current</span><span class="o">.</span><span class="na">setLocation</span><span class="o">(</span><span class="n">pos</span><span class="o">.</span><span class="na">current</span><span class="o">.</span><span class="na">getX</span><span class="o">()</span> <span class="o">+</span> <span class="n">pos</span><span class="o">.</span><span class="na">delta</span><span class="o">.</span><span class="na">getX</span><span class="o">(),</span> 
                    <span class="n">pos</span><span class="o">.</span><span class="na">current</span><span class="o">.</span><span class="na">getY</span><span class="o">()</span> <span class="o">+</span> <span class="n">pos</span><span class="o">.</span><span class="na">delta</span><span class="o">.</span><span class="na">getY</span><span class="o">());</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">pos</span><span class="o">.</span><span class="na">current</span><span class="o">.</span><span class="na">getY</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">560</span><span class="o">)</span>
                <span class="n">iterator</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">updateBullets</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">bullets</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">iterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">Point</span> <span class="n">bullet</span> <span class="o">=</span> <span class="n">iterator</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
            <span class="n">bullet</span><span class="o">.</span><span class="na">y</span> <span class="o">-=</span> <span class="mi">20</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">bullet</span><span class="o">.</span><span class="na">y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
                <span class="n">iterator</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">keyReleased</span><span class="o">(</span><span class="n">KeyEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">{}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">keyTyped</span><span class="o">(</span><span class="n">KeyEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">{}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">paintComponent</span><span class="o">(</span><span class="n">Graphics</span> <span class="n">g</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">g</span><span class="o">.</span><span class="na">setColor</span><span class="o">(</span><span class="n">Color</span><span class="o">.</span><span class="na">white</span><span class="o">);</span>
        <span class="n">g</span><span class="o">.</span><span class="na">fillRect</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">640</span><span class="o">,</span> <span class="mi">480</span><span class="o">);</span>
        <span class="n">g</span><span class="o">.</span><span class="na">drawImage</span><span class="o">(</span><span class="n">ship</span><span class="o">,</span> <span class="n">shipPos</span><span class="o">.</span><span class="na">x</span> <span class="o">-</span> <span class="n">ship</span><span class="o">.</span><span class="na">getWidth</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="n">shipPos</span><span class="o">.</span><span class="na">y</span> <span class="o">-</span> <span class="n">ship</span><span class="o">.</span><span class="na">getHeight</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="k">this</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">EnemyPos</span> <span class="nl">enemyPos:</span> <span class="n">enemies</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">g</span><span class="o">.</span><span class="na">drawImage</span><span class="o">(</span><span class="n">enemy</span><span class="o">,</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">enemyPos</span><span class="o">.</span><span class="na">current</span><span class="o">.</span><span class="na">getX</span><span class="o">()</span> <span class="o">-</span> <span class="n">enemy</span><span class="o">.</span><span class="na">getWidth</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span>
                <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">enemyPos</span><span class="o">.</span><span class="na">current</span><span class="o">.</span><span class="na">getY</span><span class="o">()</span> <span class="o">-</span> <span class="n">enemy</span><span class="o">.</span><span class="na">getHeight</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="k">this</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">g</span><span class="o">.</span><span class="na">setColor</span><span class="o">(</span><span class="n">Color</span><span class="o">.</span><span class="na">black</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Point</span> <span class="nl">bullet:</span> <span class="n">bullets</span><span class="o">)</span>
            <span class="n">g</span><span class="o">.</span><span class="na">drawLine</span><span class="o">(</span><span class="n">bullet</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">bullet</span><span class="o">.</span><span class="na">y</span><span class="o">,</span> <span class="n">bullet</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">bullet</span><span class="o">.</span><span class="na">y</span> <span class="o">-</span> <span class="mi">4</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">JFrame</span> <span class="n">frame</span> <span class="o">=</span> <span class="k">new</span> <span class="n">JFrame</span><span class="o">(</span><span class="s">&quot;Tatieul - New Generation Shooting Game&quot;</span><span class="o">);</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">setContentPane</span><span class="o">(</span><span class="k">new</span> <span class="n">Tatieul</span><span class="o">());</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">pack</span><span class="o">();</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">setLocationRelativeTo</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">setDefaultCloseOperation</span><span class="o">(</span><span class="n">JFrame</span><span class="o">.</span><span class="na">EXIT_ON_CLOSE</span><span class="o">);</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">setVisible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">EnemyPos</span> <span class="o">{</span>
    <span class="n">Point2D</span> <span class="n">delta</span><span class="o">,</span> <span class="n">current</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">EnemyPos</span><span class="o">(</span><span class="kt">int</span> <span class="n">shipHeight</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Random</span> <span class="n">rand</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Random</span><span class="o">();</span>
        <span class="kt">float</span> <span class="n">lifetime</span> <span class="o">=</span> <span class="n">rand</span><span class="o">.</span><span class="na">nextFloat</span><span class="o">()</span> <span class="o">*</span> <span class="mi">50</span> <span class="o">+</span> <span class="mi">50</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">startX</span> <span class="o">=</span> <span class="n">rand</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">640</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">endX</span> <span class="o">=</span> <span class="n">rand</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">640</span><span class="o">);</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point2D</span><span class="o">.</span><span class="na">Float</span><span class="o">((</span><span class="n">endX</span> <span class="o">-</span> <span class="n">startX</span><span class="o">)</span> <span class="o">/</span> <span class="n">lifetime</span><span class="o">,</span> <span class="o">(</span><span class="mi">480</span> <span class="o">+</span> <span class="n">shipHeight</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span> <span class="o">/</span> <span class="n">lifetime</span><span class="o">);</span>
        <span class="n">current</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point2D</span><span class="o">.</span><span class="na">Float</span><span class="o">(</span><span class="n">startX</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">shipHeight</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>적기도 총알을 쏴야한다. 하지만 지금까지 총알은 모두 -y 방향(플레이어가 쐈을 때)만 고려되어서 만들어져있다. 따라서 총알도 방향 정보가 추가되어야 한다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Bullet</span> <span class="o">{</span>
    <span class="n">Point</span> <span class="n">pos</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">direction</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Bullet</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">direction</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">pos</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">direction</span> <span class="o">=</span> <span class="n">direction</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>이에 따라 기존에 총알을 관리하던 코드가 바뀌어야 한다. 플레이어는 -y 방향으로 쏘니까 direction 값이 - 가 될테고, 이를 저장하는 List 는 Point 가 아닌 Bullet 을 가져야할테고, 그림 그리는 곳과 총알이 사라지는 곳까지 다 고쳐주면 된다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">private</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Bullet</span><span class="o">&gt;</span> <span class="n">bullets</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Bullet</span><span class="o">&gt;();</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">keyPressed</span><span class="o">(</span><span class="n">KeyEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">switch</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getKeyCode</span><span class="o">())</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">KeyEvent</span><span class="o">.</span><span class="na">VK_SPACE</span><span class="o">:</span> <span class="n">bullets</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Bullet</span><span class="o">(</span><span class="n">shipPos</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">shipPos</span><span class="o">.</span><span class="na">y</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">));</span> <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">repaint</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">updateBullets</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">Bullet</span><span class="o">&gt;</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">bullets</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">iterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">Bullet</span> <span class="n">bullet</span> <span class="o">=</span> <span class="n">iterator</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
        <span class="n">bullet</span><span class="o">.</span><span class="na">pos</span><span class="o">.</span><span class="na">y</span> <span class="o">+=</span> <span class="n">bullet</span><span class="o">.</span><span class="na">direction</span> <span class="o">*</span> <span class="mi">20</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">bullet</span><span class="o">.</span><span class="na">direction</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">bullet</span><span class="o">.</span><span class="na">pos</span><span class="o">.</span><span class="na">y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
                <span class="o">||</span> <span class="o">(</span><span class="n">bullet</span><span class="o">.</span><span class="na">direction</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">bullet</span><span class="o">.</span><span class="na">pos</span><span class="o">.</span><span class="na">y</span> <span class="o">&gt;</span> <span class="mi">560</span><span class="o">))</span>
            <span class="n">iterator</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">paintComponent</span><span class="o">(</span><span class="n">Graphics</span> <span class="n">g</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">g</span><span class="o">.</span><span class="na">setColor</span><span class="o">(</span><span class="n">Color</span><span class="o">.</span><span class="na">black</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Bullet</span> <span class="nl">bullet:</span> <span class="n">bullets</span><span class="o">)</span>
        <span class="n">g</span><span class="o">.</span><span class="na">drawLine</span><span class="o">(</span><span class="n">bullet</span><span class="o">.</span><span class="na">pos</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">bullet</span><span class="o">.</span><span class="na">pos</span><span class="o">.</span><span class="na">y</span><span class="o">,</span> <span class="n">bullet</span><span class="o">.</span><span class="na">pos</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">bullet</span><span class="o">.</span><span class="na">pos</span><span class="o">.</span><span class="na">y</span> <span class="o">-</span> <span class="mi">4</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p>적기가 총알을 쏴야한다. 간단하게 각 적기가 매 tick마다 random 돌려서 0.3보다 작은 값이 나오면 총알을 만들도록 하자-_-</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">private</span> <span class="kt">void</span> <span class="nf">generateEnemyBullet</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">EnemyPos</span> <span class="nl">enemyPos:</span> <span class="n">enemies</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">random</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mf">0.2</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">bullets</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Bullet</span><span class="o">((</span><span class="kt">int</span><span class="o">)</span> <span class="n">enemyPos</span><span class="o">.</span><span class="na">current</span><span class="o">.</span><span class="na">getX</span><span class="o">(),</span> 
                    <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">enemyPos</span><span class="o">.</span><span class="na">current</span><span class="o">.</span><span class="na">getY</span><span class="o">(),</span> <span class="mi">1</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>이제 충돌검사를 구현한다. 본 게임에서는 간단하게 3가지 충돌검사만 구현해보자.</p>

<ol>
<li>총알간의 충돌검사</li>
<li>총알과 비행기의 충돌검사</li>
<li>비행기간의 충돌검사</li>
</ol>

<p>그런데 비행기가 적기와 플레이어의 비행기로 2종류가 있으니 총 5가지 항목에 대해서 검사를 해야한다.
먼저 매 tick마다 총알간 충돌 검사를 하자.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="n">Set</span><span class="o">&lt;</span><span class="n">Bullet</span><span class="o">&gt;</span> <span class="n">removeBulletSet</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">Bullet</span><span class="o">&gt;();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bullets</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">bullets</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Bullet</span> <span class="n">lhs</span> <span class="o">=</span> <span class="n">bullets</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">bullets</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">lhs</span><span class="o">.</span><span class="na">pos</span><span class="o">.</span><span class="na">x</span> <span class="o">-</span> <span class="n">rhs</span><span class="o">.</span><span class="na">pos</span><span class="o">.</span><span class="na">x</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">8</span> <span class="o">&amp;&amp;</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">lhs</span><span class="o">.</span><span class="na">pos</span><span class="o">.</span><span class="na">y</span> <span class="o">-</span> <span class="n">rhs</span><span class="o">.</span><span class="na">pos</span><span class="o">.</span><span class="na">y</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">removeBulletSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">lhs</span><span class="o">);</span>
            <span class="n">removeBulletSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">rhs</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="k">for</span> <span class="o">(</span><span class="n">Bullet</span> <span class="nl">removal:</span> <span class="n">removeBulletSet</span><span class="o">)</span> 
    <span class="n">bullets</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">removal</span><span class="o">);</span>
</code></pre></div>
<p>너무 치밀하게 충돌 검사를 하면 탄막놀이가 힘들어지니까 후하게 x범위 4, y범위 10으로 주자-_-</p>

<p>대충하는 건 좋은데 문제가 생겼다. space 키를 누르고 있으면 그 총알들이 겹쳐서 다 충돌처리가 되어버린다. 이 문제를 없애기 위해 shot delay를 준다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">private</span> <span class="kt">long</span> <span class="n">shotTick</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">playerShot</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">shotTick</span> <span class="o">&lt;</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">shotTick</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()</span> <span class="o">+</span> <span class="mi">200</span><span class="o">;</span>
        <span class="n">bullets</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Bullet</span><span class="o">(</span><span class="n">shipPos</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">shipPos</span><span class="o">.</span><span class="na">y</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>그리고 나머지 충돌 처리도 한다. 적기와 플레이어의 비행기는 영역을 갖는 <code>Rectangle</code>이므로 <code>Rectangle</code>의 <code>intersect</code> 함수를 쓰면 간단하다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">private</span> <span class="kt">void</span> <span class="nf">checkCollision</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Set</span><span class="o">&lt;</span><span class="n">Bullet</span><span class="o">&gt;</span> <span class="n">removeBulletSet</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">Bullet</span><span class="o">&gt;();</span>
    <span class="n">Set</span><span class="o">&lt;</span><span class="n">EnemyPos</span><span class="o">&gt;</span> <span class="n">removeEnemySet</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">EnemyPos</span><span class="o">&gt;();</span>
    <span class="kt">int</span> <span class="n">shipWidth</span> <span class="o">=</span> <span class="n">ship</span><span class="o">.</span><span class="na">getWidth</span><span class="o">(</span><span class="k">this</span><span class="o">),</span> <span class="n">shipHeight</span> <span class="o">=</span> <span class="n">ship</span><span class="o">.</span><span class="na">getHeight</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">enemyWidth</span> <span class="o">=</span> <span class="n">enemy</span><span class="o">.</span><span class="na">getWidth</span><span class="o">(</span><span class="k">this</span><span class="o">),</span> <span class="n">enemyHeight</span> <span class="o">=</span> <span class="n">enemy</span><span class="o">.</span><span class="na">getHeight</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bullets</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">bullets</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Bullet</span> <span class="n">lhs</span> <span class="o">=</span> <span class="n">bullets</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">bullets</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">lhs</span><span class="o">.</span><span class="na">pos</span><span class="o">.</span><span class="na">x</span> <span class="o">-</span> <span class="n">rhs</span><span class="o">.</span><span class="na">pos</span><span class="o">.</span><span class="na">x</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">8</span> <span class="o">&amp;&amp;</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">lhs</span><span class="o">.</span><span class="na">pos</span><span class="o">.</span><span class="na">y</span> <span class="o">-</span> <span class="n">rhs</span><span class="o">.</span><span class="na">pos</span><span class="o">.</span><span class="na">y</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">removeBulletSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">lhs</span><span class="o">);</span>
                <span class="n">removeBulletSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">rhs</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">Rectangle2D</span> <span class="n">shipRect</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Rectangle2D</span><span class="o">.</span><span class="na">Double</span><span class="o">(</span><span class="n">shipPos</span><span class="o">.</span><span class="na">x</span> <span class="o">-</span> <span class="n">shipWidth</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> 
            <span class="n">shipPos</span><span class="o">.</span><span class="na">y</span> <span class="o">-</span> <span class="n">shipHeight</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="n">shipWidth</span><span class="o">,</span> <span class="n">shipHeight</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Bullet</span> <span class="nl">bullet:</span> <span class="n">bullets</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">EnemyPos</span> <span class="nl">enemyPos:</span> <span class="n">enemies</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">enemyPos</span><span class="o">.</span><span class="na">current</span><span class="o">.</span><span class="na">getX</span><span class="o">()</span> <span class="o">-</span> <span class="n">bullet</span><span class="o">.</span><span class="na">pos</span><span class="o">.</span><span class="na">x</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">enemyWidth</span> 
                    <span class="o">&amp;&amp;</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">enemyPos</span><span class="o">.</span><span class="na">current</span><span class="o">.</span><span class="na">getY</span><span class="o">()</span> <span class="o">-</span> <span class="n">bullet</span><span class="o">.</span><span class="na">pos</span><span class="o">.</span><span class="na">y</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">enemyHeight</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">removeEnemySet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">enemyPos</span><span class="o">);</span>
                <span class="n">removeBulletSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">bullet</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">shipPos</span><span class="o">.</span><span class="na">x</span> <span class="o">-</span> <span class="n">bullet</span><span class="o">.</span><span class="na">pos</span><span class="o">.</span><span class="na">x</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">shipWidth</span>
                <span class="o">&amp;&amp;</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">shipPos</span><span class="o">.</span><span class="na">y</span> <span class="o">-</span> <span class="n">bullet</span><span class="o">.</span><span class="na">pos</span><span class="o">.</span><span class="na">y</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">shipHeight</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">removeBulletSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">bullet</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enemies</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">EnemyPos</span> <span class="n">lhs</span> <span class="o">=</span> <span class="n">enemies</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="n">Rectangle2D</span> <span class="n">lhsRect</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Rectangle2D</span><span class="o">.</span><span class="na">Double</span><span class="o">(</span><span class="n">lhs</span><span class="o">.</span><span class="na">current</span><span class="o">.</span><span class="na">getX</span><span class="o">()</span> <span class="o">-</span> <span class="n">enemyWidth</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> 
                <span class="n">lhs</span><span class="o">.</span><span class="na">current</span><span class="o">.</span><span class="na">getY</span><span class="o">()</span> <span class="o">-</span> <span class="n">enemyHeight</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="n">enemyWidth</span><span class="o">,</span> <span class="n">enemyHeight</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">enemies</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">EnemyPos</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">enemies</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
            <span class="n">Rectangle2D</span> <span class="n">rhsRect</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Rectangle2D</span><span class="o">.</span><span class="na">Double</span><span class="o">(</span><span class="n">rhs</span><span class="o">.</span><span class="na">current</span><span class="o">.</span><span class="na">getX</span><span class="o">()</span> <span class="o">-</span> <span class="n">enemyWidth</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> 
                    <span class="n">rhs</span><span class="o">.</span><span class="na">current</span><span class="o">.</span><span class="na">getY</span><span class="o">()</span> <span class="o">-</span> <span class="n">enemyHeight</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="n">enemyWidth</span><span class="o">,</span> <span class="n">enemyHeight</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">lhsRect</span><span class="o">.</span><span class="na">intersects</span><span class="o">(</span><span class="n">rhsRect</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">removeEnemySet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">lhs</span><span class="o">);</span>
                <span class="n">removeEnemySet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">rhs</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">lhsRect</span><span class="o">.</span><span class="na">intersects</span><span class="o">(</span><span class="n">shipRect</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">removeEnemySet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">lhs</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Bullet</span> <span class="nl">removal:</span> <span class="n">removeBulletSet</span><span class="o">)</span> 
        <span class="n">bullets</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">removal</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">EnemyPos</span> <span class="nl">removal:</span> <span class="n">removeEnemySet</span><span class="o">)</span>
        <span class="n">enemies</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">removal</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p>엄청나게 대충 작성한 결과로 적기가 자신이 쏜 총알에 맞아 사망하는 놀라운 일이 발생했다-_-;</p>

<p>여기까지 코드 전문은 다음과 같다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.awt.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.awt.event.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.awt.geom.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.swing.*</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Tatieul</span> <span class="kd">extends</span> <span class="n">JPanel</span> <span class="kd">implements</span> <span class="n">KeyListener</span><span class="o">,</span> <span class="n">ActionListener</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Point</span> <span class="n">shipPos</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="o">(</span><span class="mi">320</span><span class="o">,</span> <span class="mi">400</span><span class="o">);</span>
    <span class="kd">private</span> <span class="n">Image</span> <span class="n">ship</span><span class="o">,</span> <span class="n">enemy</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Bullet</span><span class="o">&gt;</span> <span class="n">bullets</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Bullet</span><span class="o">&gt;();</span>
    <span class="kd">private</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">EnemyPos</span><span class="o">&gt;</span> <span class="n">enemies</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">EnemyPos</span><span class="o">&gt;();</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">spawnTick</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">shotTick</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Tatieul</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">setPreferredSize</span><span class="o">(</span><span class="k">new</span> <span class="n">Dimension</span><span class="o">(</span><span class="mi">640</span><span class="o">,</span> <span class="mi">480</span><span class="o">));</span>
        <span class="n">setFocusable</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
        <span class="n">addKeyListener</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="n">ship</span> <span class="o">=</span> <span class="n">Toolkit</span><span class="o">.</span><span class="na">getDefaultToolkit</span><span class="o">().</span><span class="na">getImage</span><span class="o">(</span><span class="s">&quot;player.png&quot;</span><span class="o">);</span>
        <span class="n">enemy</span> <span class="o">=</span> <span class="n">Toolkit</span><span class="o">.</span><span class="na">getDefaultToolkit</span><span class="o">().</span><span class="na">getImage</span><span class="o">(</span><span class="s">&quot;enemy.png&quot;</span><span class="o">);</span>
        <span class="k">new</span> <span class="n">javax</span><span class="o">.</span><span class="na">swing</span><span class="o">.</span><span class="na">Timer</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span> <span class="k">this</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">keyPressed</span><span class="o">(</span><span class="n">KeyEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">switch</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getKeyCode</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">case</span> <span class="n">KeyEvent</span><span class="o">.</span><span class="na">VK_UP</span><span class="o">:</span>    <span class="n">shipPos</span><span class="o">.</span><span class="na">y</span> <span class="o">-=</span> <span class="mi">10</span><span class="o">;</span> <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="n">KeyEvent</span><span class="o">.</span><span class="na">VK_DOWN</span><span class="o">:</span>  <span class="n">shipPos</span><span class="o">.</span><span class="na">y</span> <span class="o">+=</span> <span class="mi">10</span><span class="o">;</span> <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="n">KeyEvent</span><span class="o">.</span><span class="na">VK_LEFT</span><span class="o">:</span>  <span class="n">shipPos</span><span class="o">.</span><span class="na">x</span> <span class="o">-=</span> <span class="mi">10</span><span class="o">;</span> <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="n">KeyEvent</span><span class="o">.</span><span class="na">VK_RIGHT</span><span class="o">:</span> <span class="n">shipPos</span><span class="o">.</span><span class="na">x</span> <span class="o">+=</span> <span class="mi">10</span><span class="o">;</span> <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="n">KeyEvent</span><span class="o">.</span><span class="na">VK_SPACE</span><span class="o">:</span> <span class="n">playerShot</span><span class="o">();</span> <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">repaint</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">playerShot</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">shotTick</span> <span class="o">&lt;</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">shotTick</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()</span> <span class="o">+</span> <span class="mi">200</span><span class="o">;</span>
            <span class="n">bullets</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Bullet</span><span class="o">(</span><span class="n">shipPos</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">shipPos</span><span class="o">.</span><span class="na">y</span> <span class="o">-</span> <span class="o">(</span><span class="n">ship</span><span class="o">.</span><span class="na">getHeight</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">8</span><span class="o">),</span> <span class="o">-</span><span class="mi">1</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">actionPerformed</span><span class="o">(</span><span class="n">ActionEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">updateEnemyPos</span><span class="o">();</span>
        <span class="n">updateBullets</span><span class="o">();</span>
        <span class="n">checkCollision</span><span class="o">();</span>
        <span class="n">generateEnemy</span><span class="o">();</span>
        <span class="n">generateEnemyBullet</span><span class="o">();</span>
        <span class="n">repaint</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">checkCollision</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">Set</span><span class="o">&lt;</span><span class="n">Bullet</span><span class="o">&gt;</span> <span class="n">removeBulletSet</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">Bullet</span><span class="o">&gt;();</span>
        <span class="n">Set</span><span class="o">&lt;</span><span class="n">EnemyPos</span><span class="o">&gt;</span> <span class="n">removeEnemySet</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">EnemyPos</span><span class="o">&gt;();</span>
        <span class="kt">int</span> <span class="n">shipWidth</span> <span class="o">=</span> <span class="n">ship</span><span class="o">.</span><span class="na">getWidth</span><span class="o">(</span><span class="k">this</span><span class="o">),</span> <span class="n">shipHeight</span> <span class="o">=</span> <span class="n">ship</span><span class="o">.</span><span class="na">getHeight</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">enemyWidth</span> <span class="o">=</span> <span class="n">enemy</span><span class="o">.</span><span class="na">getWidth</span><span class="o">(</span><span class="k">this</span><span class="o">),</span> <span class="n">enemyHeight</span> <span class="o">=</span> <span class="n">enemy</span><span class="o">.</span><span class="na">getHeight</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bullets</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">bullets</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">Bullet</span> <span class="n">lhs</span> <span class="o">=</span> <span class="n">bullets</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">bullets</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">lhs</span><span class="o">.</span><span class="na">pos</span><span class="o">.</span><span class="na">x</span> <span class="o">-</span> <span class="n">rhs</span><span class="o">.</span><span class="na">pos</span><span class="o">.</span><span class="na">x</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">8</span> <span class="o">&amp;&amp;</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">lhs</span><span class="o">.</span><span class="na">pos</span><span class="o">.</span><span class="na">y</span> <span class="o">-</span> <span class="n">rhs</span><span class="o">.</span><span class="na">pos</span><span class="o">.</span><span class="na">y</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">removeBulletSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">lhs</span><span class="o">);</span>
                    <span class="n">removeBulletSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">rhs</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">Rectangle2D</span> <span class="n">shipRect</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Rectangle2D</span><span class="o">.</span><span class="na">Double</span><span class="o">(</span><span class="n">shipPos</span><span class="o">.</span><span class="na">x</span> <span class="o">-</span> <span class="n">shipWidth</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> 
                <span class="n">shipPos</span><span class="o">.</span><span class="na">y</span> <span class="o">-</span> <span class="n">shipHeight</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="n">shipWidth</span><span class="o">,</span> <span class="n">shipHeight</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Bullet</span> <span class="nl">bullet:</span> <span class="n">bullets</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">EnemyPos</span> <span class="nl">enemyPos:</span> <span class="n">enemies</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">enemyPos</span><span class="o">.</span><span class="na">current</span><span class="o">.</span><span class="na">getX</span><span class="o">()</span> <span class="o">-</span> <span class="n">bullet</span><span class="o">.</span><span class="na">pos</span><span class="o">.</span><span class="na">x</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">enemyWidth</span> 
                        <span class="o">&amp;&amp;</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">enemyPos</span><span class="o">.</span><span class="na">current</span><span class="o">.</span><span class="na">getY</span><span class="o">()</span> <span class="o">-</span> <span class="n">bullet</span><span class="o">.</span><span class="na">pos</span><span class="o">.</span><span class="na">y</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">enemyHeight</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">removeEnemySet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">enemyPos</span><span class="o">);</span>
                    <span class="n">removeBulletSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">bullet</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">shipPos</span><span class="o">.</span><span class="na">x</span> <span class="o">-</span> <span class="n">bullet</span><span class="o">.</span><span class="na">pos</span><span class="o">.</span><span class="na">x</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">shipWidth</span>
                    <span class="o">&amp;&amp;</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">shipPos</span><span class="o">.</span><span class="na">y</span> <span class="o">-</span> <span class="n">bullet</span><span class="o">.</span><span class="na">pos</span><span class="o">.</span><span class="na">y</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">shipHeight</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">removeBulletSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">bullet</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">enemies</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">EnemyPos</span> <span class="n">lhs</span> <span class="o">=</span> <span class="n">enemies</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">Rectangle2D</span> <span class="n">lhsRect</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Rectangle2D</span><span class="o">.</span><span class="na">Double</span><span class="o">(</span><span class="n">lhs</span><span class="o">.</span><span class="na">current</span><span class="o">.</span><span class="na">getX</span><span class="o">()</span> <span class="o">-</span> <span class="n">enemyWidth</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> 
                    <span class="n">lhs</span><span class="o">.</span><span class="na">current</span><span class="o">.</span><span class="na">getY</span><span class="o">()</span> <span class="o">-</span> <span class="n">enemyHeight</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="n">enemyWidth</span><span class="o">,</span> <span class="n">enemyHeight</span><span class="o">);</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">enemies</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">EnemyPos</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">enemies</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
                <span class="n">Rectangle2D</span> <span class="n">rhsRect</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Rectangle2D</span><span class="o">.</span><span class="na">Double</span><span class="o">(</span><span class="n">rhs</span><span class="o">.</span><span class="na">current</span><span class="o">.</span><span class="na">getX</span><span class="o">()</span> <span class="o">-</span> <span class="n">enemyWidth</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> 
                        <span class="n">rhs</span><span class="o">.</span><span class="na">current</span><span class="o">.</span><span class="na">getY</span><span class="o">()</span> <span class="o">-</span> <span class="n">enemyHeight</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="n">enemyWidth</span><span class="o">,</span> <span class="n">enemyHeight</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">lhsRect</span><span class="o">.</span><span class="na">intersects</span><span class="o">(</span><span class="n">rhsRect</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">removeEnemySet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">lhs</span><span class="o">);</span>
                    <span class="n">removeEnemySet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">rhs</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">lhsRect</span><span class="o">.</span><span class="na">intersects</span><span class="o">(</span><span class="n">shipRect</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">removeEnemySet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">lhs</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Bullet</span> <span class="nl">removal:</span> <span class="n">removeBulletSet</span><span class="o">)</span> 
            <span class="n">bullets</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">removal</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">EnemyPos</span> <span class="nl">removal:</span> <span class="n">removeEnemySet</span><span class="o">)</span>
            <span class="n">enemies</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">removal</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">updateEnemyPos</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">EnemyPos</span><span class="o">&gt;</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">enemies</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">iterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">EnemyPos</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">iterator</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
            <span class="n">pos</span><span class="o">.</span><span class="na">current</span><span class="o">.</span><span class="na">setLocation</span><span class="o">(</span><span class="n">pos</span><span class="o">.</span><span class="na">current</span><span class="o">.</span><span class="na">getX</span><span class="o">()</span> <span class="o">+</span> <span class="n">pos</span><span class="o">.</span><span class="na">delta</span><span class="o">.</span><span class="na">getX</span><span class="o">(),</span> 
                    <span class="n">pos</span><span class="o">.</span><span class="na">current</span><span class="o">.</span><span class="na">getY</span><span class="o">()</span> <span class="o">+</span> <span class="n">pos</span><span class="o">.</span><span class="na">delta</span><span class="o">.</span><span class="na">getY</span><span class="o">());</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">pos</span><span class="o">.</span><span class="na">current</span><span class="o">.</span><span class="na">getY</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">560</span><span class="o">)</span>
                <span class="n">iterator</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">updateBullets</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">Bullet</span><span class="o">&gt;</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">bullets</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">iterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">Bullet</span> <span class="n">bullet</span> <span class="o">=</span> <span class="n">iterator</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
            <span class="n">bullet</span><span class="o">.</span><span class="na">pos</span><span class="o">.</span><span class="na">y</span> <span class="o">+=</span> <span class="n">bullet</span><span class="o">.</span><span class="na">direction</span> <span class="o">*</span> <span class="mi">20</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">bullet</span><span class="o">.</span><span class="na">direction</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">bullet</span><span class="o">.</span><span class="na">pos</span><span class="o">.</span><span class="na">y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
                    <span class="o">||</span> <span class="o">(</span><span class="n">bullet</span><span class="o">.</span><span class="na">direction</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">bullet</span><span class="o">.</span><span class="na">pos</span><span class="o">.</span><span class="na">y</span> <span class="o">&gt;</span> <span class="mi">560</span><span class="o">))</span>
                <span class="n">iterator</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">generateEnemy</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">spawnTick</span> <span class="o">&lt;</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">spawnTick</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()</span> <span class="o">+</span> <span class="k">new</span> <span class="n">Random</span><span class="o">().</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">2000</span><span class="o">)</span> <span class="o">+</span> <span class="mi">500</span><span class="o">;</span>
            <span class="n">enemies</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">EnemyPos</span><span class="o">(</span><span class="n">enemy</span><span class="o">.</span><span class="na">getHeight</span><span class="o">(</span><span class="k">this</span><span class="o">)));</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">generateEnemyBullet</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">EnemyPos</span> <span class="nl">enemyPos:</span> <span class="n">enemies</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">random</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mf">0.2</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">bullets</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Bullet</span><span class="o">((</span><span class="kt">int</span><span class="o">)</span> <span class="n">enemyPos</span><span class="o">.</span><span class="na">current</span><span class="o">.</span><span class="na">getX</span><span class="o">(),</span> 
                        <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">enemyPos</span><span class="o">.</span><span class="na">current</span><span class="o">.</span><span class="na">getY</span><span class="o">()</span> <span class="o">+</span> <span class="o">(</span><span class="n">enemy</span><span class="o">.</span><span class="na">getHeight</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">8</span><span class="o">),</span> <span class="mi">1</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">keyReleased</span><span class="o">(</span><span class="n">KeyEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">{}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">keyTyped</span><span class="o">(</span><span class="n">KeyEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">{}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">paintComponent</span><span class="o">(</span><span class="n">Graphics</span> <span class="n">g</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">g</span><span class="o">.</span><span class="na">setColor</span><span class="o">(</span><span class="n">Color</span><span class="o">.</span><span class="na">white</span><span class="o">);</span>
        <span class="n">g</span><span class="o">.</span><span class="na">fillRect</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">640</span><span class="o">,</span> <span class="mi">480</span><span class="o">);</span>
        <span class="n">g</span><span class="o">.</span><span class="na">drawImage</span><span class="o">(</span><span class="n">ship</span><span class="o">,</span> <span class="n">shipPos</span><span class="o">.</span><span class="na">x</span> <span class="o">-</span> <span class="n">ship</span><span class="o">.</span><span class="na">getWidth</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="n">shipPos</span><span class="o">.</span><span class="na">y</span> <span class="o">-</span> <span class="n">ship</span><span class="o">.</span><span class="na">getHeight</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="k">this</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">EnemyPos</span> <span class="nl">enemyPos:</span> <span class="n">enemies</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">g</span><span class="o">.</span><span class="na">drawImage</span><span class="o">(</span><span class="n">enemy</span><span class="o">,</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">enemyPos</span><span class="o">.</span><span class="na">current</span><span class="o">.</span><span class="na">getX</span><span class="o">()</span> <span class="o">-</span> <span class="n">enemy</span><span class="o">.</span><span class="na">getWidth</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> 
                    <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">enemyPos</span><span class="o">.</span><span class="na">current</span><span class="o">.</span><span class="na">getY</span><span class="o">()</span> <span class="o">-</span> <span class="n">enemy</span><span class="o">.</span><span class="na">getHeight</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="k">this</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">g</span><span class="o">.</span><span class="na">setColor</span><span class="o">(</span><span class="n">Color</span><span class="o">.</span><span class="na">black</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Bullet</span> <span class="nl">bullet:</span> <span class="n">bullets</span><span class="o">)</span>
            <span class="n">g</span><span class="o">.</span><span class="na">drawLine</span><span class="o">(</span><span class="n">bullet</span><span class="o">.</span><span class="na">pos</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">bullet</span><span class="o">.</span><span class="na">pos</span><span class="o">.</span><span class="na">y</span><span class="o">,</span> <span class="n">bullet</span><span class="o">.</span><span class="na">pos</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">bullet</span><span class="o">.</span><span class="na">pos</span><span class="o">.</span><span class="na">y</span> <span class="o">-</span> <span class="mi">4</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">JFrame</span> <span class="n">frame</span> <span class="o">=</span> <span class="k">new</span> <span class="n">JFrame</span><span class="o">(</span><span class="s">&quot;Tatieul - New Generation Shooting Game&quot;</span><span class="o">);</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">setContentPane</span><span class="o">(</span><span class="k">new</span> <span class="n">Tatieul</span><span class="o">());</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">pack</span><span class="o">();</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">setLocationRelativeTo</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">setDefaultCloseOperation</span><span class="o">(</span><span class="n">JFrame</span><span class="o">.</span><span class="na">EXIT_ON_CLOSE</span><span class="o">);</span>
        <span class="n">frame</span><span class="o">.</span><span class="na">setVisible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">EnemyPos</span> <span class="o">{</span>
    <span class="n">Point2D</span> <span class="n">delta</span><span class="o">,</span> <span class="n">current</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">EnemyPos</span><span class="o">(</span><span class="kt">int</span> <span class="n">shipHeight</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Random</span> <span class="n">rand</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Random</span><span class="o">();</span>
        <span class="kt">float</span> <span class="n">lifetime</span> <span class="o">=</span> <span class="n">rand</span><span class="o">.</span><span class="na">nextFloat</span><span class="o">()</span> <span class="o">*</span> <span class="mi">50</span> <span class="o">+</span> <span class="mi">50</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">startX</span> <span class="o">=</span> <span class="n">rand</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">640</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">endX</span> <span class="o">=</span> <span class="n">rand</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">640</span><span class="o">);</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point2D</span><span class="o">.</span><span class="na">Float</span><span class="o">((</span><span class="n">endX</span> <span class="o">-</span> <span class="n">startX</span><span class="o">)</span> <span class="o">/</span> <span class="n">lifetime</span><span class="o">,</span> <span class="o">(</span><span class="mi">480</span> <span class="o">+</span> <span class="n">shipHeight</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span> <span class="o">/</span> <span class="n">lifetime</span><span class="o">);</span>
        <span class="n">current</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point2D</span><span class="o">.</span><span class="na">Float</span><span class="o">(</span><span class="n">startX</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">shipHeight</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Bullet</span> <span class="o">{</span>
    <span class="n">Point</span> <span class="n">pos</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">direction</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Bullet</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">direction</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">pos</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">direction</span> <span class="o">=</span> <span class="n">direction</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>억지로 한 파일에 최대한 짧고 대충 짜려다보니 코드가 개판이 되었다. 여러 이슈가 있겠지만, 일단 다음번에는 저걸 보다 구조화하는 작업을 해보도록 하자. (안 그러면 코드가 너무 더러워서 도저히 진행을 못할 것 같다-_-)</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">자바로 만드는 비행기 게임 4</h1>
				<p class="page-date">13 Nov 2011</p>
				<p class="page-tags">
						
						
					<code class="tag">java</code>
						
						
						
					<code class="tag">game</code>
						
						
						
						
				</p>
				<div class="content"><p>이번과 다음은 코드 정리를 해보자.</p>

<p>이전까지의 비행기 게임 코드는 너무 하나의 class 에서 다 처리하는 방식으로, 뭐 하나 수정하기도 좋지 못한 구조였다 (물론 코드 전체가 별로 안 기니까 크게 상관없겠지만)</p>

<p>예를 들어 적기의 종류를 새로 추가한다던가, 총알의 종류를 새로 추가한다던가 하는 것이 쉽지 않은 코드였다. 따라서 이번에는 간단하게 코드를 묶으면서 정리를 해보자.</p>

<h3>resource 정리</h3>

<p>현재 게임에서 사용되고 있는 resource는 player의 ship image와 enemy의 ship image이다. 그리고 그것들은 모두 <code>java.awt.Image</code> 형식으로 특정 정보를 가져올 때마다 <code>ImageObserver</code>(<code>MediaTracker</code>)를 걸어주는 구조로, 미리 모두 메모리에 올려두는 것과는 좀 다른 방식이다.</p>

<p>어차피 게임이 한 번 떠서 끝날 때까지 resource를 내릴 필요가 없으므로, 모든 정보가 메모리에 올라가있는 <code>java.awt.BufferedImage</code>를 사용하여 resource를 관리하자. 먼저 resource의 type을 정의하자.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">enum</span> <span class="n">ResourceType</span> <span class="o">{</span>
    <span class="n">ENEMY_SHIP</span><span class="o">,</span> <span class="n">PLAYER_SHIP</span>
<span class="o">}</span>
</code></pre></div>
<p>이제 이 type에 대해 <code>BufferedImage</code>를 갖는 <code>ResourceManager</code> class를 만들자.
이 <code>ResourceManager</code> class는 게임 전체에 딱 하나만 존재하면 되므로 singleton을 사용한다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">class</span> <span class="nc">ResourceManager</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="n">ResourceManager</span> <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ResourceManager</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">ResourceManager</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">ResourceType</span><span class="o">,</span> <span class="n">BufferedImage</span><span class="o">&gt;</span> <span class="n">imageMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">ResourceType</span><span class="o">,</span> <span class="n">BufferedImage</span><span class="o">&gt;();</span>
    <span class="kd">private</span> <span class="nf">ResourceManager</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">imageMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">ResourceType</span><span class="o">.</span><span class="na">ENEMY_SHIP</span><span class="o">,</span> <span class="n">ImageIO</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">getClass</span><span class="o">().</span><span class="na">getResource</span><span class="o">(</span><span class="s">&quot;enemy.png&quot;</span><span class="o">)));</span>
            <span class="n">imageMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">ResourceType</span><span class="o">.</span><span class="na">PLAYER_SHIP</span><span class="o">,</span> <span class="n">ImageIO</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">getClass</span><span class="o">().</span><span class="na">getResource</span><span class="o">(</span><span class="s">&quot;player.png&quot;</span><span class="o">)));</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Cannot load resources&quot;</span><span class="o">);</span>
            <span class="n">System</span><span class="o">.</span><span class="na">exit</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="n">BufferedImage</span> <span class="nf">getImage</span><span class="o">(</span><span class="n">ResourceType</span> <span class="n">type</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">imageMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">type</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>객체가 생성될 때 <code>javax.imageio.ImageIO</code> class의 helper function을 사용하여 png 파일을 읽는다. 이 때 굳이 파일을 절대 경로로 주지 않고 <code>ClassLoader</code>의 <code>getResource</code> 함수를 이유는 해당 png 파일을 project 내에 포함시켜서 하나의 jar로 배포할 때도 동작하게 하기 위함이다. (따라서 eclipse로 관리되는 프로젝트 환경에서 위와 같이 쓰려면 해당 png 파일을 project 디렉토리가 아닌 src 디렉토리에 넣어주어야 한다.)</p>

<p>생성자를 private로 만들어서 다른 곳에서의 생성을 막았고, static 함수로 <code>ResourceManager</code> class의 단일 객체를 반환하도록 하여 간단히 singleton을 구현하였다.</p>

<h3>game object 정리</h3>

<p>그리고 모든 게임 내의 물체에 대한 추상 class를 만들자. <code>GameObject</code>라고 부를 이 class는 자신의 고유 id 와 충돌 영역을 갖고, 매 tick 마다 어떻게 갱신(<code>update</code>)할지, 그리고 어떻게 그려져야할 지(<code>paint</code>)에 대한 interface 를 갖는다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">GameObject</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">long</span> <span class="n">idSerial</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kd">protected</span> <span class="kt">long</span> <span class="n">id</span> <span class="o">=</span> <span class="o">++</span><span class="n">idSerial</span><span class="o">;</span>
    <span class="kd">protected</span> <span class="kt">long</span> <span class="n">creationTick</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
    <span class="kd">protected</span> <span class="n">Point2D</span> <span class="n">location</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point2D</span><span class="o">.</span><span class="na">Float</span><span class="o">();</span>
    <span class="kd">protected</span> <span class="kt">int</span> <span class="n">width</span><span class="o">,</span> <span class="n">height</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">GameObject</span><span class="o">(</span><span class="kt">int</span> <span class="n">width</span><span class="o">,</span> <span class="kt">int</span> <span class="n">height</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">width</span> <span class="o">=</span> <span class="n">width</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">height</span> <span class="o">=</span> <span class="n">height</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLocation</span><span class="o">(</span><span class="kt">float</span> <span class="n">x</span><span class="o">,</span> <span class="kt">float</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">location</span><span class="o">.</span><span class="na">setLocation</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">protected</span> <span class="n">Rectangle2D</span> <span class="nf">getBound</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">Rectangle2D</span><span class="o">.</span><span class="na">Float</span><span class="o">((</span><span class="kt">float</span><span class="o">)</span> <span class="n">location</span><span class="o">.</span><span class="na">getX</span><span class="o">(),</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span> <span class="n">location</span><span class="o">.</span><span class="na">getY</span><span class="o">(),</span> <span class="n">width</span><span class="o">,</span> <span class="n">height</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">check</span><span class="o">(</span><span class="n">GameObject</span> <span class="n">other</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">other</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">return</span> <span class="nf">getBound</span><span class="o">().</span><span class="na">intersects</span><span class="o">(</span><span class="n">other</span><span class="o">.</span><span class="na">getBound</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getId</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">id</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getHeight</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">height</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getWidth</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">width</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">paint</span><span class="o">(</span><span class="n">Graphics2D</span> <span class="n">g2d</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">update</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">boolean</span> <span class="nf">isOutOfScreen</span><span class="o">(</span><span class="kt">int</span> <span class="n">screenWidth</span><span class="o">,</span> <span class="kt">int</span> <span class="n">screenHeight</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<ul>
<li>id는 순차적으로 발급하면 되므로 static 변수의 값을 증가시키면서 얻는다.<br>
이는 추후 총알과 비행기의 충돌검사를 할 때, 자기가 쏜 총알에는 안 맞도록 처리하기 위해 사용된다.</li>
<li>공용적으로 갖게 되는 위치(<code>location</code>) 정보와 가로, 세로 길이(<code>width</code>, <code>height</code>)를 바탕으로 충돌 영역을 반환하는 함수를 가지고 있다(<code>getBound</code>).</li>
<li>충돌 영역을 계산할 수 있다면, 충돌 검사 함수(<code>check</code>)에서는 단순히 두 <code>java.awt.geom.Rectangle2D</code> class의 <code>intersect</code> 함수를 통해 영역이 겹쳐졌나 확인해볼 수 있다.<br>
(물론 이는 XNA의 bitmap check 같은 방식은 아니라서 그냥 간단한 사각형 충돌 처리밖에 안된다, 더 자세히 하려면 <code>PathIterator</code> 같은 것을 써서 <code>Polygon</code>을 구성해서 하면 될 것이다)</li>
<li>그리고 갱신(<code>update</code>), 그리기(<code>paint</code>)에 대한 interface 를 갖는다.</li>
<li>화면 밖으로 사라졌는지(<code>isOutOfScreen</code>)에 대한 interface는 <code>update</code> 후 자신이 화면 밖으로 나갔다는 것을 판단해서 해당 객체를 없애기 위함이다.</li>
</ul>

<p>미리 말하자면 위 구조는 별로 깔끔하지 않다. 이는 #5에서 수정할 예정이다.</p>

<h4>ship 정리</h4>

<p>이제 이 class를 상속받아 <code>Ship</code>에 대한 기본 class를 만들어보자. <code>Ship</code> class는 <code>Enemy</code> class와 <code>Player</code> class가 상속받게 되는 class로, 어떤 ship image를 갖고, 그것을 어떻게 그리는지를 명시한다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Ship</span> <span class="kd">extends</span> <span class="n">GameObject</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">BufferedImage</span> <span class="n">image</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Ship</span><span class="o">(</span><span class="n">BufferedImage</span> <span class="n">image</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">image</span><span class="o">.</span><span class="na">getWidth</span><span class="o">(),</span> <span class="n">image</span><span class="o">.</span><span class="na">getHeight</span><span class="o">());</span>
        <span class="k">this</span><span class="o">.</span><span class="na">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">paint</span><span class="o">(</span><span class="n">Graphics2D</span> <span class="n">g2d</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">Math</span><span class="o">.</span><span class="na">round</span><span class="o">(</span><span class="n">location</span><span class="o">.</span><span class="na">getX</span><span class="o">()</span> <span class="o">-</span> <span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">Math</span><span class="o">.</span><span class="na">round</span><span class="o">(</span><span class="n">location</span><span class="o">.</span><span class="na">getY</span><span class="o">()</span> <span class="o">-</span> <span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="o">);</span>
        <span class="n">g2d</span><span class="o">.</span><span class="na">drawImage</span><span class="o">(</span><span class="n">image</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="n">Rectangle2D</span> <span class="nf">getBound</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">Rectangle2D</span><span class="o">.</span><span class="na">Float</span><span class="o">((</span><span class="kt">float</span><span class="o">)</span> <span class="n">location</span><span class="o">.</span><span class="na">getX</span><span class="o">()</span> <span class="o">-</span> <span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span>
                <span class="o">(</span><span class="kt">float</span><span class="o">)</span> <span class="n">location</span><span class="o">.</span><span class="na">getY</span><span class="o">()</span> <span class="o">-</span> <span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="n">width</span><span class="o">,</span> <span class="n">height</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p><code>Ship</code> class는 어떤 image 기반으로 동작할지 생성자로 Image에 대한 정보를 받는다. 그리고 그 image 를 <code>paint</code> 함수에서 그려준다. 이 때 현재 비행기의 위치를 그림의 중앙으로 보정하기 때문에 width / 2, height / 2 를 빼게 된다. 이 때문에 충돌 영역이 바뀌게 되므로 (기존 충돌 영역은 그냥 x, y 였으니까) 충돌 영역을 고쳐서 반환할 수 있도록 해준다.</p>

<h4>bullet 정리</h4>

<p>총알에 대한 class를 만든다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Bullet</span> <span class="kd">extends</span> <span class="n">GameObject</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">PLAYER</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">ENEMY</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">WIDTH</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">HEIGHT</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">BULLET_SPEED</span> <span class="o">=</span> <span class="mi">20</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">direction</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">ownerId</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Bullet</span><span class="o">(</span><span class="kt">long</span> <span class="n">ownerId</span><span class="o">,</span> <span class="kt">int</span> <span class="n">direction</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">WIDTH</span><span class="o">,</span> <span class="n">HEIGHT</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">ownerId</span> <span class="o">=</span> <span class="n">ownerId</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">direction</span> <span class="o">=</span> <span class="n">direction</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">check</span><span class="o">(</span><span class="n">GameObject</span> <span class="n">other</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">other</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">ownerId</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="na">getId</span><span class="o">())</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">check</span><span class="o">(</span><span class="n">other</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">update</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">location</span><span class="o">.</span><span class="na">setLocation</span><span class="o">(</span><span class="n">location</span><span class="o">.</span><span class="na">getX</span><span class="o">(),</span> <span class="n">location</span><span class="o">.</span><span class="na">getY</span><span class="o">()</span> <span class="o">+</span> <span class="n">direction</span> <span class="o">*</span> <span class="n">BULLET_SPEED</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">paint</span><span class="o">(</span><span class="n">Graphics2D</span> <span class="n">g2d</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">g2d</span><span class="o">.</span><span class="na">setColor</span><span class="o">(</span><span class="n">Color</span><span class="o">.</span><span class="na">gray</span><span class="o">);</span>
        <span class="n">g2d</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">getBound</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isOutOfScreen</span><span class="o">(</span><span class="kt">int</span> <span class="n">screenWidth</span><span class="o">,</span> <span class="kt">int</span> <span class="n">screenHeight</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">float</span> <span class="n">minY</span> <span class="o">=</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span> <span class="n">location</span><span class="o">.</span><span class="na">getY</span><span class="o">()</span> <span class="o">-</span> <span class="n">height</span><span class="o">;</span>
        <span class="kt">float</span> <span class="n">maxY</span> <span class="o">=</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span> <span class="n">location</span><span class="o">.</span><span class="na">getY</span><span class="o">()</span> <span class="o">+</span> <span class="n">height</span><span class="o">;</span>
        <span class="k">switch</span> <span class="o">(</span><span class="n">direction</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nl">PLAYER:</span>
            <span class="k">return</span> <span class="n">maxY</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">case</span> <span class="nl">ENEMY:</span>
            <span class="k">return</span> <span class="n">minY</span> <span class="o">&gt;</span> <span class="n">screenHeight</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p><code>Player</code>의 총알은 -y 방향으로 진행하고, <code>Enemy</code>의 총알은 +y 방향으로 진행하므로 이를 구분하는 값을 -1, 1 과 같이 정의하였다. (당연한 이야기이지만 이는 #5에서 수정될 구조이다. 딱 봐도 좋지 않다)</p>

<p>총알을 쏜 ship과는 충돌을 하면 안되므로 총알을 생성할 때 자신이 누구에 대한 총알인지 owner의 game object id를 받는다. 그래서 충돌 검사 함수를 override하여 owner id가 해당 game object의 id와 같다면 충돌 처리를 하지 않는다.</p>

<p>매 <code>update</code> 마다 지정된 속도로 총알이 이동할 수 있도록 한다. 그리고 일단 resource가 없으니까 간단하게 충돌 영역을 회색으로 칠해서 총알을 그려버린다.</p>

<p>화면에서 총알이 나갔을 때 총알을 메모리에서 없애버려야 하므로 방향에 따라 화면 이탈 여부를 고려해 <code>isOutOfScreen</code> 함수를 작성한다.</p>

<h4>player 정리</h4>

<p><code>Player</code>의 <code>Ship</code>은 방향 키에 따라 움직일 수 있다. 따라서 먼저 어떤 방향으로 움직일지에 대한 정보를 enum으로 만든다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">enum</span> <span class="n">MoveDirection</span> <span class="o">{</span>
    <span class="n">NONE</span><span class="o">,</span> <span class="n">LEFT</span><span class="o">,</span> <span class="n">RIGHT</span><span class="o">,</span> <span class="n">UP</span><span class="o">,</span> <span class="n">DOWN</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">MoveDirection</span> <span class="nf">fromKeyEvent</span><span class="o">(</span><span class="n">KeyEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">switch</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getKeyCode</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">case</span> <span class="n">KeyEvent</span><span class="o">.</span><span class="na">VK_LEFT</span><span class="o">:</span> <span class="k">return</span> <span class="n">LEFT</span><span class="o">;</span>
        <span class="k">case</span> <span class="n">KeyEvent</span><span class="o">.</span><span class="na">VK_RIGHT</span><span class="o">:</span> <span class="k">return</span> <span class="n">RIGHT</span><span class="o">;</span>
        <span class="k">case</span> <span class="n">KeyEvent</span><span class="o">.</span><span class="na">VK_UP</span><span class="o">:</span> <span class="k">return</span> <span class="n">UP</span><span class="o">;</span>
        <span class="k">case</span> <span class="n">KeyEvent</span><span class="o">.</span><span class="na">VK_DOWN</span><span class="o">:</span> <span class="k">return</span> <span class="n">DOWN</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">NONE</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>어차피 방향은 <code>KeyEvent</code> 정보로부터 받게 되므로, enum 내에 <code>KeyEvent</code>로부터 enum 값을 반환하는 함수를 작성했다.</p>

<p><code>Player</code>의 <code>Ship</code>은 사용자가 누른 Key에 대해서 움직이고, 총알을 쏠 수 있다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Player</span> <span class="kd">extends</span> <span class="n">Ship</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">BULLET_Y_POS_MARGIN</span> <span class="o">=</span> <span class="mi">8</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">SHOT_DELAY</span> <span class="o">=</span> <span class="mi">300</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">SPEED</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">lastShotTick</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Player</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">ResourceManager</span><span class="o">.</span><span class="na">getInstance</span><span class="o">().</span><span class="na">getImage</span><span class="o">(</span><span class="n">ResourceType</span><span class="o">.</span><span class="na">PLAYER_SHIP</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">update</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">move</span><span class="o">(</span><span class="n">MoveDirection</span> <span class="n">direction</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">switch</span> <span class="o">(</span><span class="n">direction</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nl">LEFT:</span> <span class="n">location</span><span class="o">.</span><span class="na">setLocation</span><span class="o">(</span><span class="n">location</span><span class="o">.</span><span class="na">getX</span><span class="o">()</span> <span class="o">-</span> <span class="n">SPEED</span><span class="o">,</span> <span class="n">location</span><span class="o">.</span><span class="na">getY</span><span class="o">());</span> <span class="k">break</span><span class="o">;</span> 
        <span class="k">case</span> <span class="nl">RIGHT:</span> <span class="n">location</span><span class="o">.</span><span class="na">setLocation</span><span class="o">(</span><span class="n">location</span><span class="o">.</span><span class="na">getX</span><span class="o">()</span> <span class="o">+</span> <span class="n">SPEED</span><span class="o">,</span> <span class="n">location</span><span class="o">.</span><span class="na">getY</span><span class="o">());</span> <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="nl">UP:</span> <span class="n">location</span><span class="o">.</span><span class="na">setLocation</span><span class="o">(</span><span class="n">location</span><span class="o">.</span><span class="na">getX</span><span class="o">(),</span> <span class="n">location</span><span class="o">.</span><span class="na">getY</span><span class="o">()</span> <span class="o">-</span> <span class="n">SPEED</span><span class="o">);</span> <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="nl">DOWN:</span> <span class="n">location</span><span class="o">.</span><span class="na">setLocation</span><span class="o">(</span><span class="n">location</span><span class="o">.</span><span class="na">getX</span><span class="o">(),</span> <span class="n">location</span><span class="o">.</span><span class="na">getY</span><span class="o">()</span> <span class="o">+</span> <span class="n">SPEED</span><span class="o">);</span> <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">canShot</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">lastShotTick</span> <span class="o">+</span> <span class="n">SHOT_DELAY</span> <span class="o">&lt;</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="n">Bullet</span> <span class="nf">shot</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">lastShotTick</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="n">Bullet</span> <span class="n">bullet</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bullet</span><span class="o">(</span><span class="n">getId</span><span class="o">(),</span> <span class="n">Bullet</span><span class="o">.</span><span class="na">PLAYER</span><span class="o">);</span>
        <span class="n">bullet</span><span class="o">.</span><span class="na">setLocation</span><span class="o">((</span><span class="kt">float</span><span class="o">)</span> <span class="n">location</span><span class="o">.</span><span class="na">getX</span><span class="o">(),</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span> <span class="n">location</span><span class="o">.</span><span class="na">getY</span><span class="o">()</span> <span class="o">-</span> <span class="n">height</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">BULLET_Y_POS_MARGIN</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">bullet</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isOutOfScreen</span><span class="o">(</span><span class="kt">int</span> <span class="n">screenWidth</span><span class="o">,</span> <span class="kt">int</span> <span class="n">screenHeight</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Player</span> <span class="nf">create</span><span class="o">(</span><span class="kt">int</span> <span class="n">screenWidth</span><span class="o">,</span> <span class="kt">int</span> <span class="n">screenHeight</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Player</span> <span class="n">player</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Player</span><span class="o">();</span>
        <span class="n">player</span><span class="o">.</span><span class="na">setLocation</span><span class="o">(</span><span class="n">screenWidth</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="n">screenHeight</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">3</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">player</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>먼저 생성할 때 <code>ResourceManager</code>로부터 PlayerShip image resource를 가져와서 <code>Ship</code> class의 생성자로 넣어준다. <code>move</code> 함수에서는 어떤 방향으로 움직일 지에 대해 지정된 값으로 더해서 이동할 수 있도록 한다.</p>

<p>총알은 지정된 shot delay가 넘지 않았다면 쏠 수 없다. 따라서 <code>canShot</code> 함수에서 이 tick이 넘었는지 검사하고, shot 함수에서 총알을 만들어서 반환한다. (여기도 수정 대상이다)</p>

<p><code>Player</code>는 매 tick마다 현재 해줄 일이 없으므로 <code>update</code> 함수는 그냥 비워둔다. <code>Player</code>를 만드는 <code>create</code> 함수가 static 으로 선언되어있는데, 현재는 별 의미 없는 함수이다.</p>

<h4>enemy 정리</h4>

<p>마지막으로 적기에 대한 class를 만들어 보자.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Enemy</span> <span class="kd">extends</span> <span class="n">Ship</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">SPAWN_BASE_TICK</span> <span class="o">=</span> <span class="mi">500</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">SPAWN_RANDOM_TICK</span> <span class="o">=</span> <span class="mi">2000</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">BULLET_Y_POS_MARGIN</span> <span class="o">=</span> <span class="mi">8</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">RANDOM_LIFETIME</span> <span class="o">=</span> <span class="mi">50</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">BASE_LIFETIME</span> <span class="o">=</span> <span class="mi">50</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">long</span> <span class="n">spawnTick</span><span class="o">;</span>

    <span class="kd">private</span> <span class="n">Point2D</span> <span class="n">moveDelta</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point2D</span><span class="o">.</span><span class="na">Float</span><span class="o">();</span>
    <span class="kd">public</span> <span class="nf">Enemy</span><span class="o">(</span><span class="n">Point2D</span> <span class="n">location</span><span class="o">,</span> <span class="n">Point2D</span> <span class="n">moveDelta</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">ResourceManager</span><span class="o">.</span><span class="na">getInstance</span><span class="o">().</span><span class="na">getImage</span><span class="o">(</span><span class="n">ResourceType</span><span class="o">.</span><span class="na">ENEMY_SHIP</span><span class="o">));</span>
        <span class="k">this</span><span class="o">.</span><span class="na">location</span><span class="o">.</span><span class="na">setLocation</span><span class="o">(</span><span class="n">location</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">moveDelta</span><span class="o">.</span><span class="na">setLocation</span><span class="o">(</span><span class="n">moveDelta</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">update</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">location</span><span class="o">.</span><span class="na">setLocation</span><span class="o">(</span><span class="n">location</span><span class="o">.</span><span class="na">getX</span><span class="o">()</span> <span class="o">+</span> <span class="n">moveDelta</span><span class="o">.</span><span class="na">getX</span><span class="o">(),</span> 
                <span class="n">location</span><span class="o">.</span><span class="na">getY</span><span class="o">()</span> <span class="o">+</span> <span class="n">moveDelta</span><span class="o">.</span><span class="na">getY</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">canShot</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">random</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mf">0.2</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="n">Bullet</span> <span class="nf">shot</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">Bullet</span> <span class="n">bullet</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bullet</span><span class="o">(</span><span class="n">getId</span><span class="o">(),</span> <span class="n">Bullet</span><span class="o">.</span><span class="na">ENEMY</span><span class="o">);</span>
        <span class="n">bullet</span><span class="o">.</span><span class="na">setLocation</span><span class="o">((</span><span class="kt">float</span><span class="o">)</span> <span class="n">location</span><span class="o">.</span><span class="na">getX</span><span class="o">(),</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span> <span class="n">location</span><span class="o">.</span><span class="na">getY</span><span class="o">()</span> <span class="o">+</span> <span class="n">height</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">BULLET_Y_POS_MARGIN</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">bullet</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isOutOfScreen</span><span class="o">(</span><span class="kt">int</span> <span class="n">screenWidth</span><span class="o">,</span> <span class="kt">int</span> <span class="n">screenHeight</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">float</span> <span class="n">minX</span> <span class="o">=</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span> <span class="n">location</span><span class="o">.</span><span class="na">getX</span><span class="o">()</span> <span class="o">-</span> <span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
        <span class="kt">float</span> <span class="n">minY</span> <span class="o">=</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span> <span class="n">location</span><span class="o">.</span><span class="na">getY</span><span class="o">()</span> <span class="o">-</span> <span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">minX</span> <span class="o">&gt;</span> <span class="n">screenWidth</span> <span class="o">||</span> <span class="n">minY</span> <span class="o">&gt;</span> <span class="n">screenHeight</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isSpawnable</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">spawnTick</span> <span class="o">&lt;</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Enemy</span> <span class="nf">spawn</span><span class="o">(</span><span class="kt">int</span> <span class="n">screenWidth</span><span class="o">,</span> <span class="kt">int</span> <span class="n">screenHeight</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">spawnTick</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()</span> <span class="o">+</span> <span class="k">new</span> <span class="n">Random</span><span class="o">().</span><span class="na">nextInt</span><span class="o">(</span><span class="n">SPAWN_RANDOM_TICK</span><span class="o">)</span> <span class="o">+</span> <span class="n">SPAWN_BASE_TICK</span><span class="o">;</span>
        <span class="n">Random</span> <span class="n">rand</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Random</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">shipHeight</span> <span class="o">=</span> <span class="n">ResourceManager</span><span class="o">.</span><span class="na">getInstance</span><span class="o">().</span><span class="na">getImage</span><span class="o">(</span><span class="n">ResourceType</span><span class="o">.</span><span class="na">ENEMY_SHIP</span><span class="o">).</span><span class="na">getHeight</span><span class="o">();</span>
        <span class="kt">float</span> <span class="n">lifetime</span> <span class="o">=</span> <span class="n">rand</span><span class="o">.</span><span class="na">nextFloat</span><span class="o">()</span> <span class="o">*</span> <span class="n">RANDOM_LIFETIME</span> <span class="o">+</span> <span class="n">BASE_LIFETIME</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">startX</span> <span class="o">=</span> <span class="n">rand</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="n">screenWidth</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">endX</span> <span class="o">=</span> <span class="n">rand</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="n">screenWidth</span><span class="o">);</span>
        <span class="n">Point2D</span> <span class="n">location</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point2D</span><span class="o">.</span><span class="na">Float</span><span class="o">(</span><span class="n">startX</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">shipHeight</span><span class="o">);</span>
        <span class="n">Point2D</span> <span class="n">moveDelta</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point2D</span><span class="o">.</span><span class="na">Float</span><span class="o">((</span><span class="n">endX</span> <span class="o">-</span> <span class="n">startX</span><span class="o">)</span> <span class="o">/</span> <span class="n">lifetime</span><span class="o">,</span> <span class="o">(</span><span class="n">screenHeight</span> <span class="o">+</span> <span class="n">shipHeight</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span> <span class="o">/</span> <span class="n">lifetime</span><span class="o">);</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Enemy</span><span class="o">(</span><span class="n">location</span><span class="o">,</span> <span class="n">moveDelta</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>적기의 logic은 이전 코드에서 그대로 가져온 것으로, 처음 시작 위치(location)와 매 tick마다 update에서 더해줄 이동 값(<code>moveDelta</code>)을 생성자로 받는다.
이것도 역시 <code>canShot</code>과 <code>shot</code> 함수를 통해 총알을 발사하게 된다.</p>

<p>적기를 spawn하는 시점과 어떤 위치에서 적기를 만들지에 대한 함수를 static으로 갖는다.</p>

<h3>main 정리</h3>

<p>이제 main class를 정리해보자.
기존에는 각 type에 대한 List를 가지고 있었어야 했지만, 이제는 <code>GameObject</code>로 이루어진 container 하나만 있으면 된다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">private</span> <span class="n">Player</span> <span class="n">player</span> <span class="o">=</span> <span class="n">Player</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">WIDTH</span><span class="o">,</span> <span class="n">HEIGHT</span><span class="o">);</span>
<span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">GameObject</span><span class="o">&gt;</span> <span class="n">objects</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">GameObject</span><span class="o">&gt;();</span>
</code></pre></div>
<p>대신, <code>Player</code>의 경우는 <code>move</code> 함수 등을 직접 조작해주어야 하니까 따로 reference를 갖는다. 하지만 이것도 <code>update</code> 함수나 <code>paint</code> 함수가 불리어야 하므로 <code>objects</code> 안에 넣어준다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">public</span> <span class="nf">Tatieul</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">setPreferredSize</span><span class="o">(</span><span class="k">new</span> <span class="n">Dimension</span><span class="o">(</span><span class="n">WIDTH</span><span class="o">,</span> <span class="n">HEIGHT</span><span class="o">));</span>
    <span class="n">setFocusable</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
    <span class="n">addKeyListener</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="k">new</span> <span class="nf">Timer</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span> <span class="k">this</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
    <span class="n">objects</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">player</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p>Key를 눌렀을 때는 <code>Player</code> 객체의 <code>move</code> 함수를 불러주면 된다. 단 <code>VK_SPACE</code> 를 눌렀다면 총알을 만들어서 <code>objects</code>에 넣어준다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">keyPressed</span><span class="o">(</span><span class="n">KeyEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">switch</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getKeyCode</span><span class="o">())</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">KeyEvent</span><span class="o">.</span><span class="na">VK_UP</span><span class="o">:</span>
    <span class="k">case</span> <span class="n">KeyEvent</span><span class="o">.</span><span class="na">VK_DOWN</span><span class="o">:</span>
    <span class="k">case</span> <span class="n">KeyEvent</span><span class="o">.</span><span class="na">VK_LEFT</span><span class="o">:</span>
    <span class="k">case</span> <span class="n">KeyEvent</span><span class="o">.</span><span class="na">VK_RIGHT</span><span class="o">:</span>
        <span class="n">player</span><span class="o">.</span><span class="na">move</span><span class="o">(</span><span class="n">MoveDirection</span><span class="o">.</span><span class="na">fromKeyEvent</span><span class="o">(</span><span class="n">e</span><span class="o">));</span>
        <span class="k">break</span><span class="o">;</span>

    <span class="k">case</span> <span class="n">KeyEvent</span><span class="o">.</span><span class="na">VK_SPACE</span><span class="o">:</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">player</span><span class="o">.</span><span class="na">canShot</span><span class="o">())</span>
            <span class="n">objects</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">player</span><span class="o">.</span><span class="na">shot</span><span class="o">());</span>
        <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">repaint</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>
<p>매 tick마다는 모든 객체의 위치를 갱신하고, 충돌 검사를 하며, 적기를 만들어내는 코드는, 실제 수행하는 부분이 모두 각 class로 빠졌으므로 단순해진다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">actionPerformed</span><span class="o">(</span><span class="n">ActionEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">updateAll</span><span class="o">();</span>
    <span class="n">checkCollision</span><span class="o">();</span>
    <span class="n">generateEnemyAndBullet</span><span class="o">();</span>
    <span class="n">repaint</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">updateAll</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">GameObject</span> <span class="nl">each:</span> <span class="n">objects</span><span class="o">)</span>
        <span class="n">each</span><span class="o">.</span><span class="na">update</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">checkCollision</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Set</span><span class="o">&lt;</span><span class="n">GameObject</span><span class="o">&gt;</span> <span class="n">removal</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">GameObject</span><span class="o">&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">objects</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">GameObject</span> <span class="n">lhs</span> <span class="o">=</span> <span class="n">objects</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">objects</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">GameObject</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">objects</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">lhs</span><span class="o">.</span><span class="na">check</span><span class="o">(</span><span class="n">rhs</span><span class="o">))</span> <span class="k">continue</span><span class="o">;</span>
            <span class="n">removal</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">lhs</span><span class="o">);</span>
            <span class="n">removal</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">rhs</span><span class="o">);</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">GameObject</span> <span class="nl">each:</span> <span class="n">objects</span><span class="o">)</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">each</span><span class="o">.</span><span class="na">isOutOfScreen</span><span class="o">(</span><span class="n">getWidth</span><span class="o">(),</span> <span class="n">getHeight</span><span class="o">()))</span>
            <span class="n">removal</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">each</span><span class="o">);</span>

    <span class="k">for</span> <span class="o">(</span><span class="n">GameObject</span> <span class="nl">each:</span> <span class="n">removal</span><span class="o">)</span>
        <span class="n">objects</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">each</span><span class="o">);</span>
<span class="o">}</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">generateEnemyAndBullet</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">Enemy</span><span class="o">.</span><span class="na">isSpawnable</span><span class="o">())</span>
        <span class="n">objects</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">Enemy</span><span class="o">.</span><span class="na">spawn</span><span class="o">(</span><span class="n">getWidth</span><span class="o">(),</span> <span class="n">getHeight</span><span class="o">()));</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">GameObject</span><span class="o">&gt;</span> <span class="n">bullets</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">GameObject</span><span class="o">&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">GameObject</span> <span class="nl">each:</span> <span class="n">objects</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!(</span><span class="n">each</span> <span class="k">instanceof</span> <span class="n">Enemy</span><span class="o">))</span>
            <span class="k">continue</span><span class="o">;</span>
        <span class="n">Enemy</span> <span class="n">enemy</span> <span class="o">=</span> <span class="o">(</span><span class="n">Enemy</span><span class="o">)</span> <span class="n">each</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">enemy</span><span class="o">.</span><span class="na">canShot</span><span class="o">())</span>
            <span class="n">bullets</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">enemy</span><span class="o">.</span><span class="na">shot</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="n">objects</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">bullets</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p>모든 object의 <code>update</code>는 단순히 <code>objects</code>의 객체를 순회하면서 <code>update</code>를 불러주는 것으로 가능하다. 충돌 검사도, 각 case 마다 따로 순회하는 것이 아니라 <code>objects</code> 내의 원소들 간의 충돌을 검사해주는 식으로 통합되었다.</p>

<p>적기를 만드는 과정은 역시 static 함수를 호출해주는 것으로 가능한데, 적기의 총알을 만드는 것은 <code>GameObject</code>가 <code>Enemy</code> class일 때 그 enemy가 총알을 만들 수 있으면 일단 다른 container에 모아놨다가 순회가 끝난 후 <code>objects</code>에 넣어주는 방식이다.</p>

<ul>
<li>그냥 <code>objects</code>를 순회하면서 생성되는 총알을 <code>objects</code>에 넣어버리면 당연한 이야기지만 <code>ConcurrentModificationException</code>이 발생한다. 어떤 container 를 순회하는 도중에는 그 container 를 수정(add/remove 등)을 할 수 없다</li>
<li>총알을 만드는 부분 역시 #5 에서의 리팩토링 대상이다</li>
</ul>

<p>이 모든 것을 화면에 그려주는 것도 단순히 <code>objects</code>를 한 번 순회하면서 <code>paint</code>를 불러주면 그만이다.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">paintComponent</span><span class="o">(</span><span class="n">Graphics</span> <span class="n">g</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Graphics2D</span> <span class="n">g2d</span> <span class="o">=</span> <span class="o">(</span><span class="n">Graphics2D</span><span class="o">)</span> <span class="n">g</span><span class="o">;</span>
    <span class="n">g</span><span class="o">.</span><span class="na">setColor</span><span class="o">(</span><span class="n">Color</span><span class="o">.</span><span class="na">white</span><span class="o">);</span>
    <span class="n">g</span><span class="o">.</span><span class="na">fillRect</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">getWidth</span><span class="o">(),</span> <span class="n">getHeight</span><span class="o">());</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">GameObject</span> <span class="nl">each:</span> <span class="n">objects</span><span class="o">)</span>
        <span class="n">each</span><span class="o">.</span><span class="na">paint</span><span class="o">(</span><span class="n">g2d</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p>이 때 굳이 <code>Graphics2D</code> 객체로 <code>Graphics</code> 객체를 casting한 이유는 나중에 여러가지 것들을 써먹기 위함이다.</p>

<h3>마무리</h3>

<p>간단하게 class를 쪼개고 묶음으로써 코드가 어느정도 정리가 되었다. (물론 덕분에 길어졌다)
코드 내에 박혀있는 숫자를 상수로 바꾸고, class 를 분할하다 보면 어떤 기능이 어느 지점에 추가해야할지 보다 명확히 보일 수 있으므로 그러한 습관을 들이면서 코딩 연습을 하는 것이 좋다.</p>

<p>미리 예고 했던 대로 #5 까지는 좀 더 리팩토링을 진행하고, #6 부터 키 입력 개선, 미사일 다양화 등 게임 컨텐츠에 집중해보도록 하겠다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1><a id="ndc14" href="#ndc14">ndc14</a></h1>
				<hr />
				<div class="page-breaker"></div>
							
						
				<h1 class="page-title">Rx와 Functional Reactive Programming으로 고성능 서버 어플리케이션 만들기</h1>
				<p class="page-date">28 May 2014</p>
				<p class="page-tags">
						
						
					<code class="tag">ndc14</code>
						
						
						
					<code class="tag">server</code>
						
						
						
						
				</p>
				<div class="content"><div class="embed rich SlideShare"><iframe src="https://www.slideshare.net/slideshow/embed_code/key/E85jkcnmqPhpsO" width="427" height="356" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="https://www.slideshare.net/jongwookkim/ndc14-rx-functional-reactive-programming" title="NDC14 - Rx와 Functional Reactive Programming으로 고성능 서버 만들기" target="_blank">NDC14 - Rx와 Functional Reactive Programming으로 고성능 서버 만들기</a> </strong> from <strong><a href="https://www.slideshare.net/jongwookkim" target="_blank">Jong Wook Kim</a></strong> </div>

<p></div></p>

<ul>
<li><a href="http://jongwook.kim/home">김종욱</a></li>
</ul>

<h3>요약</h3>

<ul>
<li>대세는 병렬처리, 이를 Reactive functional programming으로 풀어보자. <del>근데 functional 이야기 안 함</del></li>
<li>Reactive가 왜 나왔는지 알아보자, 그러면서 MONAD 잠깐 이야기</li>
<li>그러면서 Rx.NET 조금 소개 <del>고성능 이야기 안 함</del></li>
</ul>

<h3>내용</h3>

<ul>
<li>ControlFlow

<ul>
<li>Turning machine, Intel Arch</li>
<li>Imperative Programming</li>
</ul></li>
<li>DataFlow

<ul>
<li>병렬처리</li>
<li>Compiler 발전으로 최적화 잘 해줌</li>
<li>The Future of Programming

<ul>
<li>Actor Model</li>
<li>Massively Parallel model</li>
</ul></li>
</ul></li>
<li>Reactive Programming

<ul>
<li>DataFlow 설명을 위한 Excel cell 예시 A + B -&gt; C</li>
<li>독립적 작업 단위 + 데이터 흐름 예시) Gate 조합</li>
<li>기존 명령형 언어는 병렬처리가 어렵다?

<ul>
<li>선언적, DataFlow, Functional Programming, Reactive</li>
</ul></li>
</ul></li>
<li>Reactive Manifesto

<ul>
<li>Responsible</li>
<li>Scalable</li>
<li><strong>Event-driven</strong></li>
<li>Resilient</li>
</ul></li>
<li>시간 이야기

<ul>
<li>뭔가 이야기를 많이 했지만 결국 <strong>switch 비용을 줄이자</strong></li>
<li>tasklet이 작고 빨라야 함.</li>
</ul></li>
<li>event driven

<ul>
<li>사실상 microthread 이야기를 함</li>
<li>관련 framework 이야기를 하면서 callback hell 같은 문제를 언급</li>
</ul></li>
<li> MONAD

<ul>
<li> <code>INPUT =&gt; M&lt;OUTPUT&gt;</code></li>
<li> MONAD = Unit + FlatMap</li>
<li> Maybe, Try, Iterable, Future</li>
</ul></li>
</ul>

<table><thead>
<tr>
<th>-</th>
<th>하나</th>
<th>다수</th>
</tr>
</thead><tbody>
<tr>
<td>동기</td>
<td>Try</td>
<td>Iterable</td>
</tr>
<tr>
<td>비동기</td>
<td>Future</td>
<td>Rx</td>
</tr>
</tbody></table>

<ul>
<li>Reactive

<ul>
<li>Rx = Observable + LINQ + Scheduler

<ul>
<li>Observable = Reactive Stream</li>
</ul></li>
<li>Iterable (pull) -&gt; Observable (push) [duality]</li>
<li>Map: Synchronous Continuation</li>
<li>FlatMap: Asynchronous Continuation</li>
<li>기타 operation들 소개</li>
</ul></li>
<li>LE Platform

<ul>
<li>TCP -&amp;gt; Dispatch -&amp;gt; [Handlers...] -&amp;gt; Database</li>
</ul></li>
<li>기타

<ul>
<li><a href="http://reactive-streams.org">http://reactive-streams.org</a></li>
<li>java: play, akka, reactor</li>
<li><a href="http://reactconf.org">http://reactconf.org</a></li>
<li>coursera principles of Reactive programming</li>
</ul></li>
<li>debugging

<ul>
<li>data flow 기반 분석</li>
<li>data flow를 database처럼 기록(?)해서 추적</li>
</ul></li>
<li>기타 청중 건의

<ul>
<li>async lock이나 async enumerable을 쓰는 것도 고려해보세요.</li>
</ul></li>
</ul>

<hr>

<ul>
<li>발표 내용은 잘 정리되어 흥미로웠지만 정작 Reactive Programming으로 어떻게 고성능 서버를 구현하는 지에 대한 언급이 미흡

<ul>
<li>병렬 처리에 있어서 stateless한 functional programming이 유리한건 사실이나 이게 reactive programming과 어떻게 연결된다는 지에 대한 설명이 부족</li>
<li>event driven으로 microthread나 async io를 설명하는건 좋고, 이게 sync io나 blocking에 비해 성능이 좋은 것은 맞는데 reactive programming과의 연결성이 모호</li>
<li>reactive programming으로 소개된 rx.net은 표현력이 좋은 것이지 성능적 이점을 얻기 위한 것이 아님</li>
<li>lineage eternal이 저걸 어떻게 사용했는지에 대한 부분을 너무 대충 다루고 넘어감</li>
</ul></li>
<li>재미는 있었으나 내용면에서 좀 아쉬운 발표였음</li>
</ul>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">THE NPCM@STER - 라이브 게임에 어울리는 스토리 텔링의 접근법</h1>
				<p class="page-date">29 May 2014</p>
				<p class="page-tags">
						
						
					<code class="tag">ndc14</code>
						
						
						
					<code class="tag">design</code>
						
						
						
					<code class="tag">live</code>
						
						
						
						
				</p>
				<div class="content"><div class="embed rich SlideShare"><iframe src="https://www.slideshare.net/slideshow/embed_code/key/Hs0bldn3Z100wv" width="427" height="356" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="https://www.slideshare.net/khalbora/the-npcmsterpublicfinal-35354617" title="THE_NPCMASTER_PUBLIC" target="_blank">THE_NPCMASTER_PUBLIC</a> </strong> from <strong><a href="https://www.slideshare.net/khalbora" target="_blank">khalbora</a></strong> </div>

<p></div></p>

<ul>
<li><a href="https://twitter.com/khalbora">강근영</a></li>
</ul>

<h3>요약</h3>

<ul>
<li>게임 기획자는 게임 플레이의 수단으로 스토리텔링을 사용하자.

<ul>
<li>저비용 고퀄리티를 위해 캐릭터에 집중, 게임 플레이와 밀착된 캐릭터를 만들자.</li>
</ul></li>
</ul>

<h3>도입</h3>

<ul>
<li>스토리텔링은 하나의 세계를 구축/구현하는 작업이다.</li>
<li>M1 라이브를 진행하면서 스토리텔링의 기회를 얻었는데,

<ul>
<li>사전 조사를 통해 문제점을 수집하고, 열심히 고쳤는데 결과는 별로였다.</li>
<li>유저들의 성향/취향이 다르므로 이 사람들을 다 만족시킬 수는 없다.</li>
</ul></li>
<li>잘못된 이야기는 있어도 잘못된 라이터는 없다. 그렇다면 <strong>왜 잘못되었을까?</strong></li>
<li>eg) 마비노기 이리아

<ul>
<li>변화하는 이리아 땅에서 펼쳐지는 이야기. 스토리라인을 다 구성했지만,</li>
<li><em>매주 금요일 오후 9시 방송</em>으로 업데이트 계획이 변경됨.</li>
<li>유저 동향이나 사업적 이슈에 따라 변경될 수 있으므로 스토리의 사전 제작은 간단하지 않다.</li>
<li>결국 라이브 도중 상당한 수정이 진행되었고,</li>
<li>신규/기존 유저에게 다 기묘하면서, 뻔하거나 억지스럽거나, 이해가 안되거나, 설정이 급전개이거나 충돌되는 결과를 낳았다.</li>
</ul></li>
</ul>

<h3>왜?</h3>

<ul>
<li>소설 구성 3요소는 <strong>인물</strong>, 사건, 배경이다.</li>
<li>드라마틱한 상황은 감정이입에서 오는 것이고, 그러려면 캐릭터에 가치가 있어야 한다.

<ul>
<li><em>천의 얼굴을 가진 영웅</em>: 원형의 역할 / 역할 중심 해석</li>
</ul></li>
<li>엉망이 된 이유는 인물, 사건, 배경이 스토리 진행 도중 흔들렸기 때문이다.

<ul>
<li>사업적인 이슈 등으로 스토리가 실시간으로 변해야 하기 때문이다.</li>
<li>그렇다면 스토리 전달을 위해 사업적 이슈 등을 포기하는게 맞을까?</li>
<li>더 나아가 스토리 전달을 위해 gameplay를 망가뜨리는 것도 괜찮을까?</li>
</ul></li>
</ul>

<h3>라이브 (게임) 시나리오</h3>

<ul>
<li>시나리오는 감동과 재미를 주기 위해 쓴다.

<ul>
<li>업데이트와 함께 새로 즐기기 위한 컨텐츠 요소로 들어간다.</li>
</ul></li>
<li>이 중 스토리텔링은 일부에 해당한다.

<ul>
<li>이것이 차지하는 비중은 낮다.</li>
<li>강력한 경험이지만 효율이 낮기 때문에 작업 합의 도중 많이 깎여나가게 된다.</li>
</ul></li>
<li><strong>게임을 위한 스토리를 써야한다.</strong>

<ul>
<li>새로운 컨텐츠, 캐릭터, 맵 등을 <strong>자연</strong>스럽게 만들어주는 스토리를 써야한다.</li>
<li>하지만 라이브의 비용적 한계가 발생하므로 <strong>저비용 고퀄리티</strong>의 스토리를 쓰는 방법을 찾아야 한다.

<ul>
<li>잦은 수정을 하면서도 재미있는 스토리를 써야 한다.</li>
</ul></li>
</ul></li>
<li>다른 매체에서는,

<ul>
<li>책을 빨리 내는 라이트노벨의 경우 끊임없이 캐릭터를 소모한다. 등장과 소멸(공기화)를 반복한다.</li>
<li>오래 연재하는 만화책의 경우 시선을 이끄는 끊임없는 적이 등장한다. 결국 캐릭터를 소모한다.</li>
<li>무한도전, 런닝맨 등의 경우 매번 다른 Guest를 초대한다.</li>
</ul></li>
</ul>

<h3>캐릭터</h3>

<ul>
<li>많은 사람들이 소비하기 위한 컨텐츠의 <strong>왕도</strong>는 캐릭터이다.</li>
<li>캐릭터를 소모하는 방식은 경쟁에서 생존하기 좋다.

<ul>
<li>해당 작품을 계속 소비할 가치가 있게 만들어준다.</li>
<li>캐릭터를 통해 프레임을 전달한다.

<ul>
<li>변화가 필요할 경우 기존 캐릭터를 변화시킨다.</li>
<li>새로움이 필요할 경우 신규 캐릭터를 추가한다.</li>
</ul></li>
<li>소비자들이 작품 초기부터 캐릭터의 투입/변경에 익숙해지므로 작품이 변화에 적응하기가 좋다.</li>
</ul></li>
<li>때문에 무한한 확장이 가능해진다.

<ul>
<li>새로운 캐릭터의 등장은 새로운 이야기의 시작이다.</li>
<li>eg) A랑 B랑 만나면 무슨 일이 일어날까?</li>
</ul></li>
<li>이는 개발 비용 감소로 이어진다*(?!)*</li>
</ul>

<h3>속성</h3>

<ul>
<li>복잡한 설정이 속성이란 개념으로 표준화되면서 캐릭터 설명이 쉬워졌다.

<ul>
<li>이는 캐릭터를 파악하는 시간이 짧아졌고, 소비하는데 걸리는 시간 역시 단축되었다.</li>
</ul></li>
<li>따라서 여러 매체에서는 속성화된 캐릭터의 자극성을 높이고 있다.

<ul>
<li>캐릭터는 얇게, 생성/소모는 빠르게, 깊게보다 넓게!</li>
</ul></li>
<li>전통적인 스토리텔링의 핵심은 감정이입인데 반해 속성으로 단편화된 캐릭터는 비현실성을 띄므로 소비자는 감정보다 소비에 집중하게 된다.</li>
<li><strong>그래서 줄여야 한다.</strong>

<ul>
<li>라이브 스토리텔링의 핵심은 안정성과 신뢰성이다.</li>
<li>보통 스토리 단절이 생기는 시점은 기획자가 교체되는 시점인데, 만약 유서깊은 캐릭터를 이어서 작업해야 할 경우 캐릭터 연구 및 해석을 해야 한다. 이는 라이브 서비스가 길어질수록 정말 어려운 작업이다.</li>
<li>속성화되어 있다면 캐릭터가 불변이니 전달이 쉽다.</li>
</ul></li>
<li>eg) 아이돌마스터

<ul>
<li>유저들은 주어진 캐릭터를 소비한다. (1차 소비)</li>
<li>그에 대한 2차 창작을 한다. <strong>이는 아주 중요하다.</strong></li>
<li>그리고 그에 대한 2차 소비를 한다.</li>
<li>다른 캐릭터를 소비하며 위 과정을 반복한다.</li>
</ul></li>
<li>작가라면 이 방법이 올바르다고 할 수는 없겠지만, <strong>게임 기획자라면 게임 플레이의 수단으로 스토리텔링을 사용</strong>해야 한다.

<ul>
<li>물론 충분한 업데이트 주기를 갖는 게임이라면 스토리를 제대로 쓸 수 있겠지만 현실에 그런 것은 없다.</li>
<li>옴니버스, 피리어드식 구성을 통해 몰입감 있는 스토리텔링을 할 수도 있다. 즉, 스토리텔링을 위한 게임을 만들 수도 있겠지만 이는 오랜 기간 서비스를 유지하기는 어렵고, 패키지 게임 형태로 만드는 것이 더 낫다.</li>
</ul></li>
</ul>

<h3>정리</h3>

<ul>
<li>게임 기획자는 캐릭터라는 강력한 도구를 효율적으로 사용하여 스토리텔링을 해야 한다.

<ul>
<li>얕은 캐릭터를 매력적으로 만든다.</li>
<li>캐릭터를 소비하되 완전 소비시키지는 않는다.</li>
<li>초반엔 몰입을 위해 고전적 스토리텔링 기법을 도입해야 할 수도 있지만...적절히 잘 하자.</li>
</ul></li>
<li><strong>게임 플레이와 완벽하게 밀착된 캐릭터를 만든다.</strong>

<ul>
<li>퍼거스를 노리고 만든다.</li>
</ul></li>
</ul>

<h3>Q&amp;A</h3>

<ul>
<li>마케팅 등의 이슈로 스토리 수정 요청이 있을 때 방어는 얼마나 했는지?

<ul>
<li><em>쪼렙이라서 못 싸움.</em> 당연한 이야기지만 정말 말이 안되는 요청은 방어를 했고, 보통 담당자와 올바른 방향으로 가기 위해 논의를 하면 잘 진행됨.</li>
</ul></li>
<li>게임 스토리에도 개연성이 중요한지?

<ul>
<li>스토리라면 개연성은 다 중요하다.</li>
</ul></li>
<li>스토리는 수단일 뿐? 스토리가 좋은 명작이 있지 않나?

<ul>
<li>그건 그 스토리를 표현하기 위한 가장 좋은 수단이 게임인 것이다. (The Stanley Parable)</li>
</ul></li>
<li>비용을 깎는데 캐릭터가 제일 나은가? (만들기가 제일 쉬운가?)

<ul>
<li>맵이나 보스 몬스터를 만들어야 하는 비용에 비한다면 캐릭터를 깎는게 낫다고 본다.</li>
</ul></li>
</ul>

<hr>

<ul>
<li>재미있게 들었지만 잘 정리를 못하겠다 [...]</li>
<li>끊임없이 변화하는 상황에 대응하는 라이브 서비스는 순발력을 단련하기 좋은 환경이다.

<ul>
<li>잦은 수정에 대처하기 위해 프로그래머는 소프트웨어 공학 기술을 발전시키며 나름 대응책을 만들어왔다. 핵심은 <strong>작업/수정 비용을 낮추어야 한다는 것</strong>이다.</li>
<li>본 세션을 통해 이것이 다른 직군에서도 동일하게 적용될 수 있다는 점을 생각할 수 있어 좋았다.</li>
</ul></li>
<li>속성화되어 있는 캐릭터의 생산 비용을 낮춘다는 측면에서 <a href="http://www.storyhelper.co.kr/">storyhelper</a>가 떠올랐다. 같은 맥락에서 npchelper 같은 것을 만들어보면 어떨까 하는 생각이 들었다.</li>
</ul>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">WCF를 이용하여 쉽게 만드는 모바일 게임서버</h1>
				<p class="page-date">27 May 2014</p>
				<p class="page-tags">
						
						
					<code class="tag">ndc14</code>
						
						
						
					<code class="tag">c#</code>
						
						
						
					<code class="tag">server</code>
						
						
						
						
				</p>
				<div class="content"><ul>
<li>WebServiceHost를 사용한 모바일 rest web api 서버를 만들어보자.</li>
<li>msdn에 있을 법한 wcf 설명을 한참 함. <a href="http://msdn.microsoft.com/ko-kr/library/ms731190.aspx">msdn 참고</a></li>
<li><p>본인이 구현한 코드를 설명해주는 방식. 추후 발표자료와 함께 올린다고 함</p></li>
<li><p>Contract</p>

<ul>
<li>OperationContract로 web method를 노출</li>
<li>DataContract로 serialize/deserialize할 class를 정의

<ul>
<li>OnSerializing/ed, OnDeserializing/ed로 전후 hook 가능</li>
</ul></li>
</ul></li>
<li><p>Binding</p>

<ul>
<li>WebHttpBinding Http(s) 기반</li>
<li>WSDualHttpBinding은 양방향 가능</li>
<li>NetTcpBinding raw tcp로 통신 가능(?)</li>
</ul></li>
<li><p>ServiceHost</p>

<ul>
<li> InstantContextMode, ConcurrencyMode

<ul>
<li><em>single instance의 multiple concurrency를 사용하면서 동기화는 자료구조 수준으로 하는 대범함을 보임</em></li>
</ul></li>
<li> WebServiceHost

<ul>
<li> WebHttpBehavior, ServiceThrottlingBehavior, WebSecurity</li>
</ul></li>
</ul></li>
<li><p>ORM</p>

<ul>
<li> EntityFramework

<ul>
<li> 예전엔 성능이 별로였는데 요샌 좀 괜찮아졌다고 함</li>
</ul></li>
</ul></li>
</ul>

<hr>

<ul>
<li>그냥 msdn tutorial을 설명한 수준, 그나마도 기본 개념 설명에 많은 시간을 할애함.</li>
<li>예제 설명할 때 iis 안 쓰고 직접 service host 돌린 것은 이해하겠는데 콘솔이라서 뭐가 되네 안되네 하는 부분은 이해를 못 함.</li>
<li>예제의 worker thread 1023개, io thread 1000개인 이유를 모르겠음</li>
<li>관심 있으면 <a href="http://www.asp.net/web-api/overview/hosting-aspnet-web-api/self-host-a-web-api">self-host web api</a>를 보는 것이 나을 듯 싶음.</li>
</ul>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">나이키 런더시티로 본 클라우드 서비스의 장애 복구 프로세스</h1>
				<p class="page-date">28 May 2014</p>
				<p class="page-tags">
						
						
					<code class="tag">ndc14</code>
						
						
						
					<code class="tag">cloud</code>
						
						
						
						
				</p>
				<div class="content"><h3>요약</h3>

<ul>
<li>장애를 예측/계획하고 준비/복구하는 시스템을 구축한다.</li>
</ul>

<h3>terminolgy</h3>

<ul>
<li><code>DR</code> <a href="http://en.wikipedia.org/wiki/Disaster_recovery">Disaster Recovery</a></li>
<li><code>BCP</code> <a href="http://en.wikipedia.org/wiki/Business_continuity_planning">Business continuity planning</a></li>
<li><code>RTO</code> <a href="http://en.wikipedia.org/wiki/Recovery_time_objective">Recovery time objective</a></li>
</ul>

<h3>사례</h3>

<ul>
<li>대한항공 아프리카 이벤트

<ul>
<li>cloud에 대한 고민할 시간이 없어서 기존 개발자가 구축해놓은 것을 그대로 사용</li>
<li>cloud 가용성 테스트*(SLA 검토도 안 함)를* 하지 않은 상태에서 이벤트로 인한 접속 폭주</li>
<li>MCU 300~800명, 1분만에 service down</li>
<li>당시 모 cloud 사의 문제로 인해 망했다.

<ul>
<li>network packet을 무시한다던가,</li>
<li>storage kernal error가 발생한다던가.</li>
</ul></li>
</ul></li>
</ul>

<h3>내용</h3>

<ul>
<li>cloud는 공유 자원

<ul>
<li>좋은 혹은 나쁜 이웃과 자원을 공유</li>
<li>나쁜 이웃을 만나면 infra resource를 빼앗길 수 있다.</li>
<li>그래도 scale up/down이 간단하니 쓴다.</li>
</ul></li>
<li><a href="http://en.wikipedia.org/wiki/Service-level_agreement">SLA</a>

<ul>
<li>SLA uptime은 service 몇 분 down될지 정하는 것 <a href="http://uptime.is/">calculator</a></li>
<li>99.9%는 8시간 45분/year 장애 허용</li>
<li>99.995%는 1년에 26분/year 장애 허용

<ul>
<li>AWS/Azure는 99.95% (22분/month)</li>
<li>U-Cloud는 99.9% (44분/month)</li>
<li>한국 데이터센터 IDC 99.982% (8분/month)</li>
</ul></li>
<li>단, 위 수치는 이론적/통계적 수치이므로 실 장애 시간은 더 길어질 수 있다.</li>
</ul></li>
<li>따라서 <strong>Cloud 서버는 장애를 고려해서 설계</strong>해야 한다.

<ul>
<li>복구의 골든타임을 확보해야 한다.</li>
<li><strong>계획적 장애 구간</strong>을 수치화한다.

<ul>
<li>eg) <code>RTO</code> 1시간, <code>RPO</code> 30분</li>
<li>데이터베이스 이중화</li>
<li><a href="http://en.wikipedia.org/wiki/Hot_spare">hot spare</a> <em>발표자료에서는 웜대기warm standby라고 함</em>: 교체 가용군 대기</li>
<li><a href="https://aws.amazon.com/disaster-recovery/">pilot light</a>: 최후의 준비</li>
</ul></li>
</ul></li>
</ul>

<h3>설계</h3>

<ul>
<li>모든 시스템을 한 곳에 모으지 않는다.

<ul>
<li>IDC를 여러 곳 사용한다.</li>
<li>KT Cloud를 쓴다면 일부는 T Cloud를 쓴다.

<ul>
<li>해당 Cloud 장애 발생시 Active standby로 사용하거나,</li>
<li>적어도 장애 공지를 띄우기 위해서라도 다른 cloud를 사용한다.</li>
<li><em>(관련 서비스 구성도가 필요한데 추후 발표자료가 올라오면 연결하겠음)</em></li>
</ul></li>
<li>Data 부분을 VM과 망을 분리하여 구성, DDoS 공격을 받아도 다 죽지 않도록 구성한다.</li>
</ul></li>
<li>복구를 위해,

<ul>
<li>VM, Storage를 망 분리로 구성 및 다중화하여 일부 장애가 발생해도 서비스가 가용하도록 하고,</li>
<li>전 지점 장애 혹은 infra 장애 발생 시 이를 대체할 수 있는 warm standby를 준비해두고,</li>
<li>최악의 상황을 대비해 cold backup도 준비해둔다.</li>
<li>다중화된 시스템은 auto management 구성이 가능하므로 자동 복구가 되도록 구성하고,</li>
<li>warm standby 교체나 cold backup으로부터의 복구는 manual로 진행한다.

<ul>
<li>교체나 복구 도중 기존 시스템이 자동 복구되면서 충돌하는 문제 등 다양한 상황에 대한 대처를 위해 그냥 손으로 한다.</li>
<li>하지만 그런 장애가 발생했을 때에는 개발자가 쓰러져있는 경우가 많으니, 사전에 미리 <strong>복구 script를 준비</strong>해둔다.</li>
</ul></li>
</ul></li>
<li>Virtual Network는 쓰지 않는 것이 좋다.

<ul>
<li>SLA 99.9%</li>
<li>패킷을 씹어먹거나,</li>
<li>동시에 열 수 있는 connection 개수의 제한이 심해서 자원이 금방 소모되고 조용히 서비스가 제공되지 않는다고 한다.

<ul>
<li>기본 100~125만 session을 열 수 있는데,</li>
<li>SSL 등을 쓰면 약 30만 session을 사용할 수 있다고 하고, 이는 금방 소모된다고 한다. <em>(무슨 말인지는 잘 모르겠음)</em></li>
</ul></li>
</ul></li>
</ul>

<h3>기타</h3>

<ul>
<li>vCPU의 성능을 믿지 말라.

<ul>
<li>vCPU는 hyper thread 등을 가상화해서 제공하는 것이기 때문에, 대충 spec에 비해 70% 정도의 성능을 발휘한다고 생각하는 것이 좋다.</li>
<li>특히 나쁜 이웃과 함께할 경우 성능이 더 안 나온다.</li>
<li>따라서 vCPU 성능 믿지 말고 널리 분산시키는 구조를 만들어야 한다.</li>
</ul></li>
<li>U-Cloud 등은 max-core를 선택해서 사용해라.

<ul>
<li>U-Cloud 시스템에 버그가 있어서 max-core를 사용하겠다고 서비스를 선택하면, 해당 물리 서버 하나를 통째로 내가 사용할 수 있게 된다.</li>
</ul></li>
<li>nodejs 쓰지 않는 것이 좋다.

<ul>
<li>memory limit가 심한데다가, leak이 있어서 긴 시간 운용이 어렵다. (v8이 잘 죽기도 잘 죽고)</li>
<li>cloud에서 돌릴 경우 vCPU 교착 등으로 성능이 66% 수준으로 떨어진다.</li>
<li>만약 쓴다고 하면, 해당 VM의 core에 맞게 다시 빌드해서 사용하는 것이 좋다. (core에 맞게 최적화됨, visual-c나 intel-c로 v8 코드 빌드)</li>
<li>아니면 문제가 발생하는 event가 있는데, 이런 것들을 회피해서 사용할 수 있도록 코드를 작성한다.</li>
</ul></li>
</ul>

<hr>

<ul>
<li>내용이 많았는데 25분 세션이라 좀 아쉬웠다. 그나마 잘 아는 내용이 아니라서 제대로 다 못 적은 점도 좀 아쉬웠다.</li>
<li>정리한 내용이 길었지만 IDC 분산, 시스템 다중화, hot spare, cold backup 등의 단계별 복구 프로세스를 구성하고, 장애 발생 시 계획된 시간 내에 복구할 수 있는 시스템을 사전에 구축할 수 있도록 하자는 내용이다.</li>
</ul>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">던전 앤 파이터 클라이언트 로딩 속도 최적화 - 우리 아이가 세배 빨라졌어요!</h1>
				<p class="page-date">29 May 2014</p>
				<p class="page-tags">
						
						
					<code class="tag">ndc14</code>
						
						
						
					<code class="tag">optimization</code>
						
						
						
						
				</p>
				<div class="content"><div class="embed rich SlideShare"><iframe src="https://www.slideshare.net/slideshow/embed_code/key/lOtZPsSUBtfbVp" width="427" height="356" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="https://www.slideshare.net/JaeseungHa/ndc-2014-35508014" title="[NDC 2014] 던전앤파이터 클라이언트 로딩 최적화" target="_blank">[NDC 2014] 던전앤파이터 클라이언트 로딩 최적화</a> </strong> from <strong><a href="https://www.slideshare.net/JaeseungHa" target="_blank">Jaeseung Ha</a></strong> </div>

<p></div></p>

<ul>
<li><a href="https://twitter.com/ipkn">하재승</a></li>
</ul>

<h3>요약</h3>

<ul>
<li>최적화 아이디어 공유 (분할 압축, dumpable, resource dependency)</li>
<li>하지만 정작 효과가 큰 방법은 버그 수정이었다. (잘못 들어간 logging 삭제)</li>
</ul>

<h3>문제 분석</h3>

<ul>
<li>유저가 만족하는 편안한 게임을 만들어 보자.

<ul>
<li>하지만 8년간 라이브를 해서 이미 코드는 누더기 상태. <em>기술 부채를 넘어선 기술 파산</em></li>
<li>데이터 파일 54만개 642mb, packing하면 300mb</li>
<li>이미지 1000만개 이상, 4.1gb</li>
</ul></li>
<li>매번 HDD를 access하기 때문에 SSD는 필수이고, 메모리 사용량은 2GB를 넘어서 크래시가 발생한다.</li>
<li>lag 최소화, 메모리 최적화, 크래시 해결, 코드 개선 등이 필요.

<ul>
<li>그 중 본 발표에서는 lag 최소화를 이야기함.</li>
<li>eg) 클라이언트 로딩 속도 개선, 스킬 랙 개선</li>
</ul></li>
</ul>

<h3>해결</h3>

<ul>
<li>데이터 분할 압축

<ul>
<li>packing 시 binary xml 비슷한 형태로 packing해서 300mb인데 이걸 memory map으로 사용하고 있었다.

<ul>
<li>일부분만 필요하다고 해도 메모리 공간을 다 점유하고 있고,</li>
<li>XP SP2 이전에서는 특정 크기 이상 mmap을 못 서서 크래시가 발생한 적도 있다.</li>
<li>무엇보다 HDD read access를 제어할 수 없어 io에 의한 lag이 발생한다.</li>
</ul></li>
<li>전체를 압축하면 22mb인데 해제 부담이 있으니 일부분을 빠르게 얻기 위해 <strong>분할 압축을 해보자.</strong>

<ul>
<li>검증을 위해 최적 block size를 테스트해서 얻어냈다.</li>
<li>한 block이 64kb 정도면 전체 용량이 늘지 않으면서도 압축 해제 시간이 적절했다.</li>
<li>비슷한 종류끼리 압축해서 사용했다.</li>
<li>전체(22mb)를 메모리에 올리고, 필요한 부분만 압축을 풀어서 사용했다.</li>
<li>추후 데이터가 추가될 경우를 위해 incremental packing을 구현했다.</li>
</ul></li>
<li>memory 사용량이 100mb 정도 감소했고,</li>
<li>patch size도 감소했고,</li>
<li>data file access time도 감소했는데</li>
<li><strong>로딩 속도 개선은 별로 없었다.</strong></li>
</ul></li>
<li><a href="https://github.com/ipkn/dumpable">dumpable</a>

<ul>
<li>화면에 출력되는 모든 것은 animation data file로 이루어져 있는데 이는 전체 파일의 50%를 차지한다.</li>
<li>한 화면 로딩할 때마다 대충 2,000개 정도씩 로딩한다.</li>
<li>이에 대한 deserialize 부담이 좀 크니 memcpy 수준으로 로딩이 되면 좋겠다.

<ul>
<li>pointer나 stl container 등에 대해서도 serializable memory를 구성해야 한다.</li>
<li>pointer는 상대 주소로 저장하고 동적 할당된 구간에 대해서도 같이 저장한다.</li>
<li>serialize/deserialize code도 없으면 좋겠다. code generator 수준이 아니라 그냥 없으면 좋겠다.</li>
</ul></li>
<li>그래서 serialize 코드 없고, memcpy 가능한 dumpable 라이브러리를 개발했다.

<ul>
<li>memory 배치를 잘 해서 read는 casting만으로 끝날 수 있도록 했다.</li>
<li>쓰기 부담이 좀 있지만 읽기 부담은 0이고, 복사 비용도 싸다.</li>
<li><em>(자세한 것은 코드를 읽어보면 된다)</em></li>
</ul></li>
<li>하지만 그냥 접근하는 파일이 많아서 느린 것이므로 dumpable을 적용했을 때 로딩 시간이 줄어드는 효과는 별로 없었다.</li>
<li> 따라서 괜히 코드 복잡도를 높일까봐 적용하지는 않았다.</li>
</ul></li>
<li>연관 데이터 파일 미리 읽기(preload)

<ul>
<li>이미지 파일을 미리 읽어서 로딩 속도를 개선하자. <em>그런데 data dependency가 기술된 파일이 없다.</em></li>
<li>그런데 skill-tree에 따라 effect가 달라지고, 직업 별로 독특한 play style이 있어 그에 따른 연관 데이터를 찾기가 어렵다.

<ul>
<li>심지어 이러한 연관 정보가 데이터로 표현되기 힘들다고 hard coding된 것들이 많다.</li>
</ul></li>
<li>기존에는 뭘 읽을지 모르니, 읽고나서 안 버리는 구조로 작성되어 있었다.

<ul>
<li>덕분에 처음엔 랙이 발생하고 나중엔 메모리 부족으로 클라이언트가 크래시되었다.</li>
</ul></li>
<li>정적 분석을 통해 dependency를 찾아보자.

<ul>
<li>define 전처리 후 그 결과를 heuristic하게 parsing해서 코드에 기술된 skill-resource를 분석했다.</li>
<li>제대로 ast 만들어 parsing하지 않으면 제대로된 결과를 얻을 수가 없다.</li>
<li>그냥 대충 나온 것으로 preload 해봤는데 효과가 미비했다.</li>
</ul></li>
<li>유저의 loading 로그 기반으로 dependency를 찾아보자.

<ul>
<li>resource를 읽을 때 던전, 이미지, animation 파일 들을 logging하도록 클라이언트에 포함,</li>
<li>테스트 서버에 배포해서 CSV 15gb, 7700만 access 기록을 얻어냈다. <em>(대충 모든 스킬 정보가 다 포함되었다고 한다. 안 그러면 라이브에 배포할 계획이었다고 한다.)</em>

<ul>
<li>스킬에 연관된 이미지는 해당 스킬 발동 후 매번 비슷한 시점에 읽을 것이라는 가정 하에 분산을 계산해서 목록을 추렸다.</li>
<li>스킬 적용 모션은 parts화 되어 있으므로, parts별로 나오는 데이터를 grouping해서 포함할 수 있도록 했다. (face가 나오면 body도 포함하는 식)</li>
<li>던전 resource의 경우 특정 던전에서 반복해서 읽는 것을 추렸다.</li>
</ul></li>
<li>데이터 추릴 때 발생한 문제점이 있다.

<ul>
<li>스킬 사용 직후 맵을 이동하면 데이터 노이즈가 생긴다. 수집 범위 시간을 최대한 좁혀서 회피했다.</li>
<li>저사양 데이터가 섞여서 제대로 구분하기가 어렵다. outlier 강한 분포를 사용해야 할지 어떨지 모르겠다.</li>
<li>random effect가 발동되는 경우가 있는데 이건 그냥 무시하거나 노가다로 입력했다.</li>
</ul></li>
<li>그리고 주기적으로 수집해서 이전 dependency map과 통합될 수 있도록 하고,</li>
<li>이벤트성 effect의 경우로 데이터가 특정 시점에만 추가될 경우 map을 구성할 때마다 threshold 이하의 참조 resource는 삭제하는 방식으로 제거했다.</li>
</ul></li>
<li>적용 후 입장 시간은 증가했지만 랙은 감소했다. 하지만 메모리 사용량 증가로 인해 크래시가 발생했다.</li>
</ul></li>
<li>resource list 미리 구성하기

<ul>
<li>이미지 1000만개를 image pack 8만개로, 이걸 다시 image pack-pack 2000개로 만들어 배포를 하는데,</li>
<li>처음 구동 시 이걸 다 열어서 list를 구축하는 부분이 있다.</li>
<li>이걸 list로 뽑아서 같이 배포되도록 했다. 그리고 성능 개선됨.</li>
</ul></li>
<li>security logging 버그 수정

<ul>
<li>보안을 위해 primitive type 변수를 wrapping해서 사용하는데, 여기에 실수로 logging 코드가 들어가 같이 배포가 되었다.</li>
<li>이걸 빼니까 속도가 꽤 향상됬다. (animation 로딩 느린 것도 이 문제였던 것으로 추측된다.)</li>
</ul></li>
<li>기타 profiling으로 얻은 것

<ul>
<li>std::map은 boost::unordered_map으로 대체한다.

<ul>
<li>vs2010의 std::unordered_map은 boost의 것보다 많이 느리다.</li>
</ul></li>
<li>tbb의 scalable_alloc으로 약 10% 성능 향상을 얻었다.</li>
</ul></li>
</ul>

<h3>결과</h3>

<ul>
<li>저사양 유저들은 빨라졌다고 좋아하는데 고사양 유저들은 모르겠다거나 더 느려졌다는 반응이다.</li>
<li>resource list를 직접 배포하는 바람에 custom skin 기능이 막혔다. 근데 유저들이 금방 해결했다.</li>
<li>개선 후 메모리 부족 문제로 더 튕기는 현상이 많아졌고,</li>
<li>위 개선 사항은 solo play에만 국한된 것이므로 party play이 lag은 여전하다.</li>
<li>앞으로,

<ul>
<li>이제 resource data dependency를 얻었으니 던전 끝나고 불필요한 resource를 해제할 수 있다. 그럼 메모리 사용량을 좀 개선할 수 있을 것이다.</li>
<li>마을 메모리 사용량 높은 이유를 확인해봐야겠다.</li>
<li>party play 메모리도 최적화를 해야겠다.</li>
</ul></li>
</ul>

<h3>Q&amp;A</h3>

<ul>
<li>dumpable 사용하다가 casting 실수가 발생하면 어떻게?

<ul>
<li>c++은 원래 그런 언어잖아요?</li>
</ul></li>
<li>던파의 하드 코딩 수준은 어느 정도?

<ul>
<li>망했어요.</li>
</ul></li>
<li>최적화하면서 발생한 버그는 어떻게?

<ul>
<li>훌륭한 프로그래머는 버그를 만들지 않습니다.</li>
</ul></li>
</ul>

<hr>

<ul>
<li>본 세션은 기술 세션이라기 보다는 경험 공유 세션이므로, 그 과정을 다 서술하기 위해 노력했다. (덕분에 내용이 길다)</li>
<li>전 회사에서 서버 구동 시간 단축을 위해 <a href="/2013/06/09/binary-xml-for-fast-loading/">노력</a>을 해본 적이 있다. 그래서 드는 의문은,

<ul>
<li>보통 최적화를 할 때에는 <a href="http://en.wikipedia.org/wiki/Profiling_%28computer_programming%29">profiling</a>을 먼저 한다. vs의 analysis를 쓰든 vtune을 쓰든 돌려보면 느린 함수가 순서대로 잘 나온다. 그리고 보통 그 순서대로 원인을 파악하기 위해 작업을 한다.</li>
<li><del>만약 그랬다면 위 최적화의 적용 순서가 logging 삭제, list 미리 구성, <code>unordered_map</code>, <code>scalable_alloc</code> 적용, 분할 압축, dumpable 순일 것 같은데 그렇지 않았다</del> <em>특별히 어느 한 부분이 압도적으로 문제가 되는 부분이 없었다고 한다.</em></li>
<li>그렇다는 것은 던파 코드가 analysis를 써도 결과가 제대로 안 나오는 답이 없는 상황 <del>이거나 profiling을 초반에 제대로 못 돌렸다는 것이다</del> 이었다는 것이다.<br>
<em>발표 시점에 해당 내용을 놓친 것 같다. 발표자님의 댓글 도움으로 수정</em></li>
</ul></li>
<li>따라서 다른 누군가가 위 세션에 감동을 받아 최적화를 진행한다고 하면,

<ul>
<li>잘못된 logging 코드나 preload dependency map 구성에 집중하는 것이 아니라,</li>
<li>profiling을 수행한 결과를 보고 target을 추린 뒤,</li>
<li>위에서 사용한 논리 전개 방식을 참고하여 진행하는 것이 좋을 것 같다.</li>
</ul></li>
<li>다음의 방법들은 참신하거나 재미있었다.

<ul>
<li>효율적인 분할 압축의 크기를 대충 계산한 것이 아니라 직접 script를 만들어 테스트를 해봤다.</li>
<li>유저 로그를 분석할 때 시간을 grouping하기 위해 분산을 사용했다.</li>
<li>dumpable 라이브러리에서 reflection 없이 각 member를 serialize하기 위해 custom-serializable-type (<code>dptr</code>, <code>dstring</code>, <code>dvector</code>, <code>dmap</code>)에 대한 <code>operator =</code> 를 사용했다.

<ul>
<li>각 member의 size와 추가 할당된 데이터를 가져오는 것이 핵심인데,</li>
<li>위 type의 <code>operator =</code>를 구현해놓고, <code>T temp = original;</code>과 같이 복사하면 각 member의 <code>operator =</code>가 불리니까 여기서 size를 얻고 추가 할당 데이터를 local pool에 복사할 수 있다.</li>
<li>하지만 위 map을 구성하는 <code>dptr_alloc()</code>이 static 변수라 thread-safe하지 않은 문제가 있다.</li>
</ul></li>
</ul></li>
</ul>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
						
				<h1 class="page-title">라이브 상황에서 윈도우 서버 개발자가 겪은 좌충우돌 Redis 적용 경험담</h1>
				<p class="page-date">28 May 2014</p>
				<p class="page-tags">
						
						
					<code class="tag">ndc14</code>
						
						
						
					<code class="tag">server</code>
						
						
						
						
				</p>
				<div class="content"><h3>요약</h3>

<ul>
<li>linux 모르는 windows 개발자가 linux에 redis깔고 lua script 돌렸습니다.</li>
</ul>

<h3>내용</h3>

<ul>
<li>CSO에 실시간 랭킹 구현 요청에 따라 redis를 도입

<ul>
<li>db는 어렵고 sql 못하니 유지보수 못하고</li>
<li>신규 서버 만드려니 구현 부담이 너무 큼</li>
</ul></li>
<li>근데 windows redis는 unofficial임</li>
<li>따라서 ubuntu 깔고 redis 설치

<ul>
<li>sentinel 써서 master/slave 구축을 해 failover하도록 구성해야 했는데 못 함</li>
</ul></li>
<li>client library로 hiredis를 썼는데 linux library라서 porting을 할까 하다가 그냥 windows redis에 붙어있는 library 씀</li>
<li>최신 버전을 깔고 싶은데 package repo에 버전이 옛날 것.

<ul>
<li>PPA라는 좋은 물건이 있어요!</li>
</ul></li>
<li>cron 설명, pscp 설명</li>
<li>rdb, aof로 백업해서 windows에 둠

<ul>
<li>rdb는 redis desktop manager로 열어보면 좋음</li>
</ul></li>
<li>live 운영 실수로 redis, rdb 모두 날림. aof로 복구함</li>
<li>redis lua script 설명

<ul>
<li>외부 client library로 접근하는 것보다 내부 script가 훨씬 빠름</li>
<li>evalsha는 return이 없어서 script 성공/실패 여부를 알기가 어려움. 따라서 special key를 만들어 결과를 저장하고 보는 식으로 사용</li>
<li>redis nil은 lua false와 같다</li>
<li>lua 함수 제한이 있으니 _G 보고 판단해서 사용</li>
<li>lua bind도 설명</li>
</ul></li>
<li>redis pub/sub 설명</li>
</ul>

<hr>

<ul>
<li>...</li>
</ul>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">모바일 게임서비스를 위한 사설 클라우드 구축/운영 분투기</h1>
				<p class="page-date">28 May 2014</p>
				<p class="page-tags">
						
						
					<code class="tag">ndc14</code>
						
						
						
					<code class="tag">cloud</code>
						
						
						
						
				</p>
				<div class="content"><div class="embed rich SlideShare"><iframe src="https://www.slideshare.net/slideshow/embed_code/key/lUq7JAKaH6FUxC" width="427" height="356" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="https://www.slideshare.net/reinkim/ndc14" title="NDC14 모바일 게임서비스를 위한 사설 클라우드 구축/운영 분투기" target="_blank">NDC14 모바일 게임서비스를 위한 사설 클라우드 구축/운영 분투기</a> </strong> from <strong><a href="https://www.slideshare.net/reinkim" target="_blank">Jinuk Kim</a></strong> </div>

<p></div></p>

<ul>
<li><a href="http://rein.kr/blog/">김진욱</a></li>
</ul>

<h3>요약</h3>

<ul>
<li>직접 머신 infra 구축 + os/vm/open source (수정/튜닝)해서 private cloud 구축</li>
<li>문제, 대응, 문제, 대응, 문제, 대응, ...</li>
<li>근데 windows로 넘어가니 또 신세계: 문제, 대응, 문제, 대응, 문제, 대응, ...</li>
</ul>

<h3>내용</h3>

<ul>
<li>Build Private Cloud for Mobile Game

<ul>
<li>x86 + switch + cables + power</li>
<li>linux kvm, openstack, puppet, haproxy, nginx, uwsgi, dnsmasq, dpkg, fabric, ...</li>
</ul></li>
<li>Problem domain

<ul>
<li>application, vm, os, virtualize sw, infrastructure</li>
<li>infrastructure problems: cable 불량, sensor 불량, power 불량, IPMI 불량, ...</li>
</ul></li>
<li>setup automation

<ul>
<li>PXE, debian-installer, puppet, bash-scripts

<ul>
<li>PXE는 (변형된) DHCP가 필요한데 IP가 중복되면서 debian-installer가 실패하는 문제가 발생</li>
<li>debian-installer는 udeb package도 사용하는데 deb만 mirroring해서 망, 그리고 머신 종속적인 package는 관리 주의</li>
<li>puppet는 signing 문제, 머신 type별 설정 분리 문제, package 의존성에 의한 문제, 모듈 로딩 순서 문제 등</li>
</ul></li>
<li>그리고 뭔가 package repository 문제</li>
</ul></li>
<li>resource management

<ul>
<li>ulimit, sysctrl, nofile</li>
<li>network parameter: conntrack

<ul>
<li>제대로 설정을 안하면, connection이 안 맺어지거나 안 끊어지는 문제가 발생해서 서비스가 조용히 안 되는 경우가 있음</li>
</ul></li>
<li>OOM killer

<ul>
<li>linux의 메모리 할당은 낙관적인데, 메모리가 막 할당되었다가 kill 당할 수 있으니 주의</li>
</ul></li>
<li>Disk elevator</li>
<li>Scale out

<ul>
<li>보통 web server. 접속 몰리면 load balancer를 사용</li>
<li>HAProxy를 쓴다. 1vCPU + 1GB memory 주면 10K~100K http req/sec 정도는 처리</li>
<li>stat 보고 tuning해서 쓴다.</li>
<li>만약 허용량 초과하면 HAProxy를 여러 개 쓰고 DNS RoundRobin을 앞단에 붙여준다.</li>
<li>근데 DNS 갱신이 느리니까 추가될 때마다 갱신하는 것보다는 미리 IP 할당 후 등록해두고 사용한다. (expiration 줄이는 것보다 이게 더 빠르다.)</li>
</ul></li>
</ul></li>
<li>Live with FOSS

<ul>
<li>OpenStack 버그 많고 (의외로) 기능이 별로 없다.</li>
<li>HAProxy의 한계

<ul>
<li>단일 thread/process 사용.

<ul>
<li>하지만 2core 줘서 core 하나는 HA가, 나머지 하나는 kernel이 쓰게하면 처리 성능이 좋아진다.</li>
</ul></li>
<li>SSL terminator 지원을 안한다.</li>
<li>soft restart 후 glitch가 발생한다.</li>
</ul></li>
<li>보안 취약점으로 인해 패치를 할 경우, host 수준의 패치일 경우 물리 머신을 재시작해야 하는 고통이 있다.</li>
<li>OpenStack + KVM으로 windows를 구동할 경우 문제가 많다.

<ul>
<li>linux 기반으로 만든 툴을 python으로 만들어서 windows에도 배포</li>
<li>windows의 puppet는 유료, secureshell도 유료, LDAP은 복잡(?)</li>
</ul></li>
</ul></li>
<li>Monitoring

<ul>
<li>뭐가 문제인지 파악하기 위해 필요함. 장애인가 점검인가?</li>
<li>외부 서비스 장애인가?

<ul>
<li>카카오톡 게임 서비스 장애?</li>
<li>billing 서버 응답 지연?</li>
<li>통신사망 장애?</li>
</ul></li>
<li>Alarm

<ul>
<li>email: noti가 잘 안된다.</li>
<li>SMS</li>
<li>전화 걸기: 비싸다.</li>
</ul></li>
</ul></li>
<li>Summary

<ul>
<li><em>(발표 자료 참고바랍니다.)</em></li>
</ul></li>
</ul>

<hr>

<ul>
<li>역시 25분 발표라서 시간이 너무 부족함.</li>
<li>정말 분투기임. 구축자의 애환이 느껴졌다.</li>
<li>양이 너무 많아서 다 정리하기는 어려웠고, 그냥 발표자료 보는 것을 추천.</li>
</ul>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">모바일 데이터 분석</h1>
				<p class="page-date">29 May 2014</p>
				<p class="page-tags">
						
						
					<code class="tag">ndc14</code>
						
						
						
					<code class="tag">data</code>
						
						
						
						
				</p>
				<div class="content"><div class="embed rich SlideShare"><iframe src="https://www.slideshare.net/slideshow/embed_code/key/gffS3dV55aLfUI" width="427" height="356" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="https://www.slideshare.net/5rocks_io/ndc-20140529" title="[NDC 발표] 모바일 게임데이터분석 및 실전 활용" target="_blank">[NDC 발표] 모바일 게임데이터분석 및 실전 활용</a> </strong> from <strong><a href="https://www.slideshare.net/5rocks_io" target="_blank">Tapjoy X 5Rocks</a></strong> </div>

<p></div></p>

<ul>
<li><a href="https://www.5rocks.io/">서하연</a></li>
</ul>

<h3>요약</h3>

<ul>
<li>시계열 분석 대신 시간대별 분석을 사용한다.</li>
<li>유저의 특성에 따라 분석 결과를 개별적으로 적용한다.</li>
</ul>

<h3>모바일 특성 이해하기</h3>

<ul>
<li>모바일 특성을 이해해야 어떻게 분석할 지 알 수가 있다.</li>
<li>유저의 쏠림 현상

<ul>
<li>LifeStyle이 반영된다. mobile 기기의 특성 상 특정 시간대에 집중. eg) 출퇴근 시간</li>
<li>Marketing 효과가 크다. 특정 시간대 이벤트할 경우, Push 발송 등에 의해.

<ul>
<li>최대치가 보통에 비해 2~4배 정도 차이가 남. 심하면 몇 십배까지도 차이가 난다.</li>
</ul></li>
</ul></li>
<li>Simple Context

<ul>
<li>Context: 목적을 달성하기 위해 이뤄지는 일련의 action</li>
<li>device의 특성 상 화면 크기가 제한적이고 operation이 제한적이어서 action 선택 가지 수가 제한적이다. (touch, swipe)</li>
<li>평균 1분30초 ~ 5분의 session time내 play pattern이 결정되므로 만들어질 수 있는 context의 한계가 있음</li>
</ul></li>
<li>빠른 feedback

<ul>
<li>만족하지 않으면 빠르게 이탈한다. 길어야 2~3달. (성공한 mobile game들이 top을 유지한 시간의 평균)</li>
</ul></li>
</ul>

<h3>모바일 환경의 이슈들 - 데이터 처리</h3>

<ul>
<li>데이터 처리

<ul>
<li>수집 정리 (processing)</li>
<li>분석, 지표화, 사업 반영/활용</li>
</ul></li>
<li>로그 포맷 이슈

<ul>
<li>많은 간단한 데이터가 단 시간에 쏟아지는 경우 정의는 어떻게 할 것이며, 처리는 어떻게 할 것인가?</li>
</ul></li>
<li>로그 해상도 이슈

<ul>
<li>어느 정도까지 자세히 남겨야 하나? 자세함과 logging 부담의 trade-off를 고려한다.</li>
</ul></li>
<li>로그 유실 관련 이슈

<ul>
<li>모바일의 특성 상 유실이 심할 수 있다. 어떻게 correction할 것인가?</li>
</ul></li>
<li><em>(위 주제에 대한 자세한 내용에 대해서는 화요일 세션에 발표했으므로 해당 발표를 참조하도록 한다.)</em></li>
</ul>

<h3>모바일 환경에서 데이터 분석</h3>

<ul>
<li>지표의 정합성 확보

<ul>
<li>잘못된 지표로 운영하면 망한다.</li>
<li>잘못된 데이터 기반일 경우도 있으니 주의해야 한다.</li>
<li>eg) retention 값을 잘못 지정하고 luanching을 했다가 open 이후 marketing을 안해서 망했다.</li>
<li>LifeCycle이 짧으니까 삽질 한 번 잘못하면 회복할 기회가 없다.</li>
<li>측정값과 대상값을 구분해야 한다.

<ul>
<li>install 수, 신규 유저, active 유저, session 수, session time, 매출, paying 유저, 구매 회수</li>
</ul></li>
<li>이상 징후가 잘못 집계될 수 있으니 주의해야 한다.</li>
<li>open 전 테스트 기간부터 위 값을 수집/분석하여 의도대로 결과가 나오는지 확인을 해야 한다.</li>
</ul></li>
<li>interval 개념 전환

<ul>
<li>일/주/월 단위 뿐만 아니라 <strong>시간대별 분석</strong>이 필요하다.</li>
<li><strong>actionable data</strong></li>
<li>시계열 data는 현상을 볼 수는 있어도 왜 그런 현상이 일어나는지, 그래서 뭘 해야 하는지 알기가 어렵다.</li>
<li>eg) daily active user. 주말에 active user가 많다. <em>그래서?</em></li>
<li><strong>보는 방식을 바꾸자</strong></li>
<li>eg) 위 데이터를 24시간으로 재배치해서 재구성. 그 중 평일/주말 방문 도수를 시간대 별로 보자.

<ul>
<li>어떤 유저가 늘 접속하던 9시에 접속을 안했다.</li>
<li>그 유저에게 뭔가를 해주어야 이탈하지 않을 가능성이 높다.</li>
</ul></li>
<li>eg) Item 판매량을 시간대별로 재구성</li>
</ul></li>
<li>분석 결과를 user별 적용

<ul>
<li>휴면 유저와 구매 유저는 구분해서 적용해야 한다.</li>
<li>전체 data를 분석해서 pattern을 찾아도, 적용은 개별적으로 해야 한다.</li>
<li>eg) 시계열 graph로 휴면 유저를 보면, 그냥 휴면 유저가 늘고 있다는 것만 알 수 있다. 즉, 현상의 결과만 볼 수 있다.

<ul>
<li>매일 방문 유저가 4일째 접속을 안할 경우,</li>
<li>주말에 주로 접속하는 유저가 4일째 접소을 안할 경우,</li>
<li>두 유저를 같은 유저로 취급해서 방문 push를 보내면 안된다.</li>
<li>따라서 사용자의 play pattern, 구매 pattern을 개별 분석 후 적용해야 한다.</li>
</ul></li>
</ul></li>
<li><code>user별 이탈자 수 = {휴면기간} / {User 고유 접속 주기}</code>

<ul>
<li>고유 접속 주기는 매일 접속일 경우 1, 주말 접속일 경우 7이 된다.</li>
<li>4일 접속 안한 평일/주말 플레이 유저의 이탈지수는 각각 3, 0.57이 된다.</li>
<li>이 graph를 만들어 특정 구간을 넘어선 유저에 대해 push를 보낸다.</li>
<li>구매에 대해서도 같은 방식을 적용할 수 있을 것이다.</li>
</ul></li>
</ul>

<h3>정리</h3>

<ul>
<li>정확한 지표를 확보하고</li>
<li>시간대별 지표 분석이 필요하다.</li>
<li>휴면/구매 유저 관리는 개별적으로 한다.</li>
</ul>

<h3>Q&amp;A</h3>

<ul>
<li>유저의 접속률을 장기적으로 만드려면 어떻게 해야 하나?

<ul>
<li>우리나라는 초반 유입 집중이 심한 편이니 초반 1주일을 제대로 관리하고,</li>
<li>장기적으로는 <code>{이탈율} / {app 전체 총량}</code> 마케팅을 장기적으로 지속 관리한다.

<ul>
<li>eg) 특정한 날 install한 유저를 추적 관리함</li>
</ul></li>
</ul></li>
<li>유저별 시간대 행동 패터늘 어떻게 묶는 것이 좋을까?

<ul>
<li>복잡한 통계 기법을 사용할 수도 있다.</li>
<li>아니면 일단 가시적으로 보이는 group을 찾아보자.</li>
</ul></li>
</ul>

<hr>

<ul>
<li>데이터 처리 방법이 궁금했던 것인데 그건 첫째 날 발표한 것이어서 이번 내용에는 빠졌다.</li>
<li>사례에 대한 이야기도 많아서 짧은 시간에 폭풍같이 발표가 끝났다. 원래 아는 분야가 아니라 내용에 대해서는 할 말이 없다.</li>
</ul>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
						
				<h1 class="page-title">범용 게임 서버 프레임워크 디자인 및 테크닉</h1>
				<p class="page-date">28 May 2014</p>
				<p class="page-tags">
						
						
					<code class="tag">ndc14</code>
						
						
						
					<code class="tag">design</code>
						
						
						
					<code class="tag">server</code>
						
						
						
						
				</p>
				<div class="content"><div class="embed rich SlideShare"><iframe src="https://www.slideshare.net/slideshow/embed_code/key/8CCbTMPDEQdwX4" width="427" height="356" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="https://www.slideshare.net/iFunFactory/20140524-ndc-sharing" title="NDC14 범용 게임 서버 프레임워크 디자인 및 테크닉" target="_blank">NDC14 범용 게임 서버 프레임워크 디자인 및 테크닉</a> </strong> from <strong><a href="https://www.slideshare.net/iFunFactory" target="_blank">iFunFactory Inc.</a></strong> </div>

<p></div></p>

<ul>
<li><a href="http://ifunfactory.com/">문대경</a></li>
</ul>

<h3>요약</h3>

<ul>
<li>가정/목표를 정하고 할 수 있는 것/없는 것을 구분하여 시스템을 설계한다.</li>
<li>Comm=JSON, Mgmt=RestAPI, Obj=Json CodeGen/STM, Dist=RPC인 GameServer를 설계한다.</li>
</ul>

<h3>System Design</h3>

<ul>
<li>System = interface + Architecture</li>
<li>Architecture = functional list + 그것들의 배치/연동</li>
<li>design decision은 trade off가 있다.</li>
<li>design goal을 세우고 잘 지키도록 한다.

<ul>
<li>목표를 정의하고, 가정/필수/포기를 결정한다.</li>
<li>제공하는 것, 할 수 있는 것, 할 수 없는 것을 결정한다.</li>
</ul></li>
<li>이를 바탕으로 구현하는 것은 system builder라고 한다. (기술에 집중하는 사람)</li>
<li>system designer의 성장 방향

<ul>
<li>코드 한 줄 - 함수 - 모듈 - 서비스 - 사람(?) 을 설계하는 방향으로 성장</li>
</ul></li>
<li>정리하면, <strong>가정 하에 뭐가 되고 안 되는지</strong>를 결정 (trade off를 잘 고려)</li>
</ul>

<h3>Generic GameServer Framework Design</h3>

<ul>
<li>가정: 뭐가 올라가는 지 모름</li>
<li>목표: <strong>Flexibility</strong> (임의의 게임을 올려야 하니까), <strong>Scalability</strong> (확장성이 좋아야함), <strong>minimum-performance</strong> (상대적으로 포기한다)</li>
<li><strong>client-server message format</strong>

<ul>
<li>standard format은 http, udp, json, xml... usability, inefficiency</li>
<li>custom format은 TLV, length를 기록한 tcp, ... efficiency, manageability</li>
<li>overhead, traffic profiling, encryption 등을 고려

<ul>
<li>eg) MTU 보다 message 크기가 크냐 작냐</li>
</ul></li>
<li>본 설계에서는 flexibility 측면에서 <strong>JSON을 선택</strong>함

<ul>
<li>traffic, encryption, serialize, deserialize overhead가 있다.</li>
</ul></li>
</ul></li>
<li><strong>Management</strong>

<ul>
<li>push-based <em>(중요 유저 행동 로그 남길 때 사용)</em>

<ul>
<li>db, file, logging</li>
<li>Management가 GameServer에게 control 명령을 내리면, GameServer는 Management에게 data를 push함.</li>
<li>GameServer는 구현이 편한데(?) Management에서 data를 읽을 수 있도록 맞추는게 힘듬(?)</li>
</ul></li>
<li>pull-based <em>(서버 상태 및 통계 데이터 조회 시 사용)</em>

<ul>
<li>SOAP, REST</li>
<li>Management가 GameServer에세 control 명령 내리고 그 결과를 바로 받아옴</li>
<li>불특정 외부 시스템 연동이 용이</li>
</ul></li>
<li>따라서, <strong>management에는 REST를 선택</strong>함.</li>
</ul></li>
<li><strong>GameObject</strong>

<ul>
<li>class hierarchy를 framework에서 다 강제해서 준다면,

<ul>
<li>잘 맞으면 좋고 안 맞으면 유연성이 없으니 힘들다. 근데 잘 맞을 일이 없다.</li>
<li>특히 c++처럼 상속 관계에 대한 customize가 어려운 곳이면 정말 좋지 않다.</li>
</ul></li>
<li>개발자가 다 만들어 쓰도록 한다면,

<ul>
<li>framework에서 할 일이 없네.</li>
</ul></li>
<li>따라서 중도책으로, <strong>meta language를 사용하여 code generation</strong>을 하겠다.

<ul>
<li>json으로 object를 정의하고 codegen으로 object code를 생성한다.</li>
</ul></li>
<li>갑자기 deadlock 이야기. <em>(아마도 GameObject를 만들었으니 상태 변경에 대한 concurrency control을 하고 싶은 듯)</em>

<ul>
<li>deadlock을 피하기 위해서 변경 작업은 cancellable해야 한다. 그리고 rollback해야 한다.</li>
<li>optimistic concurrency control을 사용하기 위해 journaling &amp; rollback을 수행한다. <em>(STM 구현한다는 소리를 하고 싶은 것 같다)</em></li>
</ul></li>
</ul></li>
<li><strong>분산 서버</strong>

<ul>
<li>partitioned server를 만들어서 존/채널 단위로 분리하면 쉽다.</li>
<li>하지만 <strong>rpc 기반의 shared world</strong>를 만들 것이다.

<ul>
<li>rpc 기반의 remote lock까지 만들어서 사용</li>
<li>object가 서버 별로 분산되어 있으므로,

<ul>
<li>object를 lookup하기 위한 Directory Service를 만들고,</li>
<li>어느 서버에 object가 있는지 찾으면 해당 서버로 rpc 날려서 lock 걸고</li>
<li>상태 변경을 한다.</li>
<li>이 때 lock 건 서버가 사망하면 골치 아프니 적당히 timeout 걸어서 해결</li>
<li><em>(분산 transaction은 어떻게 구현하실 건가요? 라는 질문이 있었는데 답변이 길어진다고 넘어감)</em></li>
</ul></li>
<li>위처럼 하면, 특정 object를 소유하지 않은 서버가 접근을 많이하는 부담이 있을 수 있다.</li>
<li>이를 해결하기 위해 object migration을 한다.

<ul>
<li>참조를 가장 많이하는 서버에세 object 관리를 넘기는 방법</li>
<li>reference counting을 해서 처리한댄다.</li>
</ul></li>
</ul></li>
<li>zoo keeper 같은 것을 쓸 수도 있는데 느려서 안 쓴댄다.</li>
</ul></li>
<li>그래서 정리해보면,

<ul>
<li>client-server message format은 JSON,</li>
<li>management를 위해 RestAPI 제공,</li>
<li>game-object는 json으로부터 code generation을 하고, STM을 구현해 동시성을 제어,</li>
<li>분산 서버는 rpc 기반으로 구축한다.</li>
</ul></li>
</ul>

<hr>

<ul>
<li>Q&amp;A 때 성능으로 질문이 들어오긴 했는데, <em>목표에서 이미 성능은 포기했다</em>로 답변함.</li>
<li>마지막 분산 시스템 설계 부분에서는 <em>왜 저렇게까지 해야 하나</em>라는 생각이 들 정도. 저럴거면 그냥 object sharing server로 redis같은 것을 쓰는게 낫지 않나?</li>
</ul>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">분산서버 구축의 ABC - 대규모 분산 시스템을 구축하기 위한 실용적 예와 그 원칙들</h1>
				<p class="page-date">28 May 2014</p>
				<p class="page-tags">
						
						
					<code class="tag">ndc14</code>
						
						
						
					<code class="tag">distributed</code>
						
						
						
						
				</p>
				<div class="content"><ul>
<li><a href="https://twitter.com/hoblue">이호규</a> / <a href="http://www.slideshare.net/HoGyuLee/ndc14-abc">발표자료</a></li>
</ul>

<h3>왜?</h3>

<ul>
<li>기획 요구가 높아짐에 따라 성능 문제가 야기됨</li>
<li>단일 머신으로 처리가 어려우니 분산으로 간다! network traffic, cpu, memory 등</li>
</ul>

<h3>어떻게?</h3>

<ul>
<li>scale out

<ul>
<li>기능 분리 서버

<ul>
<li>상점 서버, 퀘스트 서버, ... 이런 식으로 분리</li>
<li>예외 처리도 어렵고 transaction 구성도 어렵다. 그냥 이렇게 안 하는게 좋겠다.</li>
</ul></li>
<li>통합 독립 서버

<ul>
<li>role로 분리. 일반 서버, 던전 서버, ... 이런 식</li>
<li>동시성 제어 및 유지보수가 용이하다.</li>
</ul></li>
</ul></li>
<li>scale up

<ul>
<li>성능보다 안정성을 위해 scale up을 사용 <em>(?)</em></li>
</ul></li>
<li>database scale out

<ul>
<li>sharding

<ul>
<li>mapping table을 써서 shard 정보를 저장할 경우 caching 필수. 필요시 scale up</li>
<li>dynamic sharding은 db-instance가 추가되었을 경우 resharding이 어렵다.</li>
</ul></li>
<li>transaction은 어떻게? 그냥 code로 다 구현해야 한다.</li>
</ul></li>
<li>cpu

<ul>
<li>pipeline 구조가 아닌 producer/consumer 구조로 구현을 해야 한다.</li>
</ul></li>
<li>memory

<ul>
<li>한 머신에 2TB까지 사용할 수 있다. <em>(?)</em></li>
</ul></li>
<li>IO

<ul>
<li>database

<ul>
<li>일단 memory에 반영 후 db validation (즉, 후처리). 이 때 실패하면 해당 유저 disconnect하고 db 정합성 유지하도록 한다. <em>(?)</em></li>
</ul></li>
<li>network

<ul>
<li>chat을 분리해서 network 병목을 제거한다.</li>
<li>broadcast는 지불할 수 밖에 없는 비용이지만 grouping을 최적화해서 잘 하거나, 아니면 역시 network를 분리한다. <em>(?)</em></li>
</ul></li>
</ul></li>
<li>지표

<ul>
<li>cpu는 packet queue 소모 시간을 본다.</li>
<li>network는 latency나 send queue 크기를 본다.</li>
<li>병목 지점을 찾을 때에는 제일 부하를 많이 주는 로직을 단일 instance에서 실행해서 찾도록 한다.</li>
</ul></li>
<li>서버 성능

<ul>
<li>비동기 IO를 쓰고, polling보다는 event를 쓰고, 계산 값을 caching하는 등 최적화한다.</li>
<li>multi process와 multi thread 중 무엇을 사용하는 것이 좋을까?

<ul>
<li>switching 비용과 구현 비용 등을 고민하자.</li>
</ul></li>
<li>multi thread를 쓰면 throughput이 좋지만 concurrent 버그가 발생하고 singleton에 접근하는 thread간의 경합 문제로 인해 제약(?)이 발생한댄다. <em>(?)</em></li>
<li>그래서 mo/mmo 서버가 아니면 multi io thread, single logic thread의 multi process 구조가 관리 개발이 편하니 좋댄다.</li>
</ul></li>
</ul>

<h3>무엇을?</h3>

<ul>
<li>fault tolerance

<ul>
<li>exception handling

<ul>
<li>always available (SEH)

<ul>
<li>예외가 발생해도 SEH로 잘 잡아서 문제 상황만 적출하고 서비스는 가용하도록 한다.</li>
</ul></li>
<li>graceful exception handling

<ul>
<li>문제가 발생한 유저를 disconnect하는게 아니라 정중하게 로비로 모셔준다.</li>
</ul></li>
<li>error trace (callstack + debug log)

<ul>
<li>tracing하기 쉽게 정보를 잘 모아서 남겨준다.</li>
</ul></li>
</ul></li>
<li>fail over

<ul>
<li>instance load</li>
<li>local db, memory db</li>
<li>db replication</li>
</ul></li>
</ul></li>
<li>user trace</li>
<li>server dashboard</li>
<li>log

<ul>
<li>file보다 검색이 용이한 db를 쓰자.</li>
<li>하나의 테이블에 데이터가 너무 많아지면 조회가 느려지니까 일일 로그는 일별 테이블을 만들어서 기록하자.</li>
</ul></li>
<li>monitor

<ul>
<li>redis 등의 memory db를 쓰자</li>
</ul></li>
<li>indicator

<ul>
<li>중요한 로그는 서버에서 남기자, 근데 logging도 부담이 있으니까,</li>
<li>게임 분석 지표는 클라이언트에서 logging을 하도록 하자. RabbitMQ 같은걸 쓰자.</li>
</ul></li>
<li>redis

<ul>
<li>push(notification) 기능을 사용해서 management를 위한 실시간 event를 전달하거나 상점 on/off같은 작업을 수행하자.</li>
</ul></li>
</ul>

<h3>deploy</h3>

<ul>
<li>binary

<ul>
<li>united server

<ul>
<li>모든 기능을 하나의 binary에 다 넣어두면 관리가 편하고 좋댄다.</li>
</ul></li>
<li>one binary server

<ul>
<li>위랑 뭐가 다른지는 잘 모르겠지만 아무튼 좋댄다. 근데 종합 설정 파일 같은게 나와서 복잡해질 수 있다고 한다.</li>
</ul></li>
</ul></li>
<li>일정 산출

<ul>
<li>분산 시스템을 도입할 경우 유지보수 비용이 꽤 크기 때문에 개발:유지보수의 비율을 6:4 정도로 생각하고 일정을 잡자.</li>
<li>TDD를 애용하자.</li>
</ul></li>
</ul>

<hr>

<ul>
<li><strong>중간중간 무슨 소리인지 잘 이해가 안 되는 부분이 있었다.</strong>

<ul>
<li><a href="http://redirect.disqus.com/url?impression=e0a616e0-0aff-11e4-ae27-003048db5eee&amp;forum=3026737&amp;thread=2763589449&amp;behavior=click&amp;url=http%3A%2F%2Flacti.me%2F2014%2F05%2F28%2Fndc14-build-distributed-system%2F%23comment-1483795001%3AmwG_lKpQhTAuKYl4yhK6XJkCV2Y&amp;post=1483795001&amp;type=notification.post.moderator&amp;event=email">이해가 안 되는 부분에 대해서는 발표자님께서 댓글로 친절히 설명을 해주셨다.</a></li>
</ul></li>
<li>chat의 경우 시야 범위의 broadcasting이 아닌 전체 전달 같은 경우엔 독립적 기능이니 community server를 따로 두어 io를 분산시키는 방법이 유효할지 모르겠는데, broadcasting의 network io를 분리한다는 발상은 좀 이상해보인다. 차라리 io를 전담하는 server를 둔다면 모르겠는데 어차피 분산 서버를 설계하는 상황에서 그게 무슨 큰 의미가 있는지 모르겠다.</li>
<li>singleton 이야기는 그냥 concurrency control의 어려움을 이야기하려는 것 같은데 multi threading에서 singleton을 쓰려면 lock을 전제로 하거나 tls를 이용한 replica를 생각해야 할텐데 뭘 생각하는 건지 자세히 이야기를 안 해줘서 잘 모르겠다.</li>
<li>서비스 가용성 이야기하면서 계속 SEH 이야기를 하는데 heap corruption이 일어나거나 transaction 오류로 아이템 복사가 일어나도 SEH로 잡고 넘어갈 수 있다고 생각하는지 모르겠다.</li>
<li>일일 로그를 일일 테이블로 쪼개야한다는 것에서는 의견이 좀 분분한데, 요새 dbms는 내부적으로 partition을 제공해주기 때문에 굳이 사용자가 table을 직접 vertical partition을 해줘야 할 것 같지는 않다.</li>
</ul>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">신입 프로그래머들의 고민을 통해 생각해보는 누구나 쉽게 적응할 수 있는 프로젝트 만들기</h1>
				<p class="page-date">29 May 2014</p>
				<p class="page-tags">
						
						
					<code class="tag">ndc14</code>
						
						
						
					<code class="tag">live</code>
						
						
						
						
				</p>
				<div class="content"><ul>
<li><a href="https://twitter.com/LTeaRain">최진욱</a></li>
<li><a href="https://twitter.com/skyser2003">장승호</a></li>
</ul>

<h3>요약</h3>

<ul>
<li>Effective (Live) Old Project</li>
<li>적절한 과제를 통해 신입 프로그래머의 실력 향상을 돕자.</li>
<li>추후 라이브 상황을 고려하여 신규 때 기반을 잘 닦도록 하자.</li>
</ul>

<h3>목표</h3>

<ul>
<li>오래 라이브 서비스가 가능하면서 신입이 쉽게 적응할 수 있는 project를 만듭시다.</li>
</ul>

<h3>신입은 무슨 생각?</h3>

<ul>
<li>라이브에 배치됨

<ul>
<li>이미 만들어진 게임, 할게 적을 것 같다.</li>
<li>하지만 이벤트 등의 신규 컨텐츠 구현할 게 꽤 많다.</li>
</ul></li>
<li>실력에 대한 불안감

<ul>
<li>채용 후 근거없는 자신감으로 변함</li>
<li>실력 향상을 위한 도서 등의 가이드가 필요하다.</li>
</ul></li>
<li><strong>지침과 격려가 필요함</strong></li>
</ul>

<h3>사례 연구</h3>

<ul>
<li>CSO2

<ul>
<li>자력으로 문제 해결 능력을 키우도록 과제를 준다.</li>
</ul></li>
<li>M1

<ul>
<li>코드 분석을 통해 의도/흐름을 정리하도록 한다.</li>
<li>기존 시나리오를 바탕으로 유사 코드를 작성하도록 한다. (2달 정도)</li>
<li>결과에 대한 평가/피드백으로 같은 실수 방지 등의 실력 향상 도모</li>
<li>실무와 유사한 작업이므로 실력과 자신감을 같이 키울 수 있다.</li>
<li>모두에게 발표: 기존 프로그매러도 큰 그림을 볼 기회를 얻음</li>
</ul></li>
<li>GE

<ul>
<li>신입이 할만한 것으로 과제를 부여</li>
<li>있으면 좋은 기능 중 복잡도가 낮고 부담이 별로 없는 것을 준다.</li>
<li>몇 번 반복시킨다.</li>
</ul></li>
<li><strong>적절한 난이도 과제를 주어서 불안을 몰입으로 만들 기회를 주자</strong></li>
</ul>

<h3>old project에서 겪는 문제 및 해결</h3>

<ul>
<li>legacy

<ul>
<li>문서화했다고 해도 찾는데 부담이 크다.</li>
<li>그냥 코드를 잘 작성해서 코드만으로 유추할 수 있도록 하자. <em>(literate programming?)</em></li>
</ul></li>
<li>TODO

<ul>
<li>오래되면 엄청 많아지니 convention을 통해 category하는 등 잘 찾아볼 수 있도록 한다.</li>
</ul></li>
<li>툴 소스 관리

<ul>
<li>툴의 binary만 버전관리하지 말고 툴 source도 같이 버전 관리를 해서 추후 유지보수가 가능하도록 한다.</li>
</ul></li>
<li>폐기된 코드

<ul>
<li>코드 파악에 방해되므로 주기적으로 정리한다. 

<ul>
<li>주석처리 하지 말고 삭제하거나 브랜치로 관리한다.</li>
</ul></li>
<li>많아질 경우, c++ 같은 언어라면 컴파일 시간도 길어질 수 있다.</li>
</ul></li>
<li>컴파일 시간 증가

<ul>
<li>급하면 컴파일 시간을 줄이겠다고, 하단 수정이 필요함에도 상대적으로 의존성이 적은 상단에서 수정을 할 수도 있다.</li>
<li>include 정리, forward decl, pch, include 정리, unitybuild 도입, 빌드 머신 scale up, incredibuild 도입 등을 고민해본다.</li>
</ul></li>
<li>과도한 절약과 최적화로 인한 유지보수 어려움

<ul>
<li>macro, template

<ul>
<li>신입들은 익숙하지 않다.</li>
<li>visual assist x나 intellisense의 성능을 저하시킨다.</li>
<li>왠만하면 자제 부탁</li>
</ul></li>
<li>주요 변수를 8bit로 구현

<ul>
<li>시간이 지나면 256개로는 부족하다.</li>
<li>쉽게 고칠 수 있는 부분이 아니라면 초기부터 넉넉하게 할당해두자.</li>
</ul></li>
<li>profiling을 통한 필요 부분 최적화를 지향하자.</li>
<li>차후 수정이 쉬운 방향으로 리팩토링을 하자.</li>
</ul></li>
<li>pImpl

<ul>
<li>build-time이 줄어드는 것이 좋기는 하지만,</li>
<li>interface와 implement 모두 수정해야 하므로 코드 수정량이 많아진다.</li>
<li>debugging할 때도 step 수가 많아져서 불편하다.</li>
<li>과도한 사용을 하지 말자.</li>
</ul></li>
<li>정보 공유

<ul>
<li>정보 공유를 위해 Q&amp;A를 자주하면 작업 효율성이 저하된다.</li>
<li>정보 저장소를 관리해서 검색할 수 있게 하자.</li>
</ul></li>
<li>UnitTest 부재

<ul>
<li>코드 수정을 쉽게 할 수가 없다.</li>
<li>특히 Client/Server 구조에서 둘 다 구동해서 login하고 테스트하는 것은 비용도 크다.</li>
</ul></li>
<li>external library 사용은 신중히 하자.

<ul>
<li>license 정책이 변경되는 경우가 있다.</li>
<li>해당 기능이 표준으로 통합될 수 있다.</li>
</ul></li>
<li>Tool에 VCS api를 hard-binding하지 말자.

<ul>
<li>specific한 VCS api를 hard-binding하면 추후 VCS 변경이 어렵다.</li>
<li>중간에 추상화된 layer를 두고 연결할 수 있도록 하면 좋겠다.</li>
</ul></li>
<li>구현을 비워둔 virtual function이 있다면 assert라도 넣어주자.</li>
</ul>

<h3><del>그래도</del> 좋은 점도 있다!</h3>

<ul>
<li>M1

<ul>
<li>XML 기반의 UI

<ul>
<li>unpack 등 보안에 취약한 점도 있지만 생산성 증대 효과가 더 크다.</li>
</ul></li>
<li>MetaData

<ul>
<li>string key/value 형태로 가독성 덜 해치는 범위에서 급한 코딩을 할 때 유용하다.</li>
</ul></li>
<li>직군 회의

<ul>
<li>merge나 localize 이슈 등의 불편 사항을 공유/논의할 수 있어 좋다.</li>
</ul></li>
<li>운영툴

<ul>
<li>잘 만들어놨다.</li>
</ul></li>
<li>script 함수 목록 gathering이 가능하다.</li>
</ul></li>
<li>GE

<ul>
<li>기획자 처리 범위가 넓어 대부분의 컨텐츠를 기획자가 구현하는 것이 가능하다.

<ul>
<li>XML 구조가 간단해서 가능하다 (?)</li>
</ul></li>
<li>범용적 script (...)</li>
<li>짧은 빌드 시간</li>
<li>단일 솔루션으로 인한 빌드 관리가 용이하다.</li>
</ul></li>
<li>공통

<ul>
<li>전 국가 trunk를 공유하고 기능별로 로직을 분기한다.</li>
<li>merge 비용이 적고 side effect를 조기에 발견 가능하다.</li>
<li>근데 build broken 상태가 되면 stop the world.

<ul>
<li>신속한 수정이 가능하다면 괜찮다고 본다.</li>
</ul></li>
</ul></li>
</ul>

<h3>결국 &amp; 그러므로</h3>

<ul>
<li>기간이 좀 지나면 시니어 프로그래머는 신규 프로젝트로 떠난다.</li>
<li>안전성 문제로 리팩토링 &amp; 신규 기술 도입을 쉽게 할 수 없다.</li>
<li>얻을 수 있는 부분을 얻자.

<ul>
<li>라이브를 해봐서 얻는 부분이 있다.</li>
<li>프로그래머라면, 제한된 여건에서 설득을 하는 기술 등</li>
</ul></li>
<li><strong>나는 계속 배우고 있구나</strong> 라는 관점을 견지하자.</li>
</ul>

<h3>정리</h3>

<ul>
<li>처음부터 많이 고민해서 좋은 라이브가 될 수 있도록 노력이 필요하다.

<ul>
<li>그리고 믿고 의지할 시니어가 있으면 좋겠다.</li>
</ul></li>
</ul>

<h3>Q&amp;A</h3>

<ul>
<li>신규 프로젝튼 어떤가요?

<ul>
<li>열정적이다.</li>
</ul></li>
<li>라이브가 뭔가요?

<ul>
<li>서비스를 시작하면 라이브임</li>
</ul></li>
<li>프로그래머와 소통을 하려면 어떻게 하는 것이 좋을까요?

<ul>
<li>프로그래밍 언어의 기초를 익혀두면 프로그래머에 대한 이해를 하기 좋다.</li>
</ul></li>
</ul>

<hr>

<ul>
<li>내용이 상당히 유익하고 많다. Effective 시리즈를 연상시킬만큼 case by case에 대한 이야기가 많다.</li>
<li>그런데 발표 시간이 25분으로 너무 짧았고, 그 발표 시간에 맞추기 위해 내용을 축약한 점이 아쉽다.</li>
<li>많은 사람들이 볼 수 있도록 위키나 블로그에 위 내용을 정리 &amp; 발전시키면 좋겠다.</li>
<li>발표자 컨디션이 좀 안 좋았는지 (양이 많아서 말이 빠른 것과 별개로) 목소리에 좀 힘이 없는 것 같았다.</li>
</ul>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">팀을 구하는 툴 개발</h1>
				<p class="page-date">29 May 2014</p>
				<p class="page-tags">
						
						
					<code class="tag">ndc14</code>
						
						
						
					<code class="tag">tool</code>
						
						
						
						
				</p>
				<div class="content"><p><a href="http://kyungjaepark.com/">박경재</a></p>

<h3>요약</h3>

<ul>
<li>적절한 툴을 만들어 작업의 비효율을 줄이고 고통받는 동료를 구원하자.</li>
<li>그러기 위해서 높으신 분들은 이에 대한 필요성을 인지하고 자원 분배를 잘 하자.</li>
</ul>

<h3>도입</h3>

<ul>
<li>게임 개발 시 동료가 겪는 불필요한 괴로움을 극복하기 위한 툴과 마음가짐</li>
<li>라이브 서비스를 하면서 고객의 불편/불만 사항은 개선하지만, <strong>개발자 우리들의 불편/불만 사항은 개선하지 않는다.</strong></li>
<li>eg) 퀘스트 입력

<ul>
<li>기획자가 excel 파일로 데이터를 입력해서 프로그래머에게 데이터 파일로 만들어달라고 요청</li>
<li>building 후 테스트 진행. 마음에 안 들면 위 항목 반복</li>
<li>이 과정에서 excel 파일과 서버 데이터 파일의 불일치가 발생해 버그가 발생하기도 하고, 무엇보다도 <strong>비효율적</strong>이다.</li>
</ul></li>
<li>eg) map editor

<ul>
<li>옛날에 처음 만들었을 때에는 잘 돌아갔지만, 제작자 퇴사 이후 뭔가 잘 안 돌아간다.</li>
<li>저장하면 일부 파일이 깨지거나 parameter가 날아간다.</li>
<li>이 상황에서도 툴을 고치지는 않고 조심조심 사용한다.

<ol>
<li>초벌 배치를 하고,</li>
<li>필요한 부분을 손으로 채워넣고,</li>
<li>잘 동작하기를 기도한다.</li>
</ol></li>
</ul></li>
<li>eg) mobile social game

<ul>
<li>리소스 추가 시 확인해보기 위해 building 요청 등 고생을 한다.</li>
<li>사소한 실수에 의해 위 작업을 반복하므로 테스트 비효율이 심각하다.</li>
</ul></li>
<li>왜 이런 일이 일어나는가?

<ul>
<li>제대로 된 툴이 없거나 부족하기 때문에 그 부분을 작업자의 희생으로 메꾼다. <em>그럼에도 툴을 개선/개발하지 않고 현 상태를 유지한다.</em></li>
<li>프로그래머는 툴을 만들 시간에 게임 피처를 추가하는 것이 더 낫다고 생각한다.</li>
<li>기획자/아트는 현재 툴을 일단 쓸 수는 있다고 생각하고, 요청에 대한 부담으로 툴 개선/개발 이야기를 하지 않는다.

<ul>
<li>만약 툴이 잘못 동작해도 잘못 사용한 본인 탓을 하거나,</li>
<li>프로그래머에게 개선/개발 요청하는 것을 본인의 이기주의라고 생각한다.</li>
</ul></li>
</ul></li>
<li>하지만 이런 <strong>인내와 희생</strong>은 필요하지 않다.

<ul>
<li>툴 부족으로 인한 불필요한 협업은 비효율과 낭비를 야기한다.</li>
<li><strong>자신이 가장 잘하는 자기 일에 집중할 수 있도록</strong> 작업 과정은 최소화되어야 한다.</li>
<li>이를 위해서는 <strong>좋은 툴이 필요하고, 이것은 프로그래머의 일</strong>이다.</li>
</ul></li>
</ul>

<h3>툴 만들기</h3>

<ul>
<li>타이밍

<ul>
<li>prototyping 시점은 게임과 작업 프로세스가 미확정된 시점이고, 시간 자원이 중요하고 빠른 의사결정이 중요한 시기다. 따라서 이 시점에 툴 개발은 불필요하다.</li>
<li>따라서 prototyping 이후 pre-production 단계 즈음에 툴 개발하는 것이 좋다.</li>
<li>만약 이미 라이브 중이라면, <em>가능하면</em> 지금 당장 만들자.</li>
</ul></li>
<li>주체

<ul>
<li>툴 개발자로 보통 신입 사원을 시키는데, 이것이 신입 사원의 성장에는 도움이 될 수 있어도 좋은 툴을 만들지 못할 가능성이 크다.</li>
<li>좋은 툴은 업무 방식 이해가 높고 시야가 넓은 사람이 만들어야 한다. 즉, <strong>리드/시니어 프로그래머</strong>가 만드는 것이 좋다.</li>
<li><strong>툴은 하찮은 일이 아니다!</strong></li>
</ul></li>
<li>사전 조사

<ul>
<li>현재 상황을 파악하기 위해 불편한 점을 수집한다.

<ul>
<li>인터뷰는 좋은 방법이지만 그 내용이 부족하거나 부정확한 점이 있어 수집에 한계가 있다. <em>보통은 현재 상태에 만족한다고 대답하기 때문이다.</em></li>
<li>전해들은 원인은 진짜 원인이 아닐 수 있다. 따라서 한 단계 더 나아가 <strong>관찰을 한다.</strong></li>
<li>아니먼 더 나아가 <strong>하고 있는 일을 직접 따라가 보자.</strong> 시연을 해달라는 것도 좋고, 가능하면 직접 해보는 것도 좋다.</li>
<li>그러면 수집된 정보의 실제 의미, 속사정, 진짜 원인을 알 수 있게 된다.</li>
</ul></li>
<li>원한다고 생각하는 것과 진짜 필요로하는 것을 잘 구분해야 한다.</li>
</ul></li>
<li>우선순위

<ul>
<li>요구 사항으로부터 기능 목록이 완성되면 다음의 순서로 일을 진행한다.

<ol>
<li>없으면 개발이 불가능한 것</li>
<li>너무 복잡한 프로세스인 것</li>
<li>자동화가 가능한 것</li>
</ol></li>
<li>큰 계획을 세우되 작은 것부터 <strong>하나씩 꾸준히</strong> 진행해야 한다.

<ul>
<li>모든 프로세스를 커버하는 툴을 처음부터 만드려하면, 일이 너무 커져서 포기하는 경우가 발생한다.</li>
<li>따라서 작업 프로세스의 50%만 커버해도 좋으니 진짜 원하는 것을 중심으로 작업을 진행한다.</li>
<li>순간순간부터 줄이는 것은 모여서 큰 것을 이루어낸다.</li>
</ul></li>
</ul></li>
<li>포커스

<ul>
<li>아티스트/기획자/프로그래머의 편한 방법은 다 다르다.</li>
<li>따라서 익숙한 것과 최대한 비슷하게 만든다. 늘 쓰던 툴의 기능/개념을 차용해서 만들면 좋다. (photoshop, flash, excel, auto completion 등)</li>
</ul></li>
<li>주의

<ul>
<li><strong>툴의 자유도/확장성을 불편함과 바꾸지 않는다.</strong></li>
<li>불편한 것을 만들고 사용을 강요하지 말자!

<ul>
<li><em>이 정도도 안 배우고?</em> 라고 툴 개발자가 생각할 수 있는데, 프로그래머는 이해/숙련이 타 직군에 비해 빠른 편이다. 그리고 이 차이는 타 직군이 단시간 훈련해서 좁힐 수 있는 것도 아니다.</li>
<li>따라서 <strong>교육을 하기 보다는 쓰기 좋은 것을 만들어라.</strong></li>
<li>배우지 않아도 쓸 수 있는 것을 만들면 더 좋다. <em>배움의 최소화</em></li>
</ul></li>
</ul></li>
<li>제작 후

<ul>
<li>필요에 따라 그 때마다 파편화된 작은 툴을 만들면 갈수록 유지보수/관리가 잘 안된다.

<ul>
<li>tools 디렉토리 하위에는 동작하지 않거나 미완성된 툴이 쌓이게 된다.</li>
<li>그리고 이는 마치 게임 유저의 이탈처럼 개발된 툴의 사용 중단을 유발한다.</li>
</ul></li>
<li><strong>반드시 관리 책임이 필요하다.</strong></li>
<li>툴 서비스 기간의 시작과 끝을 명시하고, 항상 가용하도록 관리한다.</li>
</ul></li>
<li>피드백

<ul>
<li>툴이 의도대로 사용되고 있는가?</li>
<li>인터뷰, 관찰을 다시 한다. 하지만 이건 항상하거나 자주하기에는 자원 소모가 좀 크니, <strong>사용 지표를 남기고 그것을 분석한다.</strong></li>
<li>eg) 각 메뉴별 사용 정보를 수집한다.

<ul>
<li>언제, 어느 시점에, 어느 빈도로, 누가 사용하는지를 수집한다.</li>
<li>예상과 다르다면 사용자와 직접 만나서 피드백을 받는다.</li>
</ul></li>
<li>만약 불일치가 발생한다면 프로그래머의 멘탈 모델을 수정할 수 있다.</li>
</ul></li>
<li><strong>툴 개발 이후 업데이트와 측정에 신경을 쓰자.</strong></li>
</ul>

<h3>결론</h3>

<ul>
<li>옆 동료들에 대한 존중과 작업 환경에 대해 관심을 가지고,

<ul>
<li>프로그래머는 주변 동료가 일하는 과정에서 발생하는 어렵고 괴로운 점을 찾아 툴을 개발해주고,</li>
<li>디렉터/PM은 프로그래머에게 툴 개발을 할 수 있도록 시간을 할당해 주자.</li>
</ul></li>
<li>이는 어렵고 힘든 개발 문화를 바꿔줄 것이고, <strong>게임 개발 자체에 더 집중할 수 있도록 만들어준다.</strong></li>
</ul>

<h3>Q&amp;A</h3>

<ul>
<li>툴 전담팀을 두는 것에 대해서는 어떻게 생각?

<ul>
<li>툴 전담팀이 툴을 개발할 경우, 단기적 개발이라면 괜찮지만 시간이 지날수록 게임 개발과 동떨어진 툴이 나올 수 있다. 따라서 게임 개발하는 팀이 직접 하는 것이 좋다고 생각한다.</li>
</ul></li>
<li>동료가 얼마나 괴로워할 때 툴을 만드는 것이 좋을까? 그냥 작업을 도와주는게 낫지 않나?

<ul>
<li>3번 정도 할 일이 아니고 그 이상으로 반복되는 일이면 툴이 낫다.</li>
</ul></li>
<li>툴 개발의 중요성을 부각시키려면 어떻게?

<ul>
<li>프로그래머는 타 직군 동료들에게 해당 내역을 전파한다. (그들이 나서서 먼저 도와달라고 하기에는 좀 그렇다.)</li>
<li>디렉터와 PM 수준에서 나서야 좋은데 그들이 이를 중요치 않게 생각한다면 조직 문화가 그런 인식이 생길 수 있도록 설득해야 한다.</li>
</ul></li>
<li>툴 개발 요청을 하면 요청자에게 만들라고 한다. 어쩌면 좋나?

<ul>
<li>의사결정권자가 잘못했다. 툴은 잘 만들 수 있는 사람이 만들게 해야 한다.</li>
</ul></li>
<li>1인 개발 시 툴 개발은 필요한가?

<ul>
<li>본인 스스로 상담하라.</li>
</ul></li>
<li>툴이 내가 모르는 언어로 작성되어 있다면 어떻게?

<ul>
<li>본인만 모르면 공부하고, 개발자 모두 모르고 게임이랑 연동되는 언어도 아니라면 다른 언어로 고쳐도 좋다.</li>
</ul></li>
<li>장르 불문 공용 툴에 대해서는 어떻게 생각?

<ul>
<li>communication 툴이라면 몰라도 너무 general하게 만드려다가는 망할 수 있다.</li>
<li>한두명의 요청이라도 툴을 만드는 것이 좋다.</li>
</ul></li>
<li>프로그래머가 아닌 직군인데 툴이 필요하면 직접 만드는 것이 좋나?

<ul>
<li>그 시간에 본인이 잘할 수 있는 일을 집중하고, 툴 개발은 프로그래머에게 맡기는 것이 낫다고 생각한다.</li>
</ul></li>
</ul>

<hr>

<ul>
<li>툴 개발은 관심있던 분야고 전 회사에서 당해본 것이 많아서 굉장히 공감되는 내용이 많았다.</li>
<li><del>특히 내 경우 대외적 interface가 좀 안 좋았던 편이라서 그런지 누가 툴 개발을 요청했던 적은 적었고</del> 내가 비효율적인 부분을 찾아서 툴 개발을 진행했던 경우가 많은데,

<ul>
<li>정말 툴을 사용하는 개발자가 뭘 원하는지를 제대로 파악하지 못했던 경우나,</li>
<li>그 사람이 괜찮다고 해서 정말 괜찮다고 생각했던 적이 몇 번 있다. <em>진짜 괜찮은 줄 알았는데-_-</em> 그 점에서는 이 발표를 통해 많이 배웠다.</li>
</ul></li>
<li>결론에서도 다시 한 번 강조되었지만 툴 개발은 <strong>모든 사람의 인식이 바뀌어야 잘 진행될 수 있다.</strong>

<ul>
<li>툴이 필요한 사람은 적극적으로 개발을 타진해야 하며,</li>
<li>툴 개발자는 기꺼이 그 필요성을 인식하고 협력하여 좋은 툴을 개발할 수 있어야 하며,</li>
<li>관리자는 이를 장려하고 지원해줄 수 있어야 한다. <del>는 꿈</del></li>
</ul></li>
<li>그냥 좀 <del>억울해서</del> 이야기를 해보자면,

<ul>
<li>툴 개발자가 자의적으로 비효율 지점을 분석하여 사용자에게 툴을 공급하는 경우 잘못 분석된 프로세스에 의해 필요한 것과 한참 동떨어진 툴이 나올 수 있다. 그런데 툴 개발에 이미 자원이 꽤 소모되었다면 관리자가 이 툴 사용을 강제하는 경우가 있다-_-</li>
<li>툴 개발/지원 분위기가 장려되면 툴 요청자는 본인이 뭘 원하는지도 잘 모르면서 크고 아름답고 거대한 툴을 요청하는 경우가 있다. 최악의 경우에는 기싸움으로 번질 수가 있으니 노련한 사람이 잘 제어를 해주어야 한다. <em>왜 제 요청만 구현을 안해주세요?</em></li>
<li>툴 개발자가 툴 개발에 대한 인식이 좋지 않다면 툴 개발은 잔업으로 밖에 보이지 않는다. 이러한 인식이 바뀌지 않는다면 툴 유지보수는 꿈 같은 이야기가 된다. <em>그걸 제가 왜 고쳐요?</em></li>
<li>관리자/경영자는 비용 기반으로 결정하기 때문에 <del>본인이 꽂힌 것이 아니고서야</del> 툴 개발로 인한 효율성 개선으로 얻을 수 있는 비용이 명확하지 않다면 별로 개발을 장려하지 않는다.</li>
</ul></li>
<li>툴 요청자와 툴 개발자는 그냥 SI한다고 생각하고 개발하는 것이 제일 낫다고 본다. 갑/을 관계 이야기가 아니라 고객과 구현자의 입장에서 필요한 기능을 분석하고, 구현하고, 출시 이후 관리를 해주어야 하니까 말이다.</li>
<li>협업이니까 다들 좋은 분위기에서 효율적으로 작업하면 좋겠지만 그게 쉽지는 않다. 어쨌든 유명한 분이 좋은 발표를 해주셨으니 이제 앞으로는 좀 더 좋아지지 않을까 기대해본다.</li>
</ul>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">파이썬과 친구들 - 체계적이고 빠른 모바일 게임 서버 개발을 위한 최적의 도구</h1>
				<p class="page-date">27 May 2014</p>
				<p class="page-tags">
						
						
					<code class="tag">ndc14</code>
						
						
						
					<code class="tag">python</code>
						
						
						
					<code class="tag">server</code>
						
						
						
						
				</p>
				<div class="content"><ul>
<li>모바일은 connectivity가 불안정하다.</li>
<li>고로 WebServer 형태로 감</li>
<li><code>microframework</code>: <code>bottle</code>, <code>Flask</code></li>
</ul>

<h3>IO</h3>

<ul>
<li>event-driven io, callback chaining</li>
<li><code>gevent</code>

<ul>
<li>coroutine, nonblocking io로 monkey patch</li>
<li><em>근데 mysql python은 monkey patch가 안된다</em></li>
</ul></li>
</ul>

<h3>scaling</h3>

<ul>
<li>single thread multiple process</li>
<li><code>gunicon</code>, <code>circus</code>, <code>supervisor</code></li>
</ul>

<h3>database</h3>

<ul>
<li>nosql

<ul>
<li><code>couchbase</code> auto sharding, zero configuration</li>
<li><code>mongodb</code> logging</li>
</ul></li>
<li>rdbms

<ul>
<li><code>sqlalchemy</code></li>
</ul></li>
</ul>

<h3>cache</h3>

<ul>
<li><code>redis</code> login session 등</li>
</ul>

<h3>worker</h3>

<ul>
<li><code>celery</code>

<ul>
<li>별도 process, 서버와 io 통신</li>
<li>broker(redis, RabbitMQ)를 통한 sharing</li>
<li>decorator 붙이면 rpc로 만들어줌</li>
</ul></li>
</ul>

<h3>logging</h3>

<ul>
<li><code>logbook</code>

<ul>
<li>implements custom handler</li>
</ul></li>
</ul>

<h3>deployment</h3>

<ul>
<li>dvcs</li>
<li>repository hook api</li>
<li><code>fabric</code></li>
</ul>

<hr>

<p>초반에 파이썬 문법을 설명해서 좀 당황했는데, 어떤 개념과 어떤 라이브러리를 썼는지 정도는 다 열거를 해서 그나마 다행히었다고 생각한 세션이었음.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
						
				<h1 class="page-title">프로젝트K 서버 아키텍처 - SPOF 없는 분산 MMORPG 서버</h1>
				<p class="page-date">28 May 2014</p>
				<p class="page-tags">
						
						
					<code class="tag">ndc14</code>
						
						
						
					<code class="tag">python</code>
						
						
						
					<code class="tag">distributed</code>
						
						
						
						
				</p>
				<div class="content"><div class="embed rich SlideShare"><iframe src="https://www.slideshare.net/slideshow/embed_code/key/t9rfxofKihVSFF" width="427" height="356" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="https://www.slideshare.net/sublee/spof-mmorpg" title="[야생의 땅: 듀랑고] 서버 아키텍처 - SPOF 없는 분산 MMORPG 서버" target="_blank">[야생의 땅: 듀랑고] 서버 아키텍처 - SPOF 없는 분산 MMORPG 서버</a> </strong> from <strong><a href="https://www.slideshare.net/sublee" target="_blank">흥섭 이</a></strong> </div>

<p></div></p>

<ul>
<li><a href="http://subl.ee/">이흥섭</a></li>
</ul>

<h3>요약</h3>

<ul>
<li>gevent를 믿고 ØMQ를 통해 객체/서버 시야 개념을 바탕으로 서버간 정보 동기화를 한다.</li>
<li>정보가 동기화되었으니 서버가 다중화되었다고 치고, 서버 말고는 다 튼튼하니 SPOF가 없다. (ELB 튼튼, couchbase 튼튼)</li>
<li>하지만 무중단 패치나 서버 다운으로 인한 client의 server connection 이전은 고민 중.</li>
</ul>

<h3>목표</h3>

<ul>
<li>실시간 동기화되는, 영속성 있고, 심리스인, 단일 세계를 구현해보자.</li>
<li>높은 가용성, 높은 가용률, 높은 신축성이 목표</li>
<li><strong>따라서 <a href="http://en.wikipedia.org/wiki/Single_point_of_failure">SPOF</a>는 허용하지 않는다.</strong></li>
</ul>

<h3>구현</h3>

<ul>
<li>python

<ul>
<li>open source를 통해 생산성을 높임.</li>
<li>연산이 느리고 multi threading이 미흡하지만, 대부분은 io bound 작업(inter-server communication)이기 때문에 필요한 부분(serialize, deserialize)만 c로 작성하면 되겠다.</li>
<li>gevent

<ul>
<li>sync/async io, coroutine, monkey patch, microthread</li>
</ul></li>
</ul></li>
<li>inter-server communication

<ul>
<li>broker 없이 전 서버를 그냥 다 연결했다.</li>
<li>하지만 어떤 서버들과 연결해야 하는지 주소록은 필요하니까 주소 교환용 broker는 하나 뒀다.</li>
<li><a href="http://zeromq.org/">ØMQ</a>를 사용하여 서버간 통신

<ul>
<li>round robin 방식을 사용하면 아무 node에게나 message를 전달한다.</li>
<li>pub/sub 방식을 사용하면 해당 channel을 구독한 대상에게만 message를 전달한다.

<ul>
<li>subscriber 정보가 publisher에게 동기화되어, publisher는 해당 channel을 구독한 subscriber가 있을 때에만 정보를 보내고, 없으면 정보를 보내지 않는다.</li>
</ul></li>
</ul></li>
</ul></li>
<li>mmorpg 분산 처리

<ul>
<li>영속성은 db로, 휘발성은 memory로</li>
<li>rdbms는 분산 어렵고 느리고 schema 변경이 어렵기 때문에 분산 db로는 couchbase를 사용했다.

<ul>
<li>무중단 확장/축소, 부분 장애 허용, no schema, 응답 속도 빠름</li>
<li>응답 속도의 경우 memory 반영 후 바로 응답할지, io 반영 완료 후 응답할지를 설정할 수 있다.</li>
<li>내용 검색은 지원하지 않는데 ElasticSearch나 N1QL을 쓸 수는 있다. 하지만 엄청 느리니 live에서 쓰면 안 됨.</li>
</ul></li>
</ul></li>
<li>GameServer

<ul>
<li>거리와 상호 작용은 반비례. 보통 가까이 있는 대상과 상호작용을 한다.</li>
<li>단일 서버로 가는 것이 목표인데 서버 다중화를 해야 하니 서버끼리 열심히 동기화를 해야 한다.</li>
<li>서버간 통신 비용이 발생하는데 모바일 클라이언트와의 통신 비용에 비하면 상대적으로 싸니까 괜찮다(?)</li>
<li>시야를 grid로 나누어서 각 grid를 pub/sub channel로 사용하여 서버간 동기화를 한다.

<ul>
<li>서버 시야는 서버 내 존재하는 객체 시야의 합이다.</li>
<li>서버 간의 시야가 겹치는 영역에 대해서만, 즉 grid의 sub channel에 대해서만 객체를 동기화한다.</li>
</ul></li>
<li>객체가 무작위로 서버에 퍼지면 서버 시야가 넓어지므로 동기화 비용이 커진다.

<ul>
<li>로그인 서버를 통해 사용자를 적절하게 분리한다.</li>
<li>이 경우 사용자들의 이동으로 인해 서버 시야가 넓어질 수 있는데,

<ul>
<li>이 게임은 모바일 게임이니까 한 번 맺은 세션에서 그렇게 많이 돌아다니지는 않을 것이다. 따라서 문제는 적을 것으로 가정한다.</li>
</ul></li>
</ul></li>
</ul></li>
<li>object interaction

<ul>
<li>서버 시야가 겹치는 영역에 대해, 동일한 객체가 여러 서버에 존재할 수 있게 된다.

<ul>
<li>이 때 진짜 객체를 real이라 하고 나머지들을 ghost라고 하자.</li>
<li>ghost들은 정보를 동기화해서 가지고는 있어 accessor를 통해 정보 조회가 바로 가능하지만, mutator를 수행 시 진짜 객체를 가진 서버를 대상으로 rpc를 요청하게 된다.</li>
<li>real과 ghost는 잘 추상화해서 구분하지 않고 쓸 수 있도록 코딩해놨다.</li>
</ul></li>
</ul></li>
</ul>

<h3>정리</h3>

<ul>
<li>system topology <em>(발표자료 참고바람)</em>

<ul>
<li>User -&gt; ELB -&gt; LoginServer</li>
<li>User -&gt; GameServers... -&gt; Couchbase</li>
<li>LoginServer  GameServers...</li>
</ul></li>
<li>이 구조에서 ELB, Couchbase가 튼튼하고 GameServer가 다중화되어있으니 이 시스템은 SPOF가 없다.

<ul>
<li><em>(LoginServer나 server address broker는 장애가 발생해도 시스템은 돌아가니 SPOF로 치지 않는 것 같다)</em></li>
</ul></li>
<li>무중단 확장/축소는 가능한데 무중단 배포 서버 구성은 아직 안 되었다.</li>
<li>특정 GameServer 재시작 시 클라이언트 연결을 이전하는 문제도 아직 해결이 안 되었다.</li>
</ul>

<hr>

<ul>
<li>SPOF가 없다는 것으로 어그로를 많이 끌었다. 결국 GameServer를 다중화해서 SPOF를 없앤다는 이야긴데 구축 영역에서 이야기를 해보면 별로 효용이 없을 것 같다.

<ul>
<li>(성능 문제는 차치하더라도) 저 시스템은 서버간 통신에 의한 동기화를 기본으로 삼고 있기 때문에, 해당 로직에 문제가 있거나 기능이 추가될 경우 전체 시스템 중단이 불가피하다.</li>
<li>무중단 서비스를 위해서는 서버 다중화 뿐만 아니라 IDC 다중화도 해야 한다. <em>(cloud 구축 발표 참고)</em> 하지만 여러 다른 IDC 간의 서버 동기화를 위와 같은 잦은 방식으로 진행한다면 제 시간 내에 동기화가 되는 것을 기대하기 어려울 뿐만 아니라 통신 비용으로 인해 운영 비용 크리를 맞을 것이다.</li>
<li>그리고 특정 서버 장애 발생 시 해당 client의 연결을 얼마나 graceful하게 다른 서버로 이전해줄 것이냐에 대한 문제도 있는데 이것에 대한 언급이 없었다. 해당 서버가 죽었으니 그 서버에서 아직 동기화되지 못한 정보가 있을텐데 그것은 어떻게 넘겨줄 것이며, 정말 운 없게 transaction이라도 진행 중이었다면 그것을 어떻게 복원해줄 것인지에 대한 고민도 필요하다.</li>
</ul></li>
<li>시야 개념을 통한 동기화 개념은 꽤 재밌고, python이라는 언어적 특성을 통한 proxy(ghost) 구성도 재미있기는 하다.

<ul>
<li>하지만 ØMQ에 의한 동기화가 허용 시간 내에 일어남을 보장해줄 지 모르겠고,</li>
<li>그로 인해 뭔가 logic 문제나 transaction 구성이 실패할 경우 proxy 밑단에 숨겨져있는 문제를 잘 발견할 수 있을지 모르겠다.</li>
</ul></li>
<li>모바일이니까 괜찮아요, 라는 괜찮은 수준을 좀 정량적으로 제시하고, 그에 대한 stress test 결과가 있었으면 좋을 것 같다.</li>
<li>뭐 어쨌든 시도나 발상은 재밌다고 생각한다.</li>
</ul>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1><a id="optimization" href="#optimization">optimization</a></h1>
				<hr />
				<div class="page-breaker"></div>
							
						
				<h1 class="page-title">mswsock.dll의 비밀</h1>
				<p class="page-date">14 Feb 2014</p>
				<p class="page-tags">
						
						
					<code class="tag">optimization</code>
						
						
						
					<code class="tag">network</code>
						
						
						
					<code class="tag">c#</code>
						
						
						
						
				</p>
				<div class="content"><p>최근 회사에서 c#으로 네트워크 프로그래밍을 하고 있다. 일은 아니고 그냥 개인의 취향
나름 c#도 속도가 괜찮다는 것을 보여주려고 시작을 했는데, 진행하면서 점점 보이는 결과는 영 좋지 않다.</p>

<p>서버 과부하 테스트 프로그램을 c#으로 porting했다. 정말 과부하 테스트를 하려면 c++로 작성해야 맞지만 테스트 로직까지 c++로 작성하면 골치가 아프니 core는 c++, logic은 c#으로 작성하는 방법을 고민하면서 porting을 하고 있다. 하지만 그 전에 귀찮으니 일단 network core도 c#으로 작성했고 이 때 c# async io와 async/await을 대충 섞어서 작성했다.</p>

<p><strong>정말 대충 짰더니 정말 성능이 대충 나온다-_-;</strong><br>
vs analyze 기능을 통해 확인을 해보면 가장 오래 걸리는 부분이 mswsock.dll에 소속되어 있다고 나온다. 이 글은 대체 왜 mswsock.dll인가에 대한 고찰을 담은 글이다.</p>

<p>.net <code>Socket</code>의 <code>BeginReceive</code>, <code>EndReceive</code> 함수를 사용하면 내부에서 pinvoke로 <code>WSARecv</code> 함수를 부르게 된다. <code>WSARecv</code> 함수는 <code>ws2_32.dll</code>에 정의된 함수로 얼핏보기에는 socket 확장 api가 담겨있는 <code>mswsock.dll</code>이 부를 필요가 없어 보인다. 이를 정확히 확인하기 위해 ms symbol server에서 clr 관련 symbol을 받고 다시 profiler를 돌려보았다.</p>

<p><img src="http://lacti.me/images/mswsock_secret_functions.png" alt="functions"></p>

<p>진범이 나온 것 같다. <code>NtDeviceIoControlFile()</code>과 <code>NtRemoveIoCompletion()</code>이 1, 2위로 나왔다. 여기서 <code>NtRemoveIoCompletion()</code> 함수는 <code>GetQueuedCompletionStatus()</code> 때문에 불리는 것으로 추측되니 <code>NtDeviceIoControlFile()</code>의 정체만 밝히면 되겠다.</p>

<p>간단히 calling, called를 확인해보자.</p>

<p><img src="http://lacti.me/images/mswsock_secret_ws2_32_dll.png" alt="ws2_32.dll"></p>

<p><img src="http://lacti.me/images/mswsock_secret_mswsock_dll.png" alt="mswsock.dll"></p>

<p>원인이 명확해졌다.<br>
다량의 패킷 수신자가 <code>WSARecv</code>를 부르는 과정에서 <code>ws2_32.dll</code>의 함수가 호출된 것은 당연했다. 하지만 그 과정에서 알 수 없는 오류가 발생했고, 그 오류를 처리하기 위해 불린 <code>NtStatusToSocketError()</code> 함수가 <code>mswsock.dll</code>의 <code>NtDeviceIoControlFile()</code> 함수를 불렀던 것이다.</p>

<p>그렇다면 <code>NtDeviceIoControlFile()</code> 함수는 대체 무엇일까, 그리고 왜 그렇게 느릴까?<br>
profiling한 결과를 보면 대부분의 exclusive sample의 address가 비슷한 지점을 가리키고 있는 것을 확인할 수 있다. 즉, 특정 지점에서 많이 멈춰있다는 이야기일 것인데, 이 때 cpu 사용량이 꽤 높다는 점을 미루어볼 때 뭔가 busy waiting을 하는 것이 아닐까 추측된다.</p>

<p>이 부분은 symbol 만으로 확인하기는 어렵고, 직접 disassemble을 해서 확인을 하던가 해야하지만 별로 그러고 싶지는 않고-_-; 일단 pinvoke로 직접 iocp를 호출하는 c# 코드를 작성하여 그 부분에서도 여전히 비슷한 문제가 발생하는지 확인을 해봐야겠다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">xml 기반의 데이터시트 빨리 읽기</h1>
				<p class="page-date">09 Jun 2013</p>
				<p class="page-tags">
						
						
					<code class="tag">optimization</code>
						
						
						
					<code class="tag">data</code>
						
						
						
						
				</p>
				<div class="content"><p>지금 일하고 있는 회사에서는 모든 게임 데이터를 xml로 기술하고 있다. 서버가 시작할 때 읽게 되는 xml의 양만 본다면 대략 800~900MB로 엄청난 양을 읽어야 한다. 덕분에 서버가 저 모든 데이터시트를 읽어서 메모리에 올리는 시간만 약 4~5분이 소요가 되었고, 이 시간으로 인해 발생하는 비효율은 말할 필요가 없을 정도였다.</p>

<p>본 글에서는 이 문제를 해결하기 위해 어떠한 탐색 과정을 거쳤으며 결과적으로 문제를 어떻게 해결하였는지 서술하려고 한다.</p>

<h3>profiling</h3>

<p>xml parser로 expat을 사용하고 있는데 이는 SAX parser이다. 문제는 SAX 이벤트를 받아서 STL의 자료구조에 넣고 그걸 iterating하는 방법으로 사용하고 있었다는 것이다. 대충 추측하고 있는 성능 저하 요소가 몇가지 있었지만 문제를 정확히 분석하기 위해 해당 서버 바이너리를 VS2010의 profiler로 수행한 결과를 확인했다.</p>

<ol>
<li>XML Parsing</li>
<li>XML Model에 parsing한 결과 담기 (STL)</li>
<li>XML 파일 접근에 의한 IO</li>
</ol>

<p>위 세 가지 요소가 가장 시간을 많이 잡아먹는 것으로 확인 되었다.</p>

<p>재미있는 것은 2번 항목이다.</p>

<ul>
<li>Profiling을 돌리기 전 여러 방법으로 실험을 하는 과정에서 발견된 것인데, Debug 버전으로 작성한 서버와 Release 버전으로 작성한 서버의 시간이 크게 차이가 나고 있는 것이었다.</li>
<li>Debug와 Release에서 1) 항목과 3) 항목이 큰 차이를 보이지 않을 것이라고 판단했기 때문에 2) 항목이 꽤 큰 이유를 차지하지 않을가 생각했던 것이었는데, profiling 결과 그 값이 생각보다는 그리 크게 나오지는 않았다. (관련 내용 후술함)</li>
</ul>

<h3>binary xml</h3>

<p>위 문제를 해결하기 위해서 다음과 같은 접근 방법을 사용했다.<br>
xml parsing 시간이 오래 걸리니 이를 해결하려면 parsing을 하지 않아야한다. 그러기 위해서 xml을 parsing한 결과를 binary로 serialize해두었다. 이 때 모든 xml을 다 serialize하면 용량이 크기 때문에 서버에서만 읽는 데이터만 내보냈다.<br>
(데이터시트에는 서버, 클라이언트, 툴, 기타 디자이너 참고용[...]으로 데이터가 기술되어 있기 때문에 서버에서 필요로하는 데이터만 추리면 약 600MB까지 양이 줄어든다)</p>

<p>binary로 serialize하기 위해 만든 파일의 구조를 간단히 보면 다음과 같다.</p>

<p><img src="http://lacti.me/images/binary_xml_each.png" alt="internal structure"></p>

<p>위 그림은 하나의 xml 파일에 해당하는 정보를 갖는다. 먼저 한 파일에 대한 <code>header 정보</code> - 파일 길이, 이름, 최종 수정 시각을 갖는다. (최종 수정 시각이 필요한 이유는 이 글 마지막 부분에 설명하겠다.) 그리고 <code>XmlData</code> 영역에 <code>Node</code>와 <code>Attribute</code>를 차례대로 기록하게 된다.</p>

<p>이 때 <code>NodeIndex</code>와 <code>AttributeIndex</code>는 <code>XmlTypeDefine</code>이라는 Xml 문법 정의 파일을 참고해서 작성된다. 예를 들어 Skill이라는 Node가 XmlTypeDefine에서 3번째에 정의되었다면 NodeIndex는 3이 되는 것이다.</p>

<p>그 외에 Node의 특성에 다른 정보가 추가 bit로 구성된 것들이 있다. <code>text</code>는 XmlText를 포함할 경우 set되는 bit이고, <code>Recursive</code>는 말 그대로 Node의 구조가 recursive할 때 사용되는 bit이다. 단순히 자신의 TypeDefine 정보를 부모의 자식 정보 중 NodeIndex 번째의 것을 사용하는 것이 아니라, 부모의 것을 그대로 사용(Recursive하니까)하는 구조라는 뜻이다.</p>

<p>궁금해할 사람은 없어보이지만 string이나 list-type은 다음과 같이 serialize했다.</p>

<p><img src="http://lacti.me/images/binary_xml_string_list_type.png" alt="string, list-type"></p>

<p>이렇게 Serialize한 내용을 <code>BinaryXml</code>이라고 불렀다.</p>

<p>아까 <code>NodeIndex</code>와 <code>AttributeIndex</code>를 언급하면서 <code>XmlTypeDefine</code> 내에 기술된 순서(index) 값을 그대로 사용한다고 하였다. 그렇다면 <code>XmlTypeDefine</code>이 변경될 경우 당연히 BinaryXml을 잘못 읽을 수 있게 된다는 뜻이다.</p>

<p>이 문제를 해결하기 위해서 BinaryXml 앞 부분에다가 TypeDefine을 넣어주었다. TypeDefine 역시 xml으로 기록이 가능하기 때문에 BinaryXml로 변환이 가능하기 때문이다.</p>

<p><img src="http://lacti.me/images/binary_xml_whole_file.png" alt="string, list-type"></p>

<p>물론 TypeDefine을 BinaryXml으로 기록하기 위해서는 <code>TypeDefine에 대한 TypeDefine</code>이 필요하다. 그래야 <code>NodeIndex</code>와 <code>AttributeIndex</code>를 얻을 수 있으니까. 그 내용을 서버에서는 <code>DefineDefine.xml</code> 이라는 것으로 기술해놨는데 사실 이 부분은 그냥 코드에 박아넣어도 문제가 없었을 것이다.</p>

<p>BinaryXml을 도입함으로써 처음 성능 저하의 원인으로 꼽았던 문제가 모두 해결되었다.</p>

<ul>
<li>XML Parsing 비용이 BinaryXml으로 인해 기존처럼 text processing을 안해도 되니 크게 감소하였으며,</li>
<li>XML Model 객체에 parsing한 결과를 담을 때 이미 개수를 알고 있으니 STL을 사용할 필요도 없어졌다.</li>
<li>그리고 필요한 데이터가 BinaryXml로 표현되어 하나의 파일에 모였으니 파일 접근에 의한 IO 시간도 감소하였다.</li>
</ul>

<p>BinaryXml 데이터 집합을 <strong>DataChunk</strong>라고 표현했다.<br>
DataChunk를 만드는 과정에서 약간의 번거로움이 있지만 (XmlTypeDefine을 만들어내고, DataChunk를 생성해야 한다) 그래도 서버 시작 시간은 많이 단축되었다. 그리고 위 과정은 CI에 포함하면 되니까 각 개발자들에게 그리 큰 부담이 되는 것은 아니다.</p>

<p>그럼 끝일까?</p>

<h3>update by modification</h3>

<p>일단 데이터시트 수정 자체는 개발 과정에서 매우 빈번하게 일어나는 일이다. 따라서 DataChunk 내의 BinaryXml만 읽으면 좋겠지만 그럴 수가 없다. DataChunk 내 기록된 BinaryXml보다 xml 파일이 더 최신이라면 그 파일을 읽도록 해주어야 한다. 즉 BinaryXml에 last-modified 값이 기록된 것이고, 이 값을 통해 xml파일과 수정 시각을 비교하여 어떤 파일을 읽을지 결정하도록 한 것이다.</p>

<p>물론 이 구조로는 DataChunk 생성 이후 xml 파일이 삭제되어도 BinaryXml 파일을 읽는 문제가 있다. 즉 없어지는 파일을 감지하지 못하는 문제가 있는 것인데 이 문제는 그리 자주, 혹은 큰 문제를 일으키지 않기 때문에 무시했다.</p>

<h3>wcsicmp</h3>

<p>더 큰 문제는 DataChunk를 도입했음에도 불구하고 서버 시작 시간이 120~140초 내외였던 것이다(기껏해야 2배 빨라졌다). 목표는 1분 이내였기 때문에 다시 profiling을 돌렸다.</p>

<p>profiling 수행 후 재미있는 결과가 나왔는데, 이는 제일 처음 분석했던 문제 2)와 관련된 <em>_wcsicmp 함수 사용 부담</em>이다. 즉, attribute를 검색하기 위해 <code>string_map</code>을 사용하였고, 여기서 key compare를 하기 위해 매번 <code>wcsicmp</code> 함수가 사용되는데 이 부담이 매우 컸던 것이다. (이 부분이 Release에서는 생각보다 잘 최적화가 된 것 같다. STL의 신비)</p>

<p><code>string_map</code>을 안 쓰기 위해 <code>index-cache</code>를 TLS에 넣어두기로 했다. 개념은 다음과 같다.</p>

<ol>
<li>literal string의 주소는 다 동일하니까, literal 주소로 index-cache를 만든다.</li>
<li>이 때 다른 xml의 동일한 literal string의 주소도 같을테니까 TypeDefine의 주소도 섞어서 key로 쓴다.</li>
<li>없으면 TypeDefine에서 AttributeIndex를 찾아서 접근하고, 이 index를 잘 cache해둔다.</li>
<li>stack 변수로 attribute 이름이 조합되어 넘어올 수 있으니 잘 integrity를 검사해준다.</li>
</ol>

<p><img src="http://lacti.me/images/binary_xml_attribute_index_cache.png" alt="attribute index cache"></p>

<p>BinaryXml의 각 node에 attribute 개수만큼 배열을 미리 만들어둔다. 그러면 <code>TypeDefine</code>에서 찾은 <code>AttributeIndex</code>로 바로 접근이 가능하기 때문이다. (물론 TypeDefine에서 Attribute를 찾을 때에는 string_map을 쓴다)</p>

<p>대신 한 번 찾은 <code>AttributeIndex</code>는 계속 쓸 수 있도록 잘 cache해둔다. 여기서 사용한 개념이 동일한 literal string의 주소는 같다인데, 문제는 Skill의 &quot;id&quot;도, Npc의 &quot;id&quot;도 같은 주소이기 때문에 그 literal 주소만 key로 쓰면 안되고, 그게 어떤 TypeDefine에 소속되어있는지 까지 key로 잡기 위해 <strong>각각 주소의 하위 32bit를 엮어서</strong> key로 쓴 것이다.</p>

<p>그리고 가끔 stack으로 attribute 이름이 넘어오는 경우가 있다. 예를 들면 value1, value2, ...., value5 같은게 있는데 이 때는 주소가 모두 동일하니 위 방법으로도 제대로 걸러낼 수가 없다. 따라서 무결성 검사 항목을 value의 하위 32bit에 넣었다. 방법은 간단히 맨 앞 2글자와 맨 뒤 2글자를 ^ 연산하는 것. 일단 저정도만 해도 문제 상황은 없어서 저정도 수준으로 구현을 했다.</p>

<h3>정리</h3>

<p>위 내용까지 적용하고 나니, 놀랍게도 Debug 빌드 서버 시작 시간이 40초로 줄었다. 기존 240초에 비하면 약 6배 정도 빨라진 것이다.</p>

<p>DataChunk를 만드는 과정의 번거로움은 있지만 충분히 도입할만한 가치가 있는 물건이 나온 것이다. (라고 본인은 생각하는데 아직 안 쓰는 사람도 꽤 있는 것을 보니 본인만 그렇게 느끼는 듯 싶기도 하고)</p>

<p>최근에 <a href="/2013/06/07/csharp-game-server/">C#으로 게임 서버 만들기</a>로 회사 내 발표를 진행하면서 &quot;데이터는 왜 또 Xml을 고려하신건가요?&quot; 라는 질문을 받았다. Xml 데이터로 인한 로딩 시간을 질문하신 것 같은데,</p>

<p>위 작업을 진행하면서 내가 내린 결론은,</p>

<ol>
<li>Xml의 Parsing 속도가 느린 것은 사실이지만 충분히 개선하여 잘 사용할 수 있다.</li>
<li>문제의 도메인에 집중하여 완벽한 해결책이 아닌 가용한 해결책을 내자</li>
</ol>

<p>이다.
배운다는 입장에서는 2번이 더 중요한 것이지만, 어쨌든 회사에서 일하는 몸이니 1번 사항에 대해서 잠깐 이야기를 해보자.</p>

<p>게임을 만든다고 했을 때 데이터를 기술할 수 있는 방법은 여러가지가 있을 것이다.
그냥 txt로 쓰거나, 아니면 프로그래밍 언어로 쓰거나. xml이나 json, yaml 등의 잘 알려진 형태로 기술하거나 아니면 직접 DSL을 작성하여 기술하거나.</p>

<p>개인적인 성향으로는 DSL도 나쁘지는 않지만 작업할 수 있는 IDE나 Validator 수준을 만들어주지 않는다면 또 다른 재앙을 불러일으킨다고 보는 편이기 때문에 그닥 현업에서는 사용하고 싶지 않다. txt나 csv는 말하고 싶지도 않고.</p>

<p>xml/json을 비교해 본 적이 있는데 json을 지지하는 사람은 꽤 있지만 개인적으로 데이터를 사람이 입력하는 입장에서 json은 그닥 좋은 느낌을 못 받았다. xml로 복잡하게 기술된 내용을 json으로 기술했을 때 그 복잡함이 어디로 가는게 아니었기 때문-_-</p>

<p>xml이 그럼 낫냐? 라고 하면 역시 그거에도 동조하고 싶지는 않다. 이쯤에서 무슨 소리를 하고 싶냐! 라는 소리가 들리는 것 같은데, 정말 하고 싶은 이야기는 format 보다도 <strong>어떻게 데이터를 설계할 것이냐가 더 중요하다는 것이다.</strong></p>

<p>xml로 작성된 데이터로부터 더러움을 느꼈다면 그게 xml 본연의 문제일 확률은 낮다. 단지 xml을 더럽게 써서 그랬을 뿐이지. xml을 사용함으로 인해 발생하는 parsing 시간 소요 등의 이슈도 여러 가지 방법으로 해결할 수 있다. 데이터를 설계할 때 무엇을 고려해야할 지에 대한 이야기를 하자면 구구절절 끝도 없고 본 글의 제목과도 맞지 않을 것 같으니 이 글은 여기서 접고, 데이터 설계 이야기는 다음 글에서 하도록 하겠다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1><a id="os" href="#os">os</a></h1>
				<hr />
				<div class="page-breaker"></div>
							
						
				<h1 class="page-title">pintos 기본 구조와 동작 원리</h1>
				<p class="page-date">01 Apr 2008</p>
				<p class="page-tags">
						
						
					<code class="tag">os</code>
						
						
						
						
				</p>
				<div class="content"><h3>Pintos의 기본 구조</h3>

<p>Pintos는 가장 기본 기능인 threads를 중심으로 user program, virtual memory, 그리고 file system을 추가하는 구조를 갖는다. 그래서 소스 코드의 분포 역시 기본적인 것들은 threads 디렉토리에 다 있고, 그 밖의 것들은 각각의 디렉토리에 존재하면서 threads에 있는 소스 코드를 참조하는 식으로 되어있다. 그리고 Pintos를 구성하는 데는 필요하지만 과제 항목에는 포함되어있지 않은 기본 library나 device는 별도의 디렉토리에 존재한다.</p>

<p>즉, 기본적인 구조와 틀은 이미 threads의 init.c에 모두 존재하고 과제를 수행하면서 기능을 더 추가하거나 수정하는 구조로 되어있어 커널의 기본 틀을 고칠 일은 없는 구조로 구성되어있다.</p>

<p>예외라면 virtual memory가 예외인데, vm 디렉토리에 아무 파일이 없는 것으로 알 수 있듯이 virtual memory는 완전히 새로 추가되는 기능이라고 볼 수 있다. 사실 정확히 말하자면 page의 기능을 개선하는 것이지만 다른 과제에 비한다면 그 틀이 없다고 볼 수 있다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash">vm/build/Makefile
57 <span class="c"># No virtual memory code yet.</span>
58 <span class="c">#vm_SRC = vm/file.c         # Some file.</span>
</code></pre></div>
<p>그러면 결국 pintos의 기본 구조를 설명하려면 뼈대인 init.c의 main 함수를 설명해야할 것인데, 이미 부팅하는 과정에서 main 내의 대부분의 내용을 설명해버렸으므로 이 부분에서는 그 이후부터 설명할 것이다.</p>

<p>“Boot complete.”를 출력한 이후에는 코드가 몇 줄 남아있지 않다.</p>
<div class="highlight"><pre><code class="c language-c" data-lang="c"><span class="n">init</span><span class="p">.</span><span class="n">c</span>
<span class="mi">120</span>   <span class="cm">/* Run actions specified on kernel command line. */</span>
<span class="mi">121</span>   <span class="n">run_actions</span> <span class="p">(</span><span class="n">argv</span><span class="p">);</span>
<span class="mi">122</span>
<span class="mi">123</span>   <span class="cm">/* Finish up. */</span>
<span class="mi">124</span>   <span class="k">if</span> <span class="p">(</span><span class="n">power_off_when_done</span><span class="p">)</span>
<span class="mi">125</span>     <span class="n">power_off</span> <span class="p">();</span>
<span class="mi">126</span>   <span class="nf">thread_exit</span> <span class="p">();</span>
</code></pre></div>
<p>단순히 run_actions 함수에게 부트 로더로부터 읽어온 실행 인자를 보내고, 그 일이 끝나면 사용자의 요구에 따라서 전원을 끄거나 아니면 그대로 멈추거나 한다.</p>

<p>먼저 run_actions 함수 내부를 보면 내부에 실행 인자로 들어오는 명령 이름과 mapping되는 함수들이 action이라는 구조체로 table을 형성하고 있다. 실제로 이번 tour에서 수행하는 run alarm-multiple의 run도 여기에서 run_task란 함수와 mapping되어 그 함수가 수행되어 alarm-multiple가 동작하게 됨을 알 수 있다.</p>
<div class="highlight"><pre><code class="c language-c" data-lang="c"><span class="n">init</span><span class="p">.</span><span class="n">c</span>
<span class="mi">286</span>   <span class="cm">/* Table of supported actions. */</span>
<span class="mi">287</span>   <span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">action</span> <span class="n">actions</span><span class="p">[]</span> <span class="o">=</span>
<span class="mi">288</span>     <span class="p">{</span>
<span class="mi">289</span>       <span class="p">{</span><span class="s">&quot;run&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">run_task</span><span class="p">},</span>
<span class="mi">290</span> <span class="err">#</span><span class="n">ifdef</span> <span class="n">FILESYS</span>
<span class="mi">291</span>       <span class="p">{</span><span class="s">&quot;ls&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fsutil_ls</span><span class="p">},</span>
<span class="mi">292</span>       <span class="p">{</span><span class="s">&quot;cat&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">fsutil_cat</span><span class="p">},</span>
<span class="mi">293</span>       <span class="p">{</span><span class="s">&quot;rm&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">fsutil_rm</span><span class="p">},</span>
<span class="mi">294</span>       <span class="p">{</span><span class="s">&quot;put&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">fsutil_put</span><span class="p">},</span>
<span class="mi">295</span>       <span class="p">{</span><span class="s">&quot;get&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">fsutil_get</span><span class="p">},</span>
<span class="mi">296</span> <span class="err">#</span><span class="n">endif</span>
<span class="mi">297</span>       <span class="p">{</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">},</span>
<span class="mi">298</span>     <span class="p">};</span>
</code></pre></div>
<p>연결된 함수 포인터를 통해 다음과 같이 mapping된 함수를 수행함을 볼 수 있다.</p>
<div class="highlight"><pre><code class="c language-c" data-lang="c"><span class="n">init</span><span class="p">.</span><span class="n">c</span>
<span class="mi">317</span>       <span class="cm">/* Invoke action and advance. */</span>
<span class="mi">318</span>       <span class="n">a</span><span class="o">-&gt;</span><span class="n">function</span> <span class="p">(</span><span class="n">argv</span><span class="p">);</span>
<span class="mi">319</span>       <span class="n">argv</span> <span class="o">+=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">argc</span><span class="p">;</span>
</code></pre></div>
<p>기본 구조이므로 가볍게 <code>run_task</code>만 따라가서 분석을 해보면, 내부에서 <code>process_execute</code>라는 함수를 통해 실행 인자 중 첫 번째 인자로 들어오는 task의 이름을 인자로 보내어 해당 task에 대한 process를 생성한다, 실제로 이 동작은 <code>USERPROG</code> 매크로가 true일 때 수행되는 명령으로 여러 프로그램이 동시에 수행되어야할 때 그들을 프로세스로 관리하기 위해서 사용되는 부분이다. threads에서는 <code>USERPROG</code>가 false이므로 수행되지 않는다.</p>

<p>따라서 바로 <code>run_test</code> 함수로 수행할 동작의 이름인 <code>alarm-multiple</code>을 인자로 호출한다. 여기서는 tests라는 배열에 또 threads의 test함수와 이름이 mapping 되어있다.</p>
<div class="highlight"><pre><code class="c language-c" data-lang="c"><span class="n">threads</span><span class="o">/</span><span class="n">test</span><span class="p">.</span><span class="n">c</span>
<span class="mi">12</span> <span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">test</span> <span class="n">tests</span><span class="p">[]</span> <span class="o">=</span>
<span class="mi">13</span>   <span class="p">{</span>
<span class="mi">14</span>     <span class="p">{</span><span class="s">&quot;alarm-single&quot;</span><span class="p">,</span> <span class="n">test_alarm_single</span><span class="p">},</span>
<span class="mi">15</span>     <span class="p">{</span><span class="s">&quot;alarm-multiple&quot;</span><span class="p">,</span> <span class="n">test_alarm_multiple</span><span class="p">},</span>
<span class="mi">16</span>     <span class="p">{</span><span class="s">&quot;alarm-simultaneous&quot;</span><span class="p">,</span> <span class="n">test_alarm_simultaneous</span><span class="p">},</span>
</code></pre></div>
<p><code>run_test</code> 함수에서는 인자로 받은 이름과 일치하는 함수를 찾아서 호출해준다. 즉, 여기서는 <code>test_alarm_multiple</code>이 호출된다.</p>
<div class="highlight"><pre><code class="c language-c" data-lang="c"><span class="n">threads</span><span class="o">/</span><span class="n">test</span><span class="p">.</span><span class="n">c</span>
<span class="mi">52</span>     <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span>
<span class="mi">53</span>       <span class="p">{</span>
<span class="mi">54</span>         <span class="n">test_name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
<span class="mi">55</span>         <span class="nf">msg</span> <span class="p">(</span><span class="s">&quot;begin&quot;</span><span class="p">);</span>
<span class="mi">56</span>         <span class="n">t</span><span class="o">-&gt;</span><span class="n">function</span> <span class="p">();</span>
<span class="mi">57</span>         <span class="nf">msg</span> <span class="p">(</span><span class="s">&quot;end&quot;</span><span class="p">);</span>
<span class="mi">58</span>         <span class="k">return</span><span class="p">;</span>
<span class="mi">59</span>       <span class="p">}</span>
</code></pre></div>
<p><code>test_alarm_multiple</code> 함수는 <code>test_sleep</code>라는 내부 테스트 함수를 다시 호출한다. <code>test_sleep (5, 7)</code>으로 호출하는데 첫 번째 인자인 5가 생성할 thread의 개수이고 7이 반복을 수행할 개수이다. <code>alarm-multiple</code>를 수행했을 때 결과를 보면 thread가 0번부터 4번까지 5개가 나오고 각각 7번씩 화면에 출력되는 것을 볼 수가 있다. 차이가 있다면 0번 thread는 딜레이가 10, 1번 thread는 딜레이가 20으로 증가하여 4번 thread는 딜레이가 50이 되는 구조이다. 그래서 출력 결과물에 보면 해당 iteration을 수행할 때까지 걸린 누적 시간을 출력하는데, 0번 thread는 7을 70에 출력하고 끝나고 4번 thread는 7을 350에 출력하는 것을 볼 수 있다.</p>

<p><code>test_sleep</code>에서는 위에서 말한 동작을 수행하는 코드가 작성되어있다. thread를 지정된 개수만큼 생성하고 지정된 시간만큼 쉬고 쉰 다음에 출력에 대한 lock을 얻어 그 값을 증가시키는 구조이다.</p>

<p>정리하자면, Pintos의 커널은 기본적으로 init.c의 main 함수에 모두 들어가있다. 부팅 과정에서 커널을 메모리에 불러오는 부분은 예외이지만 커널을 초기화하고 사용자로부터 입력을 받아 그 입력을 처리하는 부분까지 모두 main 함수에 구현되어있는 구조이다.</p>

<h3>Pintos의 동작 방식</h3>

<p>Pintos의 내부 동작에 대해서는 위에서 모두 설명했기 때문에 여기서는 Pintos의 커널에게 실행 인자를 넘기고 그것을 어떻게 Pintos가 받아들인 뒤 해석하여 수행하는지에 대해 기술하겠다.</p>

<p>먼저 Pintos의 실행 부분부터 보겠다. 보고서에 기술된 Pintos의 실행 명령은 다음과 같다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash"><span class="nv">$ </span>pintos -v -- run alarm-multiple
</code></pre></div>
<p>이 실행 명령은 --를 기준으로 앞과 뒤로 나뉠 수 있다. --의 앞 쪽에 존재하는 옵션은 pintos를 통해 bochs에 전달되는 옵션이다. 따라서 no-gui 모드로 구동하라던지 아니면 메모리의 크기를 설정하겠다던지의 옵션을 지정할 수 있다.</p>

<p>그리고 -- 이후에 나오는 옵션이 바로 Pintos의 커널에게 전달될 인자들이다. 사실 pintos 파일은 perl로 구성된 스크립트로 --을 기준으로 앞 뒤를 잘라 앞의 것은 bochs로, 뒤의 것은 커널로 전달하는 역할을 수행한다. 따라서 --을 입력한 뒤에 한 칸을 띄고 run 등의 인자를 입력해야 정상 동작이 된다.</p>

<p>여기서 추출된 인자는 pintos 내부의 prepare_argument로 전달되고 이 함수는 다시 write_cmd_line 함수를 호출하여 인자로 받은 내용을 커널 이미지 파일의 인자를 넣는 부분에 직접 기록한다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash">pintos/src/utils/pintos
356 <span class="c"># Writes @args into the Pintos bootloader at the beginning of $disk.</span>
357 sub write_cmd_line <span class="o">{</span>
358     my <span class="o">(</span><span class="nv">$disk</span>, @args<span class="o">)</span> <span class="o">=</span> @_<span class="p">;</span>
359
360     <span class="c"># Figure out command line to write.</span>
361     my <span class="o">(</span><span class="nv">$arg_cnt</span><span class="o">)</span> <span class="o">=</span> pack <span class="o">(</span><span class="s2">&quot;V&quot;</span>, scalar <span class="o">(</span>@args<span class="o">))</span><span class="p">;</span>
362     my <span class="o">(</span><span class="nv">$args</span><span class="o">)</span> <span class="o">=</span> join <span class="o">(</span><span class="s1">&#39;&#39;</span>, map <span class="o">(</span><span class="s2">&quot;$_\0&quot;</span>, @args<span class="o">))</span><span class="p">;</span>
363     die <span class="s2">&quot;command line exceeds 128 bytes&quot;</span> <span class="k">if </span>length <span class="o">(</span><span class="nv">$args</span><span class="o">)</span> &gt; 128<span class="p">;</span>
364     <span class="nv">$args</span> .<span class="o">=</span> <span class="s2">&quot;\0&quot;</span> x <span class="o">(</span>128 - length <span class="o">(</span><span class="nv">$args</span><span class="o">))</span><span class="p">;</span>
365
366     <span class="c"># Write command line.</span>
367     my <span class="o">(</span><span class="nv">$handle</span>, <span class="nv">$file_name</span><span class="o">)</span> <span class="o">=</span> open_disk_copy <span class="o">(</span><span class="nv">$disk</span><span class="o">)</span><span class="p">;</span>
368     print <span class="s2">&quot;Writing command line to $file_name...\n&quot;</span><span class="p">;</span>
369     sysseek <span class="o">(</span><span class="nv">$handle</span>, 0x17a, 0<span class="o">)</span> <span class="o">==</span> 0x17a or die <span class="s2">&quot;$file_name: seek: $!\n&quot;</span><span class="p">;</span>
370     syswrite <span class="o">(</span><span class="nv">$handle</span>, <span class="s2">&quot;$arg_cnt$args&quot;</span><span class="o">)</span> or die <span class="s2">&quot;$file_name: write: $!\n&quot;</span><span class="p">;</span>
371 <span class="o">}</span>
</code></pre></div>
<p>커널에서 인자를 받는 부분은 loader.S에서 다음과 같이 정의되어있다.</p>
<div class="highlight"><pre><code class="asm language-asm" data-lang="asm"><span class="nf">loader.S</span>
<span class="err">336</span> <span class="c">#### Command-line arguments and their count.</span>
<span class="err">337</span> <span class="c">#### This is written by the `pintos&#39; utility and read by the kernel.</span>
<span class="err">338</span> <span class="c">#### The loader itself does not do anything with the command line.</span>
<span class="err">339</span>     <span class="na">.org</span> <span class="no">LOADER_ARG_CNT</span> <span class="p">-</span> <span class="no">LOADER_BASE</span>
<span class="err">340</span> <span class="nl">arg_cnt:</span>
<span class="err">341</span>     <span class="na">.long</span> <span class="mi">0</span>
<span class="err">342</span>     <span class="na">.org</span> <span class="no">LOADER_ARGS</span> <span class="p">-</span> <span class="no">LOADER_BASE</span>
<span class="err">343</span> <span class="nl">args:</span>
<span class="err">344</span>     <span class="na">.fill</span> <span class="mi">0x80</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
</code></pre></div>
<p>부트 섹터는 첫 번째 섹터로 그 크기가 512bytes이다. 이를 16진수로 나타내면 0x200인데 loader.h에서 정의하는 상수들을 사용하여 잘 계산해보면 <code>arg_cnt</code>와 <code>args</code>의 byte 위치를 계산할 수 있다. 당연한 이야기이지만 pintos에서 언급된 0x17A 지점이다.</p>

<p>이렇게 pintos가 수행될 때 인자로 받은 내용을 이미 작성된 커널 이미지를 직접 수정하여 집어넣으면 위의 부팅 과정에서 설명했듯이 init.c의 main 함수에서 <code>read_command_line()</code> 함수가 수행될 때 그 인자가 올라가 있는 메모리에 접근하여 인자를 가져오는 것이다. 이 정보는 부트 섹터에 있는데 부트 섹터는 이미 BIOS에 의해 메모리에 올라가 있는 상태이다.</p>

<p>그 다음에는 위에서도 언급했듯이 <code>parse_options()</code> 함수가 호출되어 인자로 받은 옵션 정보를 분석하여 내부의 flags를 설정한다. 또 말하자면 대표적인 예는 -q 옵션으로 이는 커널의 모든 작업이 종료되면 전원을 꺼서(power off) bochs가 종료되도록 하는 옵션이다.
이 <code>parse_options()</code> 함수는 뒤에서 다시 인자를 분석하게 될 <code>run_actions()</code> 함수보다 먼저 수행되므로 Pintos의 flags를 변경하고자 하는 옵션은 당연히 run보다 앞에 나와야 한다.</p>

<p>이제 run 뒤에 나오는 실행 인자가 분석되는 함수인 <code>run_actions()</code> 함수를 보자. 이 함수도 위에서 언급했듯이 내부에 이미 실행하려고 하는 대상의 이름과 그 대상으로 수행되어야할 작업이 기술되어있는 함수가 연결되어있는 구조체 action의 배열을 갖는다. 여기서 일치하는 명령이 존재한다면 그를 수행하는 것이고 그렇지 않다면 KERNEL PANIC 메시지를 출력하면서 Pintos는 스스로 kill을 수행할 것이다.</p>

<p>추후에 나오게 될 ls나 cat 등의 명령어도 여기에 있는 것을 볼 수 있다. 즉 이러한 명령들은 커널이 자체적으로 포함하고 있는 내부 명령어로 볼 수 있다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">pintos 부팅 과정</h1>
				<p class="page-date">01 Apr 2008</p>
				<p class="page-tags">
						
						
					<code class="tag">os</code>
						
						
						
						
				</p>
				<div class="content"><p>우리가 일반적으로 사용하는 컴퓨터 내에 존재하는 시스템은 하드 디스크 등의 보조 기억 공간을 갖고 그 기억 공간에 접근하여 동작을 수행하는데, Pintos를 수행하는 bochs는 Pintos를 빌드하여 얻어진 이미지 파일을 하드 디스크 등과 같은 storage로 인식하여 emulating을 수행한다. 하지만 Pintos는 단순히 커널만 존재하기 때문에 우리가 일반적으로 사용하는 storage와 달리 이미지 파일에는 단순히 부팅을 위한 부트 섹터와 커널 이미지만 존재하게 된다.</p>

<h3>부트로더</h3>

<p>부팅이란 컴퓨터가 구동하여 기초적인 초기화 작업을 수행하고 운영 체제를 읽어오는 일련의 작업을 말한다. 그리고 부트 섹터는 방금 언급한 기초적인 초기화 작업과 운영 체제를 읽어서 메모리에 올리고 수행시키는 작업에 대한 코드가 작성된 프로그램이 기록된 섹터로 장치의 첫 번째 트랙의 첫 번째 섹터를 지칭한다. 어떤 보조 기억 창치(storage)에 이러한 정보가 기술되어 있으면 BIOS는 컴퓨터가 구동된 후 연결된 storage들을 탐색하면서 해당 장치가 부팅 가능한 정보를 갖고 있는지 검사한다. 한 섹터의 크기는 512bytes이므로 정확히 말하자면 부트 섹터인 가장 첫 번째 섹터의 511번째 바이트와 512번째 바이트가 각각 <code>0x55</code> <code>0xAA</code>이어야 한다.</p>

<p>이러한 구조는 <code>loader.S</code>에 기술되어있다.</p>
<div class="highlight"><pre><code class="asm language-asm" data-lang="asm"><span class="err">346</span> <span class="c">#### Boot-sector signature.</span>
<span class="err">347</span> <span class="c">#### The BIOS checks that this is set properly.</span>
<span class="err">348</span>     <span class="na">.org</span> <span class="no">LOADER_SIG</span> <span class="p">-</span> <span class="no">LOADER_BASE</span>
<span class="err">349</span>     <span class="na">.word</span> <span class="mi">0xaa55</span>
</code></pre></div>
<p>따라서 부팅을 수행하려면 일단 부팅을 수행하기 위한 일련의 작업들을 코드로 기술하고, 511byte와 512byte를 <code>0x55</code> <code>0xAA</code>로 끝내는 512bytes 짜리 기계어를 작성한 후에 가장 첫 번째 섹터에 기록하면 되는 것이다.</p>

<p>이런 방법을 사용하는 이유는 Pintos의 크기가 512bytes를 넘어가기 때문에 첫 번째 섹터에 그 기계어를 다 기록할 수 없기 때문이다. 따라서 부트 섹터에 기술된 기계어는 기초적인 초기화를 한 후 크기가 512bytes보다 큰 커널을 메모리에 올려놓고 그 지점으로 jump하여 운영 체제가 동작할 수 있게 해주는 것이다.</p>

<p>이제 BIOS를 emulate하는 bochs는 Pintos 이미지가 부팅 가능하다는 것을 알게 되었기 때문에 부팅을 수행한다. BIOS는 첫 번째 섹터를 읽어 메모리의 <code>0x7C00</code>에 올려놓고 작업을 시작한다. 지금부터 설명할 부팅 시 수행하는 작업들은 loader.S에 기술되어있다.</p>

<p>먼저 부팅이 시작되면 BIOS를 사용할 수 있는 16bit 모드로 작업을 수행한다. 추후에 다시 기술할 내용이지만 Pintos는 32bit 모드로 변환한 후에도 한참 뒤에나 장치의 interrupt를 handling하기 때문에 일단은 interrupt에 의해 부팅이 방해되는 것을 막기 위해 모든 interrupt를 막는다.</p>

<p>그리고 segment 레지스터를 초기화하고 loader의 코드가 올라간 메모리의 <code>0x7C00</code> 주소에 맞추어 origin을 설정한다. 그리고 기본적으로 설정되어있는 메모리 한계인 1MB를 풀기 위해 A20 회로를 활성화시킨다. 그 다음에 메모리의 크기를 얻는 작업을 수행한다. 여기서 BIOS를 사용한다.</p>

<p>BIOS는 Basic Input/Output System의 약자로 시스템의 기초적인 입출력을 담당하고, 또한 관련 함수를 제공해준다. BIOS에서 제공하는 함수를 호출하려면 interrupt를 사용해야 한다. 각 장치 별로 interrupt 번호가 존재하고 각 장치 내에서 수행할 함수는 보통 AH로 정한다. 유명한 BIOS interrupt로 디스크 관련 인터럽트인 INT 13과 화면 관련 인터럽트인 INT 10이 존재한다.</p>
<div class="highlight"><pre><code class="asm language-asm" data-lang="asm"><span class="err">316</span> <span class="nl">panic:</span>  <span class="na">.code16</span>         <span class="c"># We only panic in real mode.</span>
<span class="err">317</span>     <span class="nf">movw</span> <span class="no">$panic_message</span><span class="p">,</span> <span class="nv">%si</span>
<span class="err">318</span>     <span class="nf">movb</span> <span class="no">$0xe</span><span class="p">,</span> <span class="nv">%ah</span>
<span class="err">319</span>     <span class="nf">subb</span> <span class="nv">%bh</span><span class="p">,</span> <span class="nv">%bh</span>
<span class="err">320</span> <span class="err">1:</span>  <span class="nf">lodsb</span>
<span class="err">321</span>     <span class="nf">test</span> <span class="nv">%al</span><span class="p">,</span> <span class="nv">%al</span>
<span class="err">322</span> <span class="err">2:</span>  <span class="nf">jz</span> <span class="mi">2</span><span class="no">b</span>           <span class="c"># Spin.</span>
<span class="err">323</span>     <span class="nf">int</span> <span class="no">$0x10</span>
<span class="err">324</span>     <span class="nf">jmp</span> <span class="mi">1</span><span class="no">b</span>
</code></pre></div>
<p>실제로 <code>INT 10</code>은 부팅 도중 PANIC이 일어났을 때 PANIC 문자열을 출력하기 위해 사용된다. 이 때 호출되는 함수는 <code>0x0E</code>번 함수인데 이는 <code>TELETYPE_OUTPUT</code> 함수이다.</p>

<h3>메모리 초기화</h3>

<p>지금은 메모리의 크기를 얻기 위해서 인터럽트를 사용한다. 이 때 인터럽트 번호는 <code>0x15</code>번이고 함수 번호는 <code>0x88</code>번이다. 이 때 반환되는 값은 실제 물리 메모리의 크기에서 1024를 뺀 값으로 단위는 kB이다. loader에서는 여기에 1024를 더해서 실제 물리 메모리의 크기를 얻는다. 하지만 Pintos는 이미 64MB 메모리 용으로 4kB의 page를 갖는 page table를 작성해두었기 때문에 메모리의 64MB만을 사용하도록 설정한다.</p>

<p>그리고 Page Table Entries와 Page Directory Entries를 초기화 하여 기초적인 page table를 구성한다. 이는 기본적인 virtual memory를 위한 page table를 구성하고, 32bit로 전환한 뒤에 loader를 메모리의 커널 영역인 <code>0xC0007C00</code>으로 취급해서 수행하게 하기 위함이다. 32bit 모드에서는 메모리 주소를 가리킬 수 있는 레지스터의 크기도 32bit가 되므로 실제로 사상될 수 있는 메모리의 크기는 최대 2<sup>32인</sup> 4GB이다. 보통 운영 체제는 이 중에서 0xC0000000 ~ 0xFFFFFFFF인 1GB를 커널 영역으로 사용한다.</p>
<div class="highlight"><pre><code class="c language-c" data-lang="c"><span class="n">loader</span><span class="p">.</span><span class="n">h</span>
 <span class="mi">11</span> <span class="cm">/* Kernel virtual address at which all physical memory is mapped.</span>
<span class="cm"> 12</span>
<span class="cm"> 13    The loader maps the 4 MB at the bottom of physical memory to</span>
<span class="cm"> 14    this virtual base address.  Later, paging_init() adds the rest</span>
<span class="cm"> 15    of physical memory to the mapping.</span>
<span class="cm"> 16</span>
<span class="cm"> 17    This must be aligned on a 4 MB boundary. */</span>
 <span class="mi">18</span> <span class="err">#</span><span class="n">define</span> <span class="n">LOADER_PHYS_BASE</span> <span class="mh">0xc0000000</span>     <span class="cm">/* 3 GB. */</span>
</code></pre></div>
<p>위의 주석에서 언급되어 있듯이 물론 page의 초기화는 kernel에서 이루어져야 하지만 16bit에서 32bit로 전환되면서 보호 모드로 바뀌었기 때문에 일단은 기초적인 page 테이블이라도 구성해서 loader를 0x7C00으로 바로 접근하는게 아니라 <code>LOADER_PHYS_BASE</code>를 더한 <code>0xC000007C00</code>의 가상 주소로 접근한다는 것이다.</p>

<p>수행 bit 모드가 바뀌었으니 다시 segment를 초기화한다. 그리고 이제부터 이미지 내에 존재하는 KELNEL 코드를 메모리의 <code>LOADER_PHYS_BASE + LOADER_KERN_BASE (0x00100000)</code>에 적재한다.</p>

<p><code>loader.S</code>의 코드를 보면 약 245줄부터 IDE Controller를 이용하여 <code>$KERNEL_LOAD_PAGES * 8 + 1</code> 개수만큼 읽는 것으로 추정되지만 <code>$KERNEL_LOAD_PAGE</code>의 값과 읽기 시작하는 섹터의 정보를 정확히 찾지 못했다. 아무튼 커널을 다 읽어서 메모리에 올려놓으면 커널 코드를 수행하기 위해 jump를 한다.</p>
<div class="highlight"><pre><code class="asm language-asm" data-lang="asm"><span class="nf">loader.S</span>
<span class="err">296</span> <span class="c">#### Jump to kernel entry point.</span>
<span class="err">297</span>
<span class="err">298</span>     <span class="nf">movl</span> <span class="no">$LOADER_PHYS_BASE</span> <span class="err">+</span> <span class="no">LOADER_KERN_BASE</span><span class="p">,</span> <span class="nv">%eax</span>
<span class="err">299</span>     <span class="nf">call</span> <span class="p">*</span><span class="nv">%eax</span>
<span class="err">300</span>     <span class="nf">jmp</span> <span class="no">panic</span>
</code></pre></div>
<p>만약 무슨 이유에서든지 커널이 메모리에 제대로 올라가지 않았거나하여 call 문이 실패하게 될 경우에는 바로 커널 패닉을 맛 볼 수 있도록 panic으로 jump를 한다.</p>

<h3>진입점 이동</h3>

<p>jump로 <code>init.c</code>의 main로 바로 이동하는 것은 아니다. 이 main함수는 gcc에 의해 컴파일되면서 그 함수의 entry가 어디에 존재할지는 디어셈블리한 후에 여러 복잡한 계산을 해보기 전에는 모르기 때문에 일단 loader의 call에 의해 호출되는 지점의 코드는 어셈블리로 한 번 더 짜고(<code>start.S</code>) 그 내부에서 main을 호출하는 구조를 이루고 있다.</p>

<p><code>loader.S</code>에서는 main을 호출할 수 없는데 <code>start.S</code>에서는 main을 그 symbol로 호출할 수 있는 이유는 빌드 과정에 있다. <code>loader.S</code>는 부트 섹터, 즉 첫 번째 기록되는 코드로써 혼자 따로 어셈블되어 0 ~ 511bytes의 위치에 기록되고, 나머지는 모두 커널 이미지라는 것으로 묶이는데 이 때 linker script인 <code>kernel.lds.S</code>에 의해 <code>init.c</code>의 <code>main()</code> 함수의 위치를 <code>start.S</code>가 알 수 있게 하여 <code>start.S</code>에서는 main으로 함수를 호출할 수 있게 되는 것이다.</p>
<div class="highlight"><pre><code class="asm language-asm" data-lang="asm"><span class="nf">start.S</span>
  <span class="err">9</span> <span class="na">.globl</span> <span class="no">start</span>
 <span class="err">10</span> <span class="na">.func</span> <span class="no">start</span>
 <span class="err">11</span>     <span class="c"># Call main.</span>
 <span class="err">12</span> <span class="nl">start:</span>  <span class="nf">call</span> <span class="no">main</span>
 <span class="err">13</span>
 <span class="err">14</span>     <span class="c"># main() should not return, but if it does, spin.</span>
 <span class="err">15</span> <span class="err">1:</span>  <span class="nf">jmp</span> <span class="mi">1</span><span class="no">b</span>
 <span class="err">16</span> <span class="na">.endfunc</span>
</code></pre></div>
<p>코드에서 볼 수 있듯이 12번 행에서 <code>call main</code>을 수행하고 있다. 그리고 어떤 이유에서든지 <code>main()</code> 함수가 종료된다면 15번 행의 무한 반복이 실행되어 절대 다른 지점으로 넘어갈 수 없도록 한다. 왜냐하면 <code>start.S</code> 뒤에 있는 것은 커널 이미지 빌드 과정에서 합쳐지는 어딘가의 소스 코드이거나 데이터 코드일 것이며, 만약 여기서 멈추지 않는다면 그 알 수 없는 코드들을 CPU는 모두 읽어서 처리하게 될 것이기 때문이다.</p>

<p>이제 <code>main()</code> 함수가 수행된다. <code>main()</code> 함수부터는 너무 깊게 들어가지 않고 가볍게 설명할 것이다.</p>

<h3>커널 초기화</h3>

<p>c 코드로 구성된 <code>init.c</code>의 <code>main()</code> 함수가 실제 커널의 초기화와 수행을 맡는 코드이다. 일단 <code>ram_init()</code> 함수를 호출하여 BSS segment를 초기화 하고 page의 개수를 <code>ram_pages</code> 변수에 넣는다. page의 개수는 <code>loader.S</code>에서 페이지 테이블을 구성하기 위해 열심히 계산했었다.</p>

<p>그 다음에 <code>read_command_line()</code> 함수를 사용하여 kernel 실행 인자를 받는다. 일단 pintos 구동 시 입력 받는 인자를 부트 섹터의 <code>arg_cnt:</code>와 <code>args:</code>에 넣어둔 뒤에 kernel에서 이 위치에 있는 인자를 가져오는 방식이다.</p>
<div class="highlight"><pre><code class="asm language-asm" data-lang="asm"><span class="nf">loader.S</span>
<span class="err">336</span> <span class="c">#### Command-line arguments and their count.</span>
<span class="err">337</span> <span class="c">#### This is written by the `pintos&#39; utility and read by the kernel.</span>
<span class="err">338</span> <span class="c">#### The loader itself does not do anything with the command line.</span>
<span class="err">339</span>     <span class="na">.org</span> <span class="no">LOADER_ARG_CNT</span> <span class="p">-</span> <span class="no">LOADER_BASE</span>
<span class="err">340</span> <span class="nl">arg_cnt:</span>
<span class="err">341</span>     <span class="na">.long</span> <span class="mi">0</span>
<span class="err">342</span>     <span class="na">.org</span> <span class="no">LOADER_ARGS</span> <span class="p">-</span> <span class="no">LOADER_BASE</span>
<span class="err">343</span> <span class="nl">args:</span>
<span class="err">344</span>     <span class="na">.fill</span> <span class="mi">0x80</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
</code></pre></div>
<p>예를 들어 <code>pintos -v -- run alarm-multiple</code>을 수행할 경우 run과 alarm-multiple이 실행 인자가 되어 메모리의 저 영역에 올라가게 되고 <code>init.c</code>의 <code>main()</code>에서 이 값을 읽어서 처리하게 된다는 것이다.</p>

<p>그 다음에 <code>parse_options()</code> 함수에서 옵션을 분석한다. 이 커널은 몇 가지 옵션을 갖고 있는데 <code>-h</code> 옵션으로 해당 옵션에 대한 설명을 볼 수 있다(<code>init.c</code>의 334줄). 대표적인 옵션으로 <code>-q</code>를 주면 지정된 동작이 끝난 후 바로 커널의 수행을 종료(power off)한다.</p>
<div class="highlight"><pre><code class="sh language-sh" data-lang="sh"><span class="nv">$ </span>pintos -v -- -q run alarm-multiple
</code></pre></div>
<p>그 다음에 <code>thread_init()</code> 함수를 호출하여 lock를 활성화시키고 대기 큐(ready_list)를 초기화한다. 그리고 현재 작동하고 있는 <code>ESP</code>를 기준으로 가장 근처에 있는 page를 찾아서 그 주소를 기준으로 thread 정보를 설정한다. 이 thread의 이름은 main으로 <code>initial_thread</code>가 된다. 그 후에 <code>console_init()</code>를 통해 console에 lock을 초기화한다. 이제부터 console를 사용할 수 있으므로 <code>printf</code> 함수를 사용할 수 있다.</p>

<p><code>printf</code>로 메모리의 크기를 출력한 후에 <code>palloc_init()</code>, <code>malloc_init()</code>, <code>paging_init()</code> 함수를 차례로 수행하여 메모리를 초기화한다. <code>palloc_init</code>는 이름 그대로 page를 allocate하는 작업을 수행할 수 있도록 초기화하는 것이고, <code>malloc_init</code>는 <code>malloc</code>을 통한 메모리 할당을 수행하기 위해 초기화를 수행하는 것이다.</p>

<p><code>paging_init()</code> 함수에서는 <code>loader.S</code>에서 구성했던 page table을 다시 구성하는 것이다. page table이란 메모리를 page로 관리하게 되면서 생긴 각 page에 대한 index를 갖고 있는 table인데 관리할 메모리가 커져감에 따라 page table도 같이 커져서 이 table을 관리할 또 다른 table이 필요했는데 그것이 page directory이다. 이 함수에서는 PD와 PE를 다시 구성한다.</p>

<p>그 다음에 다시 또 segment 설정을 수행한다. 먼저 <code>tss_init()</code>을 통해 task state segment를 설정하는데, 이는 커널이 task를 관리할 때 필요한 정보가 들어있는 segment이다. 그리고 <code>gdt_init()</code>를 통해 global description table을 초기화 한다. gdt 역시 task를 관리하는데 필요한 정보가 들어있는데 주로 메모리 보호나 segment 관련된 내용이다. <code>gdt_init()</code>에서는 kernel과 user의 code/data segment를 초기화하여 gdt를 구성한다. 여기서 segment privilege를 설정할 수 있다. 이는 해당 segement에 존재하는 기계어가 CPU의 중요한, 즉 다른 프로그램에 영향을 미칠 수 있는 코드를 수행할 수 있느냐에 대한 권한이다.</p>

<h3>인터럽트 초기화</h3>

<p>그 다음에 interrupt를 초기화한다. <code>먼저 intr_init()</code> 함수를 호출해서 PIC(programmable interrupt controller)를 초기화한다. 이 PIC는 interrupt 장치에 연결되어 CPU에게 interrupt 신호를 보내주는 장치이다. 그리고 interrupt descriptor table인 idt를 초기화한다. 이 table에는 interrupt를 handling하는 handler 함수들이 연결되는데 지금은 일단 깨끗이 초기화한다. 그리고 덤으로 0번부터 19번까지의 interrupt 이름을 초기화하는데 이는 CPU가 운영 체제, 즉 커널에게 전달하는 interrupt이다.</p>

<p>PIC에 의해 전달되는 interrupt도 0번부터 시작하지만 <code>0x00</code>부터 <code>0x19</code>까지는 CPU가 커널에게 전달하기 위한 interrupt로 사용하고 그 이후부터가 PIC에 의한 interrupt가 된다. 대표적인 예로 조금 있다 보게 될 keyboard의 interrupt 번호는 <code>0x21</code>이다.<br>
interrupt table을 초기화했으므로 이제 각 interrupt에 대해 handler를 연결한다. 먼저 이번 과제의 예제로 주어진 thread에서도 사용되는 timer를 먼저 초기화한다. timer는 PIC <code>0x00</code>번으로 <code>timer_init()</code>에서 초기화를 한다. 함수 내부에서 보면 <code>intr_register_ext()</code> 함수를 이용하여 <code>0x20</code>에 <code>timer_interrupt()</code> 함수를 연결하는 것을 확인할 수 있다.</p>
<div class="highlight"><pre><code class="c language-c" data-lang="c"><span class="n">timer</span><span class="p">.</span><span class="n">c</span>
<span class="mi">46</span>   <span class="n">intr_register_ext</span> <span class="p">(</span><span class="mh">0x20</span><span class="p">,</span> <span class="n">timer_interrupt</span><span class="p">,</span> <span class="s">&quot;8254 Timer&quot;</span><span class="p">);</span>
</code></pre></div>
<p>그리고 동일한 방법으로 <code>kbd_init()</code>에서는 keyboard의 interrupt를 초기화한다. 아직은 사용하지 않지만 keyboard로부터 입력받은 interrupt는 interrupt queue에 넣어졌다가 interrupt를 처리하는 thread에 의해 처리되는데 이러한 동작을 수행하는 모듈이 input이다. 일단 <code>input_init()</code> 함수를 호출하여 초기화한다.</p>

<p>그리고 <code>exception_init()</code> 함수를 수행하여 아까 <code>intr_init()</code>에서 작성해두었던 <code>0x00</code> ~ <code>0x13</code>까지의 interrupt를 연결한다. 연결되는 handler를 살펴보면 <code>exception.c</code>의 72번째 줄에 존재하는 <code>kill</code> 함수인데 친절하게도 왜 죽는지에 대해 설명해주고 죽는다. 주석을 보면 user program에 의해 process가 잘못된 수행을 했을 경우에 이 handler이 호출된다고 한다.</p>

<p>그 다음에 <code>syscall_init()</code> 함수를 통해 system call interrupt를 handling한다. 현재 handling하는 system call은 <code>0x30</code>번 interrupt인데 단순히 “system call!”을 출력하고 끝나는 system call이다.</p>

<p>이상으로 software interrupt(exception), hardware interrupt, system call에 대한 interrupt handler 초기화 및 설정을 마쳤다.</p>

<p>이제 설정한 interrupt를 동작시켜야 한다. interrupt를 받지 않으려는 노력은 <code>loader.S</code>의 맨 처음에서부터 시작하여 중간에 메모리 크기를 측정하고 커널 이미지를 메모리에 올리면서도 행해져 왔다. 이제 interrupt를 받도록 설정하기 위해서 일단 threads를 시작한다.</p>

<p><code>thread_start()</code> 함수는 가장 실행 우선 순위가 낮은 idle이라는 thread를 생성하여 동작시킨다. 그리고나서 <code>intr_enable()</code> 함수를 호출하여 interrupt를 활성화시키는데 그 이유는 idle에 있다. idle 함수는 일단 interrupt를 다시 disable시키고 thread를 block하여 다른 thread가 먼저 수행될 수 있도록 한다. 그 뒤에 다시 활동하게 되면 바로 inline assembly인 <code>sti; hlt</code>를 수행하게 되는데 이는 interrupt를 다시 enable하고 바로 정지하겠다는 것이다. hlt instruction은 CPU가 interrupt를 받을 때까지 대기시키는 instruction이다.</p>
<div class="highlight"><pre><code class="c language-c" data-lang="c"><span class="kr">thread</span><span class="p">.</span><span class="n">c</span>
<span class="mi">383</span>       <span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&quot;sti; hlt&quot;</span> <span class="o">:</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
</code></pre></div>
<h3>기타</h3>

<p>그 이후에 <code>serial_init_queue()</code> 함수를 통해 serial로부터 interrupt를 받아 커널을 제어할 수 있도록 한다. 이는 커널이 올라가 있는 장치에 keyboard로 바로 console를 통해 접속하는 것이 아니라 tty등의 serial interface로 접근했을 때도 커널이 반응할 수 있도록 하기 위함이다.</p>

<p>그 다음에 <code>timer_calibrate()</code> 함수에서 아까 설정한 timer interrupt에 의한 한 tick에 몇 번의 loop를 돌 수 있나 계산해서 전역 변수인 <code>loops_per_tick</code>에 넣어두고 이 값은 여러 <code>sleep()</code> 함수들의 동작을 실제로 수행하는 <code>real_time_sleep()</code> 함수에서 사용한다. 이 값을 사용하여 멈추기를 요구하는 시간을 근사한 loop 회수로 변환하여 <code>busy_wait()</code> 함수에서 지정된 회수만큼 반복문을 돌면서 대기한다.</p>

<p>그 밑의 <code>disk_init()</code>와 <code>filesys_init()</code>는 FILESYS가 있을 때 사용하는 함수로, 간단하게 설명하자면 <code>disk_init()</code> 함수에서는 커널에서 현재 연결된 storage를 검색해서 초기화하고, <code>filesys_init()</code>에서는 <code>disk_init()</code>에서 탐지하고 초기화한 disk를 가져와서 inode를 구성하거나 포맷을 수행한다.</p>

<p>마지막으로 <code>init.c</code>의 118번째 줄에서 <code>printf (&quot;Boot complete.\n&quot;)</code> 를 수행함으로써 pintos의 부팅이 완료된다.</p>

<h3>참고</h3>

<ul>
<li><a href="http://www.hanbit.co.kr/book/look.html?isbn=978-89-7914-482-6">OS 구조와 원리: OS 개발 30일 프로젝트</a></li>
<li><a href="http://www.hanbit.co.kr/book/look.html?isbn=89-7914-396-6">Windows 구조와 원리: OS를 관통하는 프로그래밍의 원리</a></li>
<li><a href="http://kangcom.com/sub/view.asp?sku=201207250002">리눅스 커널 심층 분석</a></li>
</ul>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
						
				<h1 class="page-title">pintos 환경 구축</h1>
				<p class="page-date">01 Apr 2008</p>
				<p class="page-tags">
						
						
					<code class="tag">os</code>
						
						
						
						
				</p>
				<div class="content"><p>Pintos를 구동시키기 위해서는 먼저 가상 에뮬레이터가 필요하다. Open source 중에 대표적으로 Bochs와 QEMU가 있는데, 설치법이 과제 문서에 기술되어있는 Bochs를 선택하여 설치하였다.</p>

<ul>
<li>Bochs는 Open Source 프로젝트로 Sourceforge에서 그 소스를 다운받아 컴파일하여 설치할 수 있다. 파일을 받기 위해서 Sourceforge에 lynx로 접속하여 bochs-2.3.tar.gz를 다운 받았다.</li>
<li>tar.gz 압축이므로 tar xvzf를 이용하여 압축을 풀었다.</li>
</ul>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash">~<span class="nv">$ </span>tar xvzf bochs-2.3.tar.gz
</code></pre></div>
<p>원격으로 터미널을 통해 진행할 예정이기 때문에 bochs가 terminal이 가능하고 gui가 없어도 동작할 수 있도록 컴파일해서 설치해야 했다. 따라서 configure 옵션에 <code>--with-term</code>과 <code>--with-nogui</code>를 주었다. 또 과제 문서에서 제시한 바와 같이 gdb debugging을 위해 <code>--enable-gdb-stub</code>을 옵션으로 주었다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash">~/bochs-2.3<span class="nv">$ </span>./configure --with-term --with-nogui --enable-gdb-stub
</code></pre></div>
<p>그 다음에 bochs를 make하고 설치하기 위해 make와 make install 명령을 수행했다. make install은 모든 사용자가 사용하는 전역 위치에 bochs를 설치하기 때문에 일반 사용자 권한으로는 설치가 안된다. 따라서 과제 문서가 제시한 대로 root 권한으로 설치를 수행하였다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash">~/bochs-2.3<span class="nv">$ </span>make<span class="p">;</span> sudo make install
</code></pre></div>
<p>bochs의 설치가 완료 되었다. 정상 동작을 확인하기 위해 <code>bochs --help</code>를 수행하였다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash">~/bochs-2.3<span class="nv">$ </span>bochs --help
<span class="o">========================================================================</span>
                        Bochs x86 Emulator 2.3
              Build from CVS snapshot on August 27, <span class="nv">2006</span>
<span class="o">========================================================================</span>
Usage: bochs <span class="o">[</span>flags<span class="o">]</span> <span class="o">[</span>bochsrc options<span class="o">]</span>

  -n               no configuration file
  -f configfile    specify configuration file
  -q               quick start <span class="o">(</span>skip configuration interface<span class="o">)</span>
  --help           display this <span class="nb">help </span>and <span class="nb">exit</span>

For information on Bochs configuration file arguments, see the
bochsrc section in the user documentation or the man page of bochsrc.
00000000000i<span class="o">[</span>CTRL <span class="o">]</span> quit_sim called with <span class="nb">exit </span>code 0
</code></pre></div>
<p>다음으로 pintos를 실행하기 위해 pintos를 다운로드 받았다. pintos는 구글 검색을 통해 다운로드 주소가 <a href="http://www.stanford.edu/class/cs140/projects/pintos/pintos.tar.gz">http://www.stanford.edu/class/cs140/projects/pintos/pintos.tar.gz</a>에 있음을 찾아내서 wget 명령으로 다운로드 받았다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash"><span class="nv">$ </span>wget http://www.stanford.edu/class/cs140/projects/pintos/pintos.tar.gz
</code></pre></div>
<p>역시 tar.gz 압축이므로 tar xvzf로 압축을 해제하였다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash"><span class="nv">$ </span>tar xvzf pintos.tar.gz
</code></pre></div>
<p>과제 문서에 제시된 대로 pintos/src/threads로 이동하여 make를 수행하였다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash"><span class="nv">$ </span><span class="nb">cd </span>pintos/src/threads
~/pintos/src/threads<span class="nv">$ </span>make
</code></pre></div>
<p>make 수행이 <code>undefined references to &#39;__stack_chk_fail&#39; follow</code>이라는 에러에 의해 중단되었다. 이를 해결하기 위해 구글을 검색하여 <a href="http://ubuntuforums.org/showthread.php?t=303541">다음의 레퍼런스</a>를 얻었다. 이 포럼에서 권고하는 대로 make 설정에서 CFLAGS의 값에 <code>-fno-stack-protector</code> 옵션을 추가해주기 위해 편집기 vi를 사용하여 Make.vars에 <code>CFLAGS += -fno-stack-protector</code>를 추가해 주었다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash">~/pintos/src/threads<span class="nv">$ </span>vi Make.vars
</code></pre></div>
<p>기존에 컴파일한 것들을 제거하기 위해 make clean을 수행한 후 make를 수행하여 빌드를 마쳤다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash">~/pintos/src/threads<span class="nv">$ </span>make clean
~/pintos/src/threads<span class="nv">$ </span>make
</code></pre></div>
<p>Pintos를 수행하기 전에 편의를 위해서 다음과 같은 alias를 작성하였다. 이 alias를 ~/.bashrc에 추가하여 bash이 열릴 때마다 alias가 자동으로 등록되도록 했다. 그리고 어디에서나 pintos가 실행될 수 있도록 pintos 실행 파일이 있는 곳을 PATH에 추가하였다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash">~/pintos/src/threads<span class="nv">$ </span>vi ~/.bashrc
</code></pre></div>
<p>추가한 내용은 아래와 같다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash"><span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="nv">$PATH</span>:~/pintos/src/utils/

<span class="nb">alias </span><span class="nv">pinv</span><span class="o">=</span><span class="s1">&#39;pintos -v -- run&#39;</span>
<span class="nb">alias </span><span class="nv">pint</span><span class="o">=</span><span class="s1">&#39;pintos -t -- run&#39;</span>

<span class="nb">alias </span><span class="nv">pinvg</span><span class="o">=</span><span class="s1">&#39;pintos --gdb -v -- run&#39;</span>
<span class="nb">alias </span><span class="nv">pintg</span><span class="o">=</span><span class="s1">&#39;pintos --gdb -t -- run&#39;</span>
</code></pre></div>
<p>추가한 내용을 적용시키기 위해서 source를 수행했다. 수행한 후, PATH가 적용되었는지 확인하기 위해서 설정된 PATH를 출력하도록 했다. 다음과 같이 추가된 것을 확인할 수 있었다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash">~/pintos/src/threads<span class="nv">$ </span><span class="nb">source</span> ~/.bashrc
~/pintos/src/threads<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$PATH</span>
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/home/lacti/pintos/src/utils
</code></pre></div>
<p>pintos를 수행하기 위해 threads의 build 디렉토리로 이동하였다. 미리 작성해둔 alias를 이용하여 간단하게 pintos threads를 구동하였다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash">~/pintos/src/threads/build<span class="nv">$ </span>pinv alarm-multiple
Writing <span class="nb">command </span>line to /tmp/w6Pkbt7Upa.dsk...
warning: can<span class="err">&#39;</span>t find squish-pty, so terminal input will fail
bochs –q
</code></pre></div>
<p>위의 alias에 정의되어 있듯이 <code>pinv alarm-multiple</code>을 수행했을 경우 실제 수행되는 명령어는 <code>pintos –v –- run alarm-multiple</code>이다.</p>

<p>결과는 제대로 나오지만 warning이 꺼림직했기 때문에 <code>squish-pty</code>를 빌드하기로 하였다. <code>~/pintos/src/utils</code>로 이동하여 make를 수행하였다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash">~/pintos/src/threads/build<span class="nv">$ </span><span class="nb">cd</span> ../../utils/
~/pintos/src/utils<span class="nv">$ </span>make
</code></pre></div>
<p><code>squish-pty</code>를 비롯한 몇 개의 파일들이 빌드되었고, 정상 작동함을 확인하기 위해 다시 pintos를 구동시켜보았다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash">~/pintos/src/utils<span class="nv">$ </span><span class="nb">cd</span> ../threads/build
~/pintos/src/threads/build<span class="nv">$ </span>pinv alarm-multiple
Writing <span class="nb">command </span>line to /tmp/UcIb0NhSWJ.dsk...
squish-pty bochs -q
<span class="o">========================================================================</span>
                        Bochs x86 Emulator 2.3
              Build from CVS snapshot on August 27, <span class="nv">2006</span>
<span class="o">========================================================================</span>
00000000000i<span class="o">[</span>     <span class="o">]</span> reading configuration from bochsrc.txt
00000000000i<span class="o">[</span>     <span class="o">]</span> installing nogui module as the Bochs GUI
00000000000i<span class="o">[</span>     <span class="o">]</span> using log file bochsout.txt
Kernel <span class="nb">command </span>line: run alarm-multiple
Pintos booting with 4,096 kB RAM...
375 pages available in kernel pool.
374 pages available in user pool.
Calibrating timer...  204,600 loops/s.
Boot complete.
Executing <span class="s1">&#39;alarm-multiple&#39;</span>:
<span class="o">(</span>alarm-multiple<span class="o">)</span> begin
<span class="o">(</span>alarm-multiple<span class="o">)</span> Creating 5 threads to sleep 7 <span class="nb">times </span>each.
<span class="o">(</span>alarm-multiple<span class="o">)</span> Thread 0 sleeps 10 ticks each <span class="nb">time</span>,
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 1 sleeps 20 ticks each <span class="nb">time</span>, and so on.
<span class="o">(</span>alarm-multiple<span class="o">)</span> If successful, product of iteration count and
<span class="o">(</span>alarm-multiple<span class="o">)</span> sleep duration will appear in nondescending order.
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 0: <span class="nv">duration</span><span class="o">=</span>10, <span class="nv">iteration</span><span class="o">=</span>1, <span class="nv">product</span><span class="o">=</span>10
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 0: <span class="nv">duration</span><span class="o">=</span>10, <span class="nv">iteration</span><span class="o">=</span>2, <span class="nv">product</span><span class="o">=</span>20
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 1: <span class="nv">duration</span><span class="o">=</span>20, <span class="nv">iteration</span><span class="o">=</span>1, <span class="nv">product</span><span class="o">=</span>20
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 0: <span class="nv">duration</span><span class="o">=</span>10, <span class="nv">iteration</span><span class="o">=</span>3, <span class="nv">product</span><span class="o">=</span>30
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 2: <span class="nv">duration</span><span class="o">=</span>30, <span class="nv">iteration</span><span class="o">=</span>1, <span class="nv">product</span><span class="o">=</span>30
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 0: <span class="nv">duration</span><span class="o">=</span>10, <span class="nv">iteration</span><span class="o">=</span>4, <span class="nv">product</span><span class="o">=</span>40
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 1: <span class="nv">duration</span><span class="o">=</span>20, <span class="nv">iteration</span><span class="o">=</span>2, <span class="nv">product</span><span class="o">=</span>40
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 3: <span class="nv">duration</span><span class="o">=</span>40, <span class="nv">iteration</span><span class="o">=</span>1, <span class="nv">product</span><span class="o">=</span>40
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 0: <span class="nv">duration</span><span class="o">=</span>10, <span class="nv">iteration</span><span class="o">=</span>5, <span class="nv">product</span><span class="o">=</span>50
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 4: <span class="nv">duration</span><span class="o">=</span>50, <span class="nv">iteration</span><span class="o">=</span>1, <span class="nv">product</span><span class="o">=</span>50
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 2: <span class="nv">duration</span><span class="o">=</span>30, <span class="nv">iteration</span><span class="o">=</span>2, <span class="nv">product</span><span class="o">=</span>60
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 0: <span class="nv">duration</span><span class="o">=</span>10, <span class="nv">iteration</span><span class="o">=</span>6, <span class="nv">product</span><span class="o">=</span>60
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 1: <span class="nv">duration</span><span class="o">=</span>20, <span class="nv">iteration</span><span class="o">=</span>3, <span class="nv">product</span><span class="o">=</span>60
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 0: <span class="nv">duration</span><span class="o">=</span>10, <span class="nv">iteration</span><span class="o">=</span>7, <span class="nv">product</span><span class="o">=</span>70
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 3: <span class="nv">duration</span><span class="o">=</span>40, <span class="nv">iteration</span><span class="o">=</span>2, <span class="nv">product</span><span class="o">=</span>80
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 1: <span class="nv">duration</span><span class="o">=</span>20, <span class="nv">iteration</span><span class="o">=</span>4, <span class="nv">product</span><span class="o">=</span>80
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 2: <span class="nv">duration</span><span class="o">=</span>30, <span class="nv">iteration</span><span class="o">=</span>3, <span class="nv">product</span><span class="o">=</span>90
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 4: <span class="nv">duration</span><span class="o">=</span>50, <span class="nv">iteration</span><span class="o">=</span>2, <span class="nv">product</span><span class="o">=</span>100
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 1: <span class="nv">duration</span><span class="o">=</span>20, <span class="nv">iteration</span><span class="o">=</span>5, <span class="nv">product</span><span class="o">=</span>100
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 1: <span class="nv">duration</span><span class="o">=</span>20, <span class="nv">iteration</span><span class="o">=</span>6, <span class="nv">product</span><span class="o">=</span>120
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 2: <span class="nv">duration</span><span class="o">=</span>30, <span class="nv">iteration</span><span class="o">=</span>4, <span class="nv">product</span><span class="o">=</span>120
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 3: <span class="nv">duration</span><span class="o">=</span>40, <span class="nv">iteration</span><span class="o">=</span>3, <span class="nv">product</span><span class="o">=</span>120
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 1: <span class="nv">duration</span><span class="o">=</span>20, <span class="nv">iteration</span><span class="o">=</span>7, <span class="nv">product</span><span class="o">=</span>140
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 4: <span class="nv">duration</span><span class="o">=</span>50, <span class="nv">iteration</span><span class="o">=</span>3, <span class="nv">product</span><span class="o">=</span>150
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 2: <span class="nv">duration</span><span class="o">=</span>30, <span class="nv">iteration</span><span class="o">=</span>5, <span class="nv">product</span><span class="o">=</span>150
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 3: <span class="nv">duration</span><span class="o">=</span>40, <span class="nv">iteration</span><span class="o">=</span>4, <span class="nv">product</span><span class="o">=</span>160
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 2: <span class="nv">duration</span><span class="o">=</span>30, <span class="nv">iteration</span><span class="o">=</span>6, <span class="nv">product</span><span class="o">=</span>180
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 4: <span class="nv">duration</span><span class="o">=</span>50, <span class="nv">iteration</span><span class="o">=</span>4, <span class="nv">product</span><span class="o">=</span>200
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 3: <span class="nv">duration</span><span class="o">=</span>40, <span class="nv">iteration</span><span class="o">=</span>5, <span class="nv">product</span><span class="o">=</span>200
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 2: <span class="nv">duration</span><span class="o">=</span>30, <span class="nv">iteration</span><span class="o">=</span>7, <span class="nv">product</span><span class="o">=</span>210
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 3: <span class="nv">duration</span><span class="o">=</span>40, <span class="nv">iteration</span><span class="o">=</span>6, <span class="nv">product</span><span class="o">=</span>240
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 4: <span class="nv">duration</span><span class="o">=</span>50, <span class="nv">iteration</span><span class="o">=</span>5, <span class="nv">product</span><span class="o">=</span>250
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 3: <span class="nv">duration</span><span class="o">=</span>40, <span class="nv">iteration</span><span class="o">=</span>7, <span class="nv">product</span><span class="o">=</span>280
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 4: <span class="nv">duration</span><span class="o">=</span>50, <span class="nv">iteration</span><span class="o">=</span>6, <span class="nv">product</span><span class="o">=</span>300
<span class="o">(</span>alarm-multiple<span class="o">)</span> thread 4: <span class="nv">duration</span><span class="o">=</span>50, <span class="nv">iteration</span><span class="o">=</span>7, <span class="nv">product</span><span class="o">=</span>350
<span class="o">(</span>alarm-multiple<span class="o">)</span> end
Execution of <span class="s1">&#39;alarm-multiple&#39;</span> complete.
</code></pre></div>
<p>위와 같이 정상 작동함을 확인할 수 있었다. 종료를 위해 Ctrl + C를 누르면 다음과 같이 interrupt를 받으며 종료된다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash"><span class="o">========================================================================</span>
Bochs is exiting with the following message:
<span class="o">[</span>     <span class="o">]</span> SIGNAL 2 <span class="nv">caught</span>
<span class="o">========================================================================</span>
</code></pre></div>
<p><code>pintos –t</code> 옵션을 사용하지 않고 <code>pintos –v</code> 옵션을 사용한 이유는 <code>pintos –t</code> 옵션을 사용하여 pintos를 구동시키게 되면 수행 후에 Ctrl + C로 interrupt를 걸어도 bochs가 수행을 종료하지 않고 메모리에 계속 남아있기 때문이다. 따라서 추가적으로 <code>kill -9</code> 등을 사용하여 종료해주어야 하므로 좀 더 편리한 <code>pintos –v</code> 옵션을 사용하였다. 물론 <code>pintos –t</code> 옵션을 사용하면 잠깐 지나가는 BIOS 화면을 볼 수 있다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash"><span class="nv">$ </span>ps -ef <span class="p">|</span>grep bochs
lacti    11939     1 99 02:19 pts/0    00:01:01 bochs -q
lacti    11941  3985  0 02:20 pts/0    00:00:00 grep bochs
</code></pre></div>
<p>다음 과정인 gdb를 수행하기 위해 gdb를 설치하였다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash">~<span class="nv">$ </span>sudo apt-get install gdb
</code></pre></div>
<p>PuTTY를 하나 더 켜서 pintos를 gdb모드로 실행시켰다. 글자를 조금이라도 적게 치기 위해서 이미 위에서 alias를 정의해 놓았다. v 옵션으로 gdb를 수행하므로 pinvg이다. 따라서 과제 문서에서 제시한 대로 alarm-multiple를 수행하려면 <code>pinvg alarm-multiple</code>이라고 하면 되고, 실제 명령은 <code>pintos –-gdb –v – run alarm-multiple</code>이다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash">~<span class="nv">$ </span><span class="nb">cd </span>pintos/src/threads/build/
~/pintos/src/threads/build<span class="nv">$ </span>pinvg alarm-multiple
</code></pre></div>
<p>그러면 다음과 같이 bochs가 gdb의 접속을 기다리며 수행을 멈춘다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash">~/pintos/src/threads/build<span class="nv">$ </span>pinvg alarm-multiple
Writing <span class="nb">command </span>line to /tmp/RArahIMk8f.dsk...
squish-pty bochs -q
<span class="o">========================================================================</span>
                        Bochs x86 Emulator 2.3
              Build from CVS snapshot on August 27, <span class="nv">2006</span>
<span class="o">========================================================================</span>
00000000000i<span class="o">[</span>     <span class="o">]</span> reading configuration from bochsrc.txt
00000000000i<span class="o">[</span>     <span class="o">]</span> Enabled gdbstub
00000000000i<span class="o">[</span>     <span class="o">]</span> installing nogui module as the Bochs GUI
00000000000i<span class="o">[</span>     <span class="o">]</span> using log file bochsout.txt
Waiting <span class="k">for </span>gdb connection on localhost:1234
</code></pre></div>
<p>다른 PuTTY에서 gdb를 켜서 원격 디버깅을 시작한다. 어차피 localhost이므로 <code>remote localhost:1234</code>로 연결하면 된다. 그러면 다음과 같이 접속이 이루어진다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash">~<span class="nv">$ </span>gdb
GNU gdb 6.6-debian
Copyright <span class="o">(</span>C<span class="o">)</span> 2006 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type <span class="s2">&quot;show copying&quot;</span> to see the conditions.
There is absolutely no warranty <span class="k">for </span>GDB.  Type <span class="s2">&quot;show warranty&quot;</span> <span class="k">for </span>details.
This GDB was configured as <span class="s2">&quot;i486-linux-gnu&quot;</span>.
<span class="o">(</span>gdb<span class="o">)</span> target remote localhost:1234
Remote debugging using localhost:1234
warning: unrecognized item <span class="s2">&quot;ENN&quot;</span> in <span class="s2">&quot;qSupported&quot;</span> response
0x0000fff0 in ?? <span class="o">()</span>
<span class="o">(</span>gdb<span class="o">)</span>
</code></pre></div>
<p>여기서 <code>continue</code> 명령인 <code>c</code>를 누르면 pintos가 계속 진행된다. Ctrl + C를 눌러서 수행을 중단할 수 있다. 그리고 <code>kill</code> 명령을 이용하여 debugging을 중단하고 pintos의 수행을 중단할 수 있다. gdb에서 작업을 끝내려면 <code>quit</code> 명령을 이용해서 나가면 된다.</p>

<p>다음과 같이 <code>kill</code> 명령으로 수행 중인 pintos를 종료할 수 있다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash"><span class="o">(</span>gdb<span class="o">)</span> c
Continuing.

Program received signal 0, Signal 0.
0xc0101660 in ?? <span class="o">()</span>
<span class="o">(</span>gdb<span class="o">)</span> <span class="nb">kill</span>
Kill the program being debugged? <span class="o">(</span>y or n<span class="o">)</span> y
<span class="o">(</span>gdb<span class="o">)</span>
</code></pre></div>
<p>그러면 pintos에서는 다음과 같이 Debugger의 종료 요청에 의한 종료를 수행하게 된다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash">Execution of <span class="s1">&#39;alarm-multiple&#39;</span> complete.
<span class="o">========================================================================</span>
Bochs is exiting with the following message:
<span class="o">[</span>     <span class="o">]</span> Debugger asked us to <span class="nv">quit</span>

<span class="o">========================================================================</span>
</code></pre></div></div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1><a id="tool" href="#tool">tool</a></h1>
				<hr />
				<div class="page-breaker"></div>
							
						
				<h1 class="page-title">ctags, cscope 설정 등 vim을 잘 써보자</h1>
				<p class="page-date">30 Nov 2012</p>
				<p class="page-tags">
						
						
					<code class="tag">tool</code>
						
						
						
						
				</p>
				<div class="content"><p>시스템 프로그래밍 수업 듣는 친구들이 vim을 써서 보다 빠르게 커널 탐색을 하는데 도움이 되었으면 해서 쓰는 글이지만 본인이 직접 정리하기는 귀찮으니 다음의 링크를 참조 바람 [...]</p>

<ul>
<li><a href="http://sosal.tistory.com/11">so_sal: 커널 분석기 Vi + ctags + cscope</a></li>
</ul>

<h3>search script</h3>

<p>추가로, 여러 파일에서 특정 내용을 찾는 좋은 shell script</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>
<span class="nb">echo</span> <span class="s2">&quot;- find --------&quot;</span>
<span class="nb">echo</span> <span class="nv">$1</span>
<span class="nb">echo</span> <span class="s2">&quot;---------------&quot;</span>
<span class="nb">echo</span>
find . -name <span class="s2">&quot;*.[chS]&quot;</span> -exec grep -Hn <span class="nv">$1</span> <span class="o">{}</span> <span class="se">\;</span>
find . -name <span class="s2">&quot;Make*&quot;</span> -exec grep -Hn <span class="nv">$1</span> <span class="o">{}</span> <span class="se">\;</span>
find . -name <span class="s2">&quot;*.inc&quot;</span> -exec grep -Hn <span class="nv">$1</span> <span class="o">{}</span> <span class="se">\;</span>
<span class="nb">echo</span> <span class="s2">&quot;---------------&quot;</span>
</code></pre></div>
<p>확장자가 c, h, S, inc 이거나 Make* 파일에 대해서 지정된 검색어가 있는지 검사한다.
<code>./search proc</code> 라고 치면 proc가 들어있는 파일들을 검색함.</p>

<h3>vim + ctags  대충 요약</h3>

<p>커널 소스 디렉토리에서 <code>ctags -R</code> 을 해서 tags 파일을 만든 뒤, 대충 .vimrc 파일에 다음을 추가하자. (vim이 열리는 위치마다 tags 파일을 만들면 귀찮으니 절대 경로로 tags 파일 경로를 지정해주는 것도 좋다.)</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash"><span class="nb">set </span><span class="nv">dictionary</span><span class="o">=</span>./tags,/usr/include/tags

<span class="s2">&quot;=============== ctags setting =================</span>
<span class="s2">set tags=./tags,/usr/include/tags</span>
<span class="s2">if version &gt;= 500</span>
<span class="s2">        func! Sts( )</span>
<span class="s2">                let st = expand(&quot;</span>&lt;cword&gt;<span class="s2">&quot;)</span>
<span class="s2">                exe &quot;</span>sts <span class="s2">&quot;.st</span>
<span class="s2">        endfunc</span>
<span class="s2">        nmap ,st :call Sts( )&lt;cr&gt;</span>

<span class="s2">        func! Tj( )</span>
<span class="s2">                let st = expand(&quot;</span>&lt;cword&gt;<span class="s2">&quot;)</span>
<span class="s2">                exe &quot;</span>tj <span class="s2">&quot;.st</span>
<span class="s2">        endfunc</span>
<span class="s2">        nmap ,tj :call Tj( )&lt;cr&gt;</span>
<span class="s2">endif</span>

<span class="s2">&quot;</span><span class="o">===============</span> man <span class="nv">setting</span> <span class="o">=================</span>
func! Man<span class="o">(</span> <span class="o">)</span>
    <span class="nb">let </span><span class="nv">sm</span> <span class="o">=</span> expand<span class="o">(</span><span class="s2">&quot;&lt;cword&gt;&quot;</span><span class="o">)</span>
    exe <span class="s2">&quot;!manc &quot;</span>.sm
endfunc
nmap K :call Man<span class="o">(</span> <span class="o">)</span>&lt;cr&gt;&lt;cr&gt;

<span class="s2">&quot;============= search setting ================</span>
<span class="s2">func! SearchKeyword()</span>
<span class="s2">        let sm = expand(&quot;</span>&lt;cword&gt;<span class="s2">&quot;)</span>
<span class="s2">        exe &quot;</span>!search <span class="err">&quot;</span>.sm
endfunc
nmap J :call SearchKeyword<span class="o">()</span>&lt;cr&gt;
</code></pre></div>
<p>이제 <code>,st</code> <code>,tj</code> 명령어로 tag jump가 가능한데 목록을 listing해서 창 분할해서 뛸거냐 아니면 현재 창에서 바로 이동할거냐를 고를 수 있다. (개인적으로는 창 분할해서 이동하는 <code>,st</code> 을 더 많이 썼다.)</p>

<p>그리고 manpages-dev를 설치했을 때, <code>K</code>를 누르면 해당 함수에 대한 manual을 바로 볼 수도 있고, 위에서 만들어놓은 search script와 연동해서 <code>J</code>를 누르면 해당 문자열 혹은 심볼을 포함한 파일들을 검색할 수도 있다.</p>

<p>cscope는 실행해보면 대충 알 수 있으니 잘 써보면 된다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">gdb 간단 사용법 정리</h1>
				<p class="page-date">01 Apr 2008</p>
				<p class="page-tags">
						
						
					<code class="tag">tool</code>
						
						
						
						
				</p>
				<div class="content"><p>GDB는 GNU Debugger의 약자로 console 디버거이다. console 디버거이므로 gdb는 gdb shell을 제공하고, 사용자는 그 shell에 명령을 입력함으로써 디버깅을 수행할 수 있다.</p>

<p>먼저 디버깅을 수행하기 위해서는 소스 코드를 컴파일할 때 디버깅 정보를 포함하도록 해야한다. gcc에서 이에 해당하는 옵션은 -g이다. 예를 들어 test.c라는 파일이 있다면 다음과 같이 수행하면 된다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash"><span class="nv">$ </span>gcc -g test.c
</code></pre></div>
<p>gdb에서 디버깅을 시작하는 방법은 두 가지가 있다. gdb 실행 시 디버깅할 파일을 입력하는 방법과 gdb 내에 들어가서 <code>file</code> 명령을 이용해 파일을 입력하는 방식이다.</p>

<p><code>$ gdb a.out</code> 혹은, <code>(gdb) file a.out</code></p>

<p><code>file</code> 명령은 symbol table를 불러와서 디버깅 준비를 하는 명령이다. 이와 헷갈릴 수 있는 명령으로는 <code>exec</code>가 있는데 이는 단순히 지정된 파일을 실행만 할 뿐 디버깅을 하지는 못한다.</p>

<p>gdb를 시작할 때 디버깅할 파일 이름을 입력하는게 편해보이지만 gdb 내부에서 <code>file</code> 명령을 이용하여 디버깅할 파일명을 입력할 때는 gdb의 shell에 의해 파일명을 자동 완성 해주기 때문에 더 편하다.</p>

<p>gdb shell이라는 것은 gdb를 실행하였을 때 (gdb)라는 prompt를 띄우며 사용자의 입력을 기다리고 있는 것을 지칭한다. 이 shell은 bash와 마찬가지로 tab키를 통한 자동 완성을 지원해주기 때문에 좀 더 편하게 디버깅을 수행할 수 있다. 게다가 뒤에서 언급할 이야기이지만 명령어의 축약형, ↑키를 통한 shell 명령 history-back 기능과 그리고 아무것도 입력하지 않고 return 키를 쳤을 때 방금 전에 수행한 명령을 다시 수행해주는 기능을 제공해 주기 때문에 좀 더 적은 타이핑typing으로 디버깅을 수행할 수 있도록 해준다.</p>

<p>symbol table을 읽어왔으니 프로그램의 수행을 시작해야 한다. 수행을 시작하는 명령어는 <code>run</code>이다. gdb는 명령어의 축약형이 존재하기 때문에 단순히 <code>r</code>로 실행할 수 있다. 만약 실행 인자를 주어야하는 경우에는 <code>r</code> 뒤에 작성하면 된다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash"><span class="o">(</span>gdb<span class="o">)</span> r arg0 arg1 arg2
</code></pre></div>
<p>아직 <code>breakpoints</code>를 설정하지 않았기 때문에 프로그램을 수행하면 그대로 수행을 마치고 종료해버린다. 따라서 <code>breakpoints</code>를 걸어주어야 하는데, 이 때 사용하는 명령어는 break이다. <code>b</code>로 축약하여 사용할 수 있다. <code>b</code> 뒤에는 여러 symbol이 올 수 있는데 기본적으로 줄 번호나 함수 이름을 사용할 수 있다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash"><span class="o">(</span>gdb<span class="o">)</span> b 37
<span class="o">(</span>gdb<span class="o">)</span> b main
</code></pre></div>
<p>gdb에서는 <code>list</code> 명령을 이용하여 소스를 볼 수 있다. 물론 <code>gcc -g</code> 옵션으로 컴파일을 수행한 c/c++ source 파일이 그 이름 그대로 그 위치에 존재하고 있어야 한다. 그렇지 않으면 source 파일을 찾을 수 없기 때문에 list를 보여줄 수 없다는 에러 메시지가 출력된다. 이 명령은 <code>l</code> 이라는 축약 명령을 갖는다. <code>l</code> 뒤에는 보고자하는 줄 번호가 올 수 있다. 줄 번호를 입력하지 않으면 소스를 처음 줄부터 10줄을 화면에 출력하고, 줄 번호를 입력할 경우에 그 줄 번호를 기준으로 위로 5줄, 지정한 줄, 아래로 4줄 해서 총 10줄을 보여준다.
그리고 <code>l</code>을 지속적으로 명령할 경우 현재까지 출력된 소스 코드 이후의 소스를 이어서 10줄씩 더 볼 수 있다. 이는 위에서 언급한 대로 <code>l</code>을 치지 않고 그냥 return 키를 쳐도 된다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash"><span class="o">(</span>gdb<span class="o">)</span> l
<span class="o">(</span>gdb<span class="o">)</span> l 15
</code></pre></div>
<p>breakpoint를 걸고 디버깅을 수행하면 해당 지점에서 break되고 gdb는 사용자의 명령을 기다리게 된다. 이 때 한 줄씩 진행하는 명령과 다시 동작을 재개하는 명령이 있다. 다시 동작을 재개하는 명령은 <code>continue</code>이다. 축약으로 <code>c</code>로 사용할 수 있는데 별다른 사항은 없고, 언급했듯이 단순히 break된 프로그램의 진행을 다시 수행하도록 한다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash"><span class="o">(</span>gdb<span class="o">)</span> c
</code></pre></div>
<p>한 줄씩 진행하는 명령은 두 가지 동작으로 나뉜다. 그것은 현재 수행할 명령 행의 특성에 따라 나뉘는데, 예를 들어 현재 수행할 명령이 함수 호출 명령일 때 해당 함수에 대한 symbol table이 있어서 jumping이 가능하면 그 내부의 진행 상황까지 디버깅할 수 있다. 이 경우 그 함수 내부로 진입(*step into*)하여 디버깅을 진행할 것인지, 아니면 그냥 지나쳐(*step over*) 갈 것인지 선택할 수 있다. 전자의 진입(step into)의 명령은 <code>step</code>이고, 축약은 <code>s</code>이다. 후자의 진행(step over)의 명령은 <code>next</code>이고 축약은 <code>n</code>이다. 두 명령 모두 뒤에 숫자를 입력하여 몇 개의 명령이나 진행할 것인지 지정할 수 있다.
이 명령 또한 <code>l</code>과 마찬가지로 처음에 한 번만 입력하고 그 다음부터는 그냥 return키만 입력하여 사용하는 경우가 많다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash"><span class="o">(</span>gdb<span class="o">)</span> s
<span class="o">(</span>gdb<span class="o">)</span> n 10
</code></pre></div>
<p>디버깅을 진행하다보면 내부에 존재하는 어떤 값을 출력해보고 싶을 때가 있다. 이 때 사용하는 명령은 <code>print</code>이다. 축약은 <code>p</code>이다. 이 때 <code>p</code> 뒤에는 출력하고자 하는 대상이 오면 된다. 함수를 입력하면 함수가 존재하는 메모리 주소가 나오고 symbol table에 함수가 있는 경우에는 함수의 인자가 추가로 더 나온다. 변수명을 입력하면 변수의 내용이 나온다. 만약 변수가 배열, 구조체나 객체인 경우에는 그 내부에 존재하는 원소나 멤버를 출력해준다.</p>

<p>또한 메모리 주소를 출력하기 위해 <code>&amp; 연산자</code>를 사용할 수 있고, 반대로 메모리 주소에 있는 내용을 출력하기 위해 <code>* 연산자</code>를 사용할 수 있다. 따라서 특정 변수의 메모리 주소를 보거나 메모리 주소 내에 존재하는 내용을 출력할 수 있다. 실제로 디버깅을 하다가 객체의 내용을 보고 싶을 때, class 내부에서 간단히 <code>print (*this)</code>를 사용하면 된다.</p>

<p>그리고 일반 수식도 지원하기 때문에 변수에 어떤 값을 연산한 결과 등도 출력이 가능하다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash"><span class="o">(</span>gdb<span class="o">)</span> p main
<span class="o">(</span>gdb<span class="o">)</span> p i
<span class="o">(</span>gdb<span class="o">)</span> p <span class="p">&amp;</span>i
<span class="o">(</span>gdb<span class="o">)</span> p *<span class="o">((</span>char*<span class="o">)</span>0x804834A<span class="o">)</span>
<span class="o">(</span>gdb<span class="o">)</span> p i * 21 - 2
</code></pre></div>
<p>다음으로 디버깅 도중에 존재하는 변수의 값을 변경하거나 디버깅에 사용되는 변수를 정의하는 <code>set</code> 명령이 있다. <code>s</code>는 <code>step</code> 명령의 축약이므로 <code>set</code> 명령은 축약이 존재하지 않는다. <code>set</code> 뒤에는 변수를 정의하기 위한 expression이 들어간다. 예를 들어 i 변수의 값을 11로 변경하고 싶으면 <code>set i = 11</code>을 수행하면 된다.</p>

<p>이를 응용하여 특정 메모리의 값도 변경할 수 있다. 이는 set 명령이 print 명령과 마찬가지로 <code>&amp;</code>와 <code>*</code>을 지원해주기 때문인데, <code>* 연산자</code>를 통해서 특정 위치의 메모리의 값을 변경할 수 있다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash"><span class="o">(</span>gdb<span class="o">)</span> <span class="nb">set </span><span class="nv">i</span> <span class="o">=</span> 11
<span class="o">(</span>gdb<span class="o">)</span> <span class="nb">set</span> *<span class="o">((</span>int*<span class="o">)</span>0xBFD8EB9B<span class="o">)</span> <span class="o">=</span> 23
</code></pre></div>
<p>그리고 디버깅에 사용되는 변수를 정의할 수도 있다. 프로그램 내에 존재하는 일반 변수와 구별하기 위해서 변수 이름 앞에 반드시 <code>$</code>를 붙여야 한다. 이러한 변수는 예를 들면 이중 포인터로 구성된 배열의 내용을 볼 때 사용할 수 있다. 다음과 같이 <code>$i</code>를 정의한 뒤 <code>print</code> 명령으로 배열의 첫번째 원소를 출력하게 하고, return 키를 계속 입력함으로써 이중 포인터로 구성된 배열의 내용을 살펴볼 수 있다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash"><span class="o">(</span>gdb<span class="o">)</span> <span class="nb">set</span> <span class="nv">$i</span> <span class="o">=</span> 0
<span class="o">(</span>gdb<span class="o">)</span> p env<span class="o">[</span><span class="nv">$i</span>++<span class="o">]</span>
</code></pre></div>
<p>그리고 지금까지 설정한 변수를 보려면 <code>show convience</code>를 수행하면 된다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash"><span class="o">(</span>gdb<span class="o">)</span> show convience
<span class="nv">$i</span> <span class="o">=</span> 3
</code></pre></div>
<p>break를 특정 소스의 지점에 거는 것이 아니라 변수 자체에 걸 수도 있다. 해당 변수를 watchpoints로 걸어두면 된다. 명령은 <code>watch</code>이며 뒤에는 expression이 들어간다. <code>watch</code>를 통해 watchpoints를 걸어두면 해당 변수의 값이 변할 때 break된다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash"><span class="o">(</span>gdb<span class="o">)</span> watch i
</code></pre></div>
<p><code>b</code>나 <code>watch</code>를 통해 breakpoints와 watchpoints를 보려면 <code>info</code>란 명령을 사용하면 된다. <code>info</code> 명령은 현재 디버깅에 대한 여러 정보를 보여주는 명령으로 그 축약은 <code>i</code>이다. <code>i</code>로 볼 수 있는 정보는 매우 많은데, 그 정보들의 목록을 보려면 그냥 <code>i</code>만 입력하고 return 키를 누르면 된다.</p>

<ul>
<li>대표적으로 많이 사용되는 <code>i</code> 명령은 위에서 언급한 breakpoints를 보는 <code>i breakpoints</code> 명령인데, 줄여서 <code>i b</code>로 가능하다.</li>
<li>또, <code>i line</code> 명령은 현재 디버깅하고 있는 위치를 출력해준다.</li>
<li><code>i program</code>은 수행되고 있는 프로그램의 process 정보를 보여준다.</li>
<li><code>i args</code>는 현재 호출된 함수로 넘어온 인자의 정보를,</li>
<li><code>i local</code>은 현재 함수에서 사용하는 지역 변수에 대한 정보를 출력한다.</li>
<li>등록한 watchpoints를 보기 위해서 <code>i watchpoints</code>를 수행해도 되지만 breakpoints와 watchpoints는 동일하게 취급되기 때문에 이왕이면 짧은 명령인 <code>i b</code>로 보는게 편하다.</li>
</ul>

<p>정리하면 다음과 같다.</p>

<table><thead>
<tr>
<th>명령</th>
<th>설명</th>
</tr>
</thead><tbody>
<tr>
<td>i b</td>
<td>등록된 breakpoints와 watchpoints를 본다.</td>
</tr>
<tr>
<td>i line</td>
<td>현재 디버깅하고 있는 위치 정보를 본다.</td>
</tr>
<tr>
<td>i program</td>
<td>현재 프로그램의 process 정보를 본다.</td>
</tr>
<tr>
<td>i args</td>
<td>현재 함수로 넘어온 인자의 정보를 본다.</td>
</tr>
<tr>
<td>i local</td>
<td>현재 함수의 지역 변수를 본다.</td>
</tr>
</tbody></table>

<p>정의한 breakpoints와 watchpoints를 제거하려면 <code>clear</code> 명령과 <code>delete</code> 명령을 사용해야한다. <code>clear</code> 명령은 특정 symbol에 걸려있는 breakpoints나 watchpoints를 제거하는 것으로 뒤에 변수명이나 함수명이 올 수 있다. 반면에 <code>delete</code>는 제거하고자 하는 breakpoint number를 입력해서 제거할 수 있다.</p>

<p>breakpoint number는 gdb 구동시 0부터 시작하여 breakpoints나 watchpoints를 설정할 때 자동으로 1씩 증가하는 값이다. 이 번호는 breakpoints를 설정할 때 볼 수 있고, 또 <code>i b</code>명령을 통해서도 볼 수 있다. <code>delete</code>의 축약 명령은 <code>d</code>로, <code>d</code> 뒤에 number를 입력함으로써 해당 번호의 breakpoints를 제거할 수도 있고, 그냥 <code>d</code>만을 명령함으로써 현재 설정된 모든 breakpoints를 제거할 수도 있다.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash"><span class="o">(</span>gdb<span class="o">)</span> clear main
<span class="o">(</span>gdb<span class="o">)</span> d 1
<span class="o">(</span>gdb<span class="o">)</span> d
</code></pre></div>
<p>지금까지 GDB의 기초 사용법에 대해 정리하였다. 지금까지 언급한 명령을 표로 정리하면 다음과 같다.</p>

<table><thead>
<tr>
<th>명령</th>
<th>인자</th>
<th>설명</th>
</tr>
</thead><tbody>
<tr>
<td>file</td>
<td>파일명</td>
<td>파일의 symbol table을 읽어온다.</td>
</tr>
<tr>
<td>r</td>
<td>[실행 인자]</td>
<td>프로그램을 실행한다.</td>
</tr>
<tr>
<td>b</td>
<td>함수, 줄 번호</td>
<td>breakpoints를 설정한다.</td>
</tr>
<tr>
<td>l</td>
<td>[줄 번호]</td>
<td>source 코드를 본다.</td>
</tr>
<tr>
<td>c</td>
<td>break</td>
<td>상태에서 다시 진행을 재개한다.</td>
</tr>
<tr>
<td>s</td>
<td>[진행할 행 수]</td>
<td>step into하며 진행한다.</td>
</tr>
<tr>
<td>n</td>
<td>[진행할 행 수]</td>
<td>step over하며 진행한다.</td>
</tr>
<tr>
<td>p</td>
<td>변수, 함수 등</td>
<td>지정된 변수의 값이나 함수의 주소를 출력한다.</td>
</tr>
<tr>
<td>set</td>
<td>변수 등</td>
<td>변수나 메모리의 값을 설정하거나 디버깅 변수를 설정한다.</td>
</tr>
<tr>
<td>watch</td>
<td>변수 등</td>
<td>watchpoints를 설정한다.</td>
</tr>
<tr>
<td>i</td>
<td>b, args 등</td>
<td>breakpoints나 인자 정보 등을 출력한다.</td>
</tr>
<tr>
<td>clear</td>
<td>변수, 함수</td>
<td>지정된 변수나 함수에 걸린 breakpoints나 watchpoints를 제거한다.</td>
</tr>
<tr>
<td>d</td>
<td>[bpnum]</td>
<td>지정된 breakpoint number의 breakpoint나 watchpoint를 제거한다.</td>
</tr>
</tbody></table>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1><a id="web" href="#web">web</a></h1>
				<hr />
				<div class="page-breaker"></div>
							
						
				<h1 class="page-title">github pages와 jekyll을 사용한 blog 만들기</h1>
				<p class="page-date">23 Jun 2014</p>
				<p class="page-tags">
						
						
					<code class="tag">web</code>
						
						
						
						
				</p>
				<div class="content"><p>본 글에서는 <a href="http://jekyllrb.com/">jekyll</a>과 <a href="http://travis-ci.org/">travis-ci</a>를 사용하여 <a href="http://pages.github.com/">github pages</a>에 publish하고, 이를 custom domain에 연결하여 blog를 구축하는 방법에 대해 서술한다.</p>

<p><a href="http://pages.github.com/">github pages</a>는 <a href="http://github.com/">github</a>에서 제공하는 cdn으로 static page를 서비스해주는 공간이다. github pages에 자세한 설명이 나와있지만 간단히 요약하면,</p>

<ul>
<li><em>{본인 id 혹은 그룹 id}.github.io</em> 라는 repository를 만들거나,</li>
<li>프로젝트 repository에 <em>gh-pages</em> 라는 브랜치를 만든 후,</li>
<li>뭔가의 파일을 올려놓으면 <strong>{...}.github.io</strong> 라는 주소로 접근이 가능하다는 것이다.</li>
</ul>

<p>따라서 저 공간에 html 파일을 올려놓는다면 static page를 제공할 수 있다. 따라서 블로그에 작성할 글들을 하나하나 html로 작성해서 위 repo에 push하면 블로그를 만들 수 있다는 것이다.</p>

<h3>static site generator</h3>

<p>글을 쓸 때마다 하나씩 html을 작성하는 것은 매우 번거로운 일이므로, site generator를 사용해보자. 본 글에서는 github pages에서 기본으로 제공해주는 <a href="http://jekyllrb.com/">jekyll</a>을 사용할 것이다.</p>

<ul>
<li><a href="http://jekyllrb.com/">jekyll</a> 페이지의 안내에 따라 설치한 후, <code>jekyll new my-blog</code> 명령을 사용하여 기본 골격을 만들어보자.</li>
<li>이제 <code>_posts</code> 디렉토리에 적절한 형태(markdown, textile, text, ...)로 글을 작성한 후</li>
<li><code>jekyll serve</code> 명령으로 서버를 띄우고 작성한 글이 제대로 나오는지 보면 된다.</li>
</ul>

<p>위 과정까지 진행했다면 <code>_sites</code>라는 디렉토리에 생성된 결과물이 모여있는 것을 볼 수 있다. 저 파일들을 아까의 repo에 올려서 블로그를 운영할 수도 있겠지만 <strong>github pages는 기본으로 jekyll을 지원하므로</strong> 번거롭게 매번 <code>_sites</code>를 만들어 파일을 올릴 필요없이 <code>jekyll new</code>로 만들어진 파일들을 올려놓으면 된다.</p>

<ul>
<li>즉, <code>jekyll new</code>로 만들어진 파일들을 repo에 push해놓고,</li>
<li><code>_posts</code>에 글을 쓴 후 push하면 블로그를 운영할 수 있다는 것이다.</li>
</ul>

<p>개인적으로는 <a href="https://help.github.com/articles/github-flavored-markdown">gfm</a>을 좋아하기 때문에 markdown으로 글을 작성한다.</p>

<h3>custom domain</h3>

<p>기왕 만든 블로그니 도메인도 멋지게 연결해주고 싶을 수 있다. 이에 대한 설명은 <a href="https://help.github.com/articles/setting-up-a-custom-domain-with-github-pages">Setting up a custom domain with github pages</a>에 잘 나와있다. 이에 대해 요약하면,</p>

<p>위 repo에 CNAME 파일을 만들어 도메인을 기록한다. 예를 들면 <code>lacti.me</code>와 같이 적은 파일을 push해준다.</p>

<p><code>lacti.me</code>처럼 subdomain이 아니라 apex domain일 경우에는 <em>A 레코드 설정</em>을 해준다.</p>

<ul>
<li><a href="http://dotname.co.kr/">dotname</a>일 경우에는 <code>도메인 레코드 관리</code>에 들어가 <code>A 레코드 설정</code>에 ip를 추가해주면 된다.</li>
<li><a href="http://kr.dnsever.com/">dnsever</a>일 경우에는 <code>호스트 IP(A) 관리</code>에 들어가 ip를 추가해주면 된다.</li>
<li>이 때 www는 github pages에서 redirect를 해주므로 subdomain 입력 없이 ip만 입력하고 추가를 해주면 된다.</li>
<li>추가할 ip 주소는 현재 <code>192.30.252.153</code>, <code>192.30.252.154</code> 인데 이는 추후 변경될 수 있으므로 <a href="https://help.github.com/articles/tips-for-configuring-an-a-record-with-your-dns-provider">Tips for configuring an a record with your dns provider</a> 페이지를 참고하는 것이 좋다.</li>
</ul>

<p><code>blog.lacti.me</code>처럼 subdomain일 경우에는 <em>CNAME 레코드 설정</em>을 해준다.</p>

<ul>
<li><a href="http://dotname.co.kr/">dotname</a>일 경우에는 <code>도메인 레코드 관리</code>에 들어가 <code>CNAME 레코드 설정</code>에 연결 주소를 추가해주면 된다.</li>
<li><a href="http://kr.dnsever.com/">dnsever</a>일 경우에는 <code>도메인 별명(CNAME) 관리</code>에 들어가 목적지 도메인을 추가해주면 된다.</li>
<li>추가할 주소는 <code>username.github.io</code>이다. 작업 후 dig 명령을 사용하여 제대로 연결되었는지 확인해볼 수 있다. 추후 변경될 수 있으므로 <a href="https://help.github.com/articles/tips-for-configuring-a-cname-record-with-your-dns-provider">Tips for configuring a cname record with your dns provider</a> 페이지를 참고하는 것이 좋다.</li>
</ul>

<p>그리고 dns가 반영될 때까지 시간이 좀 흐르면 연결한 도메인으로 해당 github pages를 접속해볼 수 있다.</p>

<h3>custom jekyll</h3>

<p>github #s에 내장된 jekyll은 보안적인 이슈로 인해 plugin을 사용할 수가 없다. <a href="https://github.com/jekyll/jekyll/issues/325">참고</a></p>

<p>jekyll의 기본 기능은 좀 부족해서,</p>

<ul>
<li>liquid 태그를 추가한다던가,</li>
<li>related_posts를 개선한다던가,</li>
<li>pandoc converter 등을 사용한다던가,</li>
</ul>

<p>하는 이슈가 발생하게 된다. 이 부분을 개선하려면 plugin을 사용해야 하므로 github pages의 내장 jekyll 대신 <a href="http://travis-ci.org/">travis-ci</a>를 통한 <code>_sites</code>를 deploy하는 방법을 사용할 것이다.</p>

<p>방법은 다음과 같다.</p>

<ul>
<li><em>{...}.github.io</em> repo에서 글을 올릴 브랜치를 만든다. 이 글에서는 이를 <code>source</code> 브랜치라고 칭하겠다. 따라서 해당 repo의 <code>master</code> 브랜치에는 jekyll이 생성한 결과물이 push될 것이다.</li>
<li><a href="http://travis-ci.org/">travis-ci</a>를 사용하여 repo의 <code>source</code> 브랜치가 변경되었을 때 이를 <code>jekyll build</code>하여 그 결과물을 <code>master</code> 브랜치에 push할 것이다.</li>
</ul>

<p><code>source</code>, <code>master</code> 브랜치를 만드는 것은 어렵지 않다. 일단 첫 번째 난관은 <a href="http://travis-ci.org/">travis-ci</a>에 jekyll을 연결하는 것이다. 다행히도 <a href="https://github.com/mfenner/jekyll-travis">https://github.com/mfenner/jekyll-travis</a>에 jekyll-travis용 script가 있으니 이를 참고해서 설정을 하면 되겠다.</p>

<ul>
<li><code>.travis.yml</code> 파일에 push를 위한 secure token을 입력해야 한다. secure token을 만들어야 하니 다음을 참고. <a href="http://sleepycoders.blogspot.kr/2013/03/sharing-travis-ci-generated-files.html">Sharing travis ci generated files</a></li>
<li>secure token의 길이 제한은 128bytes이므로 암호화할 필요가 없는 변수들은 바깥으로 빼는 것이 좋다. <a href="https://github.com/lacti/lacti.github.io/blob/source/.travis.yml">lacti: .travis.yml</a></li>
<li>추가 package가 필요할 경우 <code>Gemfile</code>에다가 package 파일을 기록해주면 된다.</li>
</ul>

<p>필요한 설정을 다 했으니 <a href="http://travis-ci.org/">travis-ci</a>에 가서 위 repo를 연결해주면 되겠다. <code>master</code> 브랜치에 대한 작업은 할 필요가 없으니 <em>Build only if .travis.yml is present</em>을 켜주면 된다.</p>

<p>이제 <code>source</code> 브랜치의 <code>_posts</code>에 글을 commit하면 <a href="http://travis-ci.org/">travis-ci</a>가 이를 감지하여 <a href="http://jekyllrb.com/">jekyll</a>을 실행하고, 그 결과물을 <code>master</code> 브랜치로 push해줄 것이다.</p>

<h3>gem cache</h3>

<p>잘 돌아가는 것 같지만 한 가지 문제가 있다. github pages의 내장 jekyll을 쓸 때보다 글 반영 속도가 현격히 느리다는 것이다. 그 이유는 gem이 느리기 때문이다. travis-ci에서 한 cycle에 걸리는 시간을 보면 평균 2분 30초 가량이다. 이 때 약 1분 30초 이상을 <code>gem install</code> 구분에서 소모하고 있는 것을 볼 수 있다. 이를 개선하기 위해 <a href="https://github.com/mezis/rebund">rebund</a>를 사용한 gem cache를 만들어보자.</p>

<ul>
<li><a href="https://www.heroku.com/">heroku</a>에 <a href="https://github.com/mezis/keyfile">keyfile</a>을 올린다.</li>
<li><a href="https://github.com/mezis/rebund">rebund</a>를 <code>source</code> 브랜치에 submodule로 걸고 travis에서 <code>bundle install</code> 전후에 <code>rebund</code>를 사용하도록 한다. <a href="https://github.com/lacti/lacti.github.io/blob/source/.travis.yml">참고</a></li>
<li>gem의 변경 사항이 없다면 bundle install 시 local만 참조하도록 <code>bundle install --local</code>을 수행하게 한다.</li>
</ul>

<p><a href="https://github.com/mezis/keyfile">keyfile</a>과 <a href="https://github.com/mezis/rebund">rebund</a>의 설정 방식은 위 페이지의 README에 잘 나와있다. 약간 보충하면,</p>

<ul>
<li>keyfile 설치 시 <code>.env</code> 파일을 열어서 <code>database_url</code>을 변경해주어야 한다. 이 값은 <code>heroku config --app {appname}</code> 명령을 통해 확인할 수 있다. postgre 주소를 잘 입력해주면 된다.</li>
<li>rebund 연결 시 <code>REBUND_ENDPOINT</code> 값을 설정할 때 주소 마지막에 <code>/</code>이 붙으면 안 된다. 그걸 붙이면 잘못된 url이 만들어져서 curl 명령이 계속 실패한다.</li>
<li><code>bundle install --local</code>을 안하면 gem fetch가 지속적으로 이뤄지게 되고, 이 과정 역시 30~60초 정도 소모한다. 따라서 추가적인 gem이 필요없다면 한 번 cache한 이후에는 <code>--local</code> 옵션을 주는 것이 좋다.</li>
</ul>

<p>이를 적용하면 2분 30초 ~ 3분 걸리는 작업이 30초 ~ 50초가량으로 줄어들게 된다. 이제 글을 push한 후 1분 정도만 기다리면 해당 글이 블로그에 잘 올라가는 것을 확인할 수 있다.</p>

<h3>정리</h3>

<ul>
<li><a href="http://pages.github.com/">github pages</a>를 사용하여 작성한 글을 배포할 수 있다.</li>
<li><a href="http://jekyllrb.com/">jekyll</a>을 사용하면 보다 쉽게 사이트를 만들 수 있다.</li>
<li>jekyll 플러그인을 사용할 경우 <a href="http://travis-ci.org/">travis-ci</a>을 사용하자.</li>
<li>이 때 gem이 너무 느리다면 <a href="https://github.com/mezis/rebund">rebund</a>를 사용하자.</li>
</ul>

<h3>참고</h3>

<ul>
<li><a href="http://libsora.so/posts/static-blog-sample/">if1live: GitHub Pages와 travis-ci를 엮은 정적 블로그 자동화</a></li>
</ul>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
						
				<h1 class="page-title">웹 기반 채팅방</h1>
				<p class="page-date">14 Aug 2011</p>
				<p class="page-tags">
						
						
					<code class="tag">web</code>
						
						
						
						
				</p>
				<div class="content"><p>동아리에는 현재 대충 그지같이 만들어놓은 채팅방이 있다. <del>내가 만들었다 orz</del><br>
코드 라인별 분석은 당연히 의미가 없을 것 같고, 핵심적인 부분에 대해 간략히 이야기해보려고 한다.</p>

<p>채팅방을 만들기 위해서 고민해야할 것은 다음과 같다.
* 메세지 구조
* 동기화 방법</p>

<h3>동기, 비동기?</h3>

<p>웹 프로그래밍은 다른 네트워크 프로그래밍과 약간은 다르게, 서버와 클라이언트가 통신하는 메세지 구조에 대해 고민하지 않는 경우가 많다. 왜냐하면 어차피 웹 서버는 HTML을 만들어서 클라이언트에게 반환하면, 클라이언트는 이를 rendering해서 보여주기만 하니까.</p>

<p>하지만 Ajax라는게 나오고, 조금이나마 웹이란 세상에서도 메세지를 신경써야되는 시대가 왔다. 전체 페이지를 HTML로 다같이(동기적으로) 갱신하는게 아니라, 부분적 정보만을 요청하여 받은 데이터로 클라이언트 영역의 부분만을 갱신하는, 즉 전체 페이지가 각 영역별로 따로(비동기적으로) 갱신하는 구조가 된 것이다.</p>

<p>전자의 방식에서는 클라이언트 FORM 페이지에서 웹 서버로 데이터를 보내는 POST 단계와, 서버의 스크립트 언어로 FORM DATA를 처리한 후 다시 클라이언트에게 HTML을 보내주는 BACK 단계를 합쳐서 POSTBACK이란 용어가 나오게 되었다.</p>

<p>브라우저의 현재 URL 값을 변경하여 페이지 전체의 데이터를 보내는 경우에는 딱히 고민하지 않아도 될 것이 메세지 구조였다. 어차피 서버에서는 HTML을 반환시키면 그만이니까. 우리에게 친숙한 언어의 함수로보면 아래와 같다.</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">HTML</span> <span class="nf">process_in_server</span> <span class="p">(</span><span class="n">FORMDATA</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">make_html</span> <span class="p">(</span><span class="n">process_formdata</span> <span class="p">(</span><span class="n">data</span><span class="p">));</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">request_in_client</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">render_in_client</span> <span class="p">(</span><span class="n">process_in_server</span> <span class="p">(</span><span class="n">get_form_data</span> <span class="p">()));</span>
<span class="p">}</span>
</code></pre></div>
<p>그렇다면 비동기적인 방법으로 갱신하는 건 어떤 것일까?</p>
<div class="highlight"><pre><code class="cpp language-cpp" data-lang="cpp"><span class="n">MESSAGE</span> <span class="nf">process_in_server_async</span> <span class="p">(</span><span class="n">FORMDATA</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">make_message</span> <span class="p">(</span><span class="n">process_formdata</span> <span class="p">(</span><span class="n">data</span><span class="p">));</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">request_in_client</span> <span class="p">(</span><span class="n">UPDATEAREA</span> <span class="n">area</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">MESSAGE</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">process_in_server</span> <span class="p">(</span><span class="n">get_form_data</span> <span class="p">());</span>
    <span class="n">HTML</span> <span class="n">html</span> <span class="o">=</span> <span class="n">translate_message_result</span> <span class="p">(</span><span class="n">msg</span><span class="p">);</span>
    <span class="n">update_in_client_area</span> <span class="p">(</span><span class="n">html</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>서버의 코드는 크게 변한게 없다. 다만 HTML을 반환하는게 아니라 message 형식으로 반환한다는 것이다.</p>

<ul>
<li>Ajax(Asynchronous Javascript and XML)를 예를 들어본다면 이름에서 알 수 있듯이 message 형식을 XML으로도 할 수 있는 것이다.</li>
<li>아니면 요즘 대세인 작고 가벼운 JSON(Javascript Object Notation)을 쓰는 것도 하나의 방법이고,</li>
<li>직접 Serializer와 Deserializer(Parser)를 구현한다면 자신이 정의한 message 형식으로 반환해도 된다.</li>
<li>아예 서버 쪽에서 비동기 요청에 대해 HTML을 만들어서 반환하면, 클라이언트에서는 그 HTML을 바로 특정 영역(update area)에 반영시켜도 좋을 것이다.</li>
</ul>

<p>요약하면,</p>

<ul>
<li>동기적 갱신에 대해 클라이언트는 어차피 전체 페이지가 모두 변경되니 변경될 지역을 신경 쓸 필요가 없지만,</li>
<li>비동기적 갱신에 대해서는 갱신해야할 부분을 지정해서, 서버가 반환한 값으로부터 HTML 을 구성하여 직접 갱신해주어야 하는 작업이 추가적으로 필요하다는 것.</li>
</ul>

<p>따라서 전자의 방식이 단순 Server-Side 프로그래밍만으로 해결될 문제라면, 후자의 방식은 클라이언트에서 화면 갱신을 위한 코드가 필요하기 때문에 Client-Side 프로그래밍이 반드시 필요하다는 것이다.</p>

<h3>ajax를 왜 쓸까?</h3>

<p>데이터 통신량이 아까워서 하는 것도 맞기는 한데, 데스크탑의 wired 환경에서는 정답은 아닌 것 같다.</p>

<p>전체 화면을 100이라고 했을 때 특정 동작으로 갱신되어야 하는 화면이 대략 10 정도만을 차지한다고 하자. 그 요청을 할 때마다 화면이 전체 갱신되어 깜빡거린다면 사용자로써는 그 대기 시간 기다리는 것도 짜증나고 여러 모로 좋지 않은 경험을 하게 될 것이다. 따라서 보다 미려한 환경을 구축하기 위해 쓴다고 보면 되겠다.</p>

<p><span style="color: #888;">덕분에 페이지에 Ajax 방법을 도입할 때는 신경써줘야 할 것들이 무지하게 많아지지만 본 글의 목적에서 벗어나므로 이 글에서 서술하지는 않겠다.</span></p>

<p>메세지 구조에는 XML과 JSON이 있다고 하자. <del>다른 것도 많겠지만 생각하기 귀찮으니까.</del>
* XML은 사실상(defecto) 업계상 표준이라고 한다. 따라서 다양한 플랫폼으로의 이식성을 고려한다면 XML을 쓰는게 좋을지도 모르겠지만, 다 옛날 말이 된 것 같다.
* 표기법이 간단하고 쓰기도 쉬운 JSON이 대세가 된 것 같다. JSON parser가 없는 플랫폼이 없을 정도고, 직접 Parser 만드는 것도 어렵지 않으니까.</p>

<p>웹 기반으로 채팅방을 구성함에 있어 가장 곤란한 것은 <strong>비동기 알림(Server Push)</strong>이다.<br>
위에서 동기네 비동기네 했던 이야기는 모두 클라이언트의 이야기.</p>

<p>웹은 그 구조상 클라이언트가 요청을 하면 서버가 그 결과를 반환하게 되어있다. HTTP 프로토콜 자체가 그리 구성되어있는 것이고, 보안상 내가 요청하지도 않았는데 서버가 알아서 알려줄 수도(비동기 알림) 없는 것이다. (그러면 서버가 클라이언트를 해킹하는 개념이 되겠지)</p>

<p>채팅의 경우는 네트워크 프로그래밍의 기초 예제로 많이 나온다. 클라이언트에서 서버로, 서버에서 클라이언트로 쌍방 데이터를 주고 받는 가장 간단한 구조이기 때문이다.</p>

<p>웹은 태생부터 저 구조에 부합되지 못한다. 클라이언트에서 서버로 요청하는 것은 문제가 없지만, 서버에서 클라이언트로 데이터를 보낼 방법이 없기 때문이다.<br>
(내가 채팅 메세지를 보낼 때만 요청 반환 값으로 다른 사람이 이야기한 것을 받아올 수 있다. 테트리스로 치자면, 내가 키를 누르기 전까지는 블록이 아래로 내려오지 않는 것과 같다)</p>

<p>이걸 해결하기 위한 가장 간단한 방법은,
1. 무한 새로고침 (동기적 해결법)
2. Ajax polling (비동기적 해결법)
3. long-held HTTP Request (<a href="http://en.wikipedia.org/wiki/Comet_%28programming%29">COMET</a>)
4. Web Socket</p>

<p>1번은 설명 안해도 알 것이고, 3, 4번은 여기서 설명할 내용은 아니다. 이 글에서는 2번에 대해서 설명하겠다.</p>

<h3>polling</h3>

<p>클라이언트에서 일정 시간 간격으로 서버에 ajax로 지속적인 요청을 한다. 서버는 해당 클라이언트가 갖고 있는 메세지 이후부터 새로 받은 메세지를 반환한다.<br>
(물론 웹 서버는 Stateless 하니까 SESSION 등으로 각 클라이언트를 식별할 정보를 잘 갖고 있어야겠다.)</p>

<p>사용자 A와 B가 있다. A는 B의 말을 들어주는 중이고, B는 열심히 지 할 말을 하고 있다.
* B 컴퓨터의 웹 클라이언트는 떠드는 메세지를 서버에게 지속적으로 보낼(Request) 것이다. 이 메세지들은 서버에 차곡차곡 쌓아놔야한다.
* 그리고 A 컴퓨터의 웹 클라이언트가 이걸 받아가야한다. 이왕이면 봤던 것 이후로, 즉 내가 읽은 것 말고, 그 다음부터 B 가 떠든 내용을 받아오고 싶을 것이다. 따라서 A 클라이언트는 서버에게 내가 아까 본 이후로 B 가 얼마나 떠들었나를 요청(Request) 할 것이고, 서버는 그에 대한 응답 메시지를 A 클라이언트에게 보내면 A 클라이언트는 그걸 받아서 화면을 갱신할 것이다.</p>

<p>서버가 클라이언트에게 비동기 알림이 안되니까 매번 클라이언트가 직접 물어보고 가져오는 건데, 그 동안 서버에 얼마나 데이터가 쌓일지 모르니까, <strong>서버는 클라이언트에게 보낼 데이터를 다 저장해두고 있어야 한다는 것.</strong>
이 부분이 이러한 방식의 프로그래밍을 어렵게 하는 요소다.</p>

<p>동아리 채팅방에서는 매우 단순 무식한 구조를 사용하고 있다.
1. 각 클라이언트가 채팅 메세지를 서버로 보내면 서버는 무조건 모든 데이터를 다 데이터베이스에 집어 넣는다.
2. 그리고 클라이언트가 서버에게 지금까지 쌓인 메세지를 보내달라고 요청하면, 그 데이터베이스에서 무조건 20개를 꺼내서 그걸 HTML 로 만들어서 반환한다. 그러면 클라이언트는 그 HTML 로 채팅 영역을 update 한다.</p>

<p>사람이 많이 들어오면 답이 없는 구조다. DB가 엄청난 병목 지점이 되기 때문이다.<br>
(물론 데이터베이스에서 해당 채팅 메세지를 저장하는 테이블을 Memory Table 로 작성해놨지만 그래도 느리다)</p>

<p>그리고 클라이언트가 항상 최근 20개를 받아와서 자기 영역을 갱신한다.
바꿔 말하면 채팅방에 아무런 대화가 없어도 클라이언트는 계속해서 채팅 영역을 교체(update) 하면서 CPU 를 소모한다는 것이다.<br>
(그나마 이 부분은 채팅 내용이 완전히 동일할 경우 클라이언트에서 교체하지 않도록 코드를 작성해놨지만, 그래도 네트워크 자원 소모는 지속적으로 이루어진다)</p>

<p>추후 누군가의 요청에 의해 동아리 친구가 스크롤바 기능을 구현해놨는데, 이게 메세지 구조를 뜯어 고친게 아니라 일단 서버로부터 20개를 HTML로 받아온 뒤 그걸 Parsing 해서 새로 추가된 부분만 채팅 영역에 삽입하는 방식으로 작성된 것이라 문제가 발생할 가능성이 많다.<br>
(자바 스크립트의 문자열 비교 기능이 개판인건 아닌데 여기에 htmlentities가 끼면 제대로 동등 비교가 안되어서 채팅방에 계속 중복된 메세지가 추가되는 경우가 있다.)</p>

<p>근본적으로 저 문제를 해결하려면 각 메세지에 <code>AUTO_INCREMENT</code>한 ID 값을 박아넣고, 요청할 때 최근에 받은 ID 값을 서버로 보내서 그 다음 데이터부터 받아와서 해당 영역에 추가(<code>appendChild</code>) 해주는 방법을 사용하면 될 것이다.</p>

<p>그런데 저 방법은 내가 해봤는데 지금 우리 채팅방에 쓰면 안 될거다. 제대로 확인은 안해봤지만 글을 동시에 대량으로 보낼 경우 ID 값이 꼬이는지 제대로 클라이언트간 동기화가 안 되었던 것으로 기억한다.</p>

<p>따라서 해당 ID 값에 보정치를 고려하여 클라이언트에서 JSON 형태로 메시지를 받아서 ID 값에 대해 현재 클라이언트에 없는 부분만 삽입해주는 방법으로 구현하면 제일 깔끔할 것이고,</p>

<p>현재 채팅방의 가장 고질적인 문제인, <em>계속 켜놓으면 메모리 점유율이 너무 높아진다</em>도 추가하는 채팅 로그 개수가 일정량이 넘어갔을 때 위에서부터 제거하면 해결될 문제다.</p>

<p>생각해보면, 채팅방을 Ajax 로 구현한다는 것 자체가 문제겠지.
당연히 WebSocket으로 개발하는게 맞겠지만 일부 브라우저 (특히 군대) 에서는 WebSocket 이 지원되지 않을 수 있기 때문에 WebSocket과 Ajax 방식 둘 다 유지해야한다는 이야기가 있어서 귀찮아서 그만 두었다.</p>

<p>게다가 WebSocket으로 작성하려면 WebSocket 서버와 웹 서버간의 SESSION 공유도 해주어야 하잖아?<br>
<a href="http://doodoori2.tistory.com/" title="Doodoori2&#39;s Blog">doodoori2</a>님의 이야기로는 데이터베이스에 SESSION을 넣어두고 WebSocket 서버에게 DB 접근 권한을 주어서 공유하라고 하는데, 그렇게되면 SESSION의 갱신에 대해 WebSocket이 능동적으로 알아챌 수 있는 방법이 없기 때문에 결국 DB Polling을 해야하는 사태가 벌어질 수도 있을 것 같다.</p>

<p>여러가지 해결책이 있겠지만 귀찮다는 핑계로 고민 중이다.</p>

<h3>정리</h3>

<p>본 글에서는 기존의 웹 통신 기반의 채팅방을 어떻게 구성하면 좋을지에 대해 써봤다.
코드가 없다고 아쉬워하는 사람이 있을지는 모르겠는데,</p>

<ul>
<li>웹 서버 쪽 프로그래밍이야 Server-Side Script 로 각 클라이언트간 동기화 로직만 잘 짜주면 되니까 이건 그냥 코딩이고,</li>
<li>클라이언트 쪽 프로그래밍이라면 Ajax나 WebSocket 관련 라이브러리를 가져다 쓰는게 좋겠다.</li>
</ul>

<p>난 전통적인 <a href="http://prototypejs.org">prototypejs</a> 유저라서 잘 모르겠지만, 대세가 <a href="http://jquery.com">jQuery</a> 라고 하니 그 쪽을 공부해보는 것도 좋겠다.</p>
</div>
				<hr />
				<div class="page-breaker"></div>
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				
				
			</div>
		</div>

		
		<footer>
			<hr />
			<div id="footer-menu">
				<a href="#top" title="go to top"><i class="fa fa-chevron-up fa-lg"></i></a>
				<div class="mobile-only">
					<a href="/" title="home"><i class="fa fa-home fa-lg"></i></a>
					<a href="/about/" title="about"><i class="fa fa-male fa-lg"></i></a>
					<a href="/archives/" title="archives"><i class="fa fa-file-text-o fa-lg"></i></a>
					<a href="/tags/" title="tags"><i class="fa fa-tags fa-lg"></i></a>
					<a href="https://github.com/lacti" title="github" rel="nofollow"><i class="fa fa-github fa-lg"></i></a>
					<a href="https://twitter.com/lacti" title="twitter" rel="nofollow"><i class="fa fa-twitter fa-lg"></i></a>
					<a href="http://www.slideshare.net/lactrious/presentations" title="slideshare" rel="nofollow"><i class="fa fa-toggle-right fa-lg"></i></a>
					<a href="http://www.linkedin.com/pub/jaeyoung-choi/99/243/861" title="linkedin" rel="nofollow"><i class="fa fa-linkedin fa-lg"></i></a>
					<a href="https://facebook.com/lactrious" title="facebook" rel="nofollow"><i class="fa fa-facebook fa-lg"></i></a>
					<a href="/atom.xml" title="atom"><i class="fa fa-rss fa-lg"></i></a>
				</div>
			</div>
			<p class="text-right">
				<em>© 2008-2015 Jaeyoung Choi</em>
			</p>
		</footer>
	</div>
	<!-- /.container -->
	<!-- ga -->
	<script>
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

		ga('create', 'UA-51932355-1', 'lacti.me');
		ga('send', 'pageview');
	</script>
</body>
</html>
