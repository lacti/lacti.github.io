{"componentChunkName":"component---src-templates-page-tsx","path":"/2011/08/22/static-sized-concurrent-pool/","webpackCompilationHash":"551181b12e79e57a3ef2","result":{"data":{"site":{"siteMetadata":{"title":"Lacti's Archive","description":"All about I learned","author":{"name":"Jaeyoung, Choi","url":"https://twitter.com/lacti"}}},"markdownRemark":{"html":"<p>정적인 크기의 Thread-safe한 (Concurrent) Object Pool을 만들어보자.<br>\n핵심은 배열을 사용한다는 것. 왜냐하면 여러 thread가 접근해도 자신만의 index 지점을 접근하면 한 지점에 동시에 thread가 접근하면서 발생하는 문제가 없기 때문.</p>\n<p>이게 동적으로 크기가 확장되면 배열의 포인터가 무효화되면서 여러 문제가 생길 수 있어 복잡하다. 따라서 정적인 크기라고 고정짓고 이야기를 해보자.</p>\n<p>Object Pool은 미리 Object들을 만들어놓고 필요할 때마다 하나씩 꺼내서 쓰겠다는 것이다. 그 이유는 객체 생성과 소멸, 메모리 할당과 해제의 비용이 아깝기 때문.<br>\n(때에 따라서 객체의 초기화 비용은 중복될 수도 있다. 다시 사용하기 전에 초기화할 수도 있으니까)</p>\n<p>따라서 미리 객체를 일정 개수만큼 만들어놓고, 필요할 때 꺼내서 쓰고, 다시 집어넣어서 <strong>재사용</strong> 가능하게 해주는 기법이 Object Pool 이라고 보면 된다.</p>\n<h2>구현과 한계</h2>\n<p>일정 크기만큼의 객체 배열을 생성한다. 이 때 여러 Thread가 객체를 하나씩 요구할 때, 공유되는 변수는 index 하나 뿐이다.<br>\n즉, 여러 Thread가 객체를 동시에 요청해도, index 값만 원자적으로 증가시켜서 그 index에 위치한 객체만 해당 thread에게 반환한다. 그렇게 되면 index의 객체는 오로지 그 thread에서만 접근이 가능하므로 thread-safe하게 접근할 수 있을 것이다.</p>\n<p>말로 설명하니 길고 지루한데, 요약하자면</p>\n<ul>\n<li>circular queue에서 index를 interlocked으로 증가시켜서 그 지점에 객체를 넣었다 뺐다 할 수 있게 해주면 thread-safe한 object pool이 만들어진다는 것이다.</li>\n</ul>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">template</span><span class=\"mtk1\"> &lt;</span><span class=\"mtk4\">typename</span><span class=\"mtk1\"> </span><span class=\"mtk10\">T</span><span class=\"mtk1\">&gt;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">class</span><span class=\"mtk1\"> </span><span class=\"mtk10\">ObjectPool</span><span class=\"mtk1\"> {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">public:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">bool</span><span class=\"mtk1\"> </span><span class=\"mtk11\">Pop</span><span class=\"mtk1\"> (</span><span class=\"mtk10\">T</span><span class=\"mtk4\">&amp;</span><span class=\"mtk1\"> </span><span class=\"mtk12\">element</span><span class=\"mtk1\">);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">bool</span><span class=\"mtk1\"> </span><span class=\"mtk11\">Push</span><span class=\"mtk1\"> (</span><span class=\"mtk4\">const</span><span class=\"mtk1\"> </span><span class=\"mtk10\">T</span><span class=\"mtk4\">&amp;</span><span class=\"mtk1\"> </span><span class=\"mtk12\">element</span><span class=\"mtk1\">);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk10\">LONG</span><span class=\"mtk1\"> </span><span class=\"mtk11\">Count</span><span class=\"mtk1\"> (</span><span class=\"mtk4\">void</span><span class=\"mtk1\">) </span><span class=\"mtk4\">const</span><span class=\"mtk1\"> { </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> mCount; }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk10\">LONG</span><span class=\"mtk1\"> </span><span class=\"mtk11\">Size</span><span class=\"mtk1\"> (</span><span class=\"mtk4\">void</span><span class=\"mtk1\">) </span><span class=\"mtk4\">const</span><span class=\"mtk1\"> { </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> mSize; }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk11\">ObjectPool</span><span class=\"mtk1\"> (LONG size);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    ~</span><span class=\"mtk11\">ObjectPool</span><span class=\"mtk1\"> (</span><span class=\"mtk4\">void</span><span class=\"mtk1\">);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">private:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    T*   mArray;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    LONG mSize;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    LONG mCount;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    LONG mPushIndex;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    LONG mPopIndex;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">}</span></span></code></pre>\n<p>생성과 소멸은 객체의 배열의 할당과 해제를 해주면 된다.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">template</span><span class=\"mtk1\"> &lt;</span><span class=\"mtk4\">typename</span><span class=\"mtk1\"> </span><span class=\"mtk10\">T</span><span class=\"mtk1\">&gt;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk10\">ObjectPool</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">T</span><span class=\"mtk1\">&gt;::</span><span class=\"mtk11\">ObjectPool</span><span class=\"mtk1\"> (LONG size)</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    : </span><span class=\"mtk11\">mSize</span><span class=\"mtk1\"> (size), </span><span class=\"mtk11\">mCount</span><span class=\"mtk1\"> (</span><span class=\"mtk7\">0</span><span class=\"mtk1\">), </span><span class=\"mtk11\">mPushIndex</span><span class=\"mtk1\"> (</span><span class=\"mtk7\">0</span><span class=\"mtk1\">), </span><span class=\"mtk11\">mPopIndex</span><span class=\"mtk1\"> (</span><span class=\"mtk7\">0</span><span class=\"mtk1\">) {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    mArray = </span><span class=\"mtk15\">new</span><span class=\"mtk1\"> </span><span class=\"mtk12\">T</span><span class=\"mtk1\">[size];</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">}</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">template</span><span class=\"mtk1\"> &lt;</span><span class=\"mtk4\">typename</span><span class=\"mtk1\"> </span><span class=\"mtk10\">T</span><span class=\"mtk1\">&gt;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk10\">ObjectPool</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">T</span><span class=\"mtk1\">&gt;::~</span><span class=\"mtk11\">ObjectPool</span><span class=\"mtk1\"> (</span><span class=\"mtk4\">void</span><span class=\"mtk1\">) {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk15\">delete[]</span><span class=\"mtk1\"> mArray;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">}</span></span></code></pre>\n<p><code>Push</code>와 <code>Pop</code>은 Circular Queue와 동일하다. 다만 index를 증가시키는 부분이 interlocked으로 작성되어있다는 것이다.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">template</span><span class=\"mtk1\"> &lt;</span><span class=\"mtk4\">typename</span><span class=\"mtk1\"> </span><span class=\"mtk10\">T</span><span class=\"mtk1\">&gt;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">bool</span><span class=\"mtk1\"> </span><span class=\"mtk10\">ObjectPool</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">T</span><span class=\"mtk1\">&gt;::</span><span class=\"mtk11\">Pop</span><span class=\"mtk1\"> (</span><span class=\"mtk10\">T</span><span class=\"mtk4\">&amp;</span><span class=\"mtk1\"> </span><span class=\"mtk12\">element</span><span class=\"mtk1\">) {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">int</span><span class=\"mtk1\"> index = </span><span class=\"mtk11\">InterlockedIncrement</span><span class=\"mtk1\"> (&amp;mPopIndex) % mSize;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk11\">is_null</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">mArray</span><span class=\"mtk1\">[index]))</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk4\">false</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    element = </span><span class=\"mtk12\">mArray</span><span class=\"mtk1\">[index];</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk11\">set_null</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">mArray</span><span class=\"mtk1\">[index]);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk4\">true</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">}</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">template</span><span class=\"mtk1\"> &lt;</span><span class=\"mtk4\">typename</span><span class=\"mtk1\"> </span><span class=\"mtk10\">T</span><span class=\"mtk1\">&gt;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">bool</span><span class=\"mtk1\"> </span><span class=\"mtk10\">ObjectPool</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">T</span><span class=\"mtk1\">&gt;::</span><span class=\"mtk11\">Push</span><span class=\"mtk1\"> (</span><span class=\"mtk4\">const</span><span class=\"mtk1\"> </span><span class=\"mtk10\">T</span><span class=\"mtk4\">&amp;</span><span class=\"mtk1\"> </span><span class=\"mtk12\">element</span><span class=\"mtk1\">) {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">int</span><span class=\"mtk1\"> index = </span><span class=\"mtk11\">InterlockedIncrement</span><span class=\"mtk1\"> (&amp;mPushIndex) % mSize;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (!</span><span class=\"mtk11\">is_null</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">mArray</span><span class=\"mtk1\">[index]))</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk4\">false</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk12\">mArray</span><span class=\"mtk1\">[index] = element;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk4\">false</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">}</span></span></code></pre>\n<p><code>Push</code>와 <code>Pop</code>함수가 <code>bool</code>을 반환하는 이유는 Pool의 크기가 정적인 이상 해당 요청이 실패할 수도 있기 때문이다.<br>\n<code>T</code>라는 type 자체가 포인터일 경우에는 <code>Pop</code> 함수에서 <code>NULL</code>을 반환하게 한다거나, 아니면 예외를 던지게 하는 방법이 있을 수 있겠지만 별로 둘 다 좋은 방법 같지는 않다는 생각에 <code>bool</code>을 반환하게 했다.</p>\n<p>또 하나의 문제는 <code>is_null</code>과 <code>set_null</code> 함수이다. 이 뜬금없는 함수에 대한 구현은 여기서 설명할 수 없는데, 그것은 이 기능이 각 type 마다 다르기 때문이다.<br>\n만약 <code>T</code>가 포인터 type이라면 위 문제는 간단해진다. <code>is_null</code> 함수는 그 지점이 <code>NULL</code>인지만 비교하면 되고, <code>set_null</code> 함수는 그 지점에 <code>NULL</code>을 넣어주면 되니까.</p>\n<p>하지만 그냥 객체이면 문제가 좀 복잡해지는데, 저걸 설정해줄 수 있도록 <code>T</code> 자체가 기능을 포함하는 건 어불성설이고, 아마도 <code>T</code>에 대한 proxy 객체를 쓰든지 해서 해당 지점이 유효한지, 유효하지 않은지를 관리하도록 하는게 좋을 것 같다.</p>\n<p>아니면 bool array를 크기만큼 하나 더 만들어서 그 지점에 데이터가 이미 있는지 없는지를 검사하게 하는 것도 방법일 수도 있겠다.</p>\n<p>위와 같은 2가지 방법은 완벽한 해결책이 될 수 없다. 왜냐하면 Thread 1이 <code>Push</code>를 해서 해당 지점에 객체를 반환하고, bool 값을 update하기 직전에, Thread 2가 <code>Pop</code>을 요청했는데 그 지점이라면 값을 가져갈 수가 없기 때문이다. (아직 bool 값이 갱신되지 않았으니까.)<br>\n그런데 이 문제는 T가 포인터일 때 NULL을 대입하고 검사하는 과정에서도 <code>Push</code>와 <code>Pop</code>이 빈번하다면 발생할 수 있을 것 같다.</p>\n<p>이를 해결하려면 더욱 첨예한 알고리즘을 사용해야하는데 이에 대해서는 고민을 좀 더 해봐야겠다.</p>\n<h2>결론</h2>\n<p>Circular Queue를 이용하여 Concurrent Object Pool을 간단하게 구성해보았다. 하지만 유효성 검사 한계 때문에 일반 객체에 대해서는 사용하지 못하고 포인터에 대해서만 사용 가능할 것 같다.</p>\n<p>그나마도 Push와 Pop을 빈번하게 할 경우 문제가 발생할 수 있으니 좀 더 고민해서 좋은 구조를 만들어보자.</p>\n<style class=\"vscode-highlight-styles\">:root {\n  --vscode-highlight-padding-v: 1rem;\n  --vscode-highlight-padding-h: 1.5rem;\n  --vscode-highlight-padding-top: var(--vscode-highlight-padding-v);\n  --vscode-highlight-padding-right: var(--vscode-highlight-padding-h);\n  --vscode-highlight-padding-bottom: var(--vscode-highlight-padding-v);\n  --vscode-highlight-padding-left: var(--vscode-highlight-padding-h);\n  --vscode-highlight-border-radius: 8px;\n\n  --vscode-highlight-line-highlighted-background-color: transparent;\n  --vscode-highlight-line-highlighted-border-width: 4px;\n  --vscode-highlight-line-highlighted-border-color: transparent;\n}\n\n.vscode-highlight {\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n  padding-top: 1rem;\n  padding-top: var(--vscode-highlight-padding-top);\n  padding-bottom: 1rem;\n  padding-bottom: var(--vscode-highlight-padding-bottom);\n  border-radius: 8px;\n  border-radius: var(--vscode-highlight-border-radius);\n  font-feature-settings: normal;\n}\n\n.vscode-highlight-code {\n  display: inline-block;\n  min-width: 100%;\n}\n\n.vscode-highlight-line {\n  display: inline-block;\n  box-sizing: border-box;\n  width: 100%;\n  padding-left: 1.5rem;\n  padding-left: var(--vscode-highlight-padding-left);\n  padding-right: 1.5rem;\n  padding-right: var(--vscode-highlight-padding-right);\n}\n\n.vscode-highlight-line-highlighted {\n  background-color: var(--vscode-highlight-line-highlighted-background-color);\n  box-shadow: inset var(--vscode-highlight-line-highlighted-border-width) 0 0 0 var(--vscode-highlight-line-highlighted-border-color);\n}\n.default-dark {\nbackground-color: #1E1E1E;\ncolor: #D4D4D4;\n}\n\n.default-dark .mtk1 { color: #D4D4D4; }\n.default-dark .mtk2 { color: #1E1E1E; }\n.default-dark .mtk3 { color: #6A9955; }\n.default-dark .mtk4 { color: #569CD6; }\n.default-dark .mtk5 { color: #D16969; }\n.default-dark .mtk6 { color: #D7BA7D; }\n.default-dark .mtk7 { color: #B5CEA8; }\n.default-dark .mtk8 { color: #CE9178; }\n.default-dark .mtk9 { color: #646695; }\n.default-dark .mtk10 { color: #4EC9B0; }\n.default-dark .mtk11 { color: #DCDCAA; }\n.default-dark .mtk12 { color: #9CDCFE; }\n.default-dark .mtk13 { color: #000080; }\n.default-dark .mtk14 { color: #F44747; }\n.default-dark .mtk15 { color: #C586C0; }\n.default-dark .mtk16 { color: #6796E6; }\n.default-dark .mtk17 { color: #808080; }\n.default-dark .mtki { font-style: italic; }\n.default-dark .mtkb { font-weight: bold; }\n.default-dark .mtku { text-decoration: underline; text-underline-position: under; }</style>","excerpt":"정적인 크기의 Thread-safe한 (Concurrent) Object Pool을 만들어보자. 핵심은 배열을 사용한다는 것. 왜냐하면 여러 thread가 접근해도 자신만의 index 지점을 접근하면 한 지점에 동시에 thread…","fields":{"date":"August 22, 2011","shortdesc":""},"frontmatter":{"title":"Concurrent Pool (Static Size)","tags":["concurrency","c++"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2011/08/22/static-sized-concurrent-pool/"}}}