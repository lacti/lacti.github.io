{"componentChunkName":"component---src-templates-tag-tsx","path":"/tag/async/","webpackCompilationHash":"cdfa71eb19fc14d91b48","result":{"data":{"allMarkdownRemark":{"totalCount":7,"edges":[{"node":{"excerpt":"위 이야기에 이어, async 작업과 then 작업 간의 상태 공유에 대해서 알아보자.async에서 then으로 상태를 전달하는 가장 기본적인 방법은 반환값을 사용하는 방법이다. 다른 방법으로는 lambda function에 의한 variable capture가 있겠다.반환 값으로 모든 context를 전달하는 것에는 한계가 있기 때문에 capture를 통한 방법이 더 편할 수 있다.하지만 capture…","fields":{"date":"November 19, 2013","slug":"/2013/11/19/asynchronous-programming-pattern-2/"},"frontmatter":{"title":"비동기 프로그래밍 패턴 2","tags":["async","design"]}}},{"node":{"excerpt":"일련의 순서로 호출되어야 하는 비동기 함수들이 있다. 이 때 사용되는 method chaining을 사용한 async/then 패턴과 수행할 비동기 context를 갖고 직접 비동기 수행을 연쇄적으로 진행하는 async_worker 패턴을 알아보자.연속적인 비동기 작업을 처리할 때에는 동기적 프로그래밍과는 다르게 코드를 순차적으로 서술할 수 없다. 만약 아래와 같이 작성된다면, async_work2나 async_work…","fields":{"date":"October 09, 2013","slug":"/2013/10/09/asynchronous-programming-pattern-1/"},"frontmatter":{"title":"비동기 프로그래밍 패턴 1","tags":["async","design"]}}},{"node":{"excerpt":"오늘 스터디에서 공부한 내용을 간단히 정리해보자.async, futurefuture, promise는 비동기로 실행되는 수행 결과를 받아오기 위한 개념이다.async는 내부적으로 promise를 사용하여 결과를 set()할 비동기 작업을 수행시키고, future를 반환한다.packaged_task는 비동기 작업을 수행할 수 있는 task 객체를 만들어준다. task 객체로부터 future를 가져올 수 있다.vs201…","fields":{"date":"August 18, 2013","slug":"/2013/08/18/cpp11-async-corotuine-io-study/"},"frontmatter":{"title":"c++11 async, corotuine, io 스터디","tags":["async","io","study"]}}},{"node":{"excerpt":"함수를 호출하는 코드를 작성한다고 해보자. synchronous하게 호출하는 방법이 있고, asynchronous하게 호출하는 방법이 있다. (보통 후자는 호출이라고 하기보다는 요청을 한다고 할 것이다)코드를 작성하는 프로그래머 입장에서는 당연히 synchronous…","fields":{"date":"March 18, 2012","slug":"/2012/03/18/asynchronous-programming-and-async-await/"},"frontmatter":{"title":"asynchronous programming과 async, await","tags":["async"]}}},{"node":{"excerpt":"(주의, 아래 글은 Visual Studio 2010 을 쓴다는 가정하에 작성하였다. 아무튼 C++11 이 지원되어야 한다)여러 Thread가 동시에 접근을 수행하는 객체를 보호하기 위해서는 어떤 방법이 있을까?lock을 건다각 Thread들은 하나의 queue에 요청할 작업을 쌓아두고, 그 객체 전담 Thread가 그 작업들을 처리한다.Read / Write Phase를 나누어서 Read는 다같이, Write…","fields":{"date":"August 11, 2011","slug":"/2011/08/11/synchronize-function-execution-in-each-object/"},"frontmatter":{"title":"객체별 함수 수행 동기화","tags":["concurrency","c++","async"]}}},{"node":{"excerpt":"다중 입출력 함수는 POSIX의 select 함수를 공부하면서 가장 많이 보게 되는 함수이다. 다중 입출력 함수라는 것은 영어로 바꿔보면 multiplex io function인데 말 그대로 여러 개의 io 를 하나의 함수로 처리한다는 것이다.지난 글의 동기와 비동기에 이어서 여러 개의 io를 어떻게 처리하는 것이 효율적인지 알아보자.\n비동기 IO 함수지난 번에 봤던 함수들은 하나의 IO…","fields":{"date":"August 07, 2011","slug":"/2011/08/07/efficient-processing-for-multiplexing-io/"},"frontmatter":{"title":"다중 입출력에 대한 효율적 처리","tags":["async","io"]}}},{"node":{"excerpt":"IO 함수라고 하면 생소하게 느끼는 경우가 많다. IO 함수는 input / output 함수의 줄임말인데 우리가 흔히 봐왔던 함수로는 scanf와 printf가 있겠다. scanf는 keyboard에서 글자를 읽어(input) 오는 것이고, printf는 문자열을 화면으로 출력(print)하는 함수다.이 뿐만 아니라 fprintf, fscanf 등의 파일 입출력 관련의 함수 역시 io 함수들이고, 파일 관련 Windows…","fields":{"date":"August 07, 2011","slug":"/2011/08/07/asynchronous-io/"},"frontmatter":{"title":"비동기 IO 함수","tags":["async","io"]}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"tag":"async"}}}