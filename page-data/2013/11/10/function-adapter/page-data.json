{"componentChunkName":"component---src-templates-page-tsx","path":"/2013/11/10/function-adapter/","result":{"data":{"site":{"siteMetadata":{"title":"Lacti's Archive","description":"All about I learned","author":{"name":"Jaeyoung, Choi","url":"https://twitter.com/lacti"}}},"markdownRemark":{"html":"<p>과제는 다음의 Adapter를 만들어보자는 것이다.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"cpp\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">int</span><span class=\"mtk1\"> </span><span class=\"mtk11\">sum</span><span class=\"mtk1\">(</span><span class=\"mtk4\">int</span><span class=\"mtk1\"> </span><span class=\"mtk12\">a</span><span class=\"mtk1\">, </span><span class=\"mtk4\">int</span><span class=\"mtk1\"> </span><span class=\"mtk12\">b</span><span class=\"mtk1\">) { </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> a + b; }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">void</span><span class=\"mtk1\"> </span><span class=\"mtk11\">main</span><span class=\"mtk1\">() {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    Adapter&lt;</span><span class=\"mtk4\">int</span><span class=\"mtk3\"> /* return-type */</span><span class=\"mtk1\">, </span><span class=\"mtk4\">int</span><span class=\"mtk3\"> /* 1st-arg-type */</span><span class=\"mtk1\">, </span><span class=\"mtk4\">int</span><span class=\"mtk3\"> /* 2nd-arg-type */</span><span class=\"mtk1\">&gt;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">functor1</span><span class=\"mtk1\">(sum, </span><span class=\"mtk7\">100</span><span class=\"mtk3\"> /* 1st-arg */</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">int</span><span class=\"mtk1\"> result1 = </span><span class=\"mtk11\">functor1</span><span class=\"mtk1\">(</span><span class=\"mtk7\">20</span><span class=\"mtk1\">);</span><span class=\"mtk3\"> // 120</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">int</span><span class=\"mtk1\"> result2 = </span><span class=\"mtk11\">functor1</span><span class=\"mtk1\">(</span><span class=\"mtk7\">80</span><span class=\"mtk1\">);</span><span class=\"mtk3\"> // 180</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>많은 친구들이 이미 문제를 잘 풀었기 때문에 자세한 설명은 생략한다.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"cpp\" data-index=\"1\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">template</span><span class=\"mtk1\"> &lt;</span><span class=\"mtk4\">typename</span><span class=\"mtk1\"> </span><span class=\"mtk10\">R</span><span class=\"mtk1\">, </span><span class=\"mtk4\">typename</span><span class=\"mtk1\"> </span><span class=\"mtk10\">T1</span><span class=\"mtk1\">, </span><span class=\"mtk4\">typename</span><span class=\"mtk1\"> </span><span class=\"mtk10\">T2</span><span class=\"mtk1\">&gt;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">struct</span><span class=\"mtk1\"> </span><span class=\"mtk10\">Adapter</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">typedef</span><span class=\"mtk1\"> </span><span class=\"mtk10\">R</span><span class=\"mtk1\"> (*</span><span class=\"mtk12\">F</span><span class=\"mtk1\">)(</span><span class=\"mtk10\">T1</span><span class=\"mtk1\">, </span><span class=\"mtk10\">T2</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">Adapter</span><span class=\"mtk1\">(</span><span class=\"mtk10\">F</span><span class=\"mtk1\"> </span><span class=\"mtk12\">func</span><span class=\"mtk1\">, </span><span class=\"mtk10\">T1</span><span class=\"mtk1\"> </span><span class=\"mtk12\">arg1</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        : </span><span class=\"mtk11\">_function</span><span class=\"mtk1\">(func), </span><span class=\"mtk11\">_arg1</span><span class=\"mtk1\">(arg1) {}</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk10\">R</span><span class=\"mtk1\"> </span><span class=\"mtk15\">operator</span><span class=\"mtk1\"> () (</span><span class=\"mtk10\">T2</span><span class=\"mtk1\"> </span><span class=\"mtk12\">arg2</span><span class=\"mtk1\">) </span><span class=\"mtk4\">const</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk11\">_function</span><span class=\"mtk1\">(_arg1, arg2);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    F _function;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    T1 _arg1;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">};</span></span></span></code></pre>\n<p>이름 잘 지어주는 것도 물론 중요하지만 이정도 코드에서는 저정도 글자만 써줘도 이해할 것 같으니 과감히 생략.</p>\n<p>개인적으로 풀이 중 가장 마음에 드는 것은 [Omniavinco]가 [if1live] 글에 댓글로 단 binder1st 상속을 통한 구현. (있는 것 가져다가 쓰는게 제일)</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"cpp\" data-index=\"2\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">#include</span><span class=\"mtk4\"> </span><span class=\"mtk8\">&lt;functional&gt;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">template</span><span class=\"mtk1\"> &lt;</span><span class=\"mtk4\">typename</span><span class=\"mtk1\"> </span><span class=\"mtk10\">T1</span><span class=\"mtk1\">, </span><span class=\"mtk4\">typename</span><span class=\"mtk1\"> </span><span class=\"mtk10\">T2</span><span class=\"mtk1\">, </span><span class=\"mtk4\">typename</span><span class=\"mtk1\"> </span><span class=\"mtk10\">T3</span><span class=\"mtk1\">&gt;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">class</span><span class=\"mtk1\"> </span><span class=\"mtk10\">Adapter</span><span class=\"mtk1\">:</span><span class=\"mtk4\">public</span><span class=\"mtk1\"> </span><span class=\"mtk10\">std</span><span class=\"mtk1\">::</span><span class=\"mtk10\">binder1st</span><span class=\"mtk1\">&lt; </span><span class=\"mtk10\">std</span><span class=\"mtk1\">::</span><span class=\"mtk10\">pointer_to_binary_function</span><span class=\"mtk1\">&lt; </span><span class=\"mtk10\">T2</span><span class=\"mtk1\">, </span><span class=\"mtk10\">T3</span><span class=\"mtk1\">, </span><span class=\"mtk10\">T1</span><span class=\"mtk1\"> &gt; &gt; {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">public:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk11\">Adapter</span><span class=\"mtk1\">(</span><span class=\"mtk10\">T1</span><span class=\"mtk1\"> (*</span><span class=\"mtk12\">func</span><span class=\"mtk1\">)(</span><span class=\"mtk10\">T2</span><span class=\"mtk1\">, </span><span class=\"mtk10\">T3</span><span class=\"mtk1\">), </span><span class=\"mtk10\">T3</span><span class=\"mtk1\"> </span><span class=\"mtk12\">v</span><span class=\"mtk1\">):std::</span><span class=\"mtk11\">binder1st</span><span class=\"mtk1\">&lt; </span><span class=\"mtk10\">std</span><span class=\"mtk1\">::</span><span class=\"mtk10\">pointer_to_binary_function</span><span class=\"mtk1\">&lt; </span><span class=\"mtk10\">T2</span><span class=\"mtk1\">, </span><span class=\"mtk10\">T3</span><span class=\"mtk1\">, </span><span class=\"mtk10\">T1</span><span class=\"mtk1\"> &gt; &gt;(</span><span class=\"mtk10\">std</span><span class=\"mtk1\">::</span><span class=\"mtk11\">ptr_fun</span><span class=\"mtk1\">(func), v) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">};</span></span></span></code></pre>\n<h2>type infererence</h2>\n<p>자, 과제가 끝났습니다(…) 라고 하면 섭섭하실 것 같아 준비했습니다!</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"cpp\" data-index=\"3\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">Adapter&lt;</span><span class=\"mtk4\">int</span><span class=\"mtk3\"> /* return-type */</span><span class=\"mtk1\">, </span><span class=\"mtk4\">int</span><span class=\"mtk3\"> /* 1st-arg-type */</span><span class=\"mtk1\">, </span><span class=\"mtk4\">int</span><span class=\"mtk3\"> /* 2nd-arg-type */</span><span class=\"mtk1\">&gt;</span></span></span></code></pre>\n<p>변수 선언하기 위해서 Adapter type을 길게 써야하는게 굳이 그럴 필요가 있을까? <code>std::make_pair</code>과 같은 type inference를 이용한 helper function을 구현하여 그 귀찮음을 해소해보자.</p>\n<p>일단 function의 <code>return_type</code>, <code>arg1_type</code>, <code>arg2_type</code>을 가져오기 위해서 간단한 template 부분 특수화(partial specialization)를 사용한 <code>type_trait</code> class를 만들어보자.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"cpp\" data-index=\"4\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">template</span><span class=\"mtk1\">&lt;</span><span class=\"mtk4\">typename</span><span class=\"mtk1\"> </span><span class=\"mtk10\">Function</span><span class=\"mtk1\">&gt; </span><span class=\"mtk4\">struct</span><span class=\"mtk1\"> </span><span class=\"mtk10\">function_traits</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">template</span><span class=\"mtk1\">&lt;</span><span class=\"mtk4\">typename</span><span class=\"mtk1\"> </span><span class=\"mtk10\">R</span><span class=\"mtk1\">, </span><span class=\"mtk4\">typename</span><span class=\"mtk1\"> </span><span class=\"mtk10\">T1</span><span class=\"mtk1\">, </span><span class=\"mtk4\">typename</span><span class=\"mtk1\"> </span><span class=\"mtk10\">T2</span><span class=\"mtk1\">&gt;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">struct</span><span class=\"mtk1\"> </span><span class=\"mtk10\">function_traits</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">R</span><span class=\"mtk1\"> (*)(</span><span class=\"mtk10\">T1</span><span class=\"mtk1\">, </span><span class=\"mtk10\">T2</span><span class=\"mtk1\">)&gt; {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">typedef</span><span class=\"mtk1\"> R R;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">typedef</span><span class=\"mtk1\"> T1 T1;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">typedef</span><span class=\"mtk1\"> T2 T2;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">};</span></span></span></code></pre>\n<p>위 코드는 <a href=\"https://www.boost.org/doc/libs/release/libs/type_traits/doc/html/boost_typetraits/reference/function_traits.html\">boost::function_traits</a>에서 필요한 부분만 발췌한 코드이다. 설명을 위해서 가져온 코드이고, 그냥 <a href=\"https://www.boost.org/doc/libs/release/libs/type_traits/doc/html/index.html\">boost type_traits library</a>를 가져다 쓰는게 더 좋다.</p>\n<p>함수 type으로부터 반환 type, 인자 type들을 얻어낼 수 있게 되었으니 이제 Adapter에 넣어주기만 하면 된다. 그 부분에 대해서도 helper class를 만들어보자.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"cpp\" data-index=\"5\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">template</span><span class=\"mtk1\"> &lt;</span><span class=\"mtk4\">typename</span><span class=\"mtk1\"> </span><span class=\"mtk10\">F</span><span class=\"mtk1\">&gt;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">struct</span><span class=\"mtk1\"> </span><span class=\"mtk10\">adapter_type</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">typedef</span><span class=\"mtk1\"> Adapter&lt;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk4\">typename</span><span class=\"mtk1\"> </span><span class=\"mtk10\">function_traits</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">F</span><span class=\"mtk1\">&gt;::</span><span class=\"mtk10\">R</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk4\">typename</span><span class=\"mtk1\"> </span><span class=\"mtk10\">function_traits</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">F</span><span class=\"mtk1\">&gt;::</span><span class=\"mtk10\">T1</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk4\">typename</span><span class=\"mtk1\"> </span><span class=\"mtk10\">function_traits</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">F</span><span class=\"mtk1\">&gt;::</span><span class=\"mtk10\">T2</span><span class=\"mtk1\">&gt; type;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">};</span></span></span></code></pre>\n<p>이제 다음과 같은 방법으로 Adapter type을 간단하게 부를 수 있다.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"cpp\" data-index=\"6\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">typedef</span><span class=\"mtk1\"> </span><span class=\"mtk10\">adapter_type</span><span class=\"mtk1\">&lt;</span><span class=\"mtk4\">decltype</span><span class=\"mtk1\">(my_function)&gt;::type my_adapter;</span></span></span></code></pre>\n<p>이제 모든 준비가 끝났으니 Adapter 객체를 만들어주는 적절한 helper function만 만들면 된다. 이 함수의 인자로 우리가 원하는 함수 포인터를 넣으면 해당 함수에 대한 type을 template이 잘 알아서 inference 해줄 것이고, 그에 따라 적절한 Adapter class에 대한 객체가 만들어질 것이다.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"cpp\" data-index=\"7\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">template</span><span class=\"mtk1\"> &lt;</span><span class=\"mtk4\">typename</span><span class=\"mtk1\"> </span><span class=\"mtk10\">F</span><span class=\"mtk1\">&gt;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">typename</span><span class=\"mtk1\"> </span><span class=\"mtk10\">adapter_type</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">F</span><span class=\"mtk1\">&gt;::</span><span class=\"mtk10\">type</span><span class=\"mtk1\"> </span><span class=\"mtk11\">make_adapter</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    F func, </span><span class=\"mtk4\">typename</span><span class=\"mtk1\"> </span><span class=\"mtk10\">function_traits</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">F</span><span class=\"mtk1\">&gt;::</span><span class=\"mtk10\">T1</span><span class=\"mtk1\"> arg1) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk4\">typename</span><span class=\"mtk1\"> </span><span class=\"mtk10\">adapter_type</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">F</span><span class=\"mtk1\">&gt;::</span><span class=\"mtk10\">type</span><span class=\"mtk1\">(func, arg1);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p><code>F</code> type으로 받은 함수에 대해 <code>adapter_type</code>의 객체를 만들어 적절히 반환해준다.</p>\n<p>이제 다음과 같이 main 함수 내의 코드를 정리할 수 있다.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"cpp\" data-index=\"8\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// Adapter&lt;int, int, int&gt; adapter(sum, 100);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">auto</span><span class=\"mtk1\"> adapter = </span><span class=\"mtk11\">make_adapter</span><span class=\"mtk1\">(sum, </span><span class=\"mtk7\">100</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk10\">std</span><span class=\"mtk1\">::cout &lt;&lt; </span><span class=\"mtk11\">adapter1</span><span class=\"mtk1\">(</span><span class=\"mtk7\">20</span><span class=\"mtk1\">) &lt;&lt; </span><span class=\"mtk10\">std</span><span class=\"mtk1\">::endl;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk10\">std</span><span class=\"mtk1\">::cout &lt;&lt; </span><span class=\"mtk11\">adapter1</span><span class=\"mtk1\">(</span><span class=\"mtk7\">80</span><span class=\"mtk1\">) &lt;&lt; </span><span class=\"mtk10\">std</span><span class=\"mtk1\">::endl;</span></span></span></code></pre>\n<h2>정리</h2>\n<p>간단한 레벨에서 c++스럽게 프로그래밍을 한다면 stl만 어느정도 써도 된다. 하지만 조금만 더 프로그래밍을 하다보면 쓸데없는 중복 코드를 제거하기 위한 일반적인 프로그래밍을 하게 되고, c++에서 그걸 표현하려면 template은 필요한 요소이기 때문에 익숙해지는게 좋다.</p>\n<p>이번 과제로 나온 adapter는 어떤 함수의 interface를 다른 interface로 변환하기 위한 adapter pattern을 구현한 것이다. adapter pattern은 어떤 interface를 연결해주냐에 따라 장황한 구현의 세계가 펼쳐질 수 있는데 여기서는 간단히 함수와 함수를 연결해주는 것으로 template과 <code>operator ()</code> 만으로 구현을 한 것이다.</p>\n<p>하지만 template을 사용하게 될 경우 그 구현체를 사용하는 쪽에서 type 노가다를 해주어야할 일이 생기는데 이걸 해결하기 위해서 auto keyword와 helper function을 통한 compiler의 type inference와 <code>type_traits</code>을 사용하는 것이다. (이번 스터디에서 type_traits는 주제를 벗어나기 때문에 다루지 않을 예정이다)</p>\n<p><code>type_traits</code>을 언급했으니 말인데, 위에서 만든 Adapter의 효율은 생각보다 좋지 않다.\n왜냐하면 binding되는 인자와 <code>operator ()</code>의 인자로 받는 객체의 크기가 매우 클 경우 해당 객체가 복사되어 넘어가기 때문이다. 이 문제를 해결하기 위해 인자의 const-reference를 쓰는 것이 좋을지, 아니면 move semantics을 쓰는 것이 좋을지, 아니면 <code>shared_ptr</code>, 혹은 <code>unique_ptr</code>을 쓰는게 좋을지 고민해보고 그에 대한 구현을 해보는 것도 좋은 연습이 되겠다.</p>\n<p>template의 부분 특수화와 단위 전략(unit policy)을 공부하면 충분히 일반적인 interface를 가지면서도 각 경우에 대해 효율적으로 동작할 수 있는(심지어 compile time에 모든 것이 결정되어 runtime에 추가적인 부담을 지지 않는) 구현을 할 수 있다. <del>MC++D, TMP 스터디 절찬리 예매 중..은 아니고</del></p>\n<p>사실 오늘 구현한 내용들은 어느 정도 표준에 포함되었거나 boost에 있는 내역들이다. 따라서 다음의 구현체를 찾아보며 공부하는 것을 적극 추천한다.</p>\n<ul>\n<li><a href=\"https://en.cppreference.com/w/cpp/utility/functional/bind\">Cppref: std::bind</a></li>\n<li><a href=\"https://en.cppreference.com/w/cpp/header/type_traits\">Cppref: type_traits</a></li>\n<li><a href=\"https://www.boost.org/doc/libs/1_54_0/libs/type_traits/doc/html/index.html%22\">boost: type_traits library</a></li>\n</ul>\n<p>지금까지의 내용은 compiler time에서 일어나는 generic programming 이야기였다. 이를 runtime에서 하나의 type으로 모아서 작업하기 위한 type erasure을 오늘 다룰 것이다.</p>\n<p>그렇다면 다음 과제는 dispatcher가 될 것 같다(…)</p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n  .default-dark {\n    background-color: #1E1E1E;\n    color: #D4D4D4;\n  }\n  .default-dark .mtk4 { color: #569CD6; }\n  .default-dark .mtk1 { color: #D4D4D4; }\n  .default-dark .mtk11 { color: #DCDCAA; }\n  .default-dark .mtk12 { color: #9CDCFE; }\n  .default-dark .mtk15 { color: #C586C0; }\n  .default-dark .mtk3 { color: #6A9955; }\n  .default-dark .mtk7 { color: #B5CEA8; }\n  .default-dark .mtk10 { color: #4EC9B0; }\n  .default-dark .mtk8 { color: #CE9178; }\n  .default-dark .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(255, 255, 255, 0.1));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(255, 255, 255, 0.5));\n  }\n</style>","excerpt":"과제는 다음의 Adapter…","fields":{"date":"November 10, 2013","shortdesc":"","slug":"/2013/11/10/function-adapter/"},"frontmatter":{"title":"function adapter와 type inference","tags":["c++","template","study"]}}},"pageContext":{"slug":"/2013/11/10/function-adapter/","older":{"slug":"/2013/11/10/template-programming-and-type-erasure/","title":"template 프로그래밍과 type erasure"},"newer":{"slug":"/2013/11/16/cpp-message-dispatcher/","title":"c++ message dispatcher"}}},"staticQueryHashes":["848695393"]}