{"componentChunkName":"component---src-templates-tags-js","path":"/tags/refactor/","webpackCompilationHash":"b97af647db8cc3cf2682","result":{"data":{"allMarkdownRemark":{"totalCount":3,"edges":[{"node":{"excerpt":"지난 두 글에서 사용한 전략은, 멤버에 접근하기 위한 방법을 동일한 인터페이스로 맞춰서 (첫 번째 글에서는 멤버 데이터 포인터, 두 번째 글에서는 멤버 함수 포인터) BuffType과 그 인터페이스를 대응시키는 방법을 사용하였다. 동일한 인터페이스를 사용하기 위해서 그들을 하나의 동일한 타입으로 지칭하는 방법을 사용하였고, 그렇기 때문에 서로 다른 type, int 변수와 float…","fields":{"date":"October 07, 2012","path":"/2012/10/07/extract-code-using-member-data-pointer-3"},"frontmatter":{"title":"멤버 데이터 포인터를 사용하여 연산식 묶어내기 3","tags":["c++","refactor"]}}},{"node":{"excerpt":"이번 글에서는 Stat 자료구조 내에 배열이 있을 때 이를 어떻게 처리할지에 대해서 알아보도록 하자. Stat 코드를 작성하다보니, 이동 속도에 관해서는 각각의 변수를 따로 두는 것 보다, 배열 하나로 처리하는 것이 더 낫다는 것을 깨닫게 되었다. 배열로 묶어서 movingSpeed 관련 코드가 개선된 것까지는 좋았는데 hp와 movingSpeed는 type…","fields":{"date":"October 03, 2012","path":"/2012/10/03/extract-code-using-member-data-pointer-2"},"frontmatter":{"title":"멤버 데이터 포인터를 사용하여 연산식 묶어내기 2","tags":["c++","refactor"]}}},{"node":{"excerpt":"게임 내 스탯 시스템을 구현한다고 해보자. 그 스탯들은 여러 상황에서 버프에 의해 값이 변경될 수 있기 때문에 스탯을 저장하는 자료구조와 그 스탯을 변경하기 위한 버프 종류 enum과, 각 버프 종류 enum에 따라 스탯을 어떻게 변경할지에 대한 연산식에 대해서 코딩을 해주어야 한다. 일단 각 스탯에 어떤 값을 어떻게 계산하면 되는지에 대해서는 다음의 3가지로 추상화를 했다고 치자. SET, ADD, RATE…","fields":{"date":"October 01, 2012","path":"/2012/10/01/extract-code-using-member-data-pointer-1"},"frontmatter":{"title":"멤버 데이터 포인터를 사용하여 연산식 묶어내기 1","tags":["c++","refactor"]}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"tag":"refactor"}}}