{"componentChunkName":"component---src-templates-page-tsx","path":"/2013/08/03/concurrency-study/","webpackCompilationHash":"cdfa71eb19fc14d91b48","result":{"data":{"site":{"siteMetadata":{"title":"Lacti's Archive","description":"All about I learned","author":{"name":"Jaeyoung, Choi","url":"https://twitter.com/lacti"}}},"markdownRemark":{"html":"<p>오늘 스터디에서 공부한 내용을 간략히 정리해보자.</p>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/ABA_problem\">Wiki: ABA problem</a></li>\n<li><a href=\"https://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf\">Simple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue Algorithms</a></li>\n<li><a href=\"%7B%25%20post_url%202011-08-02-context-switching-and-simultaneously%20%25%7D\">context switching과 simultaneously 실행</a></li>\n<li><a href=\"%7B%25%20post_url%202012-02-23-thread-unsafety-problem-in-circular-queue%20%25%7D\">환형큐의 thread unsafety 문제</a></li>\n</ul>\n<h2>volatile/interlocked operation/memory barrier</h2>\n<ul>\n<li><a href=\"%7B%25%20post_url%202011-08-02-volatile-interlocked-operation%20%25%7D\">volatile 과 interlocked operation</a></li>\n<li><a href=\"https://summerlight-textcube.blogspot.kr/2009/11/volatile%EA%B3%BC-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%B0%B0%EB%A6%AC%EC%96%B4.html\">summerlight: volatile과 메모리 배리어</a></li>\n</ul>\n<h2>intrusive/non-intrusive</h2>\n<ul>\n<li><a href=\"https://www.makelinux.net/ldd3/chp-11-sect-5\">Linux kernel LinkedList</a></li>\n<li><a href=\"https://www.boost.org/doc/libs/release/doc/html/intrusive.html\">Boost: Boost.Intrusive</a></li>\n<li><a href=\"https://www.boost.org/doc/libs/release/doc/html/intrusive/intrusive_vs_nontrusive.html\">Boost: Intrusive and non-intrusive containers</a></li>\n</ul>\n<h2>InterlockedSList</h2>\n<ul>\n<li><a href=\"%7B%25%20post_url%202011-08-03-interlocked-singly-linked-lists%20%25%7D\">Interlocked Singly Linked Lists</a></li>\n</ul>\n<h2>Actor model</h2>\n<p>각 actor 객체에 접근하는 thread는 반드시 하나임을 보장함. context switching 비용을 줄이기 위해 thread 개수를 제한하지만 많은 actor를 다루기 위해 객체별 수행 동기화 기법을 사용한다.</p>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Actor_model\">Wiki: Actor model</a></li>\n<li><a href=\"%7B%25%20post_url%202011-08-11-synchronize-function-execution-in-each-object%20%25%7D\">객체별 함수 수행 동기화</a></li>\n</ul>\n<h2>out of order execution</h2>\n<ul>\n<li>컴파일러의 명령어 재배치 수준이 아닌 cpu 내부의 비순차 실행</li>\n<li>비순차 실행을 통해 최대 수행 시간의 절감 효과를 얻음</li>\n<li>하드웨어적 한계로 비순차 실행 명령어 window를 유지 (reservation stations), 그 내부에서 각 operand 준비 완료가 되면 연산 수행</li>\n<li>operand 준비 완료 통지 연산량 감소를 port grouping, 결과 순서를 보장해주기 위해 rob를 사용</li>\n<li><a href=\"https://en.wikipedia.org/wiki/Reservation_stations\">Wiki: Reservation stations</a></li>\n</ul>\n<h2>memory consistency model</h2>\n<p>우리가 작성한 대로 수행을 보장해준다면(Sequentially-consistent ordering) 프로그램의 흐름을 이해하기가 쉽지만 최적화 가능성이 줄어듬. 이를 완화(relaxed)해주어서 최적화가 잘 되게 해보자. 그런데 intel x86-64는 그런 것 신경 안 써줘도 빠르게 돌아감<em>([summerlight]님 수정)</em></p>\n<ul>\n<li><a href=\"https://www.hpl.hp.com/techreports/Compaq-DEC/WRL-95-7.pdf\">WRL-RR: Shared Memory Consistency Models: A Tutorial</a></li>\n</ul>\n<p>c++11에 memory order로 추가됨.</p>\n<ul>\n<li><a href=\"https://en.cppreference.com/w/cpp/atomic/memory_order\">Cppref: std::memory_order</a></li>\n</ul>\n<h2>c++ threading facilities</h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/C%2B%2B11#Threading_facilities\">Wiki: c++ threading facilities</a></li>\n</ul>\n<p>표준에서 지원하기는 하지만 표준 라이브러리가 어떻게 구현되어있는지 보고 괜찮은지를 판단한 후 사용하자.</p>\n<ul>\n<li><a href=\"https://www.slideshare.net/lactrious/synchronizing-concurrent-threads\">async, future, promise in c++</a></li>\n</ul>\n<h2>sync/async programming</h2>\n<p>아무튼 async가 흐름 따라가기가 어렵다.</p>\n<ul>\n<li><a href=\"%7B%25%20post_url%202012-03-18-asynchronous-programming-and-async-await%20%25%7D\">asynchronous programming 과 async, await</a></li>\n</ul>\n<h2>c++11의 lambda</h2>\n<ul>\n<li><a href=\"https://ogoons.tistory.com/69\">Visual C++10과 C++0x</a></li>\n</ul>\n<h2>thread safe한 singleton</h2>\n<ul>\n<li><a href=\"https://board.poolc.org/generation03/512\">PoolC: C++ 싱글턴 (summerlight)</a></li>\n</ul>\n<p>근데 intel x86-64에서는 memory barrier 안 쳐줘도 문제가 없다(…) 하지만 c++11부터는 함수 내 static 변수를 반환하는 것만으로도 대충 thread-safe한 singleton이 구현 가능해졌다.</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/8102125/is-local-static-variable-initialization-thread-safe-in-c11\">Stackoverflow: Is local static variable initialization thread-safe in C++11</a></li>\n<li><a href=\"https://stackoverflow.com/questions/2280630/c-threadsafe-static-constructor\">Stackoverflow: c++ threadsafe static constructor</a></li>\n</ul>\n<h2>기타 windows via c/c++ 내용</h2>\n<p>CreateThread, SSDT, Kernel object, CriticalSection, …</p>\n<h2>lock</h2>\n<ul>\n<li>CAS (InterlockedCompareExchange 사용) 로 쉽게 구현할 수 있다.</li>\n<li>reader/writer (shared/exclusive) lock을 사용할 수 있지만 fairness를 잘 고민해야한다.</li>\n<li>그냥 lock/unlock 부르지 말고 raii 잘 써서 쓰자.</li>\n</ul>\n<h2>과제 해법</h2>\n<ul>\n<li>lock 사용</li>\n<li>interlocked-operation 사용</li>\n<li>counter(actor)에 대해 message passing 사용</li>\n</ul>","excerpt":"오늘 스터디에서 공부한 내용을 간략히 정리해보자.Wiki: ABA problemSimple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue Algorithmscontext…","fields":{"date":"August 03, 2013","shortdesc":""},"frontmatter":{"title":"concurrency 스터디","tags":["concurrency","study"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2013/08/03/concurrency-study/"}}}