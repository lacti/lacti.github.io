{"componentChunkName":"component---src-templates-page-tsx","path":"/2014/02/14/secret-of-mswsock-dll/","webpackCompilationHash":"86a6406c6b4e5482e871","result":{"data":{"site":{"siteMetadata":{"title":"Lacti's Archive","description":"All about I learned","author":{"name":"Jaeyoung, Choi","url":"https://twitter.com/lacti"}}},"markdownRemark":{"html":"<p>최근 회사에서 c#으로 네트워크 프로그래밍을 하고 있다. 일은 아니고 그냥 개인의 취향\n나름 c#도 속도가 괜찮다는 것을 보여주려고 시작을 했는데, 진행하면서 점점 보이는 결과는 영 좋지 않다.</p>\n<p>서버 과부하 테스트 프로그램을 c#으로 porting했다. 정말 과부하 테스트를 하려면 c++로 작성해야 맞지만 테스트 로직까지 c++로 작성하면 골치가 아프니 core는 c++, logic은 c#으로 작성하는 방법을 고민하면서 porting을 하고 있다. 하지만 그 전에 귀찮으니 일단 network core도 c#으로 작성했고 이 때 c# async io와 async/await을 대충 섞어서 작성했다.</p>\n<p><strong>정말 대충 짰더니 정말 성능이 대충 나온다(…)</strong>\nvs analyze 기능을 통해 확인을 해보면 가장 오래 걸리는 부분이 mswsock.dll에 소속되어 있다고 나온다. 이 글은 대체 왜 mswsock.dll인가에 대한 고찰을 담은 글이다.</p>\n<p>.net <code>Socket</code>의 <code>BeginReceive</code>, <code>EndReceive</code> 함수를 사용하면 내부에서 pinvoke로 <code>WSARecv</code> 함수를 부르게 된다. <code>WSARecv</code> 함수는 <code>ws2_32.dll</code>에 정의된 함수로 얼핏보기에는 socket 확장 api가 담겨있는 <code>mswsock.dll</code>이 부를 필요가 없어 보인다. 이를 정확히 확인하기 위해 ms symbol server에서 clr 관련 symbol을 받고 다시 profiler를 돌려보았다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 766px;\"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 34.98694516971279%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAA7EAAAOwwHaapjcAAABF0lEQVQY0zWQaXaEIBCEvf+1ZlEURYSRRZwAis6SyRlSavKHx+vur6u6MiEk74RS5vF8fT4/7/f3NKdpmq21MU4pLT5EO7jn8z3PSWvtQ0hp9T5obbPrNb/mxfl8aVgrb73SxvuYllUbw1qORXNaeqWsc8v6aHnXyRu6IU7oZpQ2VUVRVEpDn3MxuBHA4FwnZJxm8L3WKIIBAKfofvnAWJtVlJYVJWVFSFmQKs8LbSzm3DhC54Cx9w9mrZAbjFsO5ZqAKcjpBO+XgpRwfsCM8wM2OHq8g2GIR/YHjNUZrZuGcbS1NsBw9LjP/SunHQZ9P4JALKhgqZA3wDVCgNU9rO0dBgcYKyCDIfxRtMNmewtsvzmEWDP2CyN3ZOA3zWxeAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"functions\"\n        title=\"functions\"\n        src=\"/static/87f8a5582a10c6a5a18de6e6215a7f60/e0264/mswsock_secret_functions.png\"\n        srcset=\"/static/87f8a5582a10c6a5a18de6e6215a7f60/9856e/mswsock_secret_functions.png 285w,\n/static/87f8a5582a10c6a5a18de6e6215a7f60/12eea/mswsock_secret_functions.png 570w,\n/static/87f8a5582a10c6a5a18de6e6215a7f60/e0264/mswsock_secret_functions.png 766w\"\n        sizes=\"(max-width: 766px) 100vw, 766px\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>진범이 나온 것 같다. <code>NtDeviceIoControlFile()</code>과 <code>NtRemoveIoCompletion()</code>이 1, 2위로 나왔다. 여기서 <code>NtRemoveIoCompletion()</code> 함수는 <code>GetQueuedCompletionStatus()</code> 때문에 불리는 것으로 추측되니 <code>NtDeviceIoControlFile()</code>의 정체만 밝히면 되겠다.</p>\n<p>간단히 calling, called를 확인해보자.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 1140px;\"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 26.141078838174277%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABOElEQVQY0y2KTUvCcACH92GCDh0s00CTGVhqYtCpQ5foq0QXg2Zrts2X1F7FuohLbFGZ/ufarJxu7kXn9p9B36NBwXP48Tw/pMd/GcpkqsM/TB0qimWMrLFquXuiudiGarty4hrNtoz/p5sQ7FU5eFIwMMV5m+AhKTjCeJYF2nFLpQSYE51cz6kOvnndPmxKqRcV65gnwCS6VlaESLjcn6OlhbzkKcre0ih0rdXVn2RlGCoPohU1UdUTd8b+w7Qmz3xkx08BPwkCNIfm37dv+0i8ADz423KmvUJxAbq7URQZ2QnSYB5rLREd/xnnI7mtq4+6DCOFruvRPB8pCrGyuHs/QDZJdjHFBNPNEP4YJtgo9dwYWusZ1nvErKab4VMWxdmdUruhwNiFuHYuREq9+OVn8qa/Vxv9AiEsxYotefjKAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"ws2_32.dll\"\n        title=\"ws2_32.dll\"\n        src=\"/static/274bc6a9a48586b9e4c6d84d1bc244dc/d2746/mswsock_secret_ws2_32_dll.png\"\n        srcset=\"/static/274bc6a9a48586b9e4c6d84d1bc244dc/9856e/mswsock_secret_ws2_32_dll.png 285w,\n/static/274bc6a9a48586b9e4c6d84d1bc244dc/12eea/mswsock_secret_ws2_32_dll.png 570w,\n/static/274bc6a9a48586b9e4c6d84d1bc244dc/d2746/mswsock_secret_ws2_32_dll.png 1140w,\n/static/274bc6a9a48586b9e4c6d84d1bc244dc/440de/mswsock_secret_ws2_32_dll.png 1205w\"\n        sizes=\"(max-width: 1140px) 100vw, 1140px\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 1140px;\"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 26.061615320566194%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABMElEQVQY0yXK60rCYACA4d1MkIrkCWeYFEQYldAldDUairM055xmYpSgfxquCSWJrukc1k5+23Ru3yq6j1bB8+vlRQRuLs4kTV6udegydaiqa2NhuVYa/GMbwFZVawXWpmb/by63I/mBkhmAy4lVmtjlKSRmDr/8IFkNH2t1AdYEWBecjvTJGzD9pGSHepH7PXHeIXkLiV2/bRCij5S2GmroZpG403vg++Re3m3JyTY46mjHXeOsZ1Lql7f67iElf10ONJRwExy0AbJPjgPFUaQ8jhFcvDo5bAq04sQJdrMwDF2xaIWLVrjU7ZxSIIqPUJxF8ddtgkuQ09OWgMQx2pOmglk6kmdQrL9Xeu6J1s4F400/hHM0ij1GMSZVe6FE039O+TJUMEdH80ys0E9WBj/5M8MqzdDOAwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"mswsock.dll\"\n        title=\"mswsock.dll\"\n        src=\"/static/8caaedce047ba57837f09a099ac8c1ea/d2746/mswsock_secret_mswsock_dll.png\"\n        srcset=\"/static/8caaedce047ba57837f09a099ac8c1ea/9856e/mswsock_secret_mswsock_dll.png 285w,\n/static/8caaedce047ba57837f09a099ac8c1ea/12eea/mswsock_secret_mswsock_dll.png 570w,\n/static/8caaedce047ba57837f09a099ac8c1ea/d2746/mswsock_secret_mswsock_dll.png 1140w,\n/static/8caaedce047ba57837f09a099ac8c1ea/812ed/mswsock_secret_mswsock_dll.png 1201w\"\n        sizes=\"(max-width: 1140px) 100vw, 1140px\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>원인이 명확해졌다.\n다량의 패킷 수신자가 <code>WSARecv</code>를 부르는 과정에서 <code>ws2_32.dll</code>의 함수가 호출된 것은 당연했다. 하지만 그 과정에서 알 수 없는 오류가 발생했고, 그 오류를 처리하기 위해 불린 <code>NtStatusToSocketError()</code> 함수가 <code>mswsock.dll</code>의 <code>NtDeviceIoControlFile()</code> 함수를 불렀던 것이다.</p>\n<p>그렇다면 <code>NtDeviceIoControlFile()</code> 함수는 대체 무엇일까, 그리고 왜 그렇게 느릴까?\nprofiling한 결과를 보면 대부분의 exclusive sample의 address가 비슷한 지점을 가리키고 있는 것을 확인할 수 있다. 즉, 특정 지점에서 많이 멈춰있다는 이야기일 것인데, 이 때 cpu 사용량이 꽤 높다는 점을 미루어볼 때 뭔가 busy waiting을 하는 것이 아닐까 추측된다.</p>\n<p>이 부분은 symbol 만으로 확인하기는 어렵고, 직접 disassemble을 해서 확인을 하던가 해야하지만 별로 그러고 싶지는 않고(…) 일단 pinvoke로 직접 iocp를 호출하는 c# 코드를 작성하여 그 부분에서도 여전히 비슷한 문제가 발생하는지 확인을 해봐야겠다.</p>","excerpt":"최근 회사에서 c#으로 네트워크 프로그래밍을 하고 있다. 일은 아니고 그냥 개인의 취향\n나름 c#도 속도가 괜찮다는 것을 보여주려고 시작을 했는데, 진행하면서 점점 보이는 결과는 영 좋지 않다. 서버 과부하 테스트 프로그램을 c#으로 porting…","fields":{"date":"February 14, 2014","shortdesc":""},"frontmatter":{"title":"mswsock.dll의 비밀","tags":["optimization","network","c#"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2014/02/14/secret-of-mswsock-dll/"}}}