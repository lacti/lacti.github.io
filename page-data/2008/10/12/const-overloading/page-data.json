{"componentChunkName":"component---src-templates-page-tsx","path":"/2008/10/12/const-overloading/","webpackCompilationHash":"dff243b0bb0545126dc2","result":{"data":{"site":{"siteMetadata":{"title":"Lacti's Archive","description":"All about I learned","author":{"name":"Jaeyoung, Choi","url":"https://twitter.com/lacti"}}},"markdownRemark":{"html":"<p>c++의 overloading은 c에서 어떤 함수를 단순히 함수의 이름으로만 식별했던 것에 비해 함수의 인자의 type, 개수, 혹은 const/volatile 여부까지 고려해서 식별한다는 것이다.</p>\n<p>즉 linking 시점에서 호출하는 지점과 호출 당하는 지점을 연결해줄 때 호출하는 지점에서 요구하는 함수의 정보(함수 이름, 인자 type, 개수, const/volatile 여부)를 기반으로 함수 table에서 찾아서 그 함수의 주소를 호출할 수 있도록 주소로 변환시켜 주면서 엮어준다는 것이다.</p>\n<p>이 글에서는 const와 reference를 엮어, 그렇지 않은 함수와 함께 overloading을 하여 사용하는 것에 대한 글을 서술하도록 하겠다.</p>\n<p>간단한 예를 들기 위해 1차원 array를 wrapping하는 class를 다음과 같이 작성한다고 해보자.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk15\">#include</span><span class=\"mtk4\"> </span><span class=\"mtk8\">&lt;iostream&gt;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">class</span><span class=\"mtk1\"> </span><span class=\"mtk10\">odarray</span><span class=\"mtk1\"> { </span><span class=\"mtk3\">// one dimension</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">public:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">friend</span><span class=\"mtk1\"> std::ostream&amp; operator &lt;&lt; (std::ostream&amp; </span><span class=\"mtk12\">out</span><span class=\"mtk1\">, </span><span class=\"mtk4\">const</span><span class=\"mtk1\"> odarray&amp; </span><span class=\"mtk12\">array</span><span class=\"mtk1\">);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">int</span><span class=\"mtk1\">&amp; operator [] (</span><span class=\"mtk4\">int</span><span class=\"mtk1\"> </span><span class=\"mtk12\">index</span><span class=\"mtk1\">) { </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">mArray</span><span class=\"mtk1\">[index]; }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">int</span><span class=\"mtk1\"> operator [] (</span><span class=\"mtk4\">int</span><span class=\"mtk1\"> </span><span class=\"mtk12\">index</span><span class=\"mtk1\">) </span><span class=\"mtk4\">const</span><span class=\"mtk1\"> { </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">mArray</span><span class=\"mtk1\">[index]; }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">int</span><span class=\"mtk1\"> </span><span class=\"mtk11\">size</span><span class=\"mtk1\"> (</span><span class=\"mtk4\">void</span><span class=\"mtk1\">) </span><span class=\"mtk4\">const</span><span class=\"mtk1\"> { </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> mSize; }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk11\">odarray</span><span class=\"mtk1\"> (</span><span class=\"mtk4\">int</span><span class=\"mtk1\"> </span><span class=\"mtk12\">size</span><span class=\"mtk1\">)</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        : </span><span class=\"mtk11\">mSize</span><span class=\"mtk1\"> (size) {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        mArray = new </span><span class=\"mtk4\">int</span><span class=\"mtk1\">[size];</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        </span><span class=\"mtk15\">for</span><span class=\"mtk1\"> (</span><span class=\"mtk4\">int</span><span class=\"mtk1\"> i = </span><span class=\"mtk7\">0</span><span class=\"mtk1\">; i &lt; size; i++)</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">            </span><span class=\"mtk12\">mArray</span><span class=\"mtk1\">[i] = </span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk11\">~odarray</span><span class=\"mtk1\"> (</span><span class=\"mtk4\">void</span><span class=\"mtk1\">) {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        delete[] mArray;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">private:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">int</span><span class=\"mtk1\"> mSize;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">int</span><span class=\"mtk1\">* mArray;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">};</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">std::ostream&amp; operator &lt;&lt; (std::ostream&amp; </span><span class=\"mtk12\">out</span><span class=\"mtk1\">, </span><span class=\"mtk4\">const</span><span class=\"mtk1\"> odarray&amp; </span><span class=\"mtk12\">array</span><span class=\"mtk1\">) {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk15\">for</span><span class=\"mtk1\"> (</span><span class=\"mtk4\">int</span><span class=\"mtk1\"> i = </span><span class=\"mtk7\">0</span><span class=\"mtk1\">; i &lt; </span><span class=\"mtk12\">array.mSize</span><span class=\"mtk1\">; i++)</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">        out &lt;&lt; </span><span class=\"mtk12\">array</span><span class=\"mtk1\">[i] &lt;&lt; </span><span class=\"mtk8\">&quot; &quot;</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> out;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">}</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">int</span><span class=\"mtk1\"> </span><span class=\"mtk11\">main</span><span class=\"mtk1\"> (</span><span class=\"mtk4\">int</span><span class=\"mtk1\"> </span><span class=\"mtk12\">argc</span><span class=\"mtk1\">, </span><span class=\"mtk4\">char</span><span class=\"mtk1\"> *</span><span class=\"mtk12\">argv</span><span class=\"mtk1\">[]) {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    odarray </span><span class=\"mtk11\">oa1</span><span class=\"mtk1\"> (</span><span class=\"mtk7\">10</span><span class=\"mtk1\">);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk12\">oa1</span><span class=\"mtk1\">[</span><span class=\"mtk7\">4</span><span class=\"mtk1\">] = </span><span class=\"mtk7\">10</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    std::cout &lt;&lt; oa1 &lt;&lt; std::endl;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">}</span></span></code></pre>\n<p><code>operator []</code>가 const인 것과 그렇지 않은 것 2개를 작성하였다. 둘의 함수 내용은 같지만 해당 함수가 호출되는 시점의 constness에 따라 다른 함수가 호출될 수 있다는 것이다.</p>\n<ul>\n<li>const가 붙어있는 함수는 int 값을 복사해서 반환하고,</li>\n<li>const가 붙어있지 않은 함수는 int&#x26; 자체를 반환하여 해당 값을 수정할 수 있게 해준다.</li>\n</ul>\n<p>간단히 말해서 예를 들어보면,</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk1\">odarray </span><span class=\"mtk11\">oa1</span><span class=\"mtk1\">(</span><span class=\"mtk7\">10</span><span class=\"mtk1\">);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk12\">oa1</span><span class=\"mtk1\">[</span><span class=\"mtk7\">4</span><span class=\"mtk1\">] = </span><span class=\"mtk7\">10</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">std::cout &lt;&lt; oa1 &lt;&lt; std::endl;[/code]</span></span></code></pre>\n<p><code>oa1[4] = 10;</code> 구문에서는 값의 변경이 필요하기 때문에 당연히 int&#x26;를 반환하는 non-constness 함수를 호출할 것이다.</p>\n<p>하지만 <code>std::cout &#x3C;&#x3C; oa1 &#x3C;&#x3C; std::endl;</code> 구문에서는 <code>oa1</code>을 <code>ostream</code>으로 출력하는 함수의 원형을 봐야한다. <code>std::ostream&#x26; operator &#x3C;&#x3C; (std::ostream&#x26; out, const odarray&#x26; array)</code><br>\n즉 이 함수는 인자로 <code>const odarray</code>를 받기 때문에 <code>odarray</code> 객체의 const를 보장하기 위해서 이 함수 내에서 호출되는 <code>odarray</code>의 멤버 함수는 모두 const 함수가 되는 것이다. 따라서 위 구문에서는 int를 반환하는 const 함수가 호출된다.</p>\n<h2>결론</h2>\n<p>c++ compiler는 const를 보장해주기 위해서 const 객체의 멤버 함수를 호출할 때는 const 멤버 함수를 호출한다.</p>\n<h2>추가</h2>\n<p>그래서 const overloading과 operator overloading을 결합하면 쉽게 getter/setter를 만들 수 있고, 이게 발전되어서 vb나 c#의 property가 된게 아닐까 싶다. 아 반환값 때문에 안되나(…)</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk1\">object&amp; operator [] (std::string </span><span class=\"mtk12\">propertyname</span><span class=\"mtk1\">);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">object operator [] (std::string </span><span class=\"mtk12\">propertyname</span><span class=\"mtk1\">) </span><span class=\"mtk4\">const</span><span class=\"mtk1\">;</span></span></code></pre>\n<style class=\"vscode-highlight-styles\">:root {\n  --vscode-highlight-padding-v: 1rem;\n  --vscode-highlight-padding-h: 1.5rem;\n  --vscode-highlight-padding-top: var(--vscode-highlight-padding-v);\n  --vscode-highlight-padding-right: var(--vscode-highlight-padding-h);\n  --vscode-highlight-padding-bottom: var(--vscode-highlight-padding-v);\n  --vscode-highlight-padding-left: var(--vscode-highlight-padding-h);\n  --vscode-highlight-border-radius: 8px;\n\n  --vscode-highlight-line-highlighted-background-color: transparent;\n  --vscode-highlight-line-highlighted-border-width: 4px;\n  --vscode-highlight-line-highlighted-border-color: transparent;\n}\n\n.vscode-highlight {\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n  padding-top: 1rem;\n  padding-top: var(--vscode-highlight-padding-top);\n  padding-bottom: 1rem;\n  padding-bottom: var(--vscode-highlight-padding-bottom);\n  border-radius: 8px;\n  border-radius: var(--vscode-highlight-border-radius);\n  font-feature-settings: normal;\n}\n\n.vscode-highlight-code {\n  display: inline-block;\n  min-width: 100%;\n}\n\n.vscode-highlight-line {\n  display: inline-block;\n  box-sizing: border-box;\n  width: 100%;\n  padding-left: 1.5rem;\n  padding-left: var(--vscode-highlight-padding-left);\n  padding-right: 1.5rem;\n  padding-right: var(--vscode-highlight-padding-right);\n}\n\n.vscode-highlight-line-highlighted {\n  background-color: var(--vscode-highlight-line-highlighted-background-color);\n  box-shadow: inset var(--vscode-highlight-line-highlighted-border-width) 0 0 0 var(--vscode-highlight-line-highlighted-border-color);\n}\n.default-dark {\nbackground-color: #1E1E1E;\ncolor: #D4D4D4;\n}\n\n.default-dark .mtk1 { color: #D4D4D4; }\n.default-dark .mtk2 { color: #1E1E1E; }\n.default-dark .mtk3 { color: #6A9955; }\n.default-dark .mtk4 { color: #569CD6; }\n.default-dark .mtk5 { color: #D16969; }\n.default-dark .mtk6 { color: #D7BA7D; }\n.default-dark .mtk7 { color: #B5CEA8; }\n.default-dark .mtk8 { color: #CE9178; }\n.default-dark .mtk9 { color: #646695; }\n.default-dark .mtk10 { color: #4EC9B0; }\n.default-dark .mtk11 { color: #DCDCAA; }\n.default-dark .mtk12 { color: #9CDCFE; }\n.default-dark .mtk13 { color: #000080; }\n.default-dark .mtk14 { color: #F44747; }\n.default-dark .mtk15 { color: #C586C0; }\n.default-dark .mtk16 { color: #6796E6; }\n.default-dark .mtk17 { color: #808080; }\n.default-dark .mtki { font-style: italic; }\n.default-dark .mtkb { font-weight: bold; }\n.default-dark .mtku { text-decoration: underline; text-underline-position: under; }</style>","excerpt":"c++의 overloading은 c에서 어떤 함수를 단순히 함수의 이름으로만 식별했던 것에 비해 함수의 인자의 type, 개수, 혹은 const/volatile 여부까지 고려해서 식별한다는 것이다.즉 linking…","fields":{"date":"October 12, 2008","shortdesc":""},"frontmatter":{"title":"const overloading","tags":["c++"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2008/10/12/const-overloading/"}}}