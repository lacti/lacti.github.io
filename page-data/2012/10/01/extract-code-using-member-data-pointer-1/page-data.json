{"componentChunkName":"component---src-templates-page-tsx","path":"/2012/10/01/extract-code-using-member-data-pointer-1/","webpackCompilationHash":"c52cfe8f35b93f400244","result":{"data":{"site":{"siteMetadata":{"title":"Lacti's Archive","description":"All about I learned","author":{"name":"Jaeyoung, Choi","url":"https://twitter.com/lacti"}}},"markdownRemark":{"html":"<p>게임 내 스탯 시스템을 구현한다고 해보자. 그 스탯들은 여러 상황에서 버프에 의해 값이 변경될 수 있기 때문에</p>\n<ul>\n<li><strong>스탯을 저장하는 자료구조</strong>와</li>\n<li>그 <strong>스탯을 변경하기 위한 버프 종류 enum</strong>과,</li>\n<li>각 버프 종류 enum에 따라 스탯을 어떻게 변경할지에 대한 <strong>연산식</strong>에 대해서</li>\n</ul>\n<p>코딩을 해주어야 한다.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">enum</span><span class=\"mtk1\"> BuffType {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    BUFF_HP,</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    BUFF_MP,</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    BUFF_ATTACK,</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    BUFF_DEFENCE,</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">};</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">struct</span><span class=\"mtk1\"> </span><span class=\"mtk10\">Stat</span><span class=\"mtk1\"> {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">float</span><span class=\"mtk1\"> hp;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">float</span><span class=\"mtk1\"> mp;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">float</span><span class=\"mtk1\"> attack;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk4\">float</span><span class=\"mtk1\"> defence;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">};</span></span></code></pre>\n<p>일단 각 스탯에 어떤 값을 어떻게 계산하면 되는지에 대해서는 다음의 3가지로 추상화를 했다고 치자. <strong>SET, ADD, RATE</strong> 즉, 지정, 더하기, 곱하기이다.</p>\n<p>그럼 대충 다음과 같은 코드가 나온다.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk15\">switch</span><span class=\"mtk1\"> (buffType) {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk15\">case</span><span class=\"mtk1\"> BUFF_HP:</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk15\">switch</span><span class=\"mtk1\"> (buffMethod) {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk15\">case</span><span class=\"mtk1\"> SET: </span><span class=\"mtk12\">stat.hp</span><span class=\"mtk1\"> = buffValue; </span><span class=\"mtk15\">break</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk15\">case</span><span class=\"mtk1\"> ADD: </span><span class=\"mtk12\">stat.hp</span><span class=\"mtk1\"> += buffValue; </span><span class=\"mtk15\">break</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk15\">case</span><span class=\"mtk1\"> RATE: </span><span class=\"mtk12\">stat.hp</span><span class=\"mtk1\"> *= buffValue; </span><span class=\"mtk15\">break</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    }</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">    </span><span class=\"mtk15\">break</span><span class=\"mtk1\">;</span></span></code></pre>\n<p><code>BUFF_MP</code>, <code>BUFF_ATTACK</code>, <code>BUFF_DEFENCE</code> 등 버프 종류가 바뀌어도 연산하는 식은 똑같다. 다만 stat 구조체 내의 어떤 변수를 접근하는지만 바뀌는 것이다.</p>\n<p>버프의 종류가 한 100가지 된다고 치자. 그러면 100개의 동일한 case pattern을 다 코딩해주어야 하나? 그리고 SET, ADD, RATE 말고 <strong>EXPONENT</strong>라는 방법이 추가되었다고 해보자. <strong>맙소사!</strong></p>\n<p>위 상황을 해결할 수 있는 가장 간단한 방법은 <code>BuffType</code> enum에 대응되는 <code>Stat</code> 자료구조의 멤버 데이터 포인터를 묶어주는 것이다.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk4\">typedef</span><span class=\"mtk1\"> </span><span class=\"mtk4\">float</span><span class=\"mtk1\"> Stat::*StatDataPtr;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">StatDataPtr </span><span class=\"mtk12\">statDataPtr</span><span class=\"mtk1\">[BUFF_MAX];</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\"></span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk12\">statDataPtr</span><span class=\"mtk1\">[BUFF_HP] = &amp;Stat::hp;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk12\">statDataPtr</span><span class=\"mtk1\">[BUFF_MP] = &amp;Stat::mp;</span></span></code></pre>\n<p>각 Buff의 종류별로 어떤 멤버를 접근할지 정보를 구성했으니, 아까의 코드가 한결 간편해진다.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk1\">StatDataPtr dataPtr = </span><span class=\"mtk12\">statDataPtr</span><span class=\"mtk1\">[buffType];</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk15\">switch</span><span class=\"mtk1\"> (buffMethod) {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk15\">case</span><span class=\"mtk1\"> SET: </span><span class=\"mtk12\">stat.*dataPtr</span><span class=\"mtk1\"> = buffValue; </span><span class=\"mtk15\">break</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk15\">case</span><span class=\"mtk1\"> ADD: </span><span class=\"mtk12\">stat.*dataPtr</span><span class=\"mtk1\"> += buffValue; </span><span class=\"mtk15\">break</span><span class=\"mtk1\">;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk15\">case</span><span class=\"mtk1\"> RATE: </span><span class=\"mtk12\">stat.*dataPtr</span><span class=\"mtk1\"> *= buffValue; </span><span class=\"mtk15\">break</span><span class=\"mtk1\">;</span></span></code></pre>\n<p>이제 <code>BuffType</code>이 추가될 때마다 해당 <code>BuffType</code>에 대응되는 <code>Stat</code>의 데이터 포인터를 배열에 추가해주기만 하면 된다. 그리고 Method가 추가되어도, 그러한 연산을 수행하는 코드가 한 곳에만 존재하기 때문에 Method를 확장하기도 좋다.</p>\n<p>하지만 아무래도 enum을 정의하고 나서 데이터 포인터와의 연결을 위해 다시 한 번 enum을 언급하는 것은 귀찮다. 이를 해결하기 위해서 X-Macro pattern를 써보자.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk3\">// buff_type.inl</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk11\">BUFF_ENUM</span><span class=\"mtk1\">(BUFF_HP, &amp;Stat::hp);</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk11\">BUFF_ENUM</span><span class=\"mtk1\">(BUFF_MP, &amp;Stat::mp);</span></span></code></pre>\n<p>위와 같이 <code>BUFF_ENUM</code>이라는 매크로를 사용하여 enum 정의와 데이터 포인터 연결을 같이 할 수 있도록 묶어주고,</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk3\">// buff_type.h</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk15\">#define</span><span class=\"mtk4\"> </span><span class=\"mtk11\">BUFF_ENUM</span><span class=\"mtk4\">(</span><span class=\"mtk12\">name, ptr</span><span class=\"mtk4\">) name,</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk4\">enum</span><span class=\"mtk1\"> BuffType {</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk15\">#include</span><span class=\"mtk4\"> </span><span class=\"mtk8\">&quot;buff_type.inl&quot;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk1\">};</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk15\">#undef</span><span class=\"mtk4\"> </span><span class=\"mtk11\">BUFF_ENUM</span></span></code></pre>\n<p>header 파일과 cpp 파일에 각기 다른 macro 함수를 적용하여 적절한 코드를 생성하도록 한다.</p>\n<pre class=\"default-dark vscode-highlight\" data-language=\"cpp\"><code class=\"vscode-highlight-code\"><span class=\"vscode-highlight-line\"><span class=\"mtk3\">// buff_bind.cpp</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk15\">#define</span><span class=\"mtk4\"> </span><span class=\"mtk11\">BUFF_ENUM</span><span class=\"mtk4\">(</span><span class=\"mtk12\">name, ptr</span><span class=\"mtk4\">) </span><span class=\"mtk12\">statDataPtr</span><span class=\"mtk4\">[buff] </span><span class=\"mtk1\">=</span><span class=\"mtk4\"> ptr;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk15\">#include</span><span class=\"mtk4\"> </span><span class=\"mtk8\">&quot;buff_type.inl&quot;</span></span>\n<span class=\"vscode-highlight-line\"><span class=\"mtk15\">#undef</span><span class=\"mtk4\"> </span><span class=\"mtk11\">BUFF_ENUM</span></span></code></pre>\n<p>이제 새로운 버프가 추가되면, buff<em>type.inl 파일 하나에만 `BUFF</em>ENUM`으로 추가해두면, buff<em>type.h와 buff</em>bind.cpp 양 쪽에 코드가 적절히 치환되어 적절하게 추가될 것이다.</p>\n<p>물론 코드가 모두 이렇게 깔끔하게 묶어낼 수 있는 것은 아니지만 만약 대부분의 코드를 이렇게 묶어낼 수 있다면, 이는 충분히 시도할만한 가치가 있는 방법이라고 생각된다.</p>\n<p>편의상 <code>Stat</code> 구조체의 모든 변수가 float임을 가정했는데, 만약 그렇지 않다면 type erasure를 써야 하는데 이건 본 글에서 다루는 내용보다 더 큰 내용이니 다음에 다루도록 하겠다.</p>\n<p>다음 글에서는 어제 [summerlight]님께 배운 정보를 바탕으로 <code>Stat</code> 구조체 내부에 배열이 있을 경우에 어떻게 처리할 수 있을지에 대해서 알아보겠다.</p>\n<style class=\"vscode-highlight-styles\">:root {\n  --vscode-highlight-padding-v: 1rem;\n  --vscode-highlight-padding-h: 1.5rem;\n  --vscode-highlight-padding-top: var(--vscode-highlight-padding-v);\n  --vscode-highlight-padding-right: var(--vscode-highlight-padding-h);\n  --vscode-highlight-padding-bottom: var(--vscode-highlight-padding-v);\n  --vscode-highlight-padding-left: var(--vscode-highlight-padding-h);\n  --vscode-highlight-border-radius: 8px;\n\n  --vscode-highlight-line-highlighted-background-color: transparent;\n  --vscode-highlight-line-highlighted-border-width: 4px;\n  --vscode-highlight-line-highlighted-border-color: transparent;\n}\n\n.vscode-highlight {\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n  padding-top: 1rem;\n  padding-top: var(--vscode-highlight-padding-top);\n  padding-bottom: 1rem;\n  padding-bottom: var(--vscode-highlight-padding-bottom);\n  border-radius: 8px;\n  border-radius: var(--vscode-highlight-border-radius);\n  font-feature-settings: normal;\n}\n\n.vscode-highlight-code {\n  display: inline-block;\n  min-width: 100%;\n}\n\n.vscode-highlight-line {\n  display: inline-block;\n  box-sizing: border-box;\n  width: 100%;\n  padding-left: 1.5rem;\n  padding-left: var(--vscode-highlight-padding-left);\n  padding-right: 1.5rem;\n  padding-right: var(--vscode-highlight-padding-right);\n}\n\n.vscode-highlight-line-highlighted {\n  background-color: var(--vscode-highlight-line-highlighted-background-color);\n  box-shadow: inset var(--vscode-highlight-line-highlighted-border-width) 0 0 0 var(--vscode-highlight-line-highlighted-border-color);\n}\n.default-dark {\nbackground-color: #1E1E1E;\ncolor: #D4D4D4;\n}\n\n.default-dark .mtk1 { color: #D4D4D4; }\n.default-dark .mtk2 { color: #1E1E1E; }\n.default-dark .mtk3 { color: #6A9955; }\n.default-dark .mtk4 { color: #569CD6; }\n.default-dark .mtk5 { color: #D16969; }\n.default-dark .mtk6 { color: #D7BA7D; }\n.default-dark .mtk7 { color: #B5CEA8; }\n.default-dark .mtk8 { color: #CE9178; }\n.default-dark .mtk9 { color: #646695; }\n.default-dark .mtk10 { color: #4EC9B0; }\n.default-dark .mtk11 { color: #DCDCAA; }\n.default-dark .mtk12 { color: #9CDCFE; }\n.default-dark .mtk13 { color: #000080; }\n.default-dark .mtk14 { color: #F44747; }\n.default-dark .mtk15 { color: #C586C0; }\n.default-dark .mtk16 { color: #6796E6; }\n.default-dark .mtk17 { color: #808080; }\n.default-dark .mtki { font-style: italic; }\n.default-dark .mtkb { font-weight: bold; }\n.default-dark .mtku { text-decoration: underline; text-underline-position: under; }</style>","excerpt":"게임 내 스탯 시스템을 구현한다고 해보자. 그 스탯들은 여러 상황에서 버프에 의해 값이 변경될 수 있기 때문에스탯을 저장하는 자료구조와그 스탯을 변경하기 위한 버프 종류 enum과,각 버프 종류 enum…","fields":{"date":"October 01, 2012"},"frontmatter":{"title":"멤버 데이터 포인터를 사용하여 연산식 묶어내기 1","tags":["c++","refactor"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2012/10/01/extract-code-using-member-data-pointer-1/"}}}