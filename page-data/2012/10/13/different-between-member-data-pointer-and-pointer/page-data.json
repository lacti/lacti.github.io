{"componentChunkName":"component---src-templates-page-tsx","path":"/2012/10/13/different-between-member-data-pointer-and-pointer/","result":{"data":{"site":{"siteMetadata":{"title":"Lacti's Archive","description":"All about I learned","author":{"name":"Jaeyoung, Choi","url":"https://twitter.com/lacti"}}},"markdownRemark":{"html":"<p>pointer는 메모리의 특정 공간의 주소를 지칭하기 위해 사용된다.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"cpp\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">float</span><span class=\"mtk1\"> some_var = </span><span class=\"mtk7\">1.0f</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">float</span><span class=\"mtk1\">* float_ptr = &amp;some_var;</span></span></span></code></pre>\n<p>member data pointer는 구조체나 클래스의 특정 멤버 변수의 위치를 상대적으로 지칭하기 위해 쓰인다. 따라서 메모리 주소 값을 가지는 것이 아니라, 구조체나 클래스 객체에서 어디에 접근을 해야하는지의 정보를 담고 있다고 생각하면 된다.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"cpp\" data-index=\"1\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">struct</span><span class=\"mtk1\"> </span><span class=\"mtk10\">tuple_t</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">float</span><span class=\"mtk1\"> first;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">};</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">typedef</span><span class=\"mtk1\"> </span><span class=\"mtk4\">float</span><span class=\"mtk1\"> </span><span class=\"mtk10\">tuple_t</span><span class=\"mtk1\">::*</span><span class=\"mtk10\">member_t</span><span class=\"mtk1\">;</span></span></span></code></pre>\n<p>때문에 실제 메모리에 접근하기 위해서는 구조체나 클래스 객체가 있어야 하고, 접근할 때에도 dereference operator를 써주어야 한다.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"cpp\" data-index=\"2\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk10\">member_t</span><span class=\"mtk1\"> member = &amp;</span><span class=\"mtk10\">tuple_t</span><span class=\"mtk1\">::first;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk10\">tuple_t</span><span class=\"mtk1\"> tuple;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">tuple</span><span class=\"mtk1\">.*</span><span class=\"mtk12\">member</span><span class=\"mtk1\"> = </span><span class=\"mtk7\">100.0f</span><span class=\"mtk1\">;</span></span></span></code></pre>\n<p>위와 같이 <code>tuple.*member</code>를 통해 <code>member</code>가 가리키는 <code>first</code> 변수에 접근할 수 있었다. 이것은 <code>tuple</code> 객체 내에서 <code>member</code>가 가리키는 위치이고, <code>tuple</code>이라는 메모리 공간의 특정 지점에 접근을 하였으니 이제 float 값을 대입할 수 있는 것이다.</p>\n<p>이제 float*로 저것을 가리킬 수 있다.</p>\n<pre class=\"grvsc-container default-dark\" data-language=\"cpp\" data-index=\"3\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">float</span><span class=\"mtk1\">* float_ptr = &amp;(</span><span class=\"mtk12\">tuple</span><span class=\"mtk1\">.*</span><span class=\"mtk12\">member</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p>요약하면,</p>\n<ul>\n<li>메모리 주소 값을 갖는 <code>float*</code>와는 다르게 member-data-pointer는 객체 내의 상대적 위치 정보를 갖기 때문에 바로 <code>float*</code>로 casting할 수는 없고,</li>\n<li>객체를 두고 객체 내의 멤버를 접근한 다음(<code>.*</code> 혹은 <code>->*</code>)에야 메모리 주소인 <code>float*</code>로 가리킬 수 있게 된다는 것이다.</li>\n</ul>\n<p>member-data-pointer가 member의 위치를 어떻게 가리킬 수 있는지에 대한 세부 내용은 접어두더라도, 객체 내의 member 위치(<code>offset_of</code>)의 방법을 이해하면 굳이 member-data-pointer를 쓰지 않아도 비슷한 효과를 흉내낼 수 있다(c-style)</p>\n<p>이에 대해서는 다음 글에서 알아보자.</p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n  .default-dark {\n    background-color: #1E1E1E;\n    color: #D4D4D4;\n  }\n  .default-dark .mtk4 { color: #569CD6; }\n  .default-dark .mtk1 { color: #D4D4D4; }\n  .default-dark .mtk7 { color: #B5CEA8; }\n  .default-dark .mtk10 { color: #4EC9B0; }\n  .default-dark .mtk12 { color: #9CDCFE; }\n  .default-dark .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(255, 255, 255, 0.1));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(255, 255, 255, 0.5));\n  }\n</style>","excerpt":"pointer는 메모리의 특정 공간의 주소를 지칭하기 위해 사용된다. member data pointer…","fields":{"date":"October 13, 2012","shortdesc":"","slug":"/2012/10/13/different-between-member-data-pointer-and-pointer/"},"frontmatter":{"title":"member-data-pointer와 pointer의 차이","tags":["c++"]}}},"pageContext":{"slug":"/2012/10/13/different-between-member-data-pointer-and-pointer/","older":{"slug":"/2012/10/07/extract-code-using-member-data-pointer-3/","title":"멤버 데이터 포인터를 사용하여 연산식 묶어내기 3"},"newer":{"slug":"/2012/10/31/member-data-pointer-casting-safety/","title":"멤버 데이터 포인터의 casting과 안정성 1"}}},"staticQueryHashes":["848695393"]}